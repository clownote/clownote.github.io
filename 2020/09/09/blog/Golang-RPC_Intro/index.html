<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Go RPC 远程过程调用今天来学习 Go 语言的远程过程调用 RPC（ Remote Procedure Call）。  在分布式计算，远程过程调用是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程。RPC是一种服务器-客户端模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 From Wiki">
<meta property="og:type" content="article">
<meta property="og:title" content="Go RPC 远程过程调用">
<meta property="og:url" content="https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/index.html">
<meta property="og:site_name" content="clownote">
<meta property="og:description" content="Go RPC 远程过程调用今天来学习 Go 语言的远程过程调用 RPC（ Remote Procedure Call）。  在分布式计算，远程过程调用是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程。RPC是一种服务器-客户端模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 From Wiki">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-09T22:26:38.909Z">
<meta property="article:modified_time" content="2021-07-15T09:11:22.538Z">
<meta property="article:author" content="CDFMLR">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/rabbit.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/rabbit_192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/rabbit_180.png">
          
        
    
    <!-- title -->
    <title>Go RPC 远程过程调用</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
    <!--Google search varification (PRIVATE)-->
    <meta name="google-site-verification" content="MrqlpFAD8nDanw3Ypv7ZsIWHLnTdhRuLa4QhSVwxIvc" />
    <!--Google AdSense 关联 (PRIVATE)-->
    <script data-ad-client="ca-pub-1510963483941114" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/09/15/blog/Golang-Protobuf-and-gRPC/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/09/03/blog/Gin_quick_start/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&text=Go RPC 远程过程调用"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&is_video=false&description=Go RPC 远程过程调用"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Go RPC 远程过程调用&body=Check out this article: https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&name=Go RPC 远程过程调用&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Go RPC 远程过程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part0-net-rpc"><span class="toc-number">1.1.</span> <span class="toc-text">Part0. net&#x2F;rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-World"><span class="toc-number">1.1.1.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E8%A7%84%E8%8C%83%E7%9A%84-RPC-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">更规范的 RPC 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-rpc-jsonrpc"><span class="toc-number">1.1.4.</span> <span class="toc-text">net&#x2F;rpc&#x2F;jsonrpc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-RPC-in-HTTP"><span class="toc-number">1.1.5.</span> <span class="toc-text">JSON-RPC in HTTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part1-%E7%AE%80%E5%8D%95-RPC-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Part1. 简单 RPC 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">网络通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">编码解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Go RPC 远程过程调用
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">clownote</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-09-09T22:26:38.909Z" itemprop="datePublished">2020-09-09</time>
        
        (Updated: <time datetime="2021-07-15T09:11:22.538Z" itemprop="dateModified">2021-07-15</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Golang/" rel="tag">Golang</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Go-RPC-远程过程调用"><a href="#Go-RPC-远程过程调用" class="headerlink" title="Go RPC 远程过程调用"></a>Go RPC 远程过程调用</h1><p>今天来学习 Go 语言的<em>远程过程调用</em> RPC（ Remote Procedure Call）。</p>
<blockquote>
<p>在分布式计算，远程过程调用是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程。RPC是一种服务器-客户端模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。</p>
<p>From WikiPedia</p>
</blockquote>
<p>RPC 可以让客户端相对直接地访问服务端的函数，这里说的「相对直接」表示我们不需要在服务端自己写一些比如 web 服务的东西来提供接口，并且在两端手动做各种数据的编码、解码。</p>
<p>本文包括两部分，第一部分介绍 Golang 标准库的 <code>net/rpc</code>，第二部分动手实现一个玩具版 PRC 框架来加深理解。</p>
<p>[TOC]</p>
<h2 id="Part0-net-rpc"><a href="#Part0-net-rpc" class="headerlink" title="Part0. net/rpc"></a>Part0. net/rpc</h2><blockquote>
<p>这一部分参考 <a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">《Go语言高级编程》4.1 RPC入门</a>。未尽之处可移步阅读原文。</p>
</blockquote>
<p>Go 标准库的 <code>net/rpc</code> 实现了基本的 RPC，它使用一种 Go 语言特有的 Gob 编码方式，所以服务端、客户端都必须使用 Golang，不能跨语言调用。</p>
<p>对于服务端， <code>net/rpc</code> 要求用一个导出的结构体来表示 RPC 服务，这个结构体中所有符合特定要求的方法就是提供给客户端访问的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">MethodName</span><span class="params">(argType T1, replyType *T2)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>结构体是导出的。</li>
<li>方法是导出的。</li>
<li>方法有两个参数，都是导出的类型（或者内置类型）。</li>
<li>方法的第二个参数是指针。</li>
<li>方法的返回值是 error。</li>
</ul>
<p>服务端通过 <code>rpc.Dial</code>（对 TCP 服务）连接服务端，然后用使用 Call 调用 RPC 服务中的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc.Call(<span class="string">&quot;T.MethodName&quot;</span>, argType T1, replyType *T2)</span><br></pre></td></tr></table></figure>
<p>例如，用 <code>net/rpc</code> 实现一个 Hello World。</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p><strong>服务端</strong></p>
<p>首先构建一个 <code>HelloService</code> 来表示提供的服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloService is a RPC service for helloWorld</span></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello say hello to request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*reply = <span class="string">&quot;Hello, &quot;</span> + request</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来注册并开启 RPC 服务，我们可以基于 HTTP 服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 用将给客户端访问的名字和HelloService实例注册 RPC 服务</span></span><br><span class="line">	rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HTTP 服务</span></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Http Listen and Serve:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 TCP 服务，替换上面的第 8～12 行代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 服务</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.ServeConn(conn)</span><br></pre></td></tr></table></figure>
<p>注意，这里服务端只 Accept 一个请求，在客户端请求过后就会自动关闭。如果需要一直保持处理，可以把后半部分代码换成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// HTTP</span></span><br><span class="line">	<span class="comment">// client, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//TCP</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;HelloService.Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先启动服务端：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run helloworld/server/server.go</span><br></pre></td></tr></table></figure>
<p>在另一个终端调用客户端，即可得到结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run helloworld/client/client.go</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure>
<h3 id="更规范的-RPC-接口"><a href="#更规范的-RPC-接口" class="headerlink" title="更规范的 RPC 接口"></a>更规范的 RPC 接口</h3><p>之前的代码服务端、客户端的注册、调用 RPC 服务都是写死的。所有的工作都放到了一块，相当不利于维护，需要考虑重构 HelloService 服务和客户端实现。</p>
<p><strong>服务端</strong></p>
<p>首先，用一个 interface 抽象服务接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloServiceName is the name of HelloService</span></span><br><span class="line"><span class="keyword">const</span> HelloServiceName = <span class="string">&quot;HelloService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloServiceInterface is a interface for HelloService</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHelloService register the RPC service on svc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloService</span><span class="params">(svc HelloServiceInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rpc.RegisterName(HelloServiceName, svc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实例化服务时，注册用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterHelloService(<span class="built_in">new</span>(HelloService))</span><br></pre></td></tr></table></figure>
<p>其余的具体服务实现没有改变。</p>
<p><strong>客户端</strong></p>
<p>在客户端，考虑将 RPC 细节封装到一个客户端对象 <code>HelloServiceClient</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloServiceClient is a client for HelloService</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	*rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ HelloServiceInterface = (*HelloServiceClient)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialHelloService dial HelloService</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHelloService</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*HelloServiceClient, error)</span></span> &#123;</span><br><span class="line">	c, err := rpc.Dial(network, address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> , err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;HelloServiceClient&#123;Client: c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello calls HelloService.Hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceClient)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Client.Call(HelloServiceName + <span class="string">&quot;.Hello&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用时，就不用去暴露处理 RPC 的细节了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">client, err := DialHelloService(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">err = client.Hello(<span class="string">&quot;world&quot;</span>, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reply)</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>运用上面的内容，做一个简单的计算器 RPC 服务。项目目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calc&#x2F;</span><br><span class="line">├── calcrpc.go</span><br><span class="line">├── client</span><br><span class="line">│   └── client.go</span><br><span class="line">└── server</span><br><span class="line">    ├── calc.go</span><br><span class="line">    └── server.go</span><br></pre></td></tr></table></figure>
<p>首先写一个 <code>calcrpc.go</code> 定义服务端/客户端通用的 RPC 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceName 计算器服务名</span></span><br><span class="line"><span class="keyword">const</span> ServiceName = <span class="string">&quot;CalcService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceInterface 计算器服务接口</span></span><br><span class="line"><span class="keyword">type</span> ServiceInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// CalcTwoNumber 对两个数进行运算</span></span><br><span class="line">	CalcTwoNumber(request Calc, reply *<span class="keyword">float64</span>)  error</span><br><span class="line">	<span class="comment">// GetOperators 获取所有支持的运算</span></span><br><span class="line">	GetOperators(request <span class="keyword">struct</span>&#123;&#125;, reply *[]<span class="keyword">string</span>)  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterCalcService register the RPC service on svc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCalcService</span><span class="params">(svc ServiceInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rpc.RegisterName(ServiceName, svc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calc 定义计算器对象，包括两个运算数</span></span><br><span class="line"><span class="keyword">type</span> Calc <span class="keyword">struct</span> &#123;</span><br><span class="line">	Number1 <span class="keyword">float64</span></span><br><span class="line">	Number2 <span class="keyword">float64</span></span><br><span class="line">	Operator <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写服务端实现，在 <code>calc.go</code> 中写一个常规的计算器抽象实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单计算器实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象的计算函数类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operation 是计算的抽象</span></span><br><span class="line"><span class="keyword">type</span> Operation <span class="function"><span class="keyword">func</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加减乘除的具体 Operation 实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 是加法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Number1 + Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub 是减法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Number1 - Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mul 是乘法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mul</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Number1 * Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Div 是除法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Number1 / Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 工厂 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operators 注册所有支持的运算</span></span><br><span class="line"><span class="keyword">var</span> Operators = <span class="keyword">map</span>[<span class="keyword">string</span>]Operation &#123;</span><br><span class="line">	<span class="string">&quot;+&quot;</span>: Add,</span><br><span class="line">	<span class="string">&quot;-&quot;</span>: Sub,</span><br><span class="line">	<span class="string">&quot;*&quot;</span>: Mul,</span><br><span class="line">	<span class="string">&quot;/&quot;</span>: Div,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateOperation 通过 string 表示的 operator 获取适合的 Operation 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateOperation</span><span class="params">(operator <span class="keyword">string</span>)</span> <span class="params">(Operation, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> oper Operation</span><br><span class="line">	<span class="keyword">if</span> oper, ok := Operators[operator]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> oper, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oper, errors.New(<span class="string">&quot;Illegal Operator&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是 RPC 服务的实现，在 <code>server.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gorpctest/calc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RPC 服务实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcService 是计算器 RPC 服务的实现</span></span><br><span class="line"><span class="keyword">type</span> CalcService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcTwoNumber 对两个数进行加减乘除运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcService)</span> <span class="title">CalcTwoNumber</span><span class="params">(request calc.Calc, reply *<span class="keyword">float64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	oper, err := CreateOperation(request.Operator)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	*reply = oper(request.Number1, request.Number2)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetOperators 获取所有支持的运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcService)</span> <span class="title">GetOperators</span><span class="params">(request <span class="keyword">struct</span>&#123;&#125;, reply *[]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	opers := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(Operators))</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> Operators &#123;</span><br><span class="line">		opers = <span class="built_in">append</span>(opers, key)</span><br><span class="line">	&#125;</span><br><span class="line">	*reply = opers</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行 RPC 服务 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	calc.RegisterCalcService(<span class="built_in">new</span>(CalcService))</span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是客户端实现，在 <code>client.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gorpctest/calc&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义客户端实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcClient is a client for CalcService</span></span><br><span class="line"><span class="keyword">type</span> CalcClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	*rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ calc.ServiceInterface = (*CalcClient)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialCalcService dial CalcService</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialCalcService</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*CalcClient, error)</span></span> &#123;</span><br><span class="line">	c, err := rpc.DialHTTP(network, address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> , err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;CalcClient&#123;Client: c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcTwoNumber 对两个数进行运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcClient)</span> <span class="title">CalcTwoNumber</span><span class="params">(request calc.Calc, reply *<span class="keyword">float64</span>)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Client.Call(calc.ServiceName + <span class="string">&quot;.CalcTwoNumber&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetOperators 获取所有支持的运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcClient)</span> <span class="title">GetOperators</span><span class="params">(request <span class="keyword">struct</span>&#123;&#125;, reply *[]<span class="keyword">string</span>)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Client.Call(calc.ServiceName + <span class="string">&quot;.GetOperators&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用客户端调用 RPC 服务 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	client, err := DialCalcService(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Err Dial Client:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test GetOperators</span></span><br><span class="line">	<span class="keyword">var</span> opers []<span class="keyword">string</span></span><br><span class="line">	err = client.GetOperators(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;, &amp;opers)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(opers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test CalcTwoNumber</span></span><br><span class="line">	testAdd := calc.Calc &#123;</span><br><span class="line">		Number1: <span class="number">2.0</span>,</span><br><span class="line">		Number2: <span class="number">3.14</span>,</span><br><span class="line">		Operator: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">float64</span></span><br><span class="line">	client.CalcTwoNumber(testAdd, &amp;result)</span><br><span class="line">	log.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="net-rpc-jsonrpc"><a href="#net-rpc-jsonrpc" class="headerlink" title="net/rpc/jsonrpc"></a>net/rpc/jsonrpc</h3><p><code>net/rpc</code> 允许 RPC 数据打包时通过插件实现自定义的编码和解码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务段的编码</span></span><br><span class="line">rpc.ServeCodec(SomeServerCodec(conn)) <span class="comment">// SomeServerCodec 是个编码器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的解码</span></span><br><span class="line">conn, _ := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">client := rpc.NewClientWithCodec(SomeClientCodec(conn)) <span class="comment">// SomeClientCodec 是个解码器</span></span><br></pre></td></tr></table></figure>
<p><code>net/rpc/jsonrpc</code> 就是这样的一种实现，它使用  JSON 而不是 Gob 编码，可以用来做跨语言 RPC。在真实的使用中，<code>net/rpc/jsonrpc</code> 在内部封装了上面提到的编码、解码实现，提供大致上和 <code>net/rpc</code> 相同的 API。</p>
<p>服务端在之前的 Hello World 基础上，只需要改动 main 的最后一行代码（不算 <code>&#125;</code>）即可变为使用 JSON RPC：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instead of `go rpc.ServeConn(conn)`</span></span><br><span class="line"><span class="keyword">go</span> jsonrpc.ServeConn(conn)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>jsonrpc.ServeConn</code> 的实现是 <code>rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</code></p>
</blockquote>
<p>在调用时，将 <code>DialHelloService</code> 中连接服务的代码改一改就可以使用了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instead of `c, err := rpc.Dial(network, address)`</span></span><br><span class="line">c, err := jsonrpc.Dial(network, address)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里也可以用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, _ := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br></pre></td></tr></table></figure>
<p>这样开的服务是基于 TCP 的。我们可以关闭服务端程序，运行 <code>nc -l 1234</code> 启动一个 TCP 服务，然后再次运行客户端程序，nc 会输出客户端请求的内容：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 1234</span><br><span class="line">&#123;<span class="string">&quot;method&quot;</span>:<span class="string">&quot;HelloService.Hello&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;world&quot;</span>],<span class="string">&quot;id&quot;</span>:0&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到请求体是 JSON 数据。反过来，模仿这个请求体，我们可以手动向正在运行的客户端发送模拟请求，查看响应体：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&#x27;&#123;&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;JSON-RPC&quot;],&quot;id&quot;:1&#125;&#x27;</span> | nc localhost 1234</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;result&quot;</span>:<span class="string">&quot;Hello, JSON-RPC&quot;</span>,<span class="string">&quot;error&quot;</span>:null&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，请求、响应的结构体大概为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    Method <span class="keyword">string</span>           <span class="string">`json:&quot;method&quot;`</span></span><br><span class="line">    Params *json.RawMessage <span class="string">`json:&quot;params&quot;`</span></span><br><span class="line">    Id     *json.RawMessage <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id     <span class="keyword">uint64</span>           <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    Result *json.RawMessage <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">    Error  <span class="keyword">interface</span>&#123;&#125;      <span class="string">`json:&quot;error&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（其实真正的实现中，客户端和服务端请求、响应定义是略有区别的）</p>
<p>使用其他语言，只要遵循这样的请求/响应结构，就可以和 Go 的 RPC 服务进行通信了。</p>
<h3 id="JSON-RPC-in-HTTP"><a href="#JSON-RPC-in-HTTP" class="headerlink" title="JSON-RPC in HTTP"></a>JSON-RPC in HTTP</h3><p>刚才的实现是基于 TCP 的，有时候不方便使用，我们可能更希望使用熟悉的 HTTP 协议。</p>
<p><code>net/rpc</code> 的 RPC 服务是建立在抽象的 <code>io.ReadWriteCloser</code> 接口之上的（conn），所以略作改变，就可以将 RPC 架设在不同的通讯协议之上。这里我们将尝试将 <code>net/rpc/jsonrpc</code> 架设到 HTTP 服务上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	RegisterHelloService(<span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HTTP 服务</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/jsonrpc&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> &#123;</span><br><span class="line">			io.Writer</span><br><span class="line">			io.ReadCloser</span><br><span class="line">		&#125; &#123;</span><br><span class="line">			ReadCloser: r.Body,</span><br><span class="line">			Writer: w,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过 HTTP 很方便地从不同的语言中访问 RPC 服务了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:1234/jsonrpc  --data <span class="string">&#x27;&#123;&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;world&quot;],&quot;id&quot;:0&#125;&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:0,<span class="string">&quot;result&quot;</span>:<span class="string">&quot;Hello, world&quot;</span>,<span class="string">&quot;error&quot;</span>:null&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这里有个问题是，不方便使用 Go 写客户端，你需要自己去构建一个客户端实现，来完成请求的编码、发送以及响应的解码、绑定😂。或者，也可以使用一个 JSON-RPC 的库。</p>
<h2 id="Part1-简单-RPC-的实现"><a href="#Part1-简单-RPC-的实现" class="headerlink" title="Part1. 简单 RPC 的实现"></a>Part1. 简单 RPC 的实现</h2><blockquote>
<p>这一部分参考 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV137411H7t9?p=9">《从0开始学习微服务框架》 P9~P14  RPC</a>。未尽之处可移步学习原视频。</p>
</blockquote>
<p>为了加深理解，我们手写一个简单的 RPC 服务，从自定义协议到编码、解码，再到 RPC 服务端、客户端实现。</p>
<p>我们写一个 <code>package rpc</code> 来实现这东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;rpc</span><br><span class="line">├── client.go</span><br><span class="line">├── codec.go</span><br><span class="line">├── server.go</span><br><span class="line">└── session.go</span><br><span class="line">(省略了测试文件)</span><br></pre></td></tr></table></figure>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>我们基于 TCP 通信，使用如下自定义的协议进行通信：</p>
<table>
<thead>
<tr>
<th><strong>网络字节流</strong></th>
<th>Header</th>
<th>Data</th>
</tr>
</thead>
<tbody><tr>
<td>大小</td>
<td><code>uint32</code>（定长：4字节）</td>
<td><code>[]byte</code>（长度由Header指明）</td>
</tr>
<tr>
<td>说明</td>
<td>Data 的长度信息</td>
<td>具体数据</td>
</tr>
</tbody></table>
<p>我们通过一个 <code>Session</code> 结构体实现这个基本的协议：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// session.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Session 是 RPC 通信的一个会话连接</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSession 从网络连接新建一个 Session</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(conn net.Conn)</span> *<span class="title">Session</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Session&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后的 RPC 通信就通过 <code>Session</code>  来对 TCP 连接进行数据读写操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// session.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 向 Session 中写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>+<span class="built_in">len</span>(data))</span><br><span class="line">	<span class="comment">// Header</span></span><br><span class="line">	binary.BigEndian.PutUint32(buf[:<span class="number">4</span>], <span class="keyword">uint32</span>(<span class="built_in">len</span>(data)))</span><br><span class="line">	<span class="comment">// Data</span></span><br><span class="line">	<span class="built_in">copy</span>(buf[<span class="number">4</span>:], data)</span><br><span class="line"></span><br><span class="line">	_, err := s.conn.Write(buf)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 从 Session 中读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Read</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 读取 Header，获取 Data 长度信息</span></span><br><span class="line">	header := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> _, err := io.ReadFull(s.conn, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	dataLen := binary.BigEndian.Uint32(header)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照 dataLen 读取 Data</span></span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, dataLen)</span><br><span class="line">	<span class="keyword">if</span> _, err := io.ReadFull(s.conn, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h3><p>在 RPC 的过程中，我们需要按照一定的格式传递函数的参数与结果。我们可以定义如下 <code>RPCData</code> 来格式化 RPC 通信的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// codec.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPCData 定义 RPC 通信的数据格式</span></span><br><span class="line"><span class="keyword">type</span> RPCData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Func <span class="keyword">string</span>        <span class="comment">// 访问的函数</span></span><br><span class="line">	Args []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 函数的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在整个 RPC 中，所有网络通信都利用 <code>Session</code> 对 <code>RPCData</code> 编码成的 <code>[]byte</code> 进行传输。要把 <code>RPCData</code> 在一端编码成字节，并在另一端解码会原本的 Go 数据类型，可以利用 <code>encoding/gob</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// codec.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// encode 将 RPCData 编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(data RPCData)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	encoder := gob.NewEncoder(&amp;buf)</span><br><span class="line">	<span class="keyword">if</span> err := encoder.Encode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decode 将数据解码为 RPCData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(RPCData, error)</span></span> &#123;</span><br><span class="line">	buf := bytes.NewBuffer(data)</span><br><span class="line">	decoder := gob.NewDecoder(buf)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> rpcData RPCData</span><br><span class="line">	err := decoder.Decode(&amp;rpcData)</span><br><span class="line">	<span class="keyword">return</span> rpcData, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了网络通信的方案以及编码解码的方式，就可以开始构建 RPC 服务的服务端框架以及客户端实现了。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>RPC 服务端的核心是，维护一个函数名到本地函数的映射。实现这个映射，并开启一个网络服务，就可以支持客户端通过给定函数名和参数即可调用服务端函数的操作了。</p>
<p>这里可以简单地把服务定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Server 是简单的 RPC 服务</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	funcs <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Server&#123;funcs: <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Value&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反射机制，来实现 funs 的映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register 注册绑定要 RPC 服务的函数</span></span><br><span class="line"><span class="comment">// 将函数名与函数对应起来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, function <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 已存在则跳过</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := s.funcs[name]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fVal := reflect.ValueOf(function)</span><br><span class="line">	s.funcs[name] = fVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是开启网络服务，监听  TCP 连接，对访问进行服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe 监听 address，运行 RPC 服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;accept error:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.handleConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体对连接的处理在 <code>handleConn</code> 中完成。对 conn 创建一个 RPC 会话，解码请求体，得到客户端希望请求的函数和参数。调用本地函数完成工作，将返回值编码，返回给客户端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// handleConn 处理 RPC 服务的 conn 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建会话</span></span><br><span class="line">	srvSession := NewSession(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取、解码数据</span></span><br><span class="line">	data, err := srvSession.Read()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;session read error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	requestRPCData, err := decode(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;data decode error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取函数</span></span><br><span class="line">	f, ok := s.funcs[requestRPCData.Func]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;unexpected rpc call: function %s not exist&quot;</span>, requestRPCData.Func)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取参数</span></span><br><span class="line">	inArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(requestRPCData.Args))</span><br><span class="line">	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> requestRPCData.Args &#123;</span><br><span class="line">		inArgs = <span class="built_in">append</span>(inArgs, reflect.ValueOf(arg))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反射调用方法</span></span><br><span class="line">	returnValues := f.Call(inArgs)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造结果</span></span><br><span class="line">	outArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(returnValues))</span><br><span class="line">	<span class="keyword">for</span> _, ret := <span class="keyword">range</span> returnValues &#123;</span><br><span class="line">		outArgs = <span class="built_in">append</span>(outArgs, ret.Interface())</span><br><span class="line">	&#125;</span><br><span class="line">	replyRPCData := RPCData&#123;</span><br><span class="line">		Func: requestRPCData.Func,</span><br><span class="line">		Args: outArgs,</span><br><span class="line">	&#125;</span><br><span class="line">	replyEncoded, err := encode(replyRPCData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;reply encode error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入结果</span></span><br><span class="line">	err = srvSession.Write(replyEncoded)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;reply write error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>RPC 客户端的一个特点是，像调用本地函数一样去调用远程的函数。要调用的函数并不是在本地实现的，但我们希望让它像本地函数一样工作。反射机制可以提供这种“欺骗自己”的特性。</p>
<p>首先我们写出客户端结构，其实就是对一个网络连接的包装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Client 是 RPC 的客户端</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn net.Conn)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Client&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现一个 <code>Call</code> 方法，把原创的函数通过 RPC 带到本地来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">(name <span class="keyword">string</span>, funcPtr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 反射初始化 funcPtr 函数原型</span></span><br><span class="line">	fn := reflect.ValueOf(funcPtr).Elem()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RPC 调用远程的函数</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(args []reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">		<span class="comment">// 参数</span></span><br><span class="line">		inArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">		<span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">			inArgs = <span class="built_in">append</span>(inArgs, arg.Interface())</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 连接服务</span></span><br><span class="line">		cliSession := NewSession(c.conn)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 请求</span></span><br><span class="line">		requestRPCData := RPCData&#123;</span><br><span class="line">			Func: name,</span><br><span class="line">			Args: inArgs,</span><br><span class="line">		&#125;</span><br><span class="line">		requestEncoded, err := encode(requestRPCData)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := cliSession.Write(requestEncoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 响应</span></span><br><span class="line">		response, err := cliSession.Read()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		respRPCData, err := decode(response)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		outArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(respRPCData.Args))</span><br><span class="line">		<span class="keyword">for</span> i, arg := <span class="keyword">range</span> respRPCData.Args &#123;</span><br><span class="line">			<span class="keyword">if</span> arg == <span class="literal">nil</span> &#123;</span><br><span class="line">				outArgs = <span class="built_in">append</span>(outArgs, reflect.Zero(fn.Type().Out(i)))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				outArgs = <span class="built_in">append</span>(outArgs, reflect.ValueOf(arg))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回远程函数的返回值</span></span><br><span class="line">		<span class="keyword">return</span> outArgs</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 RPC 调用函数赋给 fn</span></span><br><span class="line">	v := reflect.MakeFunc(fn.Type(), f)</span><br><span class="line">	fn.Set(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受两个参数，<code>name</code> 为 RPC 服务端提供的函数名，<code>funcPtr</code> 是要调用的函数的原型。该函数运行的结果是将一个「封装了 RPC 调用远程函数的函数」“赋给” <code>funcPtr</code>，让 <code>funcPtr</code> 从一个空有其表的原型变成一个可调用的真实函数，调用它就等于通过 RPC 调用服务端相应的函数。</p>
<p>例如，我们在服务端实现并注册了函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryUser</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span> &#123;</span><br><span class="line">	... <span class="comment">// queryUser 的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端，我们就可以通过一个 queryUser 函数的原型来获得其能力：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(User, error)</span> // <span class="title">query</span> 是 <span class="title">queryUser</span> 的原型</span></span><br><span class="line">client.Call(<span class="string">&quot;queryUser&quot;</span>, &amp;query) <span class="comment">// “拿到”远程的 queryUser 函数</span></span><br><span class="line">u, err := query(<span class="number">1</span>) <span class="comment">// 像调用本地函数一样去使用来自远程的函数</span></span><br></pre></td></tr></table></figure>
<p>如果对反射不太熟悉，难以理解代码实现的话，这里可能有点迷。再来看一个具体调用的例子吧：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc_test.go</span></span><br><span class="line"><span class="keyword">package</span> rpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// User  测试用的用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// queryUser 模拟查询用户的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryUser</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fake data</span></span><br><span class="line">	user := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]User)</span><br><span class="line">	user[<span class="number">0</span>] = User&#123;Name: <span class="string">&quot;Foo&quot;</span>, Age: <span class="number">12</span>&#125;</span><br><span class="line">	user[<span class="number">1</span>] = User&#123;Name: <span class="string">&quot;Bar&quot;</span>, Age: <span class="number">13</span>&#125;</span><br><span class="line">	user[<span class="number">2</span>] = User&#123;Name: <span class="string">&quot;Joe&quot;</span>, Age: <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fake query</span></span><br><span class="line">	<span class="keyword">if</span> u, ok := user[uid]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> User&#123;&#125;, fmt.Errorf(<span class="string">&quot;user wiht id %d is not exist&quot;</span>, uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRPC</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	gob.Register(User&#123;&#125;) <span class="comment">// gob 编码要注册一下才能编码结构体</span></span><br><span class="line"></span><br><span class="line">	addr := <span class="string">&quot;:8080&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务端</span></span><br><span class="line">	srv := NewServer()</span><br><span class="line">	srv.Register(<span class="string">&quot;queryUser&quot;</span>, queryUser)</span><br><span class="line">	<span class="keyword">go</span> srv.ListenAndServe(addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	cli := NewClient(conn)</span><br><span class="line">	<span class="keyword">var</span> query <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span></span><br><span class="line">	cli.Call(<span class="string">&quot;queryUser&quot;</span>, &amp;query)</span><br><span class="line"></span><br><span class="line">	u, err := query(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TestRPC</code> 中模拟了服务端以及客户端调用 RPC 服务。</p>
<p>至此，一个完整的玩具版 RPC 就完成了，自己来写这东西还是挺有意思。完整的代码我放到了这个 Gist 里 <a target="_blank" rel="noopener" href="https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f">cdfmlr/toy-rpc-golang</a>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f">https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f</a></li>
</ul>
<script src="https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f.js"></script>

<hr>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">By(<span class="string">&quot;CDFMLR&quot;</span>, <span class="string">&quot;2020-09-12&quot;</span>)</span><br><span class="line"><span class="comment">// See you.💪</span></span><br></pre></td></tr></table></figure>

  </div>
</article>
<!--Disqus-->


<!--Livere-->

    <div class="blog-post-comments">
        <div id="lv-container" data-id="city" data-uid="MTAyMC80NjEzMi8yMjY0Mw==">
            <noscript>不启用 JavaScript 支持的人是看不到可爱的评论区的。😥</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Go RPC 远程过程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part0-net-rpc"><span class="toc-number">1.1.</span> <span class="toc-text">Part0. net&#x2F;rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-World"><span class="toc-number">1.1.1.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E8%A7%84%E8%8C%83%E7%9A%84-RPC-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">更规范的 RPC 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-rpc-jsonrpc"><span class="toc-number">1.1.4.</span> <span class="toc-text">net&#x2F;rpc&#x2F;jsonrpc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-RPC-in-HTTP"><span class="toc-number">1.1.5.</span> <span class="toc-text">JSON-RPC in HTTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part1-%E7%AE%80%E5%8D%95-RPC-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Part1. 简单 RPC 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">网络通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">编码解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&text=Go RPC 远程过程调用"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&is_video=false&description=Go RPC 远程过程调用"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Go RPC 远程过程调用&body=Check out this article: https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&title=Go RPC 远程过程调用"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/09/09/blog/Golang-RPC_Intro/&name=Go RPC 远程过程调用&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 CDFMLR
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-146911386-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?9a0d2e6fde93dad496ac79f04f3aba97";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


<!--Livere Comments-->

    <script type="text/javascript">
      (function (d, s) {
        var j, e = d.getElementsByTagName(s)[0];

        if (typeof LivereTower === 'function') { return; }

        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;

        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>

</body>
</html>
