<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>命令式编程 V.S. 声明式编程</title>
      <link href="/2021/01/09/note/ImperativeDeclarativeProgramming/"/>
      <url>/2021/01/09/note/ImperativeDeclarativeProgramming/</url>
      
        <content type="html"><![CDATA[<h1 id="命令式编程-V-S-声明式编程"><a href="#命令式编程-V-S-声明式编程" class="headerlink" title="命令式编程 V.S. 声明式编程"></a>命令式编程 V.S. 声明式编程</h1><blockquote><p>Programming: Imperative &amp; Declarative</p></blockquote><p><img src="ImperativeDeclarativeProgramming/ImperativeDeclarativeProgramming.png" alt="ImperativeDeclarativeProgramming"></p><p>Q：检查 students 里的学生的平均分，并输出平均分的第一名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> scores: [<span class="type">Subject</span>: <span class="type">Int</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Subject</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Chinese</span>, <span class="type">Math</span>, <span class="type">English</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 <span class="operator">=</span> <span class="type">Student</span>(</span><br><span class="line">    name: <span class="string">&quot;Foo&quot;</span>,</span><br><span class="line">    scores: [.<span class="type">Chinese</span>: <span class="number">86</span>, .<span class="type">Math</span>: <span class="number">92</span>, .<span class="type">English</span>: <span class="number">73</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 <span class="operator">=</span> <span class="type">Student</span>(</span><br><span class="line">    name: <span class="string">&quot;Bar&quot;</span>,</span><br><span class="line">    scores: [.<span class="type">Chinese</span>: <span class="number">99</span>, .<span class="type">Math</span>: <span class="number">52</span>, .<span class="type">English</span>: <span class="number">97</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 <span class="operator">=</span> <span class="type">Student</span>(</span><br><span class="line">    name: <span class="string">&quot;Joe&quot;</span>,</span><br><span class="line">    scores: [.<span class="type">Chinese</span>: <span class="number">91</span>, .<span class="type">Math</span>: <span class="number">92</span>, .<span class="type">English</span>: <span class="number">100</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> students <span class="operator">=</span> [s1, s2, s3]</span><br></pre></td></tr></table></figure><h2 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h2><p>一步步告诉计算机怎么做。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式.swift</span></span><br><span class="line"><span class="keyword">var</span> best: (<span class="type">Student</span>, <span class="type">Double</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> students &#123;</span><br><span class="line">    <span class="keyword">var</span> totalScore <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="type">Subject</span>.allCases &#123;</span><br><span class="line">        totalScore <span class="operator">+=</span> s.scores[key] <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> averageScore <span class="operator">=</span> <span class="type">Double</span>(totalScore) <span class="operator">/</span></span><br><span class="line">    <span class="type">Double</span>(<span class="type">Subject</span>.allCases.count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> temp <span class="operator">=</span> best &#123;</span><br><span class="line">        <span class="keyword">if</span> averageScore <span class="operator">&gt;</span> temp.<span class="number">1</span> &#123;</span><br><span class="line">            best <span class="operator">=</span> (s, averageScore)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        best <span class="operator">=</span> (s, averageScore)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(best<span class="operator">?</span>.<span class="number">0</span>.name <span class="operator">??</span> <span class="string">&quot;no students&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><p>告诉计算机要做什么，具体实现由计算机决定。</p><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式.swift</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">average</span><span class="params">(<span class="keyword">_</span> scores: [Subject: Int])</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Double</span>(scores.values.reduce(<span class="number">0</span>, <span class="operator">+</span>)) <span class="operator">/</span> <span class="type">Double</span>(<span class="type">Subject</span>.allCases.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bestStudent <span class="operator">=</span> students</span><br><span class="line">    .map &#123; (<span class="variable">$0</span>, average(<span class="variable">$0</span>.scores)) &#125;</span><br><span class="line">    .sorted &#123; <span class="variable">$0</span>.<span class="number">1</span> <span class="operator">&gt;</span> <span class="variable">$1</span>.<span class="number">1</span> &#125;</span><br><span class="line">    .first</span><br></pre></td></tr></table></figure><p>（我是有点喜欢函数式啦，但 SICP 至今没看完。。）</p><h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>例如 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, <span class="built_in">avg</span>(score) <span class="keyword">as</span> avs_score </span><br><span class="line"><span class="keyword">from</span> scores <span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> avg_score;</span><br></pre></td></tr></table></figure><p>（不喜欢 SQL，我非常讨厌 <code>group by</code> 这种超过一个词的关键字，所以天天用 ORM。。）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数值分析算法总结</title>
      <link href="/2020/11/28/Algorithm/NumericalAnalysisAlogrithm/"/>
      <url>/2020/11/28/Algorithm/NumericalAnalysisAlogrithm/</url>
      
        <content type="html"><![CDATA[<h1 id="数值分析算法总结"><a href="#数值分析算法总结" class="headerlink" title="数值分析算法总结"></a>数值分析算法总结</h1><p>数值分析的算法总结，用 Python 简要描述各种方法。考前复（yu）习向。</p><p>本文给出的代码主要是针对闭卷考试背算法写的。我 jo 得记数学公式和写 LaTeX 一样，是件比写代码更可怕的事。所以，把一些主要的算法用程序写了出来，方便记忆。</p><p>（其中一部分是考试前复习时写的，经过考场的抽样检验，比较靠谱。但那时写的不太完整，后面又补充写了点，这时成绩都出了，学的也都忘了，所以可能不太对，总之别报太大期望啦~）</p><p>如果你需要的是更全的各种算法完整的代码实现与描述，请移步：</p><ul><li><a href="https://github.com/cdfmlr/NumericalAnalysis">https://github.com/cdfmlr/NumericalAnalysis</a></li><li>or <a href="https://gitee.com/cdfmlr/NumericalAnalysis">https://gitee.com/cdfmlr/NumericalAnalysis</a></li></ul><p>All right, talk is cheap, let me show you the code!</p><h2 id="非线性方程求根"><a href="#非线性方程求根" class="headerlink" title="非线性方程求根"></a>非线性方程求根</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = (a + b) / <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> f(x) * f(a) &lt; <span class="number">0</span>:</span><br><span class="line">        b = x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">a = x</span><br><span class="line">x = (a + b) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="不动点迭代"><a href="#不动点迭代" class="headerlink" title="不动点迭代"></a>不动点迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = x_0</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = phi(x)</span><br></pre></td></tr></table></figure><p>收敛：<code>diff(phi, x)</code>存在且连续 &amp;&amp; <code>abs(diff(phi, x)(x_0)) &lt; 1</code>。</p><p>or: 设 $x^*$ 为 $f(x)=0$ 的根，可以得到 $x^*=…(x^*)$，所以 $x^*$ 为 <code>x = phi(x)</code> 的不动点，对 $x^*$ 领域的 x：<code>abs(diff(phi, x)) &lt; 1</code></p><h3 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = x_0</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x -= f(x) / df(x)</span><br></pre></td></tr></table></figure><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="Lagrange-插值"><a href="#Lagrange-插值" class="headerlink" title="Lagrange 插值"></a>Lagrange 插值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lagrange_interpolate</span>(<span class="params">points</span>):</span></span><br><span class="line">L = <span class="number">0</span>  <span class="comment"># 插值多项式</span></span><br><span class="line">    <span class="keyword">for</span> i, (xi, yi) <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">        li = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j, (xj, yj) <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">            <span class="keyword">if</span> j == i:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            li *= (x - xj) / (xi - xj)</span><br><span class="line">        L += yi * li</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><p>这个程序不太好懂，还是看公式：</p><p>$$<br>L(x)=\sum <em>{j=0}^{k}y</em>{j}\ell _{j}(x)<br>$$</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm74xhj8pcj31fk06eta3.jpg" alt="截屏2020-12-31 16.48.44"></p><p>P.S. 这个公式是直接 Wikipedia 上复制的，KaTeX 渲染不出来，就放图片了。下面是它的源码：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\ell</span> <span class="built_in">_</span>&#123;j&#125;(x)=<span class="keyword">\prod</span> <span class="built_in">_</span>&#123;&#123;i=0,<span class="keyword">\,</span>i<span class="keyword">\neq</span> j&#125;&#125;<span class="built_in">^</span>&#123;&#123;k&#125;&#125;&#123;<span class="keyword">\frac</span> &#123;x-x<span class="built_in">_</span>&#123;i&#125;&#125;&#123;x<span class="built_in">_</span>&#123;j&#125;-x<span class="built_in">_</span>&#123;i&#125;&#125;&#125;=&#123;<span class="keyword">\frac</span> &#123;(x-x<span class="built_in">_</span>&#123;0&#125;)&#125;&#123;(x<span class="built_in">_</span>&#123;j&#125;-x<span class="built_in">_</span>&#123;0&#125;)&#125;&#125;<span class="keyword">\cdots</span> &#123;<span class="keyword">\frac</span> &#123;(x-x<span class="built_in">_</span>&#123;&#123;j-1&#125;&#125;)&#125;&#123;(x<span class="built_in">_</span>&#123;j&#125;-x<span class="built_in">_</span>&#123;&#123;j-1&#125;&#125;)&#125;&#125;&#123;<span class="keyword">\frac</span> &#123;(x-x<span class="built_in">_</span>&#123;&#123;j+1&#125;&#125;)&#125;&#123;(x<span class="built_in">_</span>&#123;j&#125;-x<span class="built_in">_</span>&#123;&#123;j+1&#125;&#125;)&#125;&#125;<span class="keyword">\cdots</span> &#123;<span class="keyword">\frac</span> &#123;(x-x<span class="built_in">_</span>&#123;&#123;k&#125;&#125;)&#125;&#123;(x<span class="built_in">_</span>&#123;j&#125;-x<span class="built_in">_</span>&#123;&#123;k&#125;&#125;)&#125;&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><h3 id="Newton-插值"><a href="#Newton-插值" class="headerlink" title="Newton 插值"></a>Newton 插值</h3><p>差商：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dq</span>(<span class="params">f, xs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(xs) == <span class="number">1</span>:  <span class="comment"># 0阶</span></span><br><span class="line">        <span class="keyword">return</span> f(xs[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># n 阶</span></span><br><span class="line">    <span class="keyword">return</span> (dq(f, xs[<span class="number">1</span>:]) - dq(f, xs[:-<span class="number">1</span>])) / (xs[-<span class="number">1</span>] - xs[<span class="number">0</span>]) </span><br></pre></td></tr></table></figure><p>手算用表：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl6bgm6utbj31540igtek.jpg" alt="截屏2020-11-29 20.25.29"></p><p>Newton 插值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_interpolate</span>(<span class="params">points</span>):</span></span><br><span class="line">    N = <span class="number">0</span></span><br><span class="line">    xs = []</span><br><span class="line">    <span class="keyword">for</span> (x, y) <span class="keyword">in</span> points:</span><br><span class="line">        xs.append(x)</span><br><span class="line">        N += dq(f, xs) * prod( [(<span class="string">&#x27;x&#x27;</span> - xi) <span class="keyword">for</span> xi <span class="keyword">in</span> xs[:-<span class="number">1</span>]] )</span><br><span class="line">    <span class="keyword">return</span> N</span><br></pre></td></tr></table></figure><h2 id="最小二乘拟合"><a href="#最小二乘拟合" class="headerlink" title="最小二乘拟合"></a>最小二乘拟合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].T</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>].T</span><br><span class="line"></span><br><span class="line">X = [<span class="number">1</span>, x, x**<span class="number">2</span>]</span><br><span class="line"><span class="comment"># (X.T @ X) @ theta = X.T @ y</span></span><br><span class="line">theta = pinv(X.T @ X) @ X.T @ y</span><br></pre></td></tr></table></figure><p><code>@</code> 是矩阵乘法（这是标准的 Python 运算符哦：<a href="https://docs.python.org/3/library/operator.html#operator.matmul%EF%BC%89">https://docs.python.org/3/library/operator.html#operator.matmul）</a></p><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><h3 id="梯形求积公式"><a href="#梯形求积公式" class="headerlink" title="梯形求积公式"></a>梯形求积公式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = (b - a) * (f(a) + f(b)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="辛普森求积公式"><a href="#辛普森求积公式" class="headerlink" title="辛普森求积公式"></a>辛普森求积公式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = (b - a) * (f(a) + <span class="number">4</span> * f((a + b) / <span class="number">2</span>) + f(b)) / <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Newton-Cotes"><a href="#Newton-Cotes" class="headerlink" title="Newton-Cotes"></a>Newton-Cotes</h3><p>求柯特斯系数 $C_k^{(n)}$:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">costes_coefficient</span>(<span class="params">n, k</span>):</span></span><br><span class="line">    ckn = ((-<span class="number">1</span>) ** (n - k)) / n * factorial(k) * factorial(n - k)</span><br><span class="line"></span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    t = Symbol(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> j != k:</span><br><span class="line">            h *= (t - j)</span><br><span class="line"></span><br><span class="line">    ckn *= integrate(h, (t, <span class="number">0</span>, n))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ckn</span><br></pre></td></tr></table></figure><p>打张表方便手算：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm74jwolc6j315s0fw40k.jpg" alt="costes_coefficient_table"></p><p>牛顿-科特斯求积公式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_cotes_integral</span>(<span class="params">f, a, b, n</span>):</span></span><br><span class="line">    step = (b - a) / n</span><br><span class="line">    xs = [a + i * step <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> (b - a) * <span class="built_in">sum</span>([costes_coefficient(n, k) * f(xs[k]) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n+<span class="number">1</span>)])</span><br></pre></td></tr></table></figure><h2 id="常微分方程初值问题"><a href="#常微分方程初值问题" class="headerlink" title="常微分方程初值问题"></a>常微分方程初值问题</h2><p>问题：<br>$$<br>\begin{cases}<br>y’(x)=f(x,y)\<br>y(a)=y_0\<br>\end{cases}<br>\qquad (a\le x \le b)<br>$$</p><h3 id="改进-Euler"><a href="#改进-Euler" class="headerlink" title="改进 Euler"></a>改进 Euler</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improved_euler</span>(<span class="params">f, a, b, h, y0</span>):</span>    </span><br><span class="line">    x = a</span><br><span class="line">    y = y0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> x &lt;= b:</span><br><span class="line">        <span class="keyword">yield</span> (x, y)</span><br><span class="line"></span><br><span class="line">        y_next_g = y + h * f(x, y)  <span class="comment"># 预估</span></span><br><span class="line">        y_next = y + h * ( f(x, y) + f(x+h, y_next_g) ) / <span class="number">2</span>  <span class="comment"># 校正</span></span><br><span class="line">        </span><br><span class="line">        x = x + h</span><br><span class="line">        y = y_next</span><br></pre></td></tr></table></figure><h3 id="RK4"><a href="#RK4" class="headerlink" title="RK4"></a>RK4</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runge_kutta</span>(<span class="params">f, a, b, h, y0</span>):</span></span><br><span class="line">    x = a</span><br><span class="line">    y = y0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> x &lt;= b:</span><br><span class="line">        <span class="keyword">yield</span> (x, y)</span><br><span class="line"></span><br><span class="line">        k1 = f(x, y)</span><br><span class="line">        k2 = f(x + h / <span class="number">2</span>, y + h * k1 / <span class="number">2</span>)</span><br><span class="line">        k3 = f(x + h / <span class="number">2</span>, y + h * k2 / <span class="number">2</span>)</span><br><span class="line">        k4 = f(x + h, y + h * k3)</span><br><span class="line">        </span><br><span class="line">        x = x + h</span><br><span class="line">        y = y + h * (k1 + <span class="number">2</span> * k2 + <span class="number">2</span> * k3 + k4) / <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="线性方程组直接解法"><a href="#线性方程组直接解法" class="headerlink" title="线性方程组直接解法"></a>线性方程组直接解法</h2><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A = np.c_[a, b]  <span class="comment"># 增广矩阵</span></span><br><span class="line"></span><br><span class="line">n = A.shape[<span class="number">0</span>]</span><br><span class="line">x = np.zeros(n)  <span class="comment"># 解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消元</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 列选主元，如果做顺序消元就不用做下面两行</span></span><br><span class="line">    i_max = k + argmax(<span class="built_in">abs</span>(A[k:n, k]))</span><br><span class="line">    A[[i_max, k]] = A[[k, i_max]]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># if A[k][k] == 0: 求解失败</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>, n):</span><br><span class="line">        m = A[i][k] / A[k][k];</span><br><span class="line">        A[i][k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            A[i][j] -= A[k][j] * m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回代：解三角方程</span></span><br><span class="line">x[n-<span class="number">1</span>] = A[n-<span class="number">1</span>][n] / A[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># from n-2 (included) to 0 (included)</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>, n):</span><br><span class="line">        A[k][n] -= A[k][j] * x[j]</span><br><span class="line">    x[k] = A[k][n] / A[k][k]</span><br></pre></td></tr></table></figure><h3 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h3><p>系数矩阵 a：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n = a.shape[<span class="number">0</span>]</span><br><span class="line">p = [<span class="number">0</span>, <span class="number">1</span>, ..., n-<span class="number">1</span>]  <span class="comment"># 记录交换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> 列选主元:</span><br><span class="line">        i_max = k + argmax(<span class="built_in">abs</span>(a[k:n, k]))</span><br><span class="line">        <span class="keyword">if</span> i_max != k:</span><br><span class="line">            a[[i_max, k]] = a[[k, i_max]]  <span class="comment"># swap rows</span></span><br><span class="line">            p[[i_max, k]] = p[[k, i_max]]  <span class="comment"># record</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> a[k][k] != <span class="number">0</span>, <span class="string">&quot;错误: 主元素为零&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>, n):</span><br><span class="line">        a[i][k] /= a[k][k]  <span class="comment"># L @ 严格下三角</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>, n):</span><br><span class="line">            a[i][j] -= a[i][k] * a[k][j]  <span class="comment"># U @ 上三角</span></span><br></pre></td></tr></table></figure><p>把右端常数 b 做相同的行交换（p 记录）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = [b[v] <span class="keyword">for</span> v <span class="keyword">in</span> p]</span><br></pre></td></tr></table></figure><p>然后就可以解方程了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解方程(&quot;L * y = b&quot;) =&gt; y</span><br><span class="line">解方程(&quot;U * x = y&quot;) =&gt; x</span><br></pre></td></tr></table></figure><p>附：解三角方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.zeros(n, dtype=np.<span class="built_in">float</span>)</span><br><span class="line">x[n-<span class="number">1</span>] = y[n-<span class="number">1</span>] / u[n-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># from n-2 (included) to 0 (included)</span></span><br><span class="line">    yi = y[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">        yi -= x[j] * u[i][j]</span><br><span class="line">    x[i] = yi / u[i][i]</span><br></pre></td></tr></table></figure><h2 id="线性方程组迭代解法"><a href="#线性方程组迭代解法" class="headerlink" title="线性方程组迭代解法"></a>线性方程组迭代解法</h2><h3 id="Jacobi-迭代"><a href="#Jacobi-迭代" class="headerlink" title="Jacobi 迭代"></a>Jacobi 迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A =  D - L - U</span></span><br><span class="line">D = diag(diag(A))</span><br><span class="line">L = - tril(A, -<span class="number">1</span>)</span><br><span class="line">U = - triu(A, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">B = inv(D) @ (L + U)</span><br><span class="line">f = inv(D) @ </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x_prev = x</span><br><span class="line">    x = B @ x + f</span><br></pre></td></tr></table></figure><p>emmmm，这种去手算不太现实。我依稀记得直接写出方程来算更容易（我考完试好久了，已经忘了）。。。</p><h3 id="Gauss-Seidel-迭代"><a href="#Gauss-Seidel-迭代" class="headerlink" title="Gauss-Seidel 迭代"></a>Gauss-Seidel 迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = inv(D - L) @ U</span><br><span class="line">f = inv(D - L) @ b</span><br></pre></td></tr></table></figure><h2 id="特征值求法"><a href="#特征值求法" class="headerlink" title="特征值求法"></a>特征值求法</h2><h3 id="正幂法"><a href="#正幂法" class="headerlink" title="正幂法"></a>正幂法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = array(shape=(n, n)) <span class="comment"># A 是要求特征值的 n*n 矩阵</span></span><br><span class="line"></span><br><span class="line">m = m0 = <span class="number">1</span>  <span class="comment"># 主特征值</span></span><br><span class="line">u = u0 = [<span class="number">1</span>, <span class="number">1</span>, ..., <span class="number">1</span>]  <span class="comment"># 对应的特征向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">m_prev = m</span><br><span class="line"></span><br><span class="line">v = dot(A, u)</span><br><span class="line">m = v[argmax(<span class="built_in">abs</span>(v))]</span><br><span class="line">u = v / m</span><br></pre></td></tr></table></figure><h3 id="反幂法"><a href="#反幂法" class="headerlink" title="反幂法"></a>反幂法</h3><p>正幂法改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = solve(A, u)</span><br></pre></td></tr></table></figure><p>最后结果是 <code>1/m</code> 和 <code>u</code>。</p><hr><blockquote><p>EOF</p><p>By CDFMLR 2020.12.31</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python删除字符串后缀问题</title>
      <link href="/2020/11/24/blog/python_removesuffix/"/>
      <url>/2020/11/24/blog/python_removesuffix/</url>
      
        <content type="html"><![CDATA[<h1 id="Python删除字符串后缀问题"><a href="#Python删除字符串后缀问题" class="headerlink" title="Python删除字符串后缀问题"></a>Python删除字符串后缀问题</h1><p>[TOC]</p><h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>我的 GitHub Pages 博客 <a href="https://clownote.github.io/">clownote</a> 是通过 Hexo + 一些自己写的本地脚本 + Github Action 来自动发布的（参考鄙人拙作《<a href="https://blog.csdn.net/u012419550/article/details/107594751">还在手动发博客？GitHub Actions自动化真香</a>》）。</p><p>文章修改的 GitHub 提交信息是通过一个脚本自动生成的，它会列出修改的文章名对于具体的文章（都是 markdown），会忽略后缀 <code>.md</code>，这样好看一些，而其他文件（工具脚本）则保留完整文件名：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl041kzke7j30n50ai0u3.jpg" alt="截屏2020-11-24 11.39.24"></p><p>前几天写了篇名叫 <code>Intro_sham.md</code> 的文章，即《<a href="https://blog.csdn.net/u012419550/article/details/109731346">我这人不懂什么操作系统，于是用Go语言模拟出了一个</a>》，它的提交信息是：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl043el96rj30k303c3yq.jpg" alt="截屏2020-11-24 11.41.14"></p><p><code>changed files: Intro_sha</code> 莫名缺了一个 <code>m</code>。。。</p><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>打开工具脚本，找到写 Git 提交 message 的代码在这里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    names = <span class="built_in">map</span>(<span class="keyword">lambda</span> f: os.path.basename(f).rstrip(<span class="string">&#x27;.md&#x27;</span>), changed)</span><br><span class="line">    commit_msg = <span class="string">&#x27;changed files: &#x27;</span> + <span class="string">&#x27;, &#x27;</span>.join(names)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>changed files</code> 的名字是通过一个作用于所有改变了的文件的 map 方法得到的。这个 map 做的工作是把文件的路径和 <code>.md</code> 后缀去掉（只是为了好看）。</p><p>问题呼之欲出 —— <code>rstrip</code> 的错误使用。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;emmm.md&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip(<span class="string">&#x27;.md&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="RTFM"><a href="#RTFM" class="headerlink" title="RTFM"></a>RTFM</h2><p>看一看 rstrip 的文档：<a href="https://docs.python.org/3.7/library/stdtypes.html#str.rstrip">https://docs.python.org/3.7/library/stdtypes.html#str.rstrip</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.rstrip([chars])</span><br></pre></td></tr></table></figure><p>里面写了：</p><blockquote><p>Return a copy of the string with trailing characters removed.<br>The chars argument is a string specifying the set of charactersto be removed.<br>The chars argument is not a suffix; rather, all combinations of its values are stripped.</p></blockquote><p>是结尾处有你给的 chars 参数里字符的任意组合都会被删。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个问题其实是个长期以来的痛点，StackOverflow 相关问题阅读量破万，问题活跃时长超过 7 年。以前我就碰到过，当时写这里的时候就有点感觉，似乎用 rstrip 好像不太妥当，但随便测试了几个例子没问题也就这么用了。</p><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>解决这种问题的一个方法是用正则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.sub(<span class="string">&#x27;^&#x27;</span> + re.escape(prefix), <span class="string">&#x27;&#x27;</span>, s)  <span class="comment"># 删前缀</span></span><br><span class="line">re.sub(re.escape(suffix) + <span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;&#x27;</span>, s)  <span class="comment"># 删后缀</span></span><br></pre></td></tr></table></figure><p>要导个包，麻烦。代码可读性也低，效率….估计也不怎么样。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>另一种方法是用切片解决，代码可以封装地好看一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reference https://www.python.org/dev/peps/pep-0616/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeprefix</span>(<span class="params">self: <span class="built_in">str</span>, prefix: <span class="built_in">str</span>, /</span>) -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> self.startswith(prefix):</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">len</span>(prefix):]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self[:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removesuffix</span>(<span class="params">self: <span class="built_in">str</span>, suffix: <span class="built_in">str</span>, /</span>) -&gt; str:</span></span><br><span class="line">    <span class="comment"># suffix=&#x27;&#x27; should not call self[:-0].</span></span><br><span class="line">    <span class="keyword">if</span> suffix <span class="keyword">and</span> self.endswith(suffix):</span><br><span class="line">        <span class="keyword">return</span> self[:-<span class="built_in">len</span>(suffix)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self[:]</span><br></pre></td></tr></table></figure><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>实际上，为了解决这种问题，<a href="https://www.python.org/dev/peps/pep-0616/">PEP 616 – String methods to remove prefixes and suffixes</a> 提出了专门用来删前缀/后缀的方法，这是 Python 3.9 的新特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.removeprefix(<span class="string">&#x27;prefix&#x27;</span>)</span><br><span class="line">s.removesuffix(<span class="string">&#x27;suffix&#x27;</span>)</span><br></pre></td></tr></table></figure><p>P.S. 官方的 C 实现还是很有意思的，可以去看看：<a href="https://github.com/python/cpython/pull/18939/files">cpython/pull/18939</a> 。</p><p>但这里我的环境是 Python 3.7，所以只能用前两种方法手撸一个啦。</p><h2 id="TL-DR-太长不看"><a href="#TL-DR-太长不看" class="headerlink" title="TL;DR 太长不看"></a>TL;DR 太长不看</h2><p>用 <code>str.rstrip</code> 来删除字符串后缀是错误的，这个方法会删除参数中各字符的任意组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;emmm.md&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip(<span class="string">&#x27;.md&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><ol><li>用 Python 3.9：<code>s.removesuffix(&#39;suffix&#39;)</code></li><li>正则表达式：<code>re.sub(re.escape(suffix) + &#39;$&#39;, &#39;&#39;, s)</code></li><li>endswith + 切片：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removesuffix</span>(<span class="params">s: <span class="built_in">str</span>, suffix: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> suffix <span class="keyword">and</span> self.endswith(suffix):</span><br><span class="line">        <span class="keyword">return</span> self[:-<span class="built_in">len</span>(suffix)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self[:]</span><br></pre></td></tr></table></figure><hr><p>好了，这节课我们不往下讲了，剩下的时间来做个小练习，看看今天的知识大家学废了吗。。。（**’蠢’.capitalize()**）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See you!</span></span><br><span class="line"><span class="string">&#x27;CDFMLR 2020-11-24 11:22&#x27;</span>.rstrip(<span class="string">&#x27;:2333&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Introducing Sham</title>
      <link href="/2020/11/16/blog/Intro_sham/"/>
      <url>/2020/11/16/blog/Intro_sham/</url>
      
        <content type="html"><![CDATA[<h1 id="Introducing-Sham"><a href="#Introducing-Sham" class="headerlink" title="Introducing: Sham"></a>Introducing: Sham</h1><p>1024那天写了篇的文章《<a href="https://blog.csdn.net/u012419550/article/details/109258117">Python 代码一键转流程图</a>》。CSDN 居然给了个 “最趣味”奖🏆：<a href="https://blogdev.blog.csdn.net/article/details/109536460">https://blogdev.blog.csdn.net/article/details/109536460</a> 。</p><p>一开始我是不知道获奖的事的，（害，咱想都不敢想），直到有一天， CSDN 的小姐姐主动来加我微信，怒斥我仍未填写收货地址[捂脸]。。。</p><p>经历了一些曲折，前两天我终于还是收到了 CSDN 的奖品：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkrcr94smgj30vm0u0kjo.jpg" alt="截屏2020-11-16 21.49.18"></p><p>感谢 CSDN 🙏。</p><p>不过，这不是今天的主题，<del>只是炫耀一下</del>。今天要讲的故事是：</p><p><strong>我这个人不懂什么操作系统，于是我用 Go 语言模拟出了一个……</strong></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>以前看过一篇文章叫做《<a href="https://mp.weixin.qq.com/s/eezs6MTL-quuG0q5jBoMyw">我这个人不懂什么CPU，于是我用代码模拟出了一个</a>》。这篇文章介绍了一位大佬一言不合用 Go 语言模拟了一台计算机（项目：<a href="https://github.com/djhworld/simple-computer">djhworld/simple-computer</a>）的故事，帅爆了好吗。</p><p>这学期有操作系统课，上这个课程的主要收获就是，课上那些活在 PPT 中的算法，就很迷！我是不太喜欢这种方式的，我奉行 <em>Talk is cheap. Show me the code.</em></p><p>所以，我也用 Go 语言模拟了一个“操作系统”——一个拥有标准输入输出与进程间通信的、基于时间片轮转调度的多道程序运行器：<a href="https://github.com/cdfmlr/sham">cdfmlr/sham</a> （sham 意为：骗局、虚假事物）。</p><p>取名叫做 sham 就是希望大家原谅我的标题党行为，事实上，这个东西远谈不上一个“操作系统”，和 <a href="https://github.com/djhworld/simple-computer">djhworld/simple-computer</a> 等类似的优秀项目比起来，，我做的什么都不是。但我只做了不到 10 分钟的设计，并用不到 2k 行代码实现了它。作为业余蒟蒻实现的玩具项目，你还能对它有什么更高的要求呢？</p><p>下面，介绍 Sham 系统。</p><h2 id="Sham-系统概述"><a href="#Sham-系统概述" class="headerlink" title="Sham 系统概述"></a>Sham 系统概述</h2><p>在这里，简要介绍系统中的一些关键设计思路。</p><p>至于具体的实现，事实上，这个项目非常简单，而且我写了不少注释，在 git commit message 中也留下了（在我看来）较为详细的说明，如果您不介意，完全可以去读一读源码：</p><ul><li><a href="https://github.com/cdfmlr/sham">https://github.com/cdfmlr/sham</a></li><li>备份：<a href="https://gitee.com/cdfmlr/sham">https://gitee.com/cdfmlr/sham</a></li></ul><p>当然，如果你喜欢这个项目，欢迎 Star、Fork、Watch 三连。如果有任何疑问、意见或建议，也欢迎 Issue 和 PR。</p><h3 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h3><p>这个模拟的操作系统中，主要包含以下抽象：</p><ul><li>CPU：一个带有互斥锁的结构，单独在一个协程中运行应用程序的线程。</li><li>内存：一个无限大的结构，不需要管理。</li><li>IO设备：一个独立的设备，单独在一个协程中运行，可以输入或输出。</li><li>操作系统：包括操作系统基础结构、调度器、系统调用、中断处理程序组。为例简化模型，操作系统单独运行在一个协程中，它本身不需要在 CPU、内存上运行，而是在内部持有 CPU 和内存。<ul><li>操作系统基础结构：持有并管理 CPU，内存、IO 设备、进程表和中断向量。</li><li>调度器：完成进程调度工作的具体算法。</li><li>系统调用：为应用程序提供的“内核态”操作接口。</li><li>中断处理程序：处理应用程序或操作系统内部发出的各类中断。</li></ul></li><li>进程、线程：为了简化模型，一个进程只能持有且必须持有一个线程。<ul><li>进程：包括一个可运行的进程、当前状态（运行、就绪、阻塞）以及需要的各种资源（内存等）。</li><li>线程：进程具体可执行的部分，包含要运行的“程序代码”以及运行时的上下文。</li><li>上下文：包括程序计数器、进程指针、操作系统接口。</li></ul></li><li>具体应用程序：进程的实例（在 <a href="./sham_test.go">sham_test.go</a> 中实现了一些有意思的应用）。</li></ul><p>目前的实现中，调度器使用的是一个带时间片轮转的 FCFS 调度器，但可以十分容易地添加、替换新的调度算法。</p><h3 id="系统的工作流程"><a href="#系统的工作流程" class="headerlink" title="系统的工作流程"></a>系统的工作流程</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gknstu9g88j31e00u0dkx.jpg" alt="截屏2020-11-13 19.58.42"></p><h3 id="线程的运行"><a href="#线程的运行" class="headerlink" title="线程的运行"></a>线程的运行</h3><p>关于线程的运行，直接看一部分 Thread 具体代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 线程：是一个可以在 CPU 里跑的东西。</span></span><br><span class="line"><span class="keyword">type</span> Thread <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// runnable 是实际要运行的内容</span></span><br><span class="line">runnable Runnable</span><br><span class="line"><span class="comment">// contextual 是 Thread 的环境</span></span><br><span class="line">contextual *Contextual</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 程序：应用程序的具体的代码就写在这里面</span></span><br><span class="line"><span class="comment">// 每一次返回就代表“一条指令”（一个原子操作）执行完毕，返回值为状态：</span></span><br><span class="line"><span class="comment">//  - StatusRunning 继续运行（如果时间片未用尽）</span></span><br><span class="line"><span class="comment">//  - StatusReady 会进入就绪队列（即 yield，主动让出 CPU）</span></span><br><span class="line"><span class="comment">//  - StatusBlocked 会进入阻塞状态（一般不用。需要阻塞时一般通过中断请求）</span></span><br><span class="line"><span class="comment">//  - StatusDone 进程运行结束。</span></span><br><span class="line"><span class="keyword">type</span> Runnable <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程的状态</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">StatusBlocked = <span class="number">-1</span></span><br><span class="line">StatusReady   = <span class="number">0</span></span><br><span class="line">StatusRunning = <span class="number">1</span></span><br><span class="line">StatusDone    = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contextual 上下文：线程的上下文。</span></span><br><span class="line"><span class="keyword">type</span> Contextual <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 指向 Process 的指针，可以取用 Process 的资源</span></span><br><span class="line">Process *Process</span><br><span class="line"><span class="comment">// 通过 Contextual.OS.XX 调系统调用</span></span><br><span class="line">OS OSInterface</span><br><span class="line"><span class="comment">// 程序计数器</span></span><br><span class="line">PC <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的应用程序把“代码”写在一个 Runnable 型的函数中，这个函数每执行完一个原子操作就应该返回一次。同时 runnable 也可以在执行完任何一个原子操作时，被外部事件强行打断（比如时间片用尽）。</p><p> <code>Thread.Run()</code>  实现了上述控制，runnable 的返回、外部的打断都会被 <code>Thread.Run()</code> 捕获。前面的流程图中，「CPU 运行线程」也就是调用 <code>Thread.Run()</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run 包装并运行 Thread 的 runnable。</span></span><br><span class="line"><span class="comment">// 该函数返回的 done、cancel 让 runnable 变得可控：</span></span><br><span class="line"><span class="comment">// - 当 runnable 返回，即 Thread 结束时，done 会接收到 Process/Thread 的状态。</span></span><br><span class="line"><span class="comment">// - 当外部需要强制终止 runnable 的运行（调度），调用 cancel() 即可。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Thread)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">(done <span class="keyword">chan</span> <span class="keyword">int</span>, cancel context.CancelFunc)</span></span> &#123;</span><br><span class="line">done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">_ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 一条条代码不停跑，直到阻塞｜退出｜被取消</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-_ctx.Done(): <span class="comment">// 被取消，取消由 CPU 发起</span></span><br><span class="line">                <span class="comment">// 取消时 CPU 会临时置 Status 为需要转到的状态，</span></span><br><span class="line"><span class="comment">// 这里获取并把这个值传给操作系统</span></span><br><span class="line"><span class="comment">// 同时把状态重置为 StatusRunning</span></span><br><span class="line">                <span class="comment">//（状态转化需由操作系统完成，这里只是暂时借用这个值，故要还原）</span></span><br><span class="line">s := t.contextual.Process.Status</span><br><span class="line">t.contextual.Process.Status = StatusRunning</span><br><span class="line">done &lt;- s</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret := t.runnable(t.contextual)</span><br><span class="line">                t.contextual.Commit()  <span class="comment">// PC++, clockTick()</span></span><br><span class="line"><span class="keyword">if</span> ret != StatusRunning &#123; <span class="comment">// 结束|阻塞|就绪，交给调度器处理</span></span><br><span class="line">done &lt;- ret</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> done, cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 go 语言标准库的 context 包，控制线程运行的取消（外部打断）。如果没有外部打断，runnable 返回时就会将程序计数器和时钟加一。如果 runnable 一直返回 StatusRunning 就可以一直运行下去。在 runnable 内部，通过 <code>contextual.PC</code> 以及例如 <code>switch</code> 的流程控制语句即可实现一条条代码执行的效果。</p><p>例如，下面的这个 Runnable 函数（程序）有 4 个操作（4 条指令）它们会依次执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processSeq</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> contextual.PC &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        log.Debug(<span class="string">&quot;Line 0&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        log.Debug(<span class="string">&quot;Line 1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        log.Debug(<span class="string">&quot;Line 2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> StatusDone</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法有些像汇编语言，而事实上，runnable 甚至就是这个模拟的操作系统的机器语言！所以写起来略为繁琐，这个难以避免。</p><p>运行的效果如下：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkndrmwyhcj31hm09sn1b.jpg" alt="截屏2020-11-13 11.21.54"></p><p><strong>注</strong>：把上面的程序翻译成我们平时的 Go 程序就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">processSeq</span><span class="params">()</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>.Debug(<span class="string">&quot;Line 0&quot;</span>)</span><br><span class="line"><span class="built_in">log</span>.Debug(<span class="string">&quot;Line 1&quot;</span>)</span><br><span class="line"><span class="built_in">log</span>.Debug(<span class="string">&quot;Line 2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断与-IO"><a href="#中断与-IO" class="headerlink" title="中断与 IO"></a>中断与 IO</h3><p>中断在操作系统中至关重要，所以这个模拟的操作系统也需要中断的实现。</p><p>这里对中断的建模如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interrupt <span class="keyword">struct</span> &#123;</span><br><span class="line">Typ     <span class="keyword">string</span></span><br><span class="line">Handler InterruptHandler</span><br><span class="line">Data    InterruptData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterruptHandler 是「中断处理程序」</span></span><br><span class="line"><span class="keyword">type</span> InterruptHandler <span class="function"><span class="keyword">func</span><span class="params">(os *OS, data InterruptData)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InterruptData 是中断的数据</span></span><br><span class="line"><span class="keyword">type</span> InterruptData <span class="keyword">struct</span> &#123;</span><br><span class="line">Pid <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Channel 是用来给中断发起程序与中断处理程序通信的信道。</span></span><br><span class="line">Channel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断包含一个类型，处理程序（处理程序和中断类型一一对应），以及附加的数据。</p><p>应用程序，或操作系统内部都可以通过一个<strong>系统调用</strong>发出中断（这个模拟中几乎没有硬件，所以不考虑硬件中断）。操作系统受到中断请求，会把中断放入一个中断表，然后在当前时钟周期结束后，调度运行时程序阻塞，依次调用相应中断处理程序处理中断表里的中断。</p><p>中断处理程序会做必要的工作，完成后解除发起进程的阻塞状态。</p><p>有了这个中断机制，就可以很容易地实现时间片轮转——在时间片用尽后，发出一个时钟中断，其处理程序会把进程就绪。</p><p>同时，中断支持了各种 IO 设备的使用。例如，最简单的是使用标准输出，发出一个标准输出的中断请求，传入需要的数据即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloWorld</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">    contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                                   StdOutInterrupt, ch)</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个中断的处理程序会使用标准输出设备，完成输出。运行结果：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkndndoqc4j31jc0dk7au.jpg" alt="截屏2020-11-13 11.18.57"></p><p>出了标准输入，我还实现了标准输出设备，以及特殊的 Pipe 设备。这两个东西的调用代码都比较复杂，在此不做演示。</p><p>标准输入、输出都是模拟的“硬件”，这些东西会单独在一个协程中运行。而 Pipe 设备则是一个虚拟的设备，它是对 Go 语言 channel 的封装。操作系统可以动态生成任意多个 Pipe 并分配给需要的进程，通过 Pipe 进程之间就可以利用 CSP 模型可以完成通信与同步。</p><p>利用 Pipe 设备，在这个模拟的操作系统中，可以实现「生产者-消费者」问题。代码稍微复杂（需要约 150 行代码，见 <a href="./sham_test.go">sham_test.go</a> 之 TestProducerConsumer），但完全可以正确工作：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gknf17o30tj31jj0u0hbm.jpg" alt="截屏2020-11-13 12.07.16"></p><h2 id="Sham-程序设计"><a href="#Sham-程序设计" class="headerlink" title="Sham 程序设计"></a>Sham 程序设计</h2><p>作为系统可用性的<del>不严谨</del>证明，下面给出一份 Sham 程序设计指南。</p><p>在 Sham 源码的 <a href="https://github.com/cdfmlr/sham/blob/master/sham_test.go">sham_test.go</a> 文件中，包含了一系列开发过程中测试使用的应用程序实现。我们完全可以把这个文章看作 Sham 程序设计的官方实例。下文中任何不明朗部分都请参考那些实例。</p><h3 id="如何运行-Sham"><a href="#如何运行-Sham" class="headerlink" title="如何运行 Sham?"></a>如何运行 Sham?</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shamOS := NewOS()</span><br><span class="line">shamOS.Scheduler = FCFSScheduler&#123;&#125;</span><br><span class="line"><span class="comment">// shamOS.ReadyProcs = []*Process&#123;&#125; // No Noop</span></span><br><span class="line"></span><br><span class="line">shamOS.CreateProcess(...)</span><br><span class="line">shamOS.CreateProcess(...)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">shamOS.Boot()</span><br></pre></td></tr></table></figure><p>获取一个 OS 实例，指定调度器（FCFSScheduler 是先来先服务算法），添加应用程序进程，然后 Boot 就开始运行了！</p><p>系统的就绪队列中默认有一个 Noop（NO OPeration）进程，这个进程什么也不做。如果不需要，可以参考被注释掉的第三行代码删除它。</p><p>调用 <code>shamOS.CreateProcess</code> 可以给系统中新建进程，新的进程会被正确初始化，并放入就绪队列等待运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OS)</span> <span class="title">CreateProcess</span><span class="params">(pid <span class="keyword">string</span>, precedence <span class="keyword">uint</span>, timeCost <span class="keyword">uint</span>, runnable Runnable)</span></span></span><br></pre></td></tr></table></figure><p>precedence 和 timeCost 是给留特定的调度算法使用的，如果使用 FCFSScheduler 就没什么用，随便写即可，runnable 就是具体的程序代码了，下面就介绍 runnable 的写法。</p><h3 id="顺序程序"><a href="#顺序程序" class="headerlink" title="顺序程序"></a>顺序程序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processSeq</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> contextual.PC &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        log.Debug(<span class="string">&quot;Line 0&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        log.Debug(<span class="string">&quot;Line 1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        log.Debug(<span class="string">&quot;Line 2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> StatusDone</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>switch contextual.PC</code> 和 <code>return StatusRunning</code> 一个时钟执行一个操作。当程序结束时，<code>return StatusDone</code>。</p><p>注：这里是调用了 log（github.com/sirupsen/logrus，打一条日志），这其实是个「超系统调用」，调用了 sham 以外的东西。作为测试，这没问题。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>如果你对刚才的「超系统调用」感觉不爽，那没关系，下面就介绍 Sham 的系统调用。其实之前我们使用的 <code>CreateProcess</code> 就是一个系统调用：</p><ul><li><code>CreateProcess(pid string, precedence uint, timeCost uint, runnable Runnable)</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shamOS.CreateProcess(<span class="string">&quot;processFoo&quot;</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    contextual.OS.CreateProcess(<span class="string">&quot;ProcessBar&quot;</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ProcessBar, a Process dynamic created by processFoo&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> StatusDone</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们使用 <code>contextual.OS.XXX</code> 完成系统调用。这里 processFoo 调用 <code>CreateProcess</code> 新建了一个进程 ProcessBar。 </p><p>还有一个更有用的系统调用——中断请求：</p><ul><li><code>InterruptRequest(thread *Thread, typ string, channel chan interface&#123;&#125;)</code></li></ul><p>thread 是发起中断的进程，一般是当前线程自己： <code>contextual.Process.Thread</code> ，typ 是要调用的中断类型，channel 是当前线程与中断处理程序直接通信的。</p><p>由于当前线程与中断处理程序显然不同步，channel 必须是带缓冲区的！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloWorld</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">    contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                                   StdOutInterrupt, ch)</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前可用的中断类型有：</p><table><thead><tr><th>typ</th><th>说明</th><th>channel</th></tr></thead><tbody><tr><td><code>StdOutInterrupt</code></td><td>输出到标准输出</td><td>放入药输出的东西</td></tr><tr><td><code>StdInInterrupt</code></td><td>从标准输入获取输入</td><td>一个空 chan，标准输入会写东西进去</td></tr><tr><td><code>NewPipeInterrupt</code></td><td>新建一个 Pipe 设备</td><td>放入 pipeID 和 pipeBufferSize</td></tr><tr><td><code>GetPipeInterrupt</code></td><td>获取一个 Pipe 设备</td><td>放入 pipeID</td></tr></tbody></table><p>关于 Pipe 后面再详细介绍。</p><p>使用标准输入时，需要注意，把 chan 放到 sham 线程的内存中，而不是使用一个 go 变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shamOS.CreateProcess(<span class="string">&quot;processIn&quot;</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mem := &amp;contextual.Process.Memory[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> contextual.PC &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        in := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// in 会在多个周期中被使用，需要放入内存</span></span><br><span class="line">        mem.Content = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;in&quot;</span>: in&#125;</span><br><span class="line">        contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                                       StdInInterrupt, in)</span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        in := mem.Content.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;in&quot;</span>]</span><br><span class="line"></span><br><span class="line">        content := &lt;-in</span><br><span class="line">        log.WithField(<span class="string">&quot;content&quot;</span>, content).Debug(<span class="string">&quot;got content&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StatusDone</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><p>程序中当然是需要使用变量的。但从刚才的标准输出程序可以看到，使用 sham 的内存极为麻烦！而那些从内存读写变量的操作非常套路化，所以我封装了一个 <code>VarPool</code> 来方便变量读写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contextual.InitVarPool()  <span class="comment">// 初始化变量池</span></span><br><span class="line">contextual.SetVar(<span class="string">&quot;varName&quot;</span>, something)  <span class="comment">// 放入（新建或更新）变量</span></span><br><span class="line">something := contextual.GetVar(<span class="string">&quot;varName&quot;</span>)  <span class="comment">// 读取变量，如果不存在会得到 nil</span></span><br><span class="line">something, ok := contextual.TryGetVar(<span class="string">&quot;varName&quot;</span>)  <span class="comment">// 读取变量，ok指使变量是否存在</span></span><br></pre></td></tr></table></figure><p>E.g.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shamOS.CreateProcess(<span class="string">&quot;useVarPool&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> contextual.PC == <span class="number">0</span>:</span><br><span class="line">        contextual.InitVarPool()</span><br><span class="line">        </span><br><span class="line">        contextual.SetVar(<span class="string">&quot;chOutput&quot;</span>, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> contextual.PC &lt;= <span class="number">3</span>:</span><br><span class="line">        contextual.SetVar(<span class="string">&quot;num&quot;</span>, contextual.PC*contextual.PC)</span><br><span class="line"></span><br><span class="line">        chOut := contextual.GetVar(<span class="string">&quot;chOutput&quot;</span>).(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">        </span><br><span class="line">        chOut &lt;- fmt.Sprintln(contextual.GetVar(<span class="string">&quot;num&quot;</span>), chOut)</span><br><span class="line">        contextual.OS.InterruptRequest(contextual.Process.Thread, StdOutInterrupt, chOut)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="条件-循环"><a href="#条件-循环" class="headerlink" title="条件/循环"></a>条件/循环</h3><p>条件、循环这里做的不太好，比较麻烦。需要大家手动维护额外的程序计数器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PipeProduct = <span class="string">&quot;pipe_product&quot;</span></span><br><span class="line"></span><br><span class="line">shamOS.CreateProcess(<span class="string">&quot;producer&quot;</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> contextual.PC &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        contextual.InitVarPool()</span><br><span class="line">        contextual.SetVar(<span class="string">&quot;chOutput&quot;</span>, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        pipeArgs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line">        pipeArgs &lt;- PipeProduct <span class="comment">// pipeId</span></span><br><span class="line">        pipeArgs &lt;- <span class="number">3</span>           <span class="comment">// pipeBufferSize</span></span><br><span class="line">        contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                                       NewPipeInterrupt, pipeArgs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> contextual.PC &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StatusDone</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _, ok := contextual.TryGetVar(<span class="string">&quot;dpc&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            contextual.SetVar(<span class="string">&quot;dpc&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        dpc := contextual.GetVar(<span class="string">&quot;dpc&quot;</span>).(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> dpc &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            product := contextual.PC</span><br><span class="line"></span><br><span class="line">            contextual.SetVar(<span class="string">&quot;product&quot;</span>, product)</span><br><span class="line"></span><br><span class="line">            contextual.SetVar(<span class="string">&quot;dpc&quot;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> StatusRunning</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pipe := <span class="keyword">interface</span>&#123;&#125;(</span><br><span class="line">                contextual.Process.Devices[PipeProduct]).(*Pipe)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pipe.Inputable() &#123;</span><br><span class="line">                product := contextual.GetVar(<span class="string">&quot;product&quot;</span>)</span><br><span class="line"></span><br><span class="line">                pipe.Input() &lt;- product</span><br><span class="line"></span><br><span class="line">                contextual.SetVar(<span class="string">&quot;dpc&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> StatusReady <span class="comment">// yield</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StatusRunning</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码是生产者消费者问题中的生产者线程，我们通过一个 <code>dpc</code> 变量实现了类似于 <code>JMP</code> 指令的跳转功能。</p><p>这段代码中关于 Pipe 不太好理解，所以下面介绍 Pipe。</p><h3 id="进程通信-Pipe"><a href="#进程通信-Pipe" class="headerlink" title="进程通信: Pipe"></a>进程通信: Pipe</h3><p>Pipe 是 Sham 中的一种特殊 IO 设备，它是对 Golang chan 的封装，它提供了 Sham 进程间通信的能力。</p><p>创建 Pipe：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipeArgs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line">pipeArgs &lt;- <span class="string">&quot;pipeID&quot;</span>  <span class="comment">// pipeId</span></span><br><span class="line">pipeArgs &lt;- <span class="number">3</span>         <span class="comment">// pipeBufferSize</span></span><br><span class="line">contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                               NewPipeInterrupt, pipeArgs)</span><br></pre></td></tr></table></figure><p>其他进程获取 Pipe：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipeArgs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line">pipeArgs &lt;- <span class="string">&quot;pipeID&quot;</span> <span class="comment">// pipeId</span></span><br><span class="line"></span><br><span class="line">contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                               GetPipeInterrupt, pipeArgs)</span><br></pre></td></tr></table></figure><p><code>NewPipeInterrupt</code> 和 <code>GetPipeInterrupt</code> 中断请求被成功处理之后，操作系统会把新建的/获取到的 Pipe 分配给进程，通过 contextual 可以获取：<code>contextual.Process.Devices[&quot;pipeID&quot;]</code>。我们会获取到一个 Device 类型的东西，为了具体使用时方便，我们需要把它转化为 *Pipe 类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe := <span class="keyword">interface</span>&#123;&#125;(contextual.Process.Devices[PipeProduct]).(*Pipe)</span><br></pre></td></tr></table></figure><p>在读写 Pipe 的时候需要注意边界条件，不可读时强行去读会造成死锁。</p><p>写：在 <code>pipe.Inputable()</code> 时 <code>pipe.Input() &lt;- something</code>，否则说明阻塞，主动让出 CPU：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pipe.Inputable() &#123;</span><br><span class="line">    pipe.Input() &lt;- contextual.GetVar(<span class="string">&quot;product&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StatusReady <span class="comment">// yield</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读也是类似的，检测—读取—否则让出 CPU：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pipe.Outputable() &#123;</span><br><span class="line">    contextual.SetVar(<span class="string">&quot;product&quot;</span>, &lt;-pipe.Output())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StatusReady <span class="comment">// yield</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文章结束之前"><a href="#文章结束之前" class="headerlink" title="文章结束之前"></a>文章结束之前</h2><p>无论您是技术比我强的大佬，或是在某一方面比我稍弱的同学，看到这里可能都会骂一声——“什么东西？”</p><p>为了回答您的疑问，我想重述我对 Sham 的定义：</p><blockquote><p><a href="https://github.com/cdfmlr/sham">cdfmlr/sham</a> （sham 意为：骗局、虚假事物）：一个拥有标准输入输出与进程间通信的、基于时间片轮转调度的多道程序运行器。</p></blockquote><p>这是我在学习操作系统时的个人娱乐作品。它的功能、整体设计、代码细节都做的很差，因为它最初的设计，仅是为了开玩笑写出的 200 余个字符：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkrbyvn0lkj30u0145gx2.jpg" alt="截屏2020-11-16 21.23.28"></p><p>如果您喜欢这个项目，欢迎 Star、Fork 和 PR。如果您不喜欢这东西，或有任何看法、疑问、意见或建议，也欢迎 Issue，望不吝赐教为感！</p><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shamOS := NewOS()</span><br><span class="line">shamOS.Scheduler = FCFSScheduler&#123;&#125;</span><br><span class="line">shamOS.ReadyProcs = []*Process&#123;&#125;</span><br><span class="line"></span><br><span class="line">shamOS.CreateProcess(<span class="string">&quot;SeeYou&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="function"><span class="keyword">func</span><span class="params">(contextual *Contextual)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    eof := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    eof &lt;- <span class="string">&quot;By CDFMLR \n 2020.11.16&quot;</span></span><br><span class="line">    contextual.OS.InterruptRequest(contextual.Process.Thread, </span><br><span class="line">                                   StdOutInterrupt, eof)</span><br><span class="line">    <span class="keyword">return</span> StatusDone</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">shamOS.Boot()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 代码转流程图</title>
      <link href="/2020/10/24/blog/PyFlowchart/"/>
      <url>/2020/10/24/blog/PyFlowchart/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-代码转流程图"><a href="#Python-代码转流程图" class="headerlink" title="Python 代码转流程图"></a>Python 代码转流程图</h1><p>在设计程序时，类图、流程图都是很有用的工具，我们有很多工具来绘制这些图纸，甚至还能用它们生成最基本的框架代码。也有时候我们需要把已经写好的代码反向转成类图、流程图，比如<del>写作业</del>和别人分享设计的时候。</p><p>代码转类图也有挺多工具的，VS Code、IntelliJ IDEA 这些常用的 IDE 都可以装插件来完成这一工作。而如果你做微软家的开发，Visual Studio 可选安装的“类设计器”，更是强到不像话，轻松吊打我见过的其他任何同类工具，就这一点来说， VS 对得起「宇宙第一 IDE」的称号。</p><p>然而，代码转流程图，相对来说，这个需求少一些，工具也没那么丰富。最近我突然需要把一些 Python 代码转成流程图，Google 翻了两页，GitHub 搜了几个项目，发现现有的实现都不太行：要么用的技术太怪（那些用「正则表达式」正面上的可震撼了我一下午），要么跑不起来（依赖条件苛刻，比如某些项目用了对 macOS 不太友好的 PyGame），要么跑出来太丑（凌乱的线条、奇怪的颜色，不是新丑风，是丑到抽风）。 当我看到某高赞项目 <a href="https://github.com/Vatsha/code_to_flowchart">Vatsha/code_to_flowchart</a> 甚至集合了上述三大“优点”时，，，我选择了自己动手撸一个 python to flowchart 的工具。</p><p>当然，我不是喷 <a href="https://github.com/Vatsha/code_to_flowchart">Vatsha/code_to_flowchart</a>，只是其一些细节真的欠优，有很大的改进空间。但不得不说，他的设计简单有效 ，用 PyGame 做可视化也很有新意。其实，我在做自己的实现时也大量参考了这个项目。</p><hr><p>我的解决方案 <a href="https://github.com/cdfmlr/pyflowchart">PyFlowchart</a> 基于大名鼎鼎的 flowchart.js。</p><p>（本来我是取名叫做 PyFlow 的，上传 PyPi 的时候发现重名了🤦‍♂️。所以改成了 PyFlowchart）</p><h2 id="flowchart-js"><a href="#flowchart-js" class="headerlink" title="flowchart.js"></a>flowchart.js</h2><p>如果你使用 Typora，可能知道在 Typora 中用  ```flow 可以用一种简单的文本语言来写流程图，根据 <a href="https://support.typora.io/Draw-Diagrams-With-Markdown/#flowcharts">Typora 的文档</a>，这个功能来自开源的 <a href="https://github.com/adrai/flowchart.js">flowchart.js</a>。</p><p>我的方案就是把 Python 代码转化成这种 flowchart 语言，然后你就可以借助  <a href="http://flowchart.js.org/">flowchart.js.org</a>、<a href="https://www.typora.io/">Typora</a>、 <a href="https://github.com/francoislaberge/diagrams/#flowchart">francoislaberge/diagrams</a> 等等工具来生成流程图了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">op&#x3D;&gt;operation: Your Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk07vvnullj30uo0luaa3.jpg" alt="flowchart"></p><h2 id="PyFlowchart"><a href="#PyFlowchart" class="headerlink" title="PyFlowchart"></a>PyFlowchart</h2><p>下面简要介绍如何使用我实现的 PyFlowchart，更详细的说明请看项目的 <a href="https://github.com/cdfmlr/pyflowchart/blob/master/README.md">README</a>。</p><p>安装 PyFlowchart：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install pyflowchart</span><br></pre></td></tr></table></figure><p>写一个 <code>simple.py</code> 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a:</span><br><span class="line">        print(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            print(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>运行 PyFlowchart：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pyflowchart simple.py</span><br></pre></td></tr></table></figure><p>它会输出 flowchart 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">st4439920016&#x3D;&gt;start: start foo</span><br><span class="line">io4439920208&#x3D;&gt;inputoutput: input: a, b</span><br><span class="line">cond4439920592&#x3D;&gt;condition: if a</span><br><span class="line">sub4439974736&#x3D;&gt;subroutine: print(&#39;a&#39;)</span><br><span class="line">io4439974672&#x3D;&gt;inputoutput: output:  (a + b)</span><br><span class="line">e4439974352&#x3D;&gt;end: end function return</span><br><span class="line">cond4439974224&#x3D;&gt;operation: print(&#39;b&#39;) while  i in range(3)</span><br><span class="line"></span><br><span class="line">st4439920016-&gt;io4439920208</span><br><span class="line">io4439920208-&gt;cond4439920592</span><br><span class="line">cond4439920592(yes)-&gt;sub4439974736</span><br><span class="line">sub4439974736-&gt;io4439974672</span><br><span class="line">io4439974672-&gt;e4439974352</span><br><span class="line">cond4439920592(no)-&gt;cond4439974224</span><br><span class="line">cond4439974224-&gt;io4439974672</span><br></pre></td></tr></table></figure><p>访问 <a href="http://flowchart.js.org/">flowchart.js.org</a>，把上面生成的代码粘贴到文本框里，右边就会自动生成流程图了：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk083edrrgj312j0sc4d2.jpg" alt="flowchart.js.org 截图，左边的输入框里粘贴了生成的代码，右边是画出的流程图"></p><p>当然，你也可以直接把这些代码放到 Typora 的 flow 代码块里，也会自动生成流程图。如果你喜欢使用命令行，也可以用 <a href="https://github.com/francoislaberge/diagrams/#flowchart">francoislaberge/diagrams</a> 来生成流程图。</p><p>如果生成的流程图有让人不满意的地方（比如，线条重叠）或者你喜欢指定样式，参考 <a href="http://flowchart.js.org/">flowchart.js.org</a>，手动修改一下生成的 flowchart 就可以了，非常方便。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: start PyFlowchart</span><br><span class="line">in&#x3D;&gt;inputoutput: input python source code</span><br><span class="line">sub1&#x3D;&gt;subroutine: code to ast</span><br><span class="line">sub2&#x3D;&gt;subroutine: ast to node graph</span><br><span class="line">sub3&#x3D;&gt;subroutine: node graph to flowchart</span><br><span class="line">out&#x3D;&gt;inputoutput: output flowchart</span><br><span class="line">e&#x3D;&gt;end: end</span><br><span class="line"></span><br><span class="line">st-&gt;in-&gt;sub1(right)-&gt;sub2(right)-&gt;sub3-&gt;out-&gt;e</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0bxkyis0j31k00u0tb8.jpg" alt="实现原理流程图"></p><p>PyFlowchart 利用 Python 内置的 <a href="https://docs.python.org/zh-cn/3/library/ast.html">ast</a> 包，把代码转化成 AST（抽象语法树），然后把 AST 转化成自己定义的 Node 组成的图，每个 Node 对应一个 flowchart 中的 node，遍历这个图就可以得到流程图了。</p><p>关于 ast 包，可以看看这篇文章：<a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue3/static-modification-of-python-with-python-the-ast-module.html">AST 模块：用 Python 修改 Python 代码</a>，虽然很老，但十分简单易懂。总而言之，利用 ast 包，我们可以把一段 Python 代码转化为一个数据结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expr = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>def add(a, b):</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    return a + b</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expr_ast = ast.parse(expr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expr_ast</span><br><span class="line">&lt;_ast.Module <span class="built_in">object</span> at <span class="number">0x10c773e10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(expr_ast)</span><br><span class="line"><span class="comment"># p.s. 这里手动做了格式化</span></span><br><span class="line">Module(body=[FunctionDef(name=<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">  args=arguments(</span><br><span class="line">    args=[</span><br><span class="line">      arg(arg=<span class="string">&#x27;a&#x27;</span>, annotation=<span class="literal">None</span>),</span><br><span class="line">      arg(arg=<span class="string">&#x27;b&#x27;</span>, annotation=<span class="literal">None</span>)],</span><br><span class="line">    vararg=<span class="literal">None</span>, kwonlyargs=[], kw_defaults=[], kwarg=<span class="literal">None</span>, defaults=[]),</span><br><span class="line">  body=[Return(value=BinOp(</span><br><span class="line">    left=Name(<span class="built_in">id</span>=<span class="string">&#x27;a&#x27;</span>, ctx=Load()),</span><br><span class="line">    op=Add(),</span><br><span class="line">    right=Name(<span class="built_in">id</span>=<span class="string">&#x27;b&#x27;</span>, ctx=Load())))],</span><br><span class="line">  decorator_list=[],</span><br><span class="line">  returns=<span class="literal">None</span>)])</span><br></pre></td></tr></table></figure><p>学会了这个东西，接下来的工作就是把这个 expr_ast (_ast.Module 对象) 翻译成流程图了。我们用面向对象来的方法来实现：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0b5o486pj31hz0u042n.jpg" alt="pyflowchart.node"></p><p><code>Node</code> 是最最基础的类，表示流程图中的一个节点，其他一切都继承自它。Node 有节点类型、名称、内容等属性，提供的 <code>fc_definition()</code>、<code>fc_connection()</code> 方法可以把自己转化为 flowchart 语言的字符串。另外的 <code>__visited</code> 和 <code>_traverse()</code> 是用来遍历图的。与 flowchart 中的 node types 对应，我们实现了各种 Node 的子类：StartNode、EndNode、OperationNode……</p><p><code>NodesGroup</code> 是一个特殊的 Node，它自己不会出现在生成的 flowchart 中，但它可以包含一些其他 Node。这个设计是受到 Android 的 View、ViewGroup 的启发，有了这个 NodesGroup，if 语句、for / while 循环这样有嵌套的 body 的情况就很容易处理了。</p><p><code>AstNode</code> 表示一个从 AST 对象得到的 Node。构造 AstNode，就是把某个 AST 对象翻译成一个 Node（也可以是 NodesGroup）。其子类就和各种 ast 对象对应（也就和 Python 的各种语句对应）： If、Loop、Return …….</p><p><code>Flowchart</code> 代表一张流程图。流程图就是一堆连在一起的节点嘛，所以 Flowchart 是 NodesGroup 的子类。在其 <code>from_code()</code> 中方法中，实现了用 ast 包解析 Python 代码，得到 ast 对象的工作。在 <code>flowchart()</code> 方法中，遍历图，拿到所有节点的 flowchart 表示，汇总成一张完整的 flowchart 流程图。 </p><p>其实这个东西很简单，更具体的实现看源码就很好理解了，在此不做赘述。总结一下：</p><ul><li>Flowchart 中利用 ast 包实现了 code to ast；</li><li>AstNode 及其子类实现了 ast to node graph；</li><li>Node 及其子类实现了 node graph to flowchart。</li></ul><p>附上项目地址与完整实现的类图：</p><ul><li><a href="https://github.com/cdfmlr/pyflowchart/">https://github.com/cdfmlr/pyflowchart/</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk09oeitndj33xl0u0wx7.jpg" alt="pyflowchart"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">by(<span class="string">&#x27;CDFMLR&#x27;</span>, <span class="string">&#x27;2020.10.24&#x27;</span>)</span><br><span class="line"><span class="comment"># 🎉</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc编译时优化</title>
      <link href="/2020/10/15/bullshit/a1_add_100a3_way1/"/>
      <url>/2020/10/15/bullshit/a1_add_100a3_way1/</url>
      
        <content type="html"><![CDATA[<h1 id="胡言乱语之gcc优化"><a href="#胡言乱语之gcc优化" class="headerlink" title="胡言乱语之gcc优化"></a>胡言乱语之gcc优化</h1><p>本文为业余蒟蒻尝试分析一段简单的 C 代码在 gcc <code>-O0</code>、<code>-O1</code>、<code>-O2</code> 下的优化情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">______________</span><br><span class="line">&lt; 大佬驱散！！ &gt;</span><br><span class="line"> --------------</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\&#x2F;\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure><p>做数值分析的实验，写了点 C 代码，浮点数性质的实验，很无聊。所以来尝试用不同优化等级，生成汇编代码玩玩。</p><ul><li><code>a1.c</code></li></ul><p>原始 C 代码，将 100个 a3 逐个加到 a1 上，返回 a1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">a1_add_100a3_way1</span><span class="params">(<span class="keyword">float</span> a1, <span class="keyword">float</span> a3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        a1 += a3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>gcc-9 -O0 -S a1.c</code></li></ul><p>用 0 级优化，编译成汇编，相当忠实地「直译」：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_a1_add_100a3_way1:</span><br><span class="line">LFB2:</span><br><span class="line">pushq%rbp</span><br><span class="line">LCFI3:</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">LCFI4:</span><br><span class="line">movss%xmm0, -20(%rbp)</span><br><span class="line">movss%xmm1, -24(%rbp)</span><br><span class="line">movl$0, -4(%rbp)</span><br><span class="line">jmpL3</span><br><span class="line">L4:</span><br><span class="line">movss-20(%rbp), %xmm0</span><br><span class="line">addss-24(%rbp), %xmm0</span><br><span class="line">movss%xmm0, -20(%rbp) </span><br><span class="line">addl$1, -4(%rbp)</span><br><span class="line">L3:</span><br><span class="line">cmpl$99, -4(%rbp)</span><br><span class="line">jleL4</span><br><span class="line">movss-20(%rbp), %xmm0</span><br><span class="line">popq%rbp</span><br><span class="line">LCFI5:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><ul><li><code>gcc-9 -O1 -S a1.c</code></li></ul><p>用 1 级优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_a1_add_100a3_way1:</span><br><span class="line">LFB2:</span><br><span class="line">movl$100, %eax</span><br><span class="line">L4:</span><br><span class="line">addss%xmm1, %xmm0</span><br><span class="line">subl$1, %eax</span><br><span class="line">jneL4</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这个程序简单嘛，O1 已经优化的相当出色了，各种临时遍历能砍的全砍了。手写汇编也就这水平了。值得一提的是，它把 i 从 0 加到 <code>&lt; 100</code>（即 <code>== 99</code>）的判断改成了从 100 减到 0，直接使用减法设置的 ZF，避免了一次 cmpl，很刺激。</p><ul><li><code>gcc-9 -O2 -S a1.c</code></li></ul><p>用 2 级优化，编译成汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_a1_add_100a3_way1:</span><br><span class="line">LFB2:</span><br><span class="line">movl$100, %eax</span><br><span class="line">.p2align 4,,10</span><br><span class="line">.p2align 3</span><br><span class="line">L4:</span><br><span class="line">subl$1, %eax</span><br><span class="line">addss%xmm1, %xmm0</span><br><span class="line">jneL4</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>和 1 级优化比，感觉几乎没有提升。但我有个不确定的<strong>猜想</strong>：</p><p>O2 编译把 subl 提到 addss 前运算，这样到 jne「取指」时，subl 已经到了「执行」，用一个 bubble 就可以避免流水线冒险。 而 O1 的版本里，jne 紧随 subl，jne  达到「取指」时，subl 还在「译码」阶段，需要更多的 bubble 或者其他方式来处理这里的流水线冒险，代价稍微大了一点点🤏。（流水线学的并不好，我不保证这个分析正确、有意义）</p><h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>这是一篇在桌面上找到的意义不明的文章。我于过去的某天偶然写下了这些东西，看上去很厉害，所以分享一下（但不知道内容是否正确、有效）。</p><blockquote><p>「胡言乱语」(Bullshit) 系列文章（包括但不限于相关的汉字、拼音、拉丁字母、日语假名、阿拉伯字母、单词、句子图片、影像、录音，以及前述之各种随意组合等等）均为本人随意敲击键盘所出。用于检测本人电脑键盘录入、屏幕显示的机械、光电性能，并不代表本人局部或全部同意、支持或者反对其中的任何内容及观点。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Bullshit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python gRPC 与跨语言 gRPC 调用</title>
      <link href="/2020/09/19/blog/gRPC-with-Python-and-Golang/"/>
      <url>/2020/09/19/blog/gRPC-with-Python-and-Golang/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-gRPC-与跨语言-gRPC-调用"><a href="#Python-gRPC-与跨语言-gRPC-调用" class="headerlink" title="Python gRPC 与跨语言 gRPC 调用"></a>Python gRPC 与跨语言 gRPC 调用</h1><p>本文是我上一篇文章《 <a href="https://blog.csdn.net/u012419550/article/details/108672965">Go 微服务基础：Protobuf &amp; gRPC</a>》的延伸，在开始本文前，建议先看一看那篇文章。</p><p>在《 <a href="https://blog.csdn.net/u012419550/article/details/108672965">Go 微服务基础：Protobuf &amp; gRPC</a>》一文中，我们介绍了 protobuf 的基础。随后定义了一个 userinfo proto 作为接口，实现了一套 Golang 版本的服务端、客户端。</p><p>这篇文章中，我们继续使用那个 userinfo proto 作为接口，去实现一套 Python 版本的服务端、客户端，在实例中入门 Python gRPC 使用。然后，我们做一个有意思的尝试 —— Golang 与 Python 版本客户端、服务端的跨语言调用。</p><p>[TOC]</p><h2 id="Python-gRPC-入门"><a href="#Python-gRPC-入门" class="headerlink" title="Python gRPC 入门"></a>Python gRPC 入门</h2><p>首先，我们了解一下如何配置 Python 的 gRPC 环境，如何把 proto 文件编译出 Python 接口，如何实现服务端、客户端。</p><h3 id="安装-gRPC-Python"><a href="#安装-gRPC-Python" class="headerlink" title="安装 gRPC Python"></a>安装 gRPC Python</h3><p>安装 gRPC Python 组件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install grpcio</span><br><span class="line">pip3 install grpcio-tools</span><br></pre></td></tr></table></figure><h3 id="编写-proto-生成接口"><a href="#编写-proto-生成接口" class="headerlink" title="编写 proto 生成接口"></a>编写 proto 生成接口</h3><p>编写 proto 文件，这里我们直接复制《 <a href="https://blog.csdn.net/u012419550/article/details/108672965">Go 微服务基础：Protobuf &amp; gRPC</a>》一文中的 proto：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> proto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息请求参数</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息请求响应</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserResponse</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> hobby = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息接口</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取用户信息，请求参数为 UserRequest，返回响应为 UserResponse</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUserInfo (UserRequest) <span class="keyword">returns</span> (UserResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译。注意是使用 <code>grpc_tools.protoc</code> 这个 Python 专用的编译器，而不是使用 <code>protoc</code> 哦：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m grpc_tools.protoc  -I . --python_out=. --grpc_python_out=. ./userinfo.proto</span><br></pre></td></tr></table></figure><p>会生成两个文件：</p><ul><li><code>userinfo_pb2.py</code>：请求、响应数据结构的定义的类：（proto 文件中的 message）<ul><li><code>UserRequest</code></li><li><code>UserResponse</code></li></ul></li><li><code>userinfo_pb2_grpc.py</code>：服务端、客户端的定义的类：（proto 文件中的 service）<ul><li><code>UserInfoServicer</code>：服务端</li><li><code>UserInfoStub</code>：客户端</li></ul></li></ul><blockquote><p>注：这里文件名里的 <code>pb2</code> 和 protobuf 语法的版本（<code>syntax = &quot;proto3&quot;</code>）没关系。这个 pb2 只是表示是用的 Protocol Buffers Python API 版本为 2。</p></blockquote><h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>查看 <code>userinfo_pb2_grpc.py</code> 里生成的代码可以知道，Python gRPC 的服务实现是写一个子类去继承 proto 编译生成的 <code>userinfo_pb2_grpc.UserInfoServicer</code> ，在子类中实现 RPC 的具体服务处理方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> userinfo_pb2</span><br><span class="line"><span class="keyword">import</span> userinfo_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoServicer</span>(<span class="params">userinfo_pb2_grpc.UserInfoServicer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;UserInfoServicer 具体实现 userinfo_pb2_grpc.UserInfoServicer，处理 RPC 服务</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUserInfo</span>(<span class="params">self, request, context</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取用户信息，请求参数为 UserRequest，返回响应为 UserResponse</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = request.name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Fake query</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;foo&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> userinfo_pb2.UserResponse(<span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;foo&quot;</span>, age=<span class="number">12</span>, hobby=[<span class="string">&quot;eating&quot;</span>, <span class="string">&quot;sleep&quot;</span>])</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">f&quot;unknown user: name = <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span>():</span></span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>))</span><br><span class="line">    userinfo_pb2_grpc.add_UserInfoServicer_to_server(UserInfoServicer(), server)</span><br><span class="line">    server.add_insecure_port(<span class="string">&#x27;[::]:50051&#x27;</span>)</span><br><span class="line">    server.start()</span><br><span class="line">    server.wait_for_termination()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure><h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>客户端很好理解，网络连接得到一个 channel，拿 channel 去实例化一个 stub，通过 stub 调用 RPC 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> userinfo_pb2</span><br><span class="line"><span class="keyword">import</span> userinfo_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:50051&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = userinfo_pb2_grpc.UserInfoStub(channel)</span><br><span class="line"></span><br><span class="line">        req = userinfo_pb2.UserRequest(name=<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">        resp = stub.GetUserInfo(req)</span><br><span class="line"></span><br><span class="line">        print(resp)</span><br><span class="line">        print(<span class="built_in">type</span>(resp.name), <span class="built_in">type</span>(resp.<span class="built_in">id</span>))</span><br><span class="line">        print(<span class="built_in">type</span>(resp.hobby), resp.hobby, <span class="built_in">list</span>(resp.hobby))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>先运行服务端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 server.py</span><br></pre></td></tr></table></figure><p>如果运行 <code>python3 sever.py</code> 有如下报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: module <span class="string">&#x27;google.protobuf.descriptor&#x27;</span> has no attribute <span class="string">&#x27;_internal_create_key&#x27;</span></span><br></pre></td></tr></table></figure><p>看一下 <code>protoc --version</code> 和 <code>pip3 show protobuf</code>。我这里的问题是 pip 的 protobuf 太老了，更新一下就行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install -upgrade protobuf -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>再运行客户端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Another terminal</span></span><br><span class="line">$ python3 client.py</span><br><span class="line">id: 1</span><br><span class="line">name: <span class="string">&quot;foo&quot;</span></span><br><span class="line">age: 12</span><br><span class="line">hobby: <span class="string">&quot;eating&quot;</span></span><br><span class="line">hobby: <span class="string">&quot;sleep&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;class <span class="string">&#x27;str&#x27;</span>&gt; &lt;class <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&lt;class <span class="string">&#x27;google.protobuf.pyext._message.RepeatedScalarContainer&#x27;</span>&gt; [<span class="string">&#x27;eating&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>] [<span class="string">&#x27;eating&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以看到，响应返回的 UserResponse 里都是一般的数据格式，但 repeat 的数据并不是我们熟悉的 list 什么的，但可以手动转过去。</p><p>如果我们请求一个 name 非 <code>&quot;foo&quot;</code> 的调用，服务端的处理是 <code>raise KeyError(f&quot;unknown user: name = &#123;name&#125;&quot;)</code>，这里客户端就会抛出一个错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> grpc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> userinfo_pb2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> userinfo_pb2_grpc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>channel = grpc.insecure_channel(<span class="string">&#x27;localhost:50051&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stub = userinfo_pb2_grpc.UserInfoStub(channel)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>req = userinfo_pb2.UserRequest(name=<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>resp = stub.GetUserInfo(req)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3/site-packages/grpc/_channel.py&quot;</span>, line <span class="number">826</span>, <span class="keyword">in</span> __call__</span><br><span class="line">    <span class="keyword">return</span> _end_unary_response_blocking(state, call, <span class="literal">False</span>, <span class="literal">None</span>)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3/site-packages/grpc/_channel.py&quot;</span>, line <span class="number">729</span>, <span class="keyword">in</span> _end_unary_response_blocking</span><br><span class="line">    <span class="keyword">raise</span> _InactiveRpcError(state)</span><br><span class="line">grpc._channel._InactiveRpcError: &lt;_InactiveRpcError of RPC that terminated <span class="keyword">with</span>:</span><br><span class="line">        status = StatusCode.UNKNOWN</span><br><span class="line">        details = <span class="string">&quot;Exception calling application: &#x27;unknown user: name = bar&#x27;&quot;</span></span><br><span class="line">        debug_error_string = <span class="string">&quot;&#123;&quot;</span>created<span class="string">&quot;:&quot;</span>@<span class="number">1600520567.121816000</span><span class="string">&quot;,&quot;</span>description<span class="string">&quot;:&quot;</span>Error received <span class="keyword">from</span> peer ipv6:[::<span class="number">1</span>]:<span class="number">50051</span><span class="string">&quot;,&quot;</span>file<span class="string">&quot;:&quot;</span>src/core/lib/surface/call.cc<span class="string">&quot;,&quot;</span>file_line<span class="string">&quot;:1062,&quot;</span>grpc_message<span class="string">&quot;:&quot;</span>Exception calling application: <span class="string">&#x27;unknown user: name = bar&#x27;</span><span class="string">&quot;,&quot;</span>grpc_status<span class="string">&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="跨语言-gRPC"><a href="#跨语言-gRPC" class="headerlink" title="跨语言 gRPC"></a>跨语言 gRPC</h2><p>一直说 gRPC 跨语言，但我们一直跑的服务端、客户端同一种语言的。我们已经学习了 Golang 和 Python 两种语言的 gRPC，现在尝试跨语言去调用它们。</p><p>事实上，使用一样的 proto 作为基础，即使服务端和客户端使用不同语言实现，不用做任何处理就可以互相调用。</p><p>例如，我们刚才用 Python 实现的 gRPC 服务端、客户端，和上一篇文章《 <a href="https://blog.csdn.net/u012419550/article/details/108672965">Go 微服务基础：Protobuf &amp; gRPC</a>》中用 Go 语言实现的 gRPC 服务端、客户端，都是基于同一个 proto 文件的。</p><p>那么，我们不用动任何具体代码就可以随意组合使用 Golang、Python 的服务端和客户端。</p><h3 id="Python-调用-Golang"><a href="#Python-调用-Golang" class="headerlink" title="Python 调用 Golang"></a>Python 调用 Golang</h3><p>第一个尝试是 Python 客户端调用 Golang 实现的服务端。</p><p>使用上一篇文章《 <a href="https://blog.csdn.net/u012419550/article/details/108672965">Go 微服务基础：Protobuf &amp; gRPC</a>》中实现的 <code>server/main.go</code>  作为服务端，使用本文前面部分实现的 userinfo 的 <code>client.py</code> 作为客户端。</p><p>服务端一行代码都不改，直接跑起来：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br></pre></td></tr></table></figure><p>把 <code>client.py</code> 中的端口改成匹配服务端的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:8080&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>运行客户端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 /Users/c/Desktop/grpcpy/client.py</span><br><span class="line">id: 1</span><br><span class="line">name: <span class="string">&quot;foo&quot;</span></span><br><span class="line">age: 12</span><br><span class="line">hobby: <span class="string">&quot;eating&quot;</span></span><br><span class="line">hobby: <span class="string">&quot;sleep&quot;</span></span><br></pre></td></tr></table></figure><p>跨语言调用成功，一切正确！</p><p>如果你尝试错误调用，得到的是和刚才使用 Python 服务端相同的错误。 </p><h3 id="Golang-调用-Python"><a href="#Golang-调用-Python" class="headerlink" title="Golang 调用 Python"></a>Golang 调用 Python</h3><p>反过来，使用 Golang 调用 Python。</p><p>除了协调一下端口，还是不需要做任何改动！直接跑起来：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 server.py</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line">resp: &amp;proto.UserResponse&#123;state:impl.MessageState&#123;NoUnkeyedLiterals:pragma.NoUnkeyedLiterals&#123;&#125;, DoNotCompare:pragma.DoNotCompare&#123;&#125;, DoNotCopy:pragma.DoNotCopy&#123;&#125;, atomicMessageInfo:(*impl.MessageInfo)(0xc000186638)&#125;, sizeCache:0, unknownFields:[]uint8(nil), Id:1, Name:<span class="string">&quot;foo&quot;</span>, Age:12, Hobby:[]string&#123;<span class="string">&quot;eating&quot;</span>, <span class="string">&quot;sleep&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>调用成功。</p><hr><p>这种跨语言调用简单地似乎有些不可思议，但这种强大的简单正是我们使用 gRPC 的理由。</p><h1 id="写在最后：蒟蒻的抱怨"><a href="#写在最后：蒟蒻的抱怨" class="headerlink" title="写在最后：蒟蒻的抱怨"></a>写在最后：蒟蒻的抱怨</h1><p>又到了这个叫人受不了的季节！</p><p>蒟蒻在被褥中蜷缩着、颤抖着。耳机中淡淡的老歌化身利刃，夺心而入，又化身飓风，翻起片片凌乱的回忆。三分美好、七分苦涩从蒟蒻眼前飘过。</p><p>不知道是迷离的梦境还是草淡的现实中，蒟蒻再也受不了这心痛的季节、痛苦的歌曲和苦难的回忆。抱起刻满年岁的老吉他。调弦，变调，轻轻奏响。</p><p>一样的琴谱，一样的孤独，不停地重复又重复，弹出了新感触——</p><p>它呜咽的声响，是内心的旋律，是遗忘的节奏，是回忆的季节，是即将到来的——雪藏更多回忆的冬天。</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">by(<span class="string">&quot;CDFMLR&quot;</span>, <span class="string">&quot;2020-09-19&quot;</span>)</span><br><span class="line"><span class="comment"># See you.🎸</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 微服务基础：Protobuf &amp; gRPC</title>
      <link href="/2020/09/15/blog/Golang-Protobuf-and-gRPC/"/>
      <url>/2020/09/15/blog/Golang-Protobuf-and-gRPC/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-微服务基础：Protobuf-amp-gRPC"><a href="#Go-微服务基础：Protobuf-amp-gRPC" class="headerlink" title="Go 微服务基础：Protobuf &amp; gRPC"></a>Go 微服务基础：Protobuf &amp; gRPC</h1><p>这篇文章写的稍微有点乱，因为写作过程中思路有大断流。</p><p>本文历时很多天，期间我的两大主要开发环境 —— Python 和 Golang 都炸了，顺便，包管理工具 Homebrew 也出了点小问题（全都是因为一条没经过深思的错误的 <code>brew upgrade</code> 命令）。尝试手动修复，搞了一天，无果。没办法 Time Machine 恢复了一下，由于最近几天都没备份😭，S/L 大法不太灵，它一下子给我回到了十天前。各种手动检查、清理、git pull，又花费了一天。。。</p><p>不过这些怎么样都无所谓啦，我想说的是，大家在敲回车前还是要三思，尤其是使用管理员权限时。还有备份不要忘啊，再忙也要记得做备份哦。</p><hr><p><del>我们开门见山</del>，废话结束！这篇文章前半部分介绍了 Protocol Buffers 的安装使用和基本语法。后半部分基于 Golang，通过一个实例，介绍 Protobuf 与 gRPC 的使用。</p><p>[TOC]</p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><blockquote><p><a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a> 是一种序列化数据结构的协议。对于透过管道或存储数据进行通信的程序开发上是很有用的。这个方法包含一个接口描述语言，描述一些数据结构，并提供程序工具根据这些描述产生代码，用于将这些数据结构产生或解析数据流。</p><p>——  <a href="https://zh.wikipedia.org/zh-cn/Protocol_Buffers">WikiPedia</a></p></blockquote><p>总而言之， <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a>，简称 Protobuf， 是一种数据描述语言（和 XML、JSON 这些类似）。Protobuf 配套的工具可以自动生成将各种语言中的数据结构序列化为 Protobuf 表示，然后反序列化到任意支持的语言中。</p><p>在 RPC 中，跨语言的数据编码、解码是个问题， Protobuf 是一种比较高效的解决方案。gRPC 就是基于 Protobuf 的一套 RPC 框架。</p><h3 id="安装-Protobuf"><a href="#安装-Protobuf" class="headerlink" title="安装 Protobuf"></a>安装 Protobuf</h3><p>在 macOS 上，使用  homebrew 可以快速安装 protobuf。 <code>brew</code> 绝对是我见过最省事的包管理，忽略国内众所周知的原因带来的一些小问题，几乎满足了一切日常安装需要：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew install protobuf</span><br><span class="line">...</span><br><span class="line">$ protoc --version</span><br><span class="line">libprotoc 3.13.0</span><br></pre></td></tr></table></figure><p>我们要在 Golang 中使用 protobuf，需要把 ptotobuf “编译”成 Golang，需要安装  protoc-gen-go 工具来做这件事：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go</span><br></pre></td></tr></table></figure><p>下面先尝试使用它完成一次 HelloWorld，后面再介绍 Protobuf 的基本语法呀。</p><h3 id="使用-Protobuf"><a href="#使用-Protobuf" class="headerlink" title="使用 Protobuf"></a>使用 Protobuf</h3><p>首先，创建一个 <code>hello.proto</code> 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.proto</span><br></pre></td></tr></table></figure><p>写入如下 Protocol Buffers 代码：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax =  <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> world = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> meaningless_count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，生成 Golang 代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. hello.proto</span><br></pre></td></tr></table></figure><p><code>go_out</code> 告诉 protoc 编译器加载 protoc-gen-go 工具来生成代码，把生成代码放到当前目录。忽略打印的 WARNING，<code>protoc</code> 在当前路径下生成了一个 <code>hello.pb.go</code> 的文件。里面有很多内容，包括：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by protoc-gen-go. DO NOT EDIT.</span></span><br><span class="line"><span class="comment">// versions:</span></span><br><span class="line"><span class="comment">// protoc-gen-go v1.25.0</span></span><br><span class="line"><span class="comment">// protoc        v3.13.0</span></span><br><span class="line"><span class="comment">// source: hello.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    World            <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=world,proto3&quot; json:&quot;world,omitempty&quot;`</span></span><br><span class="line">    MeaninglessCount <span class="keyword">int32</span>  <span class="string">`protobuf:&quot;varint,2,opt,name=meaningless_count,json=meaninglessCount,proto3&quot; json:&quot;meaningless_count,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Hello)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Hello)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Hello)</span> <span class="title">ProtoMessage</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Hello)</span> <span class="title">ProtoReflect</span><span class="params">()</span> <span class="title">protoreflect</span>.<span class="title">Message</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Hello)</span> <span class="title">Descriptor</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Hello)</span> <span class="title">GetWorld</span><span class="params">()</span> <span class="title">string</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Hello)</span> <span class="title">GetMeaninglessCount</span><span class="params">()</span> <span class="title">int32</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面抽出来的这些代码我们都很熟悉了，它把 proto 文件中写的 <code>message</code> 翻译成了 golang 的结构体，这样我们就能直接在 Go 中使用这个结构了。</p><p>在编译时，你也可以编译成其他语言的，用 <code>--&lt;lang&gt;_out</code> 指定一个输出目录就行了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --java_out=. --cpp_out=. hello.proto</span><br></pre></td></tr></table></figure><p>你可以生成各种语言的代码看看，Go 生成的代码绝对是最简洁、最看得懂的（之一）。</p><h3 id="Protobuf-语法"><a href="#Protobuf-语法" class="headerlink" title="Protobuf 语法"></a>Protobuf 语法</h3><p>我们把 Protocol Buffers 代码写在 <code>.proto</code> 文件中。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>Protobuf 的注释还是我们熟悉的 C/C++ 风格：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是注释</span></span><br><span class="line"><span class="comment">/* 这也是注释 */</span></span><br></pre></td></tr></table></figure><h4 id="语法版本"><a href="#语法版本" class="headerlink" title="语法版本"></a>语法版本</h4><p><code>.proto</code> 的第一行会指明所用的语法版本，我们现在用的是 proto3 版本：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>Protocol Buffers 文件也可以导入其他文件中的内容：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;project/others.proto&quot;</span></span><br></pre></td></tr></table></figure><h4 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h4><p>Protocol Buffers 使用 <code>package</code> 关键字来声明包（可选）：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar;</span><br></pre></td></tr></table></figure><p>如果需要指定在不同语言中的名称，可以使用 <code>option</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.foo&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>用 <code>message</code> 关键字来定义消息。消息，就是 RPC 中客户端给服务端穿的参数以及服务端给客户端返回的结果。使用 <code>message MsgName &#123;...&#125;</code> 的语法来声明：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SongServerRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> song_name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message 的名称一般用<strong>驼峰命名</strong>。message 的内容是一些个「字段」。</p><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>字段的格式为：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">repeated</span>&#125; &lt;type&gt; &lt;field_name&gt; = &lt;fieldNumber&gt; &#123; [ fieldOptions ] &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里花括号中的内容是可选的，尖括号中的内容是需要替换的，后面的 <code>[ fieldOptions ]</code> 方括号是protobuf 语法的一部分。</p></blockquote><p>去掉所有可选部分，一个最基本的字段写作 <code>type field_name = fieldNumber</code>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> song_name = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><code>type</code> 很好理解，就是字段的数据类型，后面会详细介绍。</li><li><code>field_name</code> 是字段名称，采用<strong>下划线命名</strong>。</li><li><code>fieldNumber</code> 是一个数字，字段的编号。</li></ul><p>一个 message 的每个字段都要这个唯一编号。建议一次写好后永远也不要改这个编号，因为这个编号是用于以消息二进制格式标识字段的。需要注意一点是，最好把出现频繁的消息元素使用编号 1~15（只需一字节编码），更大的数字就需要更多空间了，可用的取值范围是 <code>[1, 19000) U (20000, 2^29)</code>（中间挖掉的是 protocol buffers 保留的 ）</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>protobuf 支持的基本类型有：</p><table><thead><tr><th>类型</th><th>proto</th><th>对应 go 类型</th><th>说明</th></tr></thead><tbody><tr><td>字节数组</td><td><code>bytes</code></td><td><code>[]byte</code></td><td>长度不超过 <code>2^32</code></td></tr><tr><td>字符串</td><td><code>string</code></td><td><code>string</code></td><td></td></tr><tr><td>布尔类型</td><td><code>bool</code></td><td><code>bool</code></td><td></td></tr><tr><td>整数</td><td><code>int32</code>，<code>int64</code></td><td><code>int32</code>，<code>int64</code></td><td>变长编码，对负数编码效率低</td></tr><tr><td>无符号整数</td><td><code>uint32</code>，<code>uint64</code></td><td><code>uint32</code>，<code>uint64</code></td><td>变长编码</td></tr><tr><td>有符号整数</td><td><code>sint32</code>，<code>sint64</code></td><td><code>int32</code>，<code>int64</code></td><td>变长编码，对负数编码比 <code>int32/64</code> 高效</td></tr><tr><td>定长整数</td><td><code>fixed32</code>，<code>fixed64</code></td><td><code>int32</code>，<code>int64</code></td><td>固定空间，定长编码，适合大数</td></tr><tr><td>定长有符号整数</td><td><code>sfixed32</code>，<code>sfixed64</code></td><td><code>int32</code>，<code>int64</code></td><td>定长编码</td></tr><tr><td>浮点数</td><td><code>float</code>，<code>double</code></td><td><code>float32</code>，<code>float64</code></td><td></td></tr></tbody></table><p>此外，还有几个复合类型：</p><p><strong>repeated</strong></p><p><code>repeated</code> 可以用来表示可变数组，也就相当于 Golang 的切片类型。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">string</span> hobby = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里的 hobby 就可以有好多个值，编译成 Golang 可以看到它就是一个 <code>[]string</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hobby []<span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,rep,name=hobby,proto3&quot; json:&quot;hobby,omitempty&quot;`</span></span><br></pre></td></tr></table></figure><p><strong>map</strong></p><p><code>map</code> 是键值对类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">string</span>, <span class="built_in">int64</span>&gt; something = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>enum</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> </span>&#123;</span><br><span class="line">  UNKNOWN2 = <span class="number">0</span>;</span><br><span class="line">  STARTED2 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>reserved</strong></p><p>reserved 用来指明此 message 不使用（保留）某些字段。通过编码或字段名来设置保留：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AllNormalypes</span> </span>&#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">4</span> to <span class="number">6</span>;</span><br><span class="line">  reserved <span class="string">&quot;field14&quot;</span>, <span class="string">&quot;field11&quot;</span>;</span><br><span class="line">  <span class="built_in">double</span> field1 = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// float field2 = 2;</span></span><br><span class="line">  <span class="built_in">int32</span> field3 = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// int64 field4 = 4;</span></span><br><span class="line">  <span class="comment">// uint32 field5 = 5;</span></span><br><span class="line">  <span class="comment">// uint64 field6 = 6;</span></span><br><span class="line">  <span class="built_in">sint32</span> field7 = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">sint64</span> field8 = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">fixed32</span> field9 = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">fixed64</span> field10 = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// sfixed32 field11 = 11;</span></span><br><span class="line">  <span class="built_in">sfixed64</span> field12 = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">bool</span> field13 = <span class="number">13</span>;</span><br><span class="line">  <span class="comment">// string field14 = 14;</span></span><br><span class="line">  <span class="built_in">bytes</span> field15 = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明保留的字段就不能再定义，否则编译会出错。</p><p><strong>message</strong></p><p>一个 message 可以作为另一个 message 的字段出现：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SomeOtherMessage</span> </span>&#123;</span><br><span class="line">  SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>我们常把 Proto Buffers  用在 RPC 里嘛，所以 Proto Buffers  是可以直接定义 RPC 服务接口的。这个接口可以直接用 gRPC 去实现：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时 Proto Buffers 会根据选择的语言生成服务接口代码和存根（Stub）。</p><p>接下来，介绍如何在 gRPC 中使用 Ptotobuf。</p><h2 id="gRPC-with-Golang"><a href="#gRPC-with-Golang" class="headerlink" title="gRPC with Golang"></a>gRPC with Golang</h2><p>什么是 gRPC？官网上它给自己下的定义是 A high-performance, open source universal RPC framework —— 一个高性能的开源通用 RPC 框架。</p><p>gRPC 在通信的过程中使用 Protobuf。所以它基本上 Protobuf 支持的语言 gRPC 都支持，Go、C++、Java、Python 这些我们常用的后端语言都可以用 gRPC，而且是可以跨语言调用。</p><p>接下来，我们着眼于 Golang，通过一个简单实例，看看 gRPC 如何使用。</p><p>我们的目标是做一个处理用户信息的 RPC 实例。客户端通过给定用户名，从服务端查询用户信息。</p><p>最终实现的项目结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grpc</span><br><span class="line">├── client</span><br><span class="line">│   └── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── proto</span><br><span class="line">│   ├── user.pb.go</span><br><span class="line">│   ├── user.proto</span><br><span class="line">│   └── user_grpc.pb.go</span><br><span class="line">└── server</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure><ul><li>proto 目录里我们写 <code>user.proto</code> 来定义 RPC 服务接口。</li><li>server 实现一个 gRPC 服务端。</li><li>client 实现客户端。</li></ul><p>在项目根目录 grpc 目录下初始化了一个 go 模块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init grpc.learn</span><br></pre></td></tr></table></figure><p>安装 gRPC 的 Go 包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get goole.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="Protobuf-编写"><a href="#Protobuf-编写" class="headerlink" title="Protobuf 编写"></a>Protobuf 编写</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> proto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息请求参数</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息请求响应</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserResponse</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> hobby = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息接口</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取用户信息，请求参数为 UserRequest，返回响应为 UserResponse</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUserInfo (UserRequest) <span class="keyword">returns</span> (UserResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protobuf-编译"><a href="#Protobuf-编译" class="headerlink" title="Protobuf 编译"></a>Protobuf 编译</h3><p>这里我遇到一个坑， 网上的资料一般都是教用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. user.proto</span><br></pre></td></tr></table></figure><p>但现在（2020.08.18）这个不行了，会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--go_out: protoc-gen-go: plugins are not supported; use <span class="string">&#x27;protoc --go-grpc_out=...&#x27;</span> to generate gRPC</span><br></pre></td></tr></table></figure><p>我查了 <a href="https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code">gRPC 官网的有关文档</a>，以及有关的 GitHub <a href="https://github.com/grpc/grpc.io/issues/298">gRPC Issue 298</a>、<a href="https://github.com/golang/protobuf/issues/1070">Protobuf Issue 1070</a> 等等一些东西。总而言之，Protobuf 生成 gRPC 代码的工具最近有些变化，目前使用 protoc 生成 Golang 的 gRPC 代码，需要安装一个额外的包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> proto</span><br><span class="line">$ protoc -I . --go_out=. --go-grpc_out=. ./user.proto</span><br></pre></td></tr></table></figure><p>忽略输出的 <code> Missing &#39;go_package&#39; option</code> WARNING。就可以看到生成的接口文件了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proto/</span><br><span class="line">├── user.pb.<span class="keyword">go</span></span><br><span class="line">├── user.proto</span><br><span class="line">└── user_grpc.pb.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><ul><li><code>--go_out</code> 生成的  <code>user.pb.go</code> 中定义了 message 在 golang 中的结构体，以及其编码解码。</li><li><code>--go-rpc_out</code> 生成的 <code>user_grpc.pb.go</code> 里面是 service 在 golang 中的 gRPC 服务、客户端接口。</li></ul><h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>查看 <code>user_grpc.pb.go</code> 中的代码，发现里面定义有这些东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserInfoService is the service API for UserInfo service.</span></span><br><span class="line"><span class="comment">// Fields should be assigned to their respective handler implementations only before</span></span><br><span class="line"><span class="comment">// RegisterUserInfoService is called.  Any unassigned fields will result in the</span></span><br><span class="line"><span class="comment">// handler for that method returning an Unimplemented error.</span></span><br><span class="line"><span class="keyword">type</span> UserInfoService <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 获取用户信息，请求参数为 UserRequest，返回响应为 UserResponse</span></span><br><span class="line">GetUserInfo <span class="function"><span class="keyword">func</span><span class="params">(context.Context, *UserRequest)</span> <span class="params">(*UserResponse, error)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterUserInfoService registers a service implementation with a gRPC server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterUserInfoService</span><span class="params">(s grpc.ServiceRegistrar, srv *UserInfoService)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>靠我六级高达 410 分的惊人英语实力，信达雅地翻译一下：</p><ul><li><code>UserInfoService</code> 是 UserInfo 服务的服务端接口。在调用 <code>RegisterUserInfoService</code> 之前， 应该将各种服务功能的具体实现赋给 <code>UserInfoService</code> 的对应字段。</li><li><code>RegisterUserInfoService</code> 在 gRPC 服务器实例上注册一个 <code>UserInfoService</code> 实例。</li></ul><p>新建一个 <code>server/main.go</code>，在里面编写具体的服务端代码。首先要导入 protobuf 的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;grpc.learn/proto&quot;</span></span><br></pre></td></tr></table></figure><p>这里我把所有代码都放到一个叫 <code>grpc.learn</code> 的 <code>go module</code> 里了，所以这样去取 proto 子包（即刚才写的 proto 文件生成代码的包）。</p><p>你去看 gRPC 的官方例子，里面还会有给这个 protobuf 接口的包取个名字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">pb <span class="string">&quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我没取名字，没关系，这不重要。</p><p>在 <code>UserInfoService</code> 中 <code>GetUserInfo</code> 字段是函数类型的。所以可以把一个符合声明的函数赋给 <code>UserInfoService</code> 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getUserInfo 实现具体的获取用户信息的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">(ctx context.Context, request *proto.UserRequest)</span> <span class="params">(response *proto.UserResponse, err error)</span></span> &#123;</span><br><span class="line">name := request.Name</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;GetUserInfo: name =&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fake query</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;foo&quot;</span> &#123;</span><br><span class="line">response = &amp;proto.UserResponse&#123;</span><br><span class="line">Id:    <span class="number">1</span>,</span><br><span class="line">Name:  <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">Age:   <span class="number">12</span>,</span><br><span class="line">Hobby: []<span class="keyword">string</span>&#123;<span class="string">&quot;eating&quot;</span>, <span class="string">&quot;sleep&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response, fmt.Errorf(<span class="string">&quot;unknown user: name=%s&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 UserInfoService</span></span><br><span class="line"><span class="keyword">var</span> userInfoService = proto.UserInfoService&#123;</span><br><span class="line">GetUserInfo: getUserInfo,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><details><summary>Tips：Golang 函数与函数类型 （给 Go 语言初学者）</summary><p>Golang 中函数是一等公民，任何可以使用其他类型对象的地方都可以使用函数。</p><p>Golang 也支持函数类型，即将相同声明(参数接收相同个数、类型，返回相同个数、类型)的函数看作一个类型的，可以用 type 给函数类型取名字。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation 是计算的抽象</span></span><br><span class="line"><span class="keyword">type</span> Operation <span class="function"><span class="keyword">func</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span></span><br></pre></td></tr></table></figure><p>我们把各种接收两个 float64 参数、返回 float64 的函数都看作是 Operation 的<strong>实例</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number1 + Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number1 - Number2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add 和 Sub 都满足了声明 <code>func(Number1, Number2 float64) float64</code>，所以都是 Operation 函数类型的实例。函数类型的实例是具体可调用的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oper Operation</span><br><span class="line">oper = Add</span><br><span class="line">oper(<span class="number">1.0</span>, <span class="number">1.0</span>) <span class="comment">// 相当于调用 Add(1.0, 1.0)</span></span><br></pre></td></tr></table></figure><p>回到 gRPC，我们的 GetUserInfo 是一个 <code>func(context.Context, *UserRequest) (*UserResponse, error)</code> 函数类型的字段（只是没有给这个函数类型取名字），我们可以把任何满足了这个声明的函数赋值给它。这里我们把具体实现 <code>getUserInfo</code> 赋给 <code>GetUserInfo</code>。在其他地方使用 <code>GetUserInfo(...)</code> 时，就相当于使用了 <code>getUserInfo(...)</code>。</p></details><hr><p>在 main 函数中，我们需要实例化并开启服务。首先需要实例化一个 grpc 服务，然后把我们的 UserInfo 服务实例注册上。接下来，监听 TCP 网络，在监听上启动 gRPC 服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化 gRPC，注册服务</span></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">proto.RegisterUserInfoService(s, &amp;userInfoService)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听网络</span></span><br><span class="line">address := <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Listening tcp:&quot;</span>, address)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 gRPC 服务</span></span><br><span class="line">err = s.Serve(listener)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>客户端的实现上，和<a href="https://blog.csdn.net/u012419550/article/details/108555316">我上一篇文章</a>写的用 <code>net/rpc</code> 其实差别不大。</p><p>首先是连接网络：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address := <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">clientConn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dial error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> clientConn.Close()</span><br></pre></td></tr></table></figure><p>利用 gRPC 的 <code>ClientConn</code>，实例化一个客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client := proto.NewUserInfoClient(clientConn)</span><br></pre></td></tr></table></figure><p>（这里的 proto 还是之前 protoc 生成代码的那个包）</p><p>然后就可以调用服务了，请求参数是 context 和一个 UserRequest 实例的指针，返回 UserResponse 和 error：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">req := &amp;proto.UserRequest&#123;Name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">resp, err := client.GetUserInfo(context.Background(), req)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;GetUserInfo error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;resp: %#v&quot;</span>, resp)</span><br></pre></td></tr></table></figure><hr><p>以上介绍的内容都使用了最新的版本，相比于 Google 搜索 <code>go gRPC 教程</code> 结果比较靠前的几篇中文文章，这里介绍的方法从 protobuf 编译到服务端实现上都有一定区别。新旧 API 各有特色，但我觉得都还是很好用的，都挺顺手。</p><p>P.S. 我的环境是 <code>macOS Catalina</code>， <code>go 1.12</code>，<code>libprotoc 3.13.0</code>，<code>protoc-gen-go v1.25.0</code>，<code>protoc-gen-go-grpc v0.0.0-20200917190803-0f7e218c2cf4</code>。</p><p>完整的代码我还是放到了 Gist 中，需要的话可以自取：</p><ul><li><a href="https://gist.github.com/cdfmlr/95186d2db5e3c510b324e6ad47a76c9b">https://gist.github.com/cdfmlr/95186d2db5e3c510b324e6ad47a76c9b</a></li></ul><script src="https://gist.github.com/cdfmlr/95186d2db5e3c510b324e6ad47a76c9b.js"></script><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By(<span class="string">&quot;CDFMLR&quot;</span>, <span class="string">&quot;2020-09-18&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;看看今天的日期，再看看近期诸事，我们的开发者还是要更努力啊。&quot;</span>)</span><br><span class="line"><span class="comment">// See you.💪</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go RPC 远程过程调用</title>
      <link href="/2020/09/09/blog/Golang-RPC_Intro/"/>
      <url>/2020/09/09/blog/Golang-RPC_Intro/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-RPC-远程过程调用"><a href="#Go-RPC-远程过程调用" class="headerlink" title="Go RPC 远程过程调用"></a>Go RPC 远程过程调用</h1><p>今天来学习 Go 语言的<em>远程过程调用</em> RPC（ Remote Procedure Call）。</p><blockquote><p>在分布式计算，远程过程调用是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程。RPC是一种服务器-客户端模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。</p><p>From WikiPedia</p></blockquote><p>RPC 可以让客户端相对直接地访问服务端的函数，这里说的「相对直接」表示我们不需要在服务端自己写一些比如 web 服务的东西来提供接口，并且在两端手动做各种数据的编码、解码。</p><p>本文包括两部分，第一部分介绍 Golang 标准库的 <code>net/rpc</code>，第二部分动手实现一个玩具版 PRC 框架来加深理解。</p><p>[TOC]</p><h2 id="Part0-net-rpc"><a href="#Part0-net-rpc" class="headerlink" title="Part0. net/rpc"></a>Part0. net/rpc</h2><blockquote><p>这一部分参考 <a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">《Go语言高级编程》4.1 RPC入门</a>。未尽之处可移步阅读原文。</p></blockquote><p>Go 标准库的 <code>net/rpc</code> 实现了基本的 RPC，它使用一种 Go 语言特有的 Gob 编码方式，所以服务端、客户端都必须使用 Golang，不能跨语言调用。</p><p>对于服务端， <code>net/rpc</code> 要求用一个导出的结构体来表示 RPC 服务，这个结构体中所有符合特定要求的方法就是提供给客户端访问的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">MethodName</span><span class="params">(argType T1, replyType *T2)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><ul><li>结构体是导出的。</li><li>方法是导出的。</li><li>方法有两个参数，都是导出的类型（或者内置类型）。</li><li>方法的第二个参数是指针。</li><li>方法的返回值是 error。</li></ul><p>服务端通过 <code>rpc.Dial</code>（对 TCP 服务）连接服务端，然后用使用 Call 调用 RPC 服务中的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc.Call(<span class="string">&quot;T.MethodName&quot;</span>, argType T1, replyType *T2)</span><br></pre></td></tr></table></figure><p>例如，用 <code>net/rpc</code> 实现一个 Hello World。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p><strong>服务端</strong></p><p>首先构建一个 <code>HelloService</code> 来表示提供的服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloService is a RPC service for helloWorld</span></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello say hello to request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">*reply = <span class="string">&quot;Hello, &quot;</span> + request</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来注册并开启 RPC 服务，我们可以基于 HTTP 服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 用将给客户端访问的名字和HelloService实例注册 RPC 服务</span></span><br><span class="line">rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 服务</span></span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Http Listen and Serve:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 TCP 服务，替换上面的第 8～12 行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 服务</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.ServeConn(conn)</span><br></pre></td></tr></table></figure><p>注意，这里服务端只 Accept 一个请求，在客户端请求过后就会自动关闭。如果需要一直保持处理，可以把后半部分代码换成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// HTTP</span></span><br><span class="line"><span class="comment">// client, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TCP</span></span><br><span class="line">client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">err = client.Call(<span class="string">&quot;HelloService.Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run helloworld/server/server.go</span><br></pre></td></tr></table></figure><p>在另一个终端调用客户端，即可得到结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run helloworld/client/client.go</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure><h3 id="更规范的-RPC-接口"><a href="#更规范的-RPC-接口" class="headerlink" title="更规范的 RPC 接口"></a>更规范的 RPC 接口</h3><p>之前的代码服务端、客户端的注册、调用 RPC 服务都是写死的。所有的工作都放到了一块，相当不利于维护，需要考虑重构 HelloService 服务和客户端实现。</p><p><strong>服务端</strong></p><p>首先，用一个 interface 抽象服务接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloServiceName is the name of HelloService</span></span><br><span class="line"><span class="keyword">const</span> HelloServiceName = <span class="string">&quot;HelloService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloServiceInterface is a interface for HelloService</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHelloService register the RPC service on svc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloService</span><span class="params">(svc HelloServiceInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rpc.RegisterName(HelloServiceName, svc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例化服务时，注册用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterHelloService(<span class="built_in">new</span>(HelloService))</span><br></pre></td></tr></table></figure><p>其余的具体服务实现没有改变。</p><p><strong>客户端</strong></p><p>在客户端，考虑将 RPC 细节封装到一个客户端对象 <code>HelloServiceClient</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloServiceClient is a client for HelloService</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">*rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ HelloServiceInterface = (*HelloServiceClient)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialHelloService dial HelloService</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHelloService</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*HelloServiceClient, error)</span></span> &#123;</span><br><span class="line">c, err := rpc.Dial(network, address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> , err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;HelloServiceClient&#123;Client: c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello calls HelloService.Hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceClient)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.Client.Call(HelloServiceName + <span class="string">&quot;.Hello&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体调用时，就不用去暴露处理 RPC 的细节了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">client, err := DialHelloService(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">err = client.Hello(<span class="string">&quot;world&quot;</span>, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reply)</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>运用上面的内容，做一个简单的计算器 RPC 服务。项目目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calc&#x2F;</span><br><span class="line">├── calcrpc.go</span><br><span class="line">├── client</span><br><span class="line">│   └── client.go</span><br><span class="line">└── server</span><br><span class="line">    ├── calc.go</span><br><span class="line">    └── server.go</span><br></pre></td></tr></table></figure><p>首先写一个 <code>calcrpc.go</code> 定义服务端/客户端通用的 RPC 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceName 计算器服务名</span></span><br><span class="line"><span class="keyword">const</span> ServiceName = <span class="string">&quot;CalcService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceInterface 计算器服务接口</span></span><br><span class="line"><span class="keyword">type</span> ServiceInterface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// CalcTwoNumber 对两个数进行运算</span></span><br><span class="line">CalcTwoNumber(request Calc, reply *<span class="keyword">float64</span>)  error</span><br><span class="line"><span class="comment">// GetOperators 获取所有支持的运算</span></span><br><span class="line">GetOperators(request <span class="keyword">struct</span>&#123;&#125;, reply *[]<span class="keyword">string</span>)  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterCalcService register the RPC service on svc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCalcService</span><span class="params">(svc ServiceInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rpc.RegisterName(ServiceName, svc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calc 定义计算器对象，包括两个运算数</span></span><br><span class="line"><span class="keyword">type</span> Calc <span class="keyword">struct</span> &#123;</span><br><span class="line">Number1 <span class="keyword">float64</span></span><br><span class="line">Number2 <span class="keyword">float64</span></span><br><span class="line">Operator <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写服务端实现，在 <code>calc.go</code> 中写一个常规的计算器抽象实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单计算器实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象的计算函数类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operation 是计算的抽象</span></span><br><span class="line"><span class="keyword">type</span> Operation <span class="function"><span class="keyword">func</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加减乘除的具体 Operation 实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 是加法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number1 + Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub 是减法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number1 - Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mul 是乘法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mul</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number1 * Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Div 是除法的 Operation 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(Number1, Number2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number1 / Number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 工厂 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operators 注册所有支持的运算</span></span><br><span class="line"><span class="keyword">var</span> Operators = <span class="keyword">map</span>[<span class="keyword">string</span>]Operation &#123;</span><br><span class="line"><span class="string">&quot;+&quot;</span>: Add,</span><br><span class="line"><span class="string">&quot;-&quot;</span>: Sub,</span><br><span class="line"><span class="string">&quot;*&quot;</span>: Mul,</span><br><span class="line"><span class="string">&quot;/&quot;</span>: Div,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateOperation 通过 string 表示的 operator 获取适合的 Operation 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateOperation</span><span class="params">(operator <span class="keyword">string</span>)</span> <span class="params">(Operation, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> oper Operation</span><br><span class="line"><span class="keyword">if</span> oper, ok := Operators[operator]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> oper, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oper, errors.New(<span class="string">&quot;Illegal Operator&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 RPC 服务的实现，在 <code>server.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorpctest/calc&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RPC 服务实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcService 是计算器 RPC 服务的实现</span></span><br><span class="line"><span class="keyword">type</span> CalcService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcTwoNumber 对两个数进行加减乘除运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcService)</span> <span class="title">CalcTwoNumber</span><span class="params">(request calc.Calc, reply *<span class="keyword">float64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">oper, err := CreateOperation(request.Operator)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">*reply = oper(request.Number1, request.Number2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetOperators 获取所有支持的运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcService)</span> <span class="title">GetOperators</span><span class="params">(request <span class="keyword">struct</span>&#123;&#125;, reply *[]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opers := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(Operators))</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> Operators &#123;</span><br><span class="line">opers = <span class="built_in">append</span>(opers, key)</span><br><span class="line">&#125;</span><br><span class="line">*reply = opers</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行 RPC 服务 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">calc.RegisterCalcService(<span class="built_in">new</span>(CalcService))</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是客户端实现，在 <code>client.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorpctest/calc&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义客户端实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcClient is a client for CalcService</span></span><br><span class="line"><span class="keyword">type</span> CalcClient <span class="keyword">struct</span> &#123;</span><br><span class="line">*rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ calc.ServiceInterface = (*CalcClient)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialCalcService dial CalcService</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialCalcService</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*CalcClient, error)</span></span> &#123;</span><br><span class="line">c, err := rpc.DialHTTP(network, address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> , err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;CalcClient&#123;Client: c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CalcTwoNumber 对两个数进行运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcClient)</span> <span class="title">CalcTwoNumber</span><span class="params">(request calc.Calc, reply *<span class="keyword">float64</span>)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Client.Call(calc.ServiceName + <span class="string">&quot;.CalcTwoNumber&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetOperators 获取所有支持的运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CalcClient)</span> <span class="title">GetOperators</span><span class="params">(request <span class="keyword">struct</span>&#123;&#125;, reply *[]<span class="keyword">string</span>)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Client.Call(calc.ServiceName + <span class="string">&quot;.GetOperators&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用客户端调用 RPC 服务 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">client, err := DialCalcService(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Err Dial Client:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test GetOperators</span></span><br><span class="line"><span class="keyword">var</span> opers []<span class="keyword">string</span></span><br><span class="line">err = client.GetOperators(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;, &amp;opers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(opers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test CalcTwoNumber</span></span><br><span class="line">testAdd := calc.Calc &#123;</span><br><span class="line">Number1: <span class="number">2.0</span>,</span><br><span class="line">Number2: <span class="number">3.14</span>,</span><br><span class="line">Operator: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float64</span></span><br><span class="line">client.CalcTwoNumber(testAdd, &amp;result)</span><br><span class="line">log.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="net-rpc-jsonrpc"><a href="#net-rpc-jsonrpc" class="headerlink" title="net/rpc/jsonrpc"></a>net/rpc/jsonrpc</h3><p><code>net/rpc</code> 允许 RPC 数据打包时通过插件实现自定义的编码和解码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务段的编码</span></span><br><span class="line">rpc.ServeCodec(SomeServerCodec(conn)) <span class="comment">// SomeServerCodec 是个编码器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的解码</span></span><br><span class="line">conn, _ := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">client := rpc.NewClientWithCodec(SomeClientCodec(conn)) <span class="comment">// SomeClientCodec 是个解码器</span></span><br></pre></td></tr></table></figure><p><code>net/rpc/jsonrpc</code> 就是这样的一种实现，它使用  JSON 而不是 Gob 编码，可以用来做跨语言 RPC。在真实的使用中，<code>net/rpc/jsonrpc</code> 在内部封装了上面提到的编码、解码实现，提供大致上和 <code>net/rpc</code> 相同的 API。</p><p>服务端在之前的 Hello World 基础上，只需要改动 main 的最后一行代码（不算 <code>&#125;</code>）即可变为使用 JSON RPC：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instead of `go rpc.ServeConn(conn)`</span></span><br><span class="line"><span class="keyword">go</span> jsonrpc.ServeConn(conn)</span><br></pre></td></tr></table></figure><blockquote><p><code>jsonrpc.ServeConn</code> 的实现是 <code>rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</code></p></blockquote><p>在调用时，将 <code>DialHelloService</code> 中连接服务的代码改一改就可以使用了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instead of `c, err := rpc.Dial(network, address)`</span></span><br><span class="line">c, err := jsonrpc.Dial(network, address)</span><br></pre></td></tr></table></figure><blockquote><p>这里也可以用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, _ := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br></pre></td></tr></table></figure><p>这样开的服务是基于 TCP 的。我们可以关闭服务端程序，运行 <code>nc -l 1234</code> 启动一个 TCP 服务，然后再次运行客户端程序，nc 会输出客户端请求的内容：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 1234</span><br><span class="line">&#123;<span class="string">&quot;method&quot;</span>:<span class="string">&quot;HelloService.Hello&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;world&quot;</span>],<span class="string">&quot;id&quot;</span>:0&#125;</span><br></pre></td></tr></table></figure><p>可以看到请求体是 JSON 数据。反过来，模仿这个请求体，我们可以手动向正在运行的客户端发送模拟请求，查看响应体：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&#x27;&#123;&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;JSON-RPC&quot;],&quot;id&quot;:1&#125;&#x27;</span> | nc localhost 1234</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;result&quot;</span>:<span class="string">&quot;Hello, JSON-RPC&quot;</span>,<span class="string">&quot;error&quot;</span>:null&#125;</span><br></pre></td></tr></table></figure><p>总结一下，请求、响应的结构体大概为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    Method <span class="keyword">string</span>           <span class="string">`json:&quot;method&quot;`</span></span><br><span class="line">    Params *json.RawMessage <span class="string">`json:&quot;params&quot;`</span></span><br><span class="line">    Id     *json.RawMessage <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id     <span class="keyword">uint64</span>           <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    Result *json.RawMessage <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">    Error  <span class="keyword">interface</span>&#123;&#125;      <span class="string">`json:&quot;error&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（其实真正的实现中，客户端和服务端请求、响应定义是略有区别的）</p><p>使用其他语言，只要遵循这样的请求/响应结构，就可以和 Go 的 RPC 服务进行通信了。</p><h3 id="JSON-RPC-in-HTTP"><a href="#JSON-RPC-in-HTTP" class="headerlink" title="JSON-RPC in HTTP"></a>JSON-RPC in HTTP</h3><p>刚才的实现是基于 TCP 的，有时候不方便使用，我们可能更希望使用熟悉的 HTTP 协议。</p><p><code>net/rpc</code> 的 RPC 服务是建立在抽象的 <code>io.ReadWriteCloser</code> 接口之上的（conn），所以略作改变，就可以将 RPC 架设在不同的通讯协议之上。这里我们将尝试将 <code>net/rpc/jsonrpc</code> 架设到 HTTP 服务上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">RegisterHelloService(<span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 服务</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/jsonrpc&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> &#123;</span><br><span class="line">io.Writer</span><br><span class="line">io.ReadCloser</span><br><span class="line">&#125; &#123;</span><br><span class="line">ReadCloser: r.Body,</span><br><span class="line">Writer: w,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以通过 HTTP 很方便地从不同的语言中访问 RPC 服务了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:1234/jsonrpc  --data <span class="string">&#x27;&#123;&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;world&quot;],&quot;id&quot;:0&#125;&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:0,<span class="string">&quot;result&quot;</span>:<span class="string">&quot;Hello, world&quot;</span>,<span class="string">&quot;error&quot;</span>:null&#125;</span><br></pre></td></tr></table></figure><p>但是，这里有个问题是，不方便使用 Go 写客户端，你需要自己去构建一个客户端实现，来完成请求的编码、发送以及响应的解码、绑定😂。或者，也可以使用一个 JSON-RPC 的库。</p><h2 id="Part1-简单-RPC-的实现"><a href="#Part1-简单-RPC-的实现" class="headerlink" title="Part1. 简单 RPC 的实现"></a>Part1. 简单 RPC 的实现</h2><blockquote><p>这一部分参考 <a href="https://www.bilibili.com/video/BV137411H7t9?p=9">《从0开始学习微服务框架》 P9~P14  RPC</a>。未尽之处可移步学习原视频。</p></blockquote><p>为了加深理解，我们手写一个简单的 RPC 服务，从自定义协议到编码、解码，再到 RPC 服务端、客户端实现。</p><p>我们写一个 <code>package rpc</code> 来实现这东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;rpc</span><br><span class="line">├── client.go</span><br><span class="line">├── codec.go</span><br><span class="line">├── server.go</span><br><span class="line">└── session.go</span><br><span class="line">(省略了测试文件)</span><br></pre></td></tr></table></figure><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>我们基于 TCP 通信，使用如下自定义的协议进行通信：</p><table><thead><tr><th><strong>网络字节流</strong></th><th>Header</th><th>Data</th></tr></thead><tbody><tr><td>大小</td><td><code>uint32</code>（定长：4字节）</td><td><code>[]byte</code>（长度由Header指明）</td></tr><tr><td>说明</td><td>Data 的长度信息</td><td>具体数据</td></tr></tbody></table><p>我们通过一个 <code>Session</code> 结构体实现这个基本的协议：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// session.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Session 是 RPC 通信的一个会话连接</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSession 从网络连接新建一个 Session</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(conn net.Conn)</span> *<span class="title">Session</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Session&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后的 RPC 通信就通过 <code>Session</code>  来对 TCP 连接进行数据读写操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// session.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 向 Session 中写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>+<span class="built_in">len</span>(data))</span><br><span class="line"><span class="comment">// Header</span></span><br><span class="line">binary.BigEndian.PutUint32(buf[:<span class="number">4</span>], <span class="keyword">uint32</span>(<span class="built_in">len</span>(data)))</span><br><span class="line"><span class="comment">// Data</span></span><br><span class="line"><span class="built_in">copy</span>(buf[<span class="number">4</span>:], data)</span><br><span class="line"></span><br><span class="line">_, err := s.conn.Write(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 从 Session 中读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Read</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取 Header，获取 Data 长度信息</span></span><br><span class="line">header := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(s.conn, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">dataLen := binary.BigEndian.Uint32(header)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 dataLen 读取 Data</span></span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, dataLen)</span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(s.conn, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h3><p>在 RPC 的过程中，我们需要按照一定的格式传递函数的参数与结果。我们可以定义如下 <code>RPCData</code> 来格式化 RPC 通信的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// codec.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPCData 定义 RPC 通信的数据格式</span></span><br><span class="line"><span class="keyword">type</span> RPCData <span class="keyword">struct</span> &#123;</span><br><span class="line">Func <span class="keyword">string</span>        <span class="comment">// 访问的函数</span></span><br><span class="line">Args []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 函数的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个 RPC 中，所有网络通信都利用 <code>Session</code> 对 <code>RPCData</code> 编码成的 <code>[]byte</code> 进行传输。要把 <code>RPCData</code> 在一端编码成字节，并在另一端解码会原本的 Go 数据类型，可以利用 <code>encoding/gob</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// codec.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// encode 将 RPCData 编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(data RPCData)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">encoder := gob.NewEncoder(&amp;buf)</span><br><span class="line"><span class="keyword">if</span> err := encoder.Encode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decode 将数据解码为 RPCData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(RPCData, error)</span></span> &#123;</span><br><span class="line">buf := bytes.NewBuffer(data)</span><br><span class="line">decoder := gob.NewDecoder(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rpcData RPCData</span><br><span class="line">err := decoder.Decode(&amp;rpcData)</span><br><span class="line"><span class="keyword">return</span> rpcData, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了网络通信的方案以及编码解码的方式，就可以开始构建 RPC 服务的服务端框架以及客户端实现了。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>RPC 服务端的核心是，维护一个函数名到本地函数的映射。实现这个映射，并开启一个网络服务，就可以支持客户端通过给定函数名和参数即可调用服务端函数的操作了。</p><p>这里可以简单地把服务定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Server 是简单的 RPC 服务</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">funcs <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Server&#123;funcs: <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Value&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射机制，来实现 funs 的映射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register 注册绑定要 RPC 服务的函数</span></span><br><span class="line"><span class="comment">// 将函数名与函数对应起来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, function <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 已存在则跳过</span></span><br><span class="line"><span class="keyword">if</span> _, ok := s.funcs[name]; ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fVal := reflect.ValueOf(function)</span><br><span class="line">s.funcs[name] = fVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是开启网络服务，监听  TCP 连接，对访问进行服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe 监听 address，运行 RPC 服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;accept error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">s.handleConn(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体对连接的处理在 <code>handleConn</code> 中完成。对 conn 创建一个 RPC 会话，解码请求体，得到客户端希望请求的函数和参数。调用本地函数完成工作，将返回值编码，返回给客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go PART 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// handleConn 处理 RPC 服务的 conn 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建会话</span></span><br><span class="line">srvSession := NewSession(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取、解码数据</span></span><br><span class="line">data, err := srvSession.Read()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;session read error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">requestRPCData, err := decode(data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;data decode error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数</span></span><br><span class="line">f, ok := s.funcs[requestRPCData.Func]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;unexpected rpc call: function %s not exist&quot;</span>, requestRPCData.Func)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数</span></span><br><span class="line">inArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(requestRPCData.Args))</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> requestRPCData.Args &#123;</span><br><span class="line">inArgs = <span class="built_in">append</span>(inArgs, reflect.ValueOf(arg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射调用方法</span></span><br><span class="line">returnValues := f.Call(inArgs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造结果</span></span><br><span class="line">outArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(returnValues))</span><br><span class="line"><span class="keyword">for</span> _, ret := <span class="keyword">range</span> returnValues &#123;</span><br><span class="line">outArgs = <span class="built_in">append</span>(outArgs, ret.Interface())</span><br><span class="line">&#125;</span><br><span class="line">replyRPCData := RPCData&#123;</span><br><span class="line">Func: requestRPCData.Func,</span><br><span class="line">Args: outArgs,</span><br><span class="line">&#125;</span><br><span class="line">replyEncoded, err := encode(replyRPCData)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;reply encode error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入结果</span></span><br><span class="line">err = srvSession.Write(replyEncoded)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;reply write error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>RPC 客户端的一个特点是，像调用本地函数一样去调用远程的函数。要调用的函数并不是在本地实现的，但我们希望让它像本地函数一样工作。反射机制可以提供这种“欺骗自己”的特性。</p><p>首先我们写出客户端结构，其实就是对一个网络连接的包装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.go PART 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Client 是 RPC 的客户端</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn net.Conn)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Client&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现一个 <code>Call</code> 方法，把原创的函数通过 RPC 带到本地来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.go PART 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">(name <span class="keyword">string</span>, funcPtr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 反射初始化 funcPtr 函数原型</span></span><br><span class="line">fn := reflect.ValueOf(funcPtr).Elem()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RPC 调用远程的函数</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(args []reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line">inArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">inArgs = <span class="built_in">append</span>(inArgs, arg.Interface())</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 连接服务</span></span><br><span class="line">cliSession := NewSession(c.conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求</span></span><br><span class="line">requestRPCData := RPCData&#123;</span><br><span class="line">Func: name,</span><br><span class="line">Args: inArgs,</span><br><span class="line">&#125;</span><br><span class="line">requestEncoded, err := encode(requestRPCData)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := cliSession.Write(requestEncoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应</span></span><br><span class="line">response, err := cliSession.Read()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">respRPCData, err := decode(response)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">outArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(respRPCData.Args))</span><br><span class="line"><span class="keyword">for</span> i, arg := <span class="keyword">range</span> respRPCData.Args &#123;</span><br><span class="line"><span class="keyword">if</span> arg == <span class="literal">nil</span> &#123;</span><br><span class="line">outArgs = <span class="built_in">append</span>(outArgs, reflect.Zero(fn.Type().Out(i)))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">outArgs = <span class="built_in">append</span>(outArgs, reflect.ValueOf(arg))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回远程函数的返回值</span></span><br><span class="line"><span class="keyword">return</span> outArgs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 RPC 调用函数赋给 fn</span></span><br><span class="line">v := reflect.MakeFunc(fn.Type(), f)</span><br><span class="line">fn.Set(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受两个参数，<code>name</code> 为 RPC 服务端提供的函数名，<code>funcPtr</code> 是要调用的函数的原型。该函数运行的结果是将一个「封装了 RPC 调用远程函数的函数」“赋给” <code>funcPtr</code>，让 <code>funcPtr</code> 从一个空有其表的原型变成一个可调用的真实函数，调用它就等于通过 RPC 调用服务端相应的函数。</p><p>例如，我们在服务端实现并注册了函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryUser</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span> &#123;</span><br><span class="line">... <span class="comment">// queryUser 的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端，我们就可以通过一个 queryUser 函数的原型来获得其能力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(User, error)</span> // <span class="title">query</span> 是 <span class="title">queryUser</span> 的原型</span></span><br><span class="line">client.Call(<span class="string">&quot;queryUser&quot;</span>, &amp;query) <span class="comment">// “拿到”远程的 queryUser 函数</span></span><br><span class="line">u, err := query(<span class="number">1</span>) <span class="comment">// 像调用本地函数一样去使用来自远程的函数</span></span><br></pre></td></tr></table></figure><p>如果对反射不太熟悉，难以理解代码实现的话，这里可能有点迷。再来看一个具体调用的例子吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc_test.go</span></span><br><span class="line"><span class="keyword">package</span> rpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// User  测试用的用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// queryUser 模拟查询用户的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryUser</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Fake data</span></span><br><span class="line">user := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]User)</span><br><span class="line">user[<span class="number">0</span>] = User&#123;Name: <span class="string">&quot;Foo&quot;</span>, Age: <span class="number">12</span>&#125;</span><br><span class="line">user[<span class="number">1</span>] = User&#123;Name: <span class="string">&quot;Bar&quot;</span>, Age: <span class="number">13</span>&#125;</span><br><span class="line">user[<span class="number">2</span>] = User&#123;Name: <span class="string">&quot;Joe&quot;</span>, Age: <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fake query</span></span><br><span class="line"><span class="keyword">if</span> u, ok := user[uid]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> User&#123;&#125;, fmt.Errorf(<span class="string">&quot;user wiht id %d is not exist&quot;</span>, uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRPC</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">gob.Register(User&#123;&#125;) <span class="comment">// gob 编码要注册一下才能编码结构体</span></span><br><span class="line"></span><br><span class="line">addr := <span class="string">&quot;:8080&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">srv := NewServer()</span><br><span class="line">srv.Register(<span class="string">&quot;queryUser&quot;</span>, queryUser)</span><br><span class="line"><span class="keyword">go</span> srv.ListenAndServe(addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">cli := NewClient(conn)</span><br><span class="line"><span class="keyword">var</span> query <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span></span><br><span class="line">cli.Call(<span class="string">&quot;queryUser&quot;</span>, &amp;query)</span><br><span class="line"></span><br><span class="line">u, err := query(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestRPC</code> 中模拟了服务端以及客户端调用 RPC 服务。</p><p>至此，一个完整的玩具版 RPC 就完成了，自己来写这东西还是挺有意思。完整的代码我放到了这个 Gist 里 <a href="https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f">cdfmlr/toy-rpc-golang</a>：</p><ul><li><a href="https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f">https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f</a></li></ul><script src="https://gist.github.com/cdfmlr/a1e275959eb06e5335fcafb7285eb82f.js"></script><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">By(<span class="string">&quot;CDFMLR&quot;</span>, <span class="string">&quot;2020-09-12&quot;</span>)</span><br><span class="line"><span class="comment">// See you.💪</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin入门</title>
      <link href="/2020/09/03/blog/Gin_quick_start/"/>
      <url>/2020/09/03/blog/Gin_quick_start/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin-入门"><a href="#Gin-入门" class="headerlink" title="Gin 入门"></a>Gin 入门</h1><p>用 Go 好久了，也写了好几个小 Web 服务，基本都是在用标准库的 <code>net/http</code> + <code>database/sql</code>，其实开发难度、性能都还不错啦。写的多了还是觉得用标准库有些部分代码重复性还是很高的，慢慢地自己总结出一些通用的“框架”，但不成熟，问题很多。所以开始学一些成熟的框架，之前我开始用 Gorm 简化数据库这方面的流程，这次是考虑学一个 Web 框架啦—— Gin 足够简洁，使用的也比较广泛，所以就它了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>下载安装 Gin 包：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><ol start="2"><li>在代码中导入：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>(可选)如果要使用诸如 <code>http.StatusOK</code> 的常量，还要导入 <code>net/http</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br></pre></td></tr></table></figure><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>首先，创建一个文件 <code>example.go</code>，接下来的代码就写在这个文件里：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch example.go</span><br></pre></td></tr></table></figure><p>编辑文件，写代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default() <span class="comment">// r 是 router 的意思</span></span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run example.go</span><br></pre></td></tr></table></figure><p>然后就可以在浏览器里访问 <code> 0.0.0.0:8080/ping</code> 了。可以看到返回的 pong，以及终端输出的精美日志。</p><hr><p>在这个 Ping-Pong 程序里，我们使用 <code>gin.Default</code> 来生成一个框架的实例（称为 Engine）。Default 生成的 Engine 里包括了默认的 Logger 和 Recovery 中间件。Engine “继承”了 RouterGroup，所以可以直接往里面添加路由：</p><p><code>r.GET(&#39;/url&#39;, handlerFunc)</code> 声明一个路由。GET 访问 URL 触发 handlerFunc 函数，这个函数（属于函数类型<code>type HandlerFunc func(*Context)</code>）响应请求，这里用<code>c.JSON</code> 返回一个 <code>application/json</code>  的响应。</p><p><code>r.Run()</code> 让 Engine 跑起来，默认的服务地址是 <code>:8080</code>，可以用 <code>r.Run(&quot;:9999&quot;)</code> 来自定义。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>Ping-Pong 程序的例子里，已经展现了固定路径、无参数的 GET 请求路由。除了 <code>r.GET</code>，还可以在 <code>r.</code> 后面使用 <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>OPTIONS</code> 以及 <code>Any</code> 来添加各种请求类型的路由。</p><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>路径参数可以实现动态路由。</p><ul><li><code>/user/:name</code> 匹配 <code>/user/xxx</code></li></ul><p>例如，我们希望对不同的用户访问 <code>/user/foo</code>、<code>/user/bar</code>。则可以使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;Hello, %s&quot;</span>, name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl 0.0.0.0:8080/user/foobar</span><br><span class="line">Hello, foobar</span><br><span class="line">$ curl 0.0.0.0:8080/user/foobar/</span><br><span class="line">&lt;a href=<span class="string">&quot;/user/foobar&quot;</span>&gt;Moved Permanently&lt;/a&gt;.</span><br><span class="line">$ curl 0.0.0.0:8080/user/</span><br><span class="line">404 page not found</span><br></pre></td></tr></table></figure><ul><li><code>/user/:name/*action</code>  匹配 <code>/user/xxx/</code> 以及 <code>/user/xxx/yyy/...</code>;</li></ul><p>要匹配 <code>/user/:name/...</code>，使用如下玩法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    action := c.Param(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">    message := name + <span class="string">&quot; is &quot;</span> + action</span><br><span class="line">    c.String(http.StatusOK, message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl 0.0.0.0:8080/user/foobar/</span><br><span class="line">foobar is /</span><br><span class="line">$ curl 0.0.0.0:8080/user/foobar/doing/something</span><br><span class="line">foobar is /doing/something</span><br></pre></td></tr></table></figure><blockquote><p>P.S. For each matched request Context will hold the route </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.POST(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.FullPath() == <span class="string">&quot;/user/:name/*action&quot;</span> <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li>外部的重定向，使用 Redirect 通知浏览器去重定向：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET 用 301 Moved Permanently</span></span><br><span class="line">r.GET(<span class="string">&quot;/tobaidu&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// POST 用 302 Found</span></span><br><span class="line">r.POST(<span class="string">&quot;toping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusFound, <span class="string">&quot;/ping&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i <span class="string">&#x27;0.0.0.0:8080/tobaidu&#x27;</span></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Location: https://www.baidu.com</span><br><span class="line">Date: Fri, 04 Sep 2020 13:23:35 GMT</span><br><span class="line">Content-Length: 56</span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;Moved Permanently&lt;/a&gt;.</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i <span class="string">&#x27;0.0.0.0:8080/toping&#x27;</span> -X POST</span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: /ping</span><br><span class="line">Date: Fri, 04 Sep 2020 13:23:56 GMT</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><ul><li>内部的重定向，把请求的 Path 硬改了然后重新处理：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Request.URL.Path = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i <span class="string">&#x27;0.0.0.0:8080/test&#x27;</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Fri, 04 Sep 2020 13:24:41 GMT</span><br><span class="line">Content-Length: 17</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">defaultHandler := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;endpoint&quot;</span>: c.FullPath(),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v1.GET(<span class="string">&quot;/hello&quot;</span>, defaultHandler)</span><br><span class="line">    v1.POST(<span class="string">&quot;/login&quot;</span>, defaultHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v2.GET(<span class="string">&quot;/hello&quot;</span>, defaultHandler)</span><br><span class="line">    v2.POST(<span class="string">&quot;/login&quot;</span>, defaultHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>P.S. 这里的大括号是代表把其中的内容看作一个单独的语句块（独立的作用域）。</p></blockquote><p>Gin 会自动给分组的路由变成 <code>/v1/...</code> 这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET    &#x2F;v1&#x2F;hello</span><br><span class="line">POST   &#x2F;v1&#x2F;login</span><br><span class="line">GET    &#x2F;v2&#x2F;hello</span><br><span class="line">POST   &#x2F;v2&#x2F;login</span><br></pre></td></tr></table></figure><p>调用测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/v1/hello&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;endpoint&quot;</span>:<span class="string">&quot;/v1/hello&quot;</span>&#125;</span><br><span class="line">$ curl -X POST <span class="string">&#x27;0.0.0.0:8080/v2/login&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;endpoint&quot;</span>:<span class="string">&quot;/v2/login&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h2><h3 id="Querystring-参数"><a href="#Querystring-参数" class="headerlink" title="Querystring 参数"></a>Querystring 参数</h3><p>GET 请求中，我们常用 Querystring 即 <code>http://example.com/welcome?firstname=Jane&amp;lastname=Doe</code> 的这种查询方式。</p><p>使用 <code>context.Query()</code> 来获取参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    firstname := c.DefaultQuery(<span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;Guest&quot;</span>)</span><br><span class="line">    lastname := c.Query(<span class="string">&quot;lastname&quot;</span>)</span><br><span class="line">    <span class="comment">// shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)</span></span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;Hello, %s %s&quot;</span>, firstname, lastname)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/welcome?firstname=Jane&#x27;</span></span><br><span class="line">Hello, Jane </span><br><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/welcome?lastname=Doe&#x27;</span></span><br><span class="line">Hello, Guest Doe</span><br><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/welcome?firstname=Jane&amp;lastname=Doe&#x27;</span></span><br><span class="line">Hello, Jane Doe</span><br></pre></td></tr></table></figure><h3 id="POST-Form-参数"><a href="#POST-Form-参数" class="headerlink" title="POST Form 参数"></a>POST Form 参数</h3><p>对于 POST 等请求方式，我们常用 Multipart/Urlencoded Form 来传递参数信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/form_post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    message := c.PostForm(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">    nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;anonymous&quot;</span>)</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>:  <span class="string">&quot;posted&quot;</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: message,</span><br><span class="line">        <span class="string">&quot;nick&quot;</span>:    nick,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/form_post&#x27;</span> -X POST</span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;nick&quot;</span>:<span class="string">&quot;anonymous&quot;</span>,<span class="string">&quot;status&quot;</span>:<span class="string">&quot;posted&quot;</span>&#125;</span><br><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/form_post&#x27;</span> -X POST -d <span class="string">&#x27;message=hello&amp;nick=Foobar&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;nick&quot;</span>:<span class="string">&quot;Foobar&quot;</span>,<span class="string">&quot;status&quot;</span>:<span class="string">&quot;posted&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-作为参数"><a href="#Map-作为参数" class="headerlink" title="Map 作为参数"></a>Map 作为参数</h3><p>对于使用 Map 作为参数的情况，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;post?ids[a]&#x3D;1234&amp;ids[b]&#x3D;hello HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">names[first]&#x3D;thinkerou&amp;names[second]&#x3D;tianou</span><br></pre></td></tr></table></figure><p>使用 <code>QueryMap</code> 和 <code>PostFormMap</code> 来获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">    ids := c.QueryMap(<span class="string">&quot;ids&quot;</span>)</span><br><span class="line">    names := c.PostFormMap(<span class="string">&quot;names&quot;</span>)</span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;ids: %v; names: %v&quot;</span>,  ids, names)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -g <span class="string">&#x27;http://0.0.0.0:8080/post?ids[a]=1234&amp;ids[b]=hello&#x27;</span> -X POST -d <span class="string">&#x27;names[first]=thinkerou&amp;names[second]=tianou&#x27;</span></span><br><span class="line">ids: map[a:1234 b:hello]; names: map[first:thinkerou second:tianou]</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>在上传文件的时候，如果需要，可以设置一个较低的 multipart forms 内存限制（默认是 32 MiB）。</p><p>注意，这个只是限制在上传时程序可以使用的内存，并不是限制上传文件的大小！See <a href="https://stackoverflow.com/questions/56143325/gin-web-framework-limit-upload-file-size-not-working">Stackoverflow: gin web framework limit upload file size not working</a>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">r.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br></pre></td></tr></table></figure><h4 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload/single&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    file, err := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.String(http.StatusBadRequest, <span class="string">&quot;get form err: %s&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    filename := filepath.Base(file.Filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := c.SaveUploadedFile(file, filepath.Join(<span class="string">&quot;./upload&quot;</span>, filename)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.String(http.StatusBadRequest, <span class="string">&quot;upload file err: %s&quot;</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;File %s uploaded successfully&quot;</span>, filename)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>⚠️注意，不要直接用 <code>file.Filename</code>，详见 <a href="https://github.com/gin-gonic/gin/issues/1693">Gin Issue #1693</a>。</p><p>使用 curl 测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST <span class="string">&#x27;0.0.0.0:8080/upload/single&#x27;</span> \</span><br><span class="line">-F <span class="string">&quot;file=@/Users/c/Desktop/test.png&quot;</span> \</span><br><span class="line">-H <span class="string">&quot;Content-Type: multipart/form-data&quot;</span></span><br><span class="line">File test.png uploaded successfully</span><br></pre></td></tr></table></figure><h4 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload/multiple&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    form, _ := c.MultipartForm()</span><br><span class="line">    files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">        filename := filepath.Base(file.Filename)</span><br><span class="line">        c.SaveUploadedFile(file, filepath.Join(<span class="string">&quot;./upload&quot;</span>, filename))</span><br><span class="line">        log.Println(<span class="string">&quot;upload: &quot;</span>, filename)</span><br><span class="line">    &#125;</span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异常处理参考“单个文件”部分的代码，这里略了。</p><p>测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;0.0.0.0:8080/upload/multiple&#x27;</span> -X POST \</span><br><span class="line">-F <span class="string">&quot;upload[]=@/Users/c/Desktop/test1.png&quot;</span> \</span><br><span class="line">-F <span class="string">&quot;upload[]=@/Users/c/Desktop/test2.png&quot;</span> \</span><br><span class="line">-H <span class="string">&quot;Content-Type: multipart/form-data&quot;</span></span><br><span class="line">2 files uploaded!</span><br></pre></td></tr></table></figure><h2 id="响应渲染"><a href="#响应渲染" class="headerlink" title="响应渲染"></a>响应渲染</h2><h3 id="JSON-XML-YAML"><a href="#JSON-XML-YAML" class="headerlink" title="JSON, XML, YAML"></a>JSON, XML, YAML</h3><p>前面我们已经用过好几次 JSON 了。XML、YAML 和 JSON 很类似，调用对应的方法，传入状态码以及结果信息的结构体即可写入响应：</p><ul><li>JSON：<code>func (c *Context) JSON(code int, obj interface&#123;&#125;)</code></li><li>XML：<code>func (c *Context) XML(code int, obj interface&#123;&#125;)</code></li><li>YAML：<code>func (c *Context) YAML(code int, obj interface&#123;&#125;)</code></li></ul><p>对于一般简单的内容，可以使用 <code>gin.H</code> 来表示数据。<code>gin.H</code> 是 <code> map[string]interface&#123;&#125;</code> 的简写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;hey&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/someXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.XML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;hey&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/someYAML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.YAML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;hey&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于复杂的情况，也可以使用 <code>struct</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name    <span class="keyword">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">        Message <span class="keyword">string</span></span><br><span class="line">        Number  <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    msg.Name = <span class="string">&quot;Lena&quot;</span></span><br><span class="line">    msg.Message = <span class="string">&quot;hey&quot;</span></span><br><span class="line">    msg.Number = <span class="number">123</span></span><br><span class="line">    <span class="comment">// Note that msg.Name becomes &quot;user&quot; in the JSON</span></span><br><span class="line">    <span class="comment">// Will output  :   &#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;</span></span><br><span class="line">    c.JSON(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于 JSON，Gin 还提供各种需求的 <a href="https://github.com/gin-gonic/gin#securejson">SecureJSON</a>，<a href="https://github.com/gin-gonic/gin#jsonp">JSONP</a>，<a href="https://github.com/gin-gonic/gin#asciijson">AsciiJSON</a>，<a href="https://github.com/gin-gonic/gin#purejson">PureJSON</a>。</p><h3 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h3><p>Gin 还可以直接渲染 ProtoBuf：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someProtoBuf&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    reps := []<span class="keyword">int64</span>&#123;<span class="keyword">int64</span>(<span class="number">1</span>), <span class="keyword">int64</span>(<span class="number">2</span>)&#125;</span><br><span class="line">    label := <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="comment">// The specific definition of protobuf is written in the testdata/protoexample file.</span></span><br><span class="line">    data := &amp;protoexample.Test&#123;</span><br><span class="line">        Label: &amp;label,</span><br><span class="line">        Reps:  reps,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note that data becomes binary data in the response</span></span><br><span class="line">    <span class="comment">// Will output protoexample.Test protobuf serialized data</span></span><br><span class="line">    c.ProtoBuf(http.StatusOK, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>读取模版 HTML 文件：</p><ul><li> <code>func (engine *Engine) LoadHTMLGlob(pattern string)</code></li><li><code>func (engine *Engine) LoadHTMLFiles(files ...string)</code></li></ul><p>渲染 HTML，写入响应：</p><ul><li><code>func (c *Context) HTML(code int, name string, obj interface&#123;&#125;)</code> 其中 name 是模版文件路径，obj 是要填充的数据。</li></ul><p>默认渲染用的是和标准库一样的模版，详见 <a href="https://golang.org/pkg/text/template/">text/template</a> 和 <a href="https://golang.org/pkg/html/template/">html/template</a>。</p><p>E.g.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line"><span class="comment">//router.LoadHTMLFiles(&quot;templates/template1.html&quot;, &quot;templates/template2.html&quot;)</span></span><br><span class="line">router.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;Main website&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>templates/index.tmpl</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;&#123; .title &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有好多高级用法，我不太用这东西，去看文档吧：<a href="https://github.com/gin-gonic/gin#html-rendering">gin#html-rendering</a>。</p><h2 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h2><h3 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h3><p>Serving static files</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">    </span><br><span class="line">router.Static(<span class="string">&quot;/assets&quot;</span>, <span class="string">&quot;./assets&quot;</span>)</span><br><span class="line">router.StaticFS(<span class="string">&quot;/more_static&quot;</span>, http.Dir(<span class="string">&quot;my_file_system&quot;</span>))</span><br><span class="line">router.StaticFile(<span class="string">&quot;/favicon.ico&quot;</span>, <span class="string">&quot;./resources/favicon.ico&quot;</span>)</span><br><span class="line"></span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Static(relativePath, root string)</code>：在 root 路径处开静态文件服务。</li><li><code>StaticFS(relativePath string, fs http.FileSystem)</code>：类似 <code>Static()</code>，但可以用 <code>http.FileSystem</code>。</li><li><code>StaticFile(relativePath, filepath string)</code>：注册服务单个文件。</li></ul><h3 id="文件数据服务"><a href="#文件数据服务" class="headerlink" title="文件数据服务"></a>文件数据服务</h3><p>Serving data from file，就是把文件写入响应啦。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/local/file&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.File(<span class="string">&quot;local/file.go&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs http.FileSystem = <span class="comment">// ...</span></span><br><span class="line">router.GET(<span class="string">&quot;/fs/file&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.FileFromFS(<span class="string">&quot;fs/file.go&quot;</span>, fs)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-Reader-数据响应"><a href="#用-Reader-数据响应" class="headerlink" title="用 Reader 数据响应"></a>用 Reader 数据响应</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.GET(<span class="string">&quot;/someDataFromReader&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">response, err := http.Get(<span class="string">&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || response.StatusCode != http.StatusOK &#123;</span><br><span class="line">c.Status(http.StatusServiceUnavailable)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader := response.Body</span><br><span class="line">contentLength := response.ContentLength</span><br><span class="line">contentType := response.Header.Get(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line"></span><br><span class="line">extraHeaders := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Content-Disposition&quot;</span>: <span class="string">`attachment; filename=&quot;gopher.png&quot;`</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模型绑定"><a href="#模型绑定" class="headerlink" title="模型绑定"></a>模型绑定</h2><p>日常的开发中，把请求体中的内容放到一个结构体里，并验证给的信息是否完整是很常用的功能。Gin 提供模型绑定(model binding)来完成这一功能。模型绑定可以把 Form 值、JSON、XML、YAML 形式的数据绑定到 Go 的结构体。</p><p>Gin 提供两套绑定的方法：<code>Bind</code> 和 <code>ShouldBind</code>。<code>Bind</code> 在绑定出错时把 400 aborted 写入响应（<code>c.AbortWithError(400, err).SetType(ErrorTypeBind)</code>）。<code>ShouldBind</code> 在绑定失败时返回一个错误，我们需要手动去处理错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User <span class="keyword">string</span> <span class="string">`form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example for binding JSON:</span></span><br><span class="line"><span class="comment">//     &#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;</span></span><br><span class="line">router.POST(<span class="string">&quot;/loginJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> json Login</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;json); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> json.User != <span class="string">&quot;manu&quot;</span> || json.Password != <span class="string">&quot;123&quot;</span> &#123;</span><br><span class="line">c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;unauthorized&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;you are logged in&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example for binding XML:</span></span><br><span class="line"><span class="comment">//     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">//     &lt;root&gt;</span></span><br><span class="line"><span class="comment">//         &lt;user&gt;manu&lt;/user&gt;</span></span><br><span class="line"><span class="comment">//         &lt;password&gt;123&lt;/password&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/root&gt;</span></span><br><span class="line">router.POST(<span class="string">&quot;/loginXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> xml Login</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindXML(&amp;xml); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> xml.User != <span class="string">&quot;manu&quot;</span> || xml.Password != <span class="string">&quot;123&quot;</span> &#123;</span><br><span class="line">c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;unauthorized&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;you are logged in&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example for binding a HTML form:</span></span><br><span class="line"><span class="comment">//     user=manu&amp;password=123</span></span><br><span class="line">router.POST(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> form Login</span><br><span class="line"><span class="comment">// This will infer what binder to use depending on the content-type header.</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;form); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> form.User != <span class="string">&quot;manu&quot;</span> || form.Password != <span class="string">&quot;123&quot;</span> &#123;</span><br><span class="line">c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;unauthorized&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;you are logged in&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -X POST \</span><br><span class="line">  http://localhost:8080/loginJSON \</span><br><span class="line">  -H <span class="string">&#x27;content-type: application/json&#x27;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123; &quot;user&quot;: &quot;manu&quot; &#125;&#x27;</span></span><br><span class="line">&gt; POST /loginJSON HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; content-type: application/json</span><br><span class="line">&gt; Content-Length: 18</span><br><span class="line">&gt; </span><br><span class="line">* upload completely sent off: 18 out of 18 bytes</span><br><span class="line">&lt; HTTP/1.1 400 Bad Request</span><br><span class="line">&lt; Content-Type: application/json; charset=utf-8</span><br><span class="line">&lt; Date: Sun, 06 Sep 2020 13:04:57 GMT</span><br><span class="line">&lt; Content-Length: 100</span><br><span class="line">&lt; </span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;Key: &#x27;Login.Password&#x27; Error:Field validation for &#x27;Password&#x27; failed on the &#x27;required&#x27; tag&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>注意在 <code>/loginForm</code> 里面用了 <code>ShouldBind</code>，这个会自动通过 content-type 来判断你请求用的是 Form、JSON、XML、YAML 的哪一种，然后用对应的 <code>ShouldBindXXXX</code> 把请求的内容绑定到结构体。</p><p>在结构体的定义中，要使用 tag 来指定字段在各种需要的 格式中的名字，并且制定是否必须绑定：</p><ul><li><code>binding:&quot;required&quot;</code> 则必须绑定，如果请求中没有对应的项则返回错误。</li><li><code>binding:&quot;-&quot;</code>：可选，请求中没有不会报错。</li></ul><p>Gin 是使用 <code>github.com/go-playground/validator/v10</code>  来完成验证的。这个包提供更复杂的验证功能：</p><blockquote><p>(Emmmm，学不动了，但感觉这个特别有用，从文档直接抄下来了)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Booking contains binded and validated data.</span></span><br><span class="line"><span class="keyword">type</span> Booking <span class="keyword">struct</span> &#123;</span><br><span class="line">CheckIn  time.Time <span class="string">`form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;`</span></span><br><span class="line">CheckOut time.Time <span class="string">`form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn&quot; time_format:&quot;2006-01-02&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bookableDate validator.Func = <span class="function"><span class="keyword">func</span><span class="params">(fl validator.FieldLevel)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">date, ok := fl.Field().Interface().(time.Time)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">today := time.Now()</span><br><span class="line"><span class="keyword">if</span> today.After(date) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">route := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">v.RegisterValidation(<span class="string">&quot;bookabledate&quot;</span>, bookableDate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">route.GET(<span class="string">&quot;/bookable&quot;</span>, getBookable)</span><br><span class="line">route.Run(<span class="string">&quot;:8085&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBookable</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b Booking</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindWith(&amp;b, binding.Query); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Booking dates are valid!&quot;</span>&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&quot;localhost:8085/bookable?check_in=2030-04-16&amp;check_out=2030-04-17&quot;</span></span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Booking dates are valid!&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">$ curl <span class="string">&quot;localhost:8085/bookable?check_in=2030-03-10&amp;check_out=2030-03-09&quot;</span></span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;Key: &#x27;Booking.CheckOut&#x27; Error:Field validation for &#x27;CheckOut&#x27; failed on the &#x27;gtfield&#x27; tag&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">$ curl <span class="string">&quot;localhost:8085/bookable?check_in=2000-03-09&amp;check_out=2000-03-10&quot;</span></span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;Key: &#x27;Booking.CheckIn&#x27; Error:Field validation for &#x27;CheckIn&#x27; failed on the &#x27;bookabledate&#x27; tag&quot;</span>&#125;%    </span><br></pre></td></tr></table></figure><p>Gin 还提供很多其他的关于绑定的功能，比如路径参数的绑定、上传文件的绑定、HTML 复选框的绑定等等。详细的看文档吧：<a href="https://github.com/gin-gonic/gin#model-binding-and-validation">gin#model-binding-and-validation</a>。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>之前我们都是用 <code>r = gin.Default()</code> 来实例化 Gin 的，这样搞出来的 r 是自带 Logger 和 Recovery 中间件的，要创建一个全新的，没有中间件的实例，使用 <code>New</code> 来替换 <code>Default</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := gin.New()</span><br></pre></td></tr></table></figure><p>通过 <code>r.Use(中间件())</code> 来添加中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Creates a router without any middleware by default</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Global middleware</span></span><br><span class="line"><span class="comment">// Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE=release.</span></span><br><span class="line"><span class="comment">// By default gin.DefaultWriter = os.Stdout</span></span><br><span class="line">r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recovery middleware recovers from any panics and writes a 500 if there was one.</span></span><br><span class="line">r.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per route middleware, you can add as many as you desire.</span></span><br><span class="line">r.GET(<span class="string">&quot;/benchmark&quot;</span>, MyBenchLogger(), benchEndpoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authorization group</span></span><br><span class="line"><span class="comment">// authorized := r.Group(&quot;/&quot;, AuthRequired())</span></span><br><span class="line"><span class="comment">// exactly the same as:</span></span><br><span class="line">authorized := r.Group(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="comment">// per group middleware! in this case we use the custom created</span></span><br><span class="line"><span class="comment">// AuthRequired() middleware just in the &quot;authorized&quot; group.</span></span><br><span class="line">authorized.Use(AuthRequired())</span><br><span class="line">&#123;</span><br><span class="line">authorized.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">authorized.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">authorized.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested group</span></span><br><span class="line">testing := authorized.Group(<span class="string">&quot;testing&quot;</span>)</span><br><span class="line">testing.GET(<span class="string">&quot;/analytics&quot;</span>, analyticsEndpoint)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。</p><p>写不动了，了解更多 Gin 请到 <a href="https://github.com/gin-gonic/gin">gin 的 readme</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之GAN</title>
      <link href="/2020/08/24/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_5/"/>
      <url>/2020/08/24/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_5/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第8章  生成式深度学习</strong> (Chapter 8. <em>Generative deep learning</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="8-5-Introduction-to-generative-adversarial-networks"><a href="#8-5-Introduction-to-generative-adversarial-networks" class="headerlink" title="8.5 Introduction to generative adversarial networks"></a>8.5 Introduction to generative adversarial networks</h2><blockquote><p>生成式对抗网络简介</p></blockquote><p>GAN，中文是<del>淦</del>，错了，生成式对抗网络(Generative Adversarial Network)。和 VAE 一样，是用来学习图像的潜在空间的。这东西可以使生成图像与真实图像“在统计上”别无二致，说人话就是，生成的图像相当逼真。但与 VAE 不同，GAN 的潜在空间无法保证具有有意义的结构，并且是不连续的。</p><p>GAN 由两部分组成：</p><ul><li>生成器网络(generator network)：输入一个随机向量(潜在空间中的一个随机点)，并将其解码为图像。</li><li>判别器网络(discriminator network)：输入一张图像(真实的或生成器画的)，预测该图像是真实的还是由生成器网络创建的。（判别器网络也叫「对手」，adversary）</li></ul><p>训练 GAN 的目的是使「生成器网络」能够欺骗「判别器网络」。</p><p>直观理解 GAN 是一个很励志的故事：就是说有两个人，一个伪造者，一个鉴定师。伪造者仿造大师的画，然后把自己的仿制品混在真迹里交给鉴定师鉴定，鉴定师评估每一幅画的真伪，一样看穿了哪些是伪造的。好心的鉴定师反馈了伪造者，告诉他真迹有哪些特征。伪造者根据鉴定师的意见，一步步提升自己的仿造能力。两人不厌其烦地重复这个过程，伪造者变得越来越擅长复制大师的画，鉴定师也越来越擅长找出假画。到最后，伪造者造出了一批鉴定师也无可挑剔的“仿制正品”。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghva0rve82j31ec0tcthm.jpg" alt="生成器将随机潜在向量转换成图像，判别器试图分辨真实图像与生成图像。生成器的训练是为了欺骗判别器"></p><p>GAN 的训练方式很特殊，它的优化最小值是不固定的。我们通常的「梯度下降」是沿着静态的损失地形滚下山，但 GAN 训练时每下山一步都会对整个地形造成改变。它是一个动态系统，其最优化过程是两股力量之间的平衡。所以，GAN 很难训练。想要让 GAN 正常运行，需要进行大量的模型构建、超参数调节工作。</p><h3 id="深度卷积生成式对抗网络"><a href="#深度卷积生成式对抗网络" class="headerlink" title="深度卷积生成式对抗网络"></a>深度卷积生成式对抗网络</h3><p>我们来尝试用 Keras 实现最最最简单的 GAN。具体来说，我们会做一个<strong>深度卷积生成式对抗网络</strong>（deep convolutional GAN，DCGAN），这种东西的生成器和判别器都是深度卷积神经网络。</p><p>我们将用 CIFAR10 数据集中“frog”类别的图像训练 DCGAN。这个数据集包含 50000 张 32×32 的 RGB 图像，这些图像属于 10 个类别(每个类别 5000 张图像)。</p><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><ol><li><code>generator</code> 网络将形状为 <code>(latent_dim,)</code> 的向量映射到形状为 <code>(32, 32, 3)</code> 的图像。</li><li><code>discriminator</code> 网络将形状为 <code>(32, 32, 3)</code> 的图像映射到一个二进制得分(a binary score)，用于评估图像为真的概率。</li><li><code>gan</code> 网络将 <code>generator</code> 和 <code>discriminator</code> 连接在一起: <code>gan(x) = discriminator(generator(x))</code>。这个网络是将潜在向量映射到判别器的评估结果。</li><li>使用带有 <code>&quot;real&quot;</code> 或 <code>&quot;fake&quot;</code> 标签的真假图像样本来训练判别器，用常规训练普通的图像分类模型的方法。</li><li>为了训练生成器，使用 <code>gan</code> 模型的损失相对于生成器权重的梯度。在每一步都要向「让判别器更有可能将生成器解码的图像划分为“真”」移动生成器的权重，即训练生成器来欺骗判别器。</li></ol><h4 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h4><p>训练和调节 GAN 的过程非常困难。所以我们需要记住一些前人总结出的实用技巧。这些技巧一般很有用，但并不能适用于所有情况。这些东西都没有理论依据，都是玄学，所以不解释直接写结论：</p><ul><li>使用 tanh 作为生成器最后一层的激活，而不用 sigmoid。</li><li>使用正态分布(高斯分布)对潜在空间中的点进行采样，而不用均匀分布。</li><li>随机性能够提高稳健性。GAN 训练时可能以各种方式“卡住”(达到错误的动态平衡)，在训练过程中引入随机性有助于防止出现这种情况，引入随机性的方式有两种：<ol><li>在判别器中使用 dropout;</li><li>向判别器的标签添加随机噪声;</li></ol></li><li>稀疏的梯度会妨碍 GAN 的训练。「最大池化运算」和 「ReLU 激活」可能导致梯度稀疏，所以推荐：<ol><li>使用「步进卷积」代替「最大池化」来进行下采样;</li><li>使用 LeakyReLU 层来代替 ReLU 激活;</li></ol></li><li>在生成的图像中，常会见到棋盘状伪影，这是由于生成器中像素空间覆盖不均匀。解决这个问题的办法是：每当在生成器和判别器中都使用步进 Conv2DTranpose 或 Conv2D 时，内核大小要能够被步幅整除。</li></ul><p>由于步幅大小和内核大小不匹配而导致的棋盘状伪影示例图:</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghvayd7ipwj31560ggazl.jpg" alt="由于步幅大小和内核大小不匹配而导致的棋盘状伪影"></p><h4 id="生成器的实现"><a href="#生成器的实现" class="headerlink" title="生成器的实现"></a>生成器的实现</h4><p>开始构建年轻人的第一个 GAN 了！！</p><p>首先开发 generator 模型：将来自潜在空间的向量转换为一张候选图像。</p><p>为了避免训练时“卡住”，在判别器和生成器中都使用 dropout。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GAN 生成器网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">height = <span class="number">32</span></span><br><span class="line">width = <span class="number">32</span></span><br><span class="line">channels = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">latent_dim = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">generator_input = keras.Input(shape=(latent_dim,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入转换为大小为 16×16 的 128 个通道的特征图</span></span><br><span class="line">x = layers.Dense(<span class="number">128</span> * <span class="number">16</span> * <span class="number">16</span>)(generator_input)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line">x = layers.Reshape((<span class="number">16</span>, <span class="number">16</span>, <span class="number">128</span>))(x)</span><br><span class="line"></span><br><span class="line">x = layers.Conv2D(<span class="number">256</span>, <span class="number">5</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上采样为 32×32</span></span><br><span class="line">x = layers.Conv2DTranspose(<span class="number">256</span>, <span class="number">4</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line">x = layers.Conv2D(<span class="number">256</span>, <span class="number">5</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line">x = layers.Conv2D(<span class="number">256</span>, <span class="number">5</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成大小为 32×32 的特征图(CIFAR10 图像的形状)</span></span><br><span class="line">x = layers.Conv2D(channels, <span class="number">7</span>, activation=<span class="string">&#x27;tanh&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">generator = keras.models.Model(generator_input, x)</span><br><span class="line">generator.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;functional_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================input_1 (InputLayer)         [(None, 32)]              0         _________________________________________________________________dense (Dense)                (None, 32768)             1081344   _________________________________________________________________leaky_re_lu (LeakyReLU)      (None, 32768)             0         _________________________________________________________________reshape (Reshape)            (None, 16, 16, 128)       0         _________________________________________________________________conv2d (Conv2D)              (None, 16, 16, 256)       819456    _________________________________________________________________leaky_re_lu_1 (LeakyReLU)    (None, 16, 16, 256)       0         _________________________________________________________________conv2d_transpose (Conv2DTran (None, 32, 32, 256)       1048832   _________________________________________________________________leaky_re_lu_2 (LeakyReLU)    (None, 32, 32, 256)       0         _________________________________________________________________conv2d_1 (Conv2D)            (None, 32, 32, 256)       1638656   _________________________________________________________________leaky_re_lu_3 (LeakyReLU)    (None, 32, 32, 256)       0         _________________________________________________________________conv2d_2 (Conv2D)            (None, 32, 32, 256)       1638656   _________________________________________________________________leaky_re_lu_4 (LeakyReLU)    (None, 32, 32, 256)       0         _________________________________________________________________conv2d_3 (Conv2D)            (None, 32, 32, 3)         37635     =================================================================Total params: 6,264,579Trainable params: 6,264,579Non-trainable params: 0_________________________________________________________________</code></pre><h4 id="判别器的实现"><a href="#判别器的实现" class="headerlink" title="判别器的实现"></a>判别器的实现</h4><p>接下来，开发 discriminator 模型，输入一张图像(真实的或合成的)，将其划分为「真」（来自训练集的真实图像）或「假」（生成器画的图像）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GAN 判别器网络</span></span><br><span class="line"></span><br><span class="line">discriminator_input = layers.Input(shape=(height, width, channels))</span><br><span class="line"></span><br><span class="line">x = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>)(discriminator_input)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line">x = layers.Conv2D(<span class="number">128</span>, <span class="number">4</span>, strides=<span class="number">2</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line">x = layers.Conv2D(<span class="number">128</span>, <span class="number">4</span>, strides=<span class="number">2</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line">x = layers.Conv2D(<span class="number">128</span>, <span class="number">4</span>, strides=<span class="number">2</span>)(x)</span><br><span class="line">x = layers.LeakyReLU()(x)</span><br><span class="line"></span><br><span class="line">x = layers.Flatten()(x)</span><br><span class="line">x = layers.Dropout(<span class="number">0.4</span>)(x)</span><br><span class="line"></span><br><span class="line">x = layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">discriminator = keras.models.Model(discriminator_input, x)</span><br><span class="line">discriminator.summary()</span><br><span class="line"></span><br><span class="line">discriminator_optimizer = keras.optimizers.RMSprop(</span><br><span class="line">    lr=<span class="number">0.0008</span>,</span><br><span class="line">    clipvalue=<span class="number">1.0</span>,</span><br><span class="line">    decay=<span class="number">1e-8</span>)</span><br><span class="line"></span><br><span class="line">discriminator.<span class="built_in">compile</span>(optimizer=discriminator_optimizer,</span><br><span class="line">                      loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;functional_3&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================input_2 (InputLayer)         [(None, 32, 32, 3)]       0         _________________________________________________________________conv2d_4 (Conv2D)            (None, 30, 30, 128)       3584      _________________________________________________________________leaky_re_lu_5 (LeakyReLU)    (None, 30, 30, 128)       0         _________________________________________________________________conv2d_5 (Conv2D)            (None, 14, 14, 128)       262272    _________________________________________________________________leaky_re_lu_6 (LeakyReLU)    (None, 14, 14, 128)       0         _________________________________________________________________conv2d_6 (Conv2D)            (None, 6, 6, 128)         262272    _________________________________________________________________leaky_re_lu_7 (LeakyReLU)    (None, 6, 6, 128)         0         _________________________________________________________________conv2d_7 (Conv2D)            (None, 2, 2, 128)         262272    _________________________________________________________________leaky_re_lu_8 (LeakyReLU)    (None, 2, 2, 128)         0         _________________________________________________________________flatten (Flatten)            (None, 512)               0         _________________________________________________________________dropout (Dropout)            (None, 512)               0         _________________________________________________________________dense_1 (Dense)              (None, 1)                 513       =================================================================Total params: 790,913Trainable params: 790,913Non-trainable params: 0_________________________________________________________________</code></pre><h4 id="对抗网络"><a href="#对抗网络" class="headerlink" title="对抗网络"></a>对抗网络</h4><p>最后，设置 GAN，将生成器和判别器连接在一起，将潜在空间的点转换为一个真或假的分类判断。</p><p>这个模型训练时，需要将「判别器」冻结(使之不可被训练)，只让「生成器」向「提高欺骗判别器的能力」的方向移动。</p><p>训练 gan 时，我们使用的全部都是“真实图像”的标签，所以如果在训练过程中可以对「判别器」的权重进行更新，训练会使得判别器始终预测“真”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对抗网络</span></span><br><span class="line"></span><br><span class="line">discriminator.trainable = <span class="literal">False</span>    <span class="comment"># 这个只会作用于 gan</span></span><br><span class="line"></span><br><span class="line">gan_input = keras.Input(shape=(latent_dim,))</span><br><span class="line">gan_output = discriminator(generator(gan_input))</span><br><span class="line">gan = keras.models.Model(gan_input, gan_output)</span><br><span class="line"></span><br><span class="line">gan_optimizer = keras.optimizers.RMSprop(</span><br><span class="line">    lr=<span class="number">0.0004</span>,</span><br><span class="line">    clipvalue=<span class="number">1.0</span>,</span><br><span class="line">    decay=<span class="number">1e-8</span>)</span><br><span class="line">gan.<span class="built_in">compile</span>(optimizer=gan_optimizer,</span><br><span class="line">            loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="训练-DCGAN"><a href="#训练-DCGAN" class="headerlink" title="训练 DCGAN"></a>训练 DCGAN</h4><p>训练循环的流程如下:</p><ol><li>从潜在空间中抽取随机的点(随机噪声)。</li><li>把这个随机噪声给 generator 生成图像。</li><li>将生成图像与真实图像混合。</li><li>使用这些混合后的图像以及相应的标签(真实图像为“真”，生成图像为“假”)来训练 discriminator。</li><li>在潜在空间中随机抽取新的点。</li><li>使用这些随机向量以及全部是「真实图像」的标签来训练gan。</li></ol><p>具体的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GAN 的训练、</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 CIFAR10 数据</span></span><br><span class="line">(x_train, y_train), (_, _) = keras.datasets.cifar10.load_data()</span><br><span class="line"><span class="comment"># 选出青蛙🐸的图片</span></span><br><span class="line">x_train = x_train[y_train.flatten() == <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">x_train = x_train.reshape(</span><br><span class="line">    (x_train.shape[<span class="number">0</span>],) + (height, width, channels)</span><br><span class="line">).astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iterations = <span class="number">10000</span></span><br><span class="line">batch_size = <span class="number">20</span></span><br><span class="line">save_dir = <span class="string">&#x27;gan_save&#x27;</span></span><br><span class="line"></span><br><span class="line">start = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(iterations+<span class="number">1</span>):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机采样潜在点</span></span><br><span class="line">    random_latent_vectors = np.random.normal(size=(batch_size, latent_dim))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成图像</span></span><br><span class="line">    generated_images = generator.predict(random_latent_vectors)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选取真实图像</span></span><br><span class="line">    stop = start + batch_size</span><br><span class="line">    real_images = x_train[start: stop]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并生成、真实图像，给出标签</span></span><br><span class="line">    combined_images = np.concatenate([generated_images, real_images])</span><br><span class="line">    labels = np.concatenate([np.ones((batch_size, <span class="number">1</span>)),</span><br><span class="line">                             np.zeros((batch_size, <span class="number">1</span>))])</span><br><span class="line">    labels += <span class="number">0.05</span> * np.random.random(labels.shape)  <span class="comment"># 向标签中添加随机噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练判别器</span></span><br><span class="line">    d_loss = discriminator.train_on_batch(combined_images, labels)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机采样潜在点</span></span><br><span class="line">    random_latent_vectors = np.random.normal(size=(batch_size, latent_dim))</span><br><span class="line">    </span><br><span class="line">    misleading_targets = np.zeros((batch_size, <span class="number">1</span>))  <span class="comment"># 谎称全部都是真实图片</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 通过 gan 模型训练生成器</span></span><br><span class="line">    a_loss = gan.train_on_batch(random_latent_vectors, misleading_targets)</span><br><span class="line">    </span><br><span class="line">    end_time = time.time()</span><br><span class="line">    </span><br><span class="line">    start += batch_size</span><br><span class="line">    <span class="keyword">if</span> start &gt; <span class="built_in">len</span>(x_train) - batch_size:</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        gan.save_weights(<span class="string">&#x27;gan.h5&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">f&#x27;step <span class="subst">&#123;step&#125;</span>: discriminator loss: <span class="subst">&#123;d_loss&#125;</span>, adversarial loss: <span class="subst">&#123;a_loss&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        img = image.array_to_img(generated_images[<span class="number">0</span>] * <span class="number">255.</span>, scale=<span class="literal">False</span>)</span><br><span class="line">        img.save(os.path.join(save_dir, <span class="string">f&#x27;generated_frog_<span class="subst">&#123;step&#125;</span>.png&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">        img = image.array_to_img(real_images[<span class="number">0</span>] * <span class="number">255.</span>, scale=<span class="literal">False</span>)</span><br><span class="line">        img.save(os.path.join(save_dir, <span class="string">f&#x27;real_frog_<span class="subst">&#123;step&#125;</span>.png&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time_cost = end_time - start_time</span><br><span class="line">        time_eta = time_cost * (iterations - step)</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;step&#125;</span>/<span class="subst">&#123;iterations&#125;</span>: <span class="subst">&#123;time_cost:<span class="number">.2</span>f&#125;</span>s - ETA: <span class="subst">&#123;time_eta:<span class="number">.0</span>f&#125;</span>s&#x27;</span>, end=<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><pre><code>step 0: discriminator loss: 0.6944685578346252, adversarial loss: 0.7566524744033813...step 500: discriminator loss: 0.7020201683044434, adversarial loss: 0.7446410059928894...step 1000: discriminator loss: 0.7096449136734009, adversarial loss: 0.752526581287384</code></pre><p>最后输出的图像：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi27n2ulptj300w00w0si.jpg" alt="最后输出的图像"></p><p>效果相当差。这个东西训练消耗太大了，又是 CPU 劝退，我只跑了 1000 轮，还太少了。。。不愧为全书最后一题，压轴，这封青蛙图我不要了。😂</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之VAE</title>
      <link href="/2020/08/23/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_4/"/>
      <url>/2020/08/23/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_4/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第8章  生成式深度学习</strong> (Chapter 8. <em>Generative deep learning</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="8-4-Generating-images-with-variational-autoencoders"><a href="#8-4-Generating-images-with-variational-autoencoders" class="headerlink" title="8.4 Generating images with variational autoencoders"></a>8.4 Generating images with variational autoencoders</h2><blockquote><p>用变分自编码器生成图像</p></blockquote><p>前两篇介绍的 DeepDream 和 Neural Style Transfer 都只是有限地“修改”现有作品。而下面我们要介绍地 GAN 和 VAE 则是更加富有创造性的，这两种技术都是从图像的潜在空间中采样，并创建全新图像或编辑现有图像。</p><ul><li>VAE：变分自编码器(Variational AutoEncoder)</li><li>GAN：生成式对抗网络(Generative Adversarial Network)</li></ul><h3 id="从潜在空间采样"><a href="#从潜在空间采样" class="headerlink" title="从潜在空间采样"></a>从潜在空间采样</h3><p>潜在空间(latent space)是一个向量空间，其中任意点都可以被映射为一张逼真的图像。而实现这种映射(潜在点-&gt;图像)的模块就是 GAN 的 generator，或者 VAE 的 decoder。</p><p>GAN、VAE 生成图像的关键就在于找到一个低维的「表示潜在空间」(latent space of representations)。一旦找到这样的潜在空间，从中采样，映射到图像空间，就可以生成全新的图像。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghut6hcq7kj317g0qyti6.jpg" alt="学习图像的潜在向量空间，并利用这个空间来采样新图像"></p><p>GAN 和 VAE 学习的潜在空间有很大的区别：</p><ul><li>VAE 善于学习具有良好结构的潜在空间，其中的特定方向可以编码(表示)数据中一个有意义的变化的轴。</li><li>GAN 生成的图像可以非常逼真，但潜在空间缺乏良好的结构、没有足够的连续性。</li></ul><h3 id="概念向量"><a href="#概念向量" class="headerlink" title="概念向量"></a>概念向量</h3><p>概念向量(concept vector)：给定一个表示的潜在空间或一个嵌入空间，空间中的特定方向可能表示原始数据中有意义的变化轴。例如对于图像，人脸图像的潜在空间中可能存在一个代表「微笑」这个概念的向量(称为微笑向量，smile vector)：对于代表某张人脸的潜在点 z，z+s 就是同一张人脸面带微笑的表示。</p><p>找到了这样的一些概念向量之后，我们就可以用这种方法来编辑图像了：将图像投射到潜在空间，和概念向量做运算来移动其表示，然后再解码到图像空间，就可以改变图像中的某一概念了——比如微笑程度：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghuynp3pb9j31880kux67.jpg" alt="微笑向量"></p><h3 id="变分自编码器"><a href="#变分自编码器" class="headerlink" title="变分自编码器"></a>变分自编码器</h3><p>自编码器是一种网络类型，接收一张图像，通过 encoder 模块将其映射到「潜在空间」，然后再通过 decoder 模块将其解码成与原始图像尺寸相同的输出。这东西训练时的目标是使输出和输入相同，所以我们把输入、输出用同一张图片。所以自编码器学习的是对原始输入进行重新构建。</p><p>通过对编码(编码器的输出)施加限制，可以让自编码器学到有用的数据潜在表示。比如限制编码要低维并且是稀疏的，这样编码器就可以将输入数据压缩为更少二进制位的信息：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghuz8fj78aj31ao0dwtbk.jpg" alt="自编码器:将输入x映射为压缩表示，然后再将其解码为x’"></p><p>变分自编码器 VAE，是一种现代化的自编码器。它是一种生成式模型，特别做利用概念向量进行图像编辑的任务。比起经典自编码器，VAE 可以学习更连续的、高度结构化的潜在空间。</p><p>VAE 不是将输入图像压缩成潜在空间中的固定编码，而是将图像转换为统计分布的参数——平均值和方差。VAE 解码的时候利用平均值和方差，从分布中随机采样一个元素，并将这个元素解码到原始输入。所以 VAE 的编码/解码过程是有一定的随机性的。</p><p>这个过程的随机性提高了 VAE 潜在空间的稳健性：VAE 需保证潜在空间采样的每个点都能解码为有效的输出，这迫使潜在空间的任何位置都对应有意义的表示。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghuzfuik3jj31bi0piah3.jpg" alt="VAE 将一张图像映射为两个向量 z_mean 和 z_log_var，二者定义了潜在 空间中的一个概率分布，用于采样一个潜在点并对其进行解码"></p><p>上图展现了 VAE 的工作原理：</p><ol><li>Encoder 模块将输入样本 <code>input_img</code> 转换为表示潜在空间中的参数 <code>z_mean</code> 和 <code>z_log_variance</code>;</li><li>从这个潜在正态分布中随机采样一个点 z: <code>z = z_mean + exp(z_log_variance) * epsilon</code>，其中 epsilon 是取值很小的随机张量;</li><li>Decoder 模块将这个潜在点映射回原始输入图像。</li></ol><p>epsilon 是随机的，所以需要与 input_img 编码的潜在位置(z-mean)靠近的每个点都能被解码为与 input_img 类似的图像，这个性质迫使潜在空间能够连续地有意义：潜在空间中任意两个相邻的点都会被解码为高度相似的图像。连续性以及潜在空间的低维度，又迫使潜在空间中的每个方向都表示数据中一个有意义的变化轴，这样就可以通过概念向量来进行操作。</p><p>用 Keras 实现 VAE 的伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z_mean, z_log_variance = encoder(input_img)</span><br><span class="line">z = z_mean + exp(z_log_variance) * epsilon</span><br><span class="line">reconstructed_img = decoder(z)</span><br><span class="line">model = Model(input_img, reconstruced_img)</span><br></pre></td></tr></table></figure><p>训练 VAE 需要两个损失函数：</p><ul><li>重构损失(reconstruction loss)：使解码后的样本匹配初始输入;</li><li>正则化损失(regularization loss)：使潜在空间具有良好结构（连续性、概念向量可用性），同时也降低在训练数据上的过拟合;</li></ul><p>我们具体实现编码器(encoder)网络：通过一个卷积神经网络，将输入图像 x 映射为两个向量 z_mean 和 z_log_var。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用及时执行模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VAE 编码器网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_shape = (<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">latent_dim = <span class="number">2</span>    <span class="comment"># 潜在空间的维度：2D平面</span></span><br><span class="line"></span><br><span class="line">input_img = keras.Input(shape=img_shape)</span><br><span class="line">x = layers.Conv2D(<span class="number">32</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(input_img)</span><br><span class="line">x = layers.Conv2D(<span class="number">64</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, strides=(<span class="number">2</span>, <span class="number">2</span>))(x)</span><br><span class="line">x = layers.Conv2D(<span class="number">64</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">x = layers.Conv2D(<span class="number">64</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">shape_before_flattening = K.int_shape(x)</span><br><span class="line"></span><br><span class="line">x = layers.Flatten()(x)</span><br><span class="line">x = layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">z_mean = layers.Dense(latent_dim)(x)</span><br><span class="line">z_log_var = layers.Dense(latent_dim)(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来的代码将使用 z_mean 和 z_log_var 来生成（采样）一个潜在空间点 z。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 潜在空间采样的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sampling</span>(<span class="params">args</span>):</span></span><br><span class="line">    z_mean, z_log_var = args</span><br><span class="line">    epsilon = K.random_normal(shape=(K.shape(z_mean)[<span class="number">0</span>], latent_dim),</span><br><span class="line">                              mean=<span class="number">0.</span>,</span><br><span class="line">                              stddev=<span class="number">1.</span>)</span><br><span class="line">    <span class="keyword">return</span> z_mean + K.exp(z_log_var) * epsilon</span><br><span class="line"></span><br><span class="line">z = layers.Lambda(sampling)([z_mean, z_log_var])    <span class="comment"># 封装为层</span></span><br></pre></td></tr></table></figure><p>然后是解码器的实现：将向量 z 的尺寸调整为图像大小，然后使用几个卷积层来得到最终的图像输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VAE 解码器网络</span></span><br><span class="line"></span><br><span class="line">decoder_input = layers.Input(K.int_shape(z)[<span class="number">1</span>:])</span><br><span class="line">x = layers.Dense(np.prod(shape_before_flattening[<span class="number">1</span>:]),</span><br><span class="line">                 activation=<span class="string">&#x27;relu&#x27;</span>)(decoder_input)</span><br><span class="line">x = layers.Reshape(shape_before_flattening[<span class="number">1</span>:])(x)</span><br><span class="line">x = layers.Conv2DTranspose(<span class="number">32</span>, <span class="number">3</span>,</span><br><span class="line">                           padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                           activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                           strides=(<span class="number">2</span>, <span class="number">2</span>))(x)</span><br><span class="line">x = layers.Conv2D(<span class="number">1</span>, <span class="number">3</span>,</span><br><span class="line">                  padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  activation=<span class="string">&#x27;sigmoid&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">decoder = Model(decoder_input, x)</span><br><span class="line"></span><br><span class="line">z_decoded = decoder(z)</span><br></pre></td></tr></table></figure><p>VAE 要用两个损失，所以不能直接写成 <code>loss(input, target)</code>，我们需要编写一个自定义层，在其中使用内置的 <code>add_loss</code> 方法来创建需要的损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于计算 VAE 损失的自定义层</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomVariationalLayer</span>(<span class="params">keras.layers.Layer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vae_loss</span>(<span class="params">self, x, z_decoded</span>):</span></span><br><span class="line">        x = K.flatten(x)</span><br><span class="line">        z_decoded = K.flatten(z_decoded)</span><br><span class="line">        </span><br><span class="line">        xent_loss = keras.metrics.binary_crossentropy(x, z_decoded)</span><br><span class="line">        kl_loss = -<span class="number">5e-4</span> * K.mean(</span><br><span class="line">            <span class="number">1</span> + z_log_var - K.square(z_mean) - K.exp(z_log_var),</span><br><span class="line">            axis=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> K.mean(xent_loss + kl_loss)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">        x = inputs[<span class="number">0</span>]</span><br><span class="line">        z_decoded = inputs[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        loss = self.vae_loss(x, z_decoded)</span><br><span class="line">        self.add_loss(loss, inputs=inputs)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">y = CustomVariationalLayer()([input_img, z_decoded])</span><br></pre></td></tr></table></figure><p>最后，将模型实例化并开始训练。由于我们的损失以及包含在自定义层里面了，所以编译时无须指定外部损失(<code>loss=None</code>)，所以也就不需要外部指定的目标数据(<code>y=None</code>)。</p><p>这里我们用 MNIST 去训练它，也就是生成手写数字的潜在空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"></span><br><span class="line">vae = Model(input_img, y)</span><br><span class="line">vae.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="literal">None</span>)</span><br><span class="line">vae.summary()</span><br><span class="line"></span><br><span class="line">(x_train, _), (x_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255.</span></span><br><span class="line">x_train = x_train.reshape(x_train.shape + (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255.</span></span><br><span class="line">x_test = x_test.reshape(x_test.shape + (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">vae.fit(x=x_train, y=<span class="literal">None</span>,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        epochs=<span class="number">10</span>,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        validation_data=(x_test, <span class="literal">None</span>))</span><br></pre></td></tr></table></figure><pre><code>WARNING:tensorflow:Output custom_variational_layer_1 missing from loss dictionary. We assume this was done on purpose. The fit and evaluate APIs will not be expecting any data to be passed to custom_variational_layer_1.Model: &quot;functional_7&quot;__________________________________________________________________________________________________Layer (type)                    Output Shape         Param #     Connected to                     ==================================================================================================input_1 (InputLayer)            [(None, 28, 28, 1)]  0                                            __________________________________________________________________________________________________conv2d_5 (Conv2D)               (None, 28, 28, 32)   320         input_1[0][0]                    __________________________________________________________________________________________________conv2d_6 (Conv2D)               (None, 14, 14, 64)   18496       conv2d_5[0][0]                   __________________________________________________________________________________________________conv2d_7 (Conv2D)               (None, 14, 14, 64)   36928       conv2d_6[0][0]                   __________________________________________________________________________________________________conv2d_8 (Conv2D)               (None, 14, 14, 64)   36928       conv2d_7[0][0]                   __________________________________________________________________________________________________flatten_1 (Flatten)             (None, 12544)        0           conv2d_8[0][0]                   __________________________________________________________________________________________________dense_4 (Dense)                 (None, 32)           401440      flatten_1[0][0]                  __________________________________________________________________________________________________dense_5 (Dense)                 (None, 2)            66          dense_4[0][0]                    __________________________________________________________________________________________________dense_6 (Dense)                 (None, 2)            66          dense_4[0][0]                    __________________________________________________________________________________________________lambda_1 (Lambda)               (None, 2)            0           dense_5[0][0]                                                                                     dense_6[0][0]                    __________________________________________________________________________________________________functional_5 (Functional)       (None, 28, 28, 1)    56385       lambda_1[0][0]                   __________________________________________________________________________________________________custom_variational_layer_1 (Cus (None, 28, 28, 1)    0           input_1[0][0]                                                                                     functional_5[0][0]               ==================================================================================================Total params: 550,629Trainable params: 550,629Non-trainable params: 0__________________________________________________________________________________________________Train on 60000 samples, validate on 10000 samplesEpoch 1/1060000/60000 [==============================] - 219s 4ms/sample - loss: 0.2173 - val_loss: 0.2016...Epoch 10/1060000/60000 [==============================] - 234s 4ms/sample - loss: 0.1840 - val_loss: 0.1826</code></pre><p>训练好模型，我们就可以使用 decoder 将任意潜在空间中的向量转换为图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从潜在空间中采样一组点，解码为图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line">n = <span class="number">15</span>    <span class="comment"># 显示 15x15个数</span></span><br><span class="line">digit_size = <span class="number">28</span></span><br><span class="line">figure = np.zeros((digit_size * n, digit_size * n))</span><br><span class="line"></span><br><span class="line">grid_x = norm.ppf(np.linspace(<span class="number">0.05</span>, <span class="number">0.95</span>, n))  <span class="comment"># ppf 函数对线性分隔的坐标进行变换，以生成潜在变量 z 的值</span></span><br><span class="line">grid_y = norm.ppf(np.linspace(<span class="number">0.05</span>, <span class="number">0.95</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, yi <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid_x):</span><br><span class="line">    <span class="keyword">for</span> j, xi <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid_y):</span><br><span class="line">        z_simple = np.array([[xi, yi]])</span><br><span class="line">        z_simple = np.tile(z_simple, batch_size).reshape(batch_size, <span class="number">2</span>)</span><br><span class="line">        x_decoded = decoder.predict(z_simple, batch_size=batch_size)</span><br><span class="line">        digit = x_decoded[<span class="number">0</span>].reshape(digit_size, digit_size)</span><br><span class="line">        figure[i * digit_size: (i + <span class="number">1</span>) * digit_size,</span><br><span class="line">               j * digit_size: (j + <span class="number">1</span>) * digit_size] = digit</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plt.imshow(figure, cmap=<span class="string">&#x27;Greys_r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi0w0g9euhj30gb0g2dib.jpg" alt="png"></p><p>书上到这里就结束了，并没有深入写之前提到的概念向量的应用😂，好遗憾啊。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之神经风格迁移</title>
      <link href="/2020/08/22/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_3/"/>
      <url>/2020/08/22/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_3/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第8章  生成式深度学习</strong> (Chapter 8. <em>Generative deep learning</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="8-3-Neural-style-transfer"><a href="#8-3-Neural-style-transfer" class="headerlink" title="8.3 Neural style transfer"></a>8.3 Neural style transfer</h2><blockquote><p>神经风格迁移</p></blockquote><p>神经风格迁移(neural style transfer)，基于深度学习的神经网络，将参考图像的风格应用于目标图像，同时保留目标图像的内容，创造出新的图像。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghsqybmpeij314y0cgarv.jpg" alt="一个风格迁移的示例"></p><p>神经风格迁移的思想很简单：定义一个损失函数来指定要实现的目标，然后将这个损失最小化。这里的目标就是保存原始图像的内容，同时采用参考图像的风格。</p><p>假设有函数 content 和 style 分别可以计算出输入图像的内容和风格，以及有范式函数 distance，则神经风格迁移的损失可以表达为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = distance(content(original_image) - content(generated_image)) +</span><br><span class="line">       distance(style(reference_image) - style(generated_image))</span><br></pre></td></tr></table></figure><p>事实上，利用深度卷积神经网络，是可以从数学上定义 style 和 content 函数的。</p><h4 id="损失定义"><a href="#损失定义" class="headerlink" title="损失定义"></a>损失定义</h4><ol><li><strong>内容损失</strong></li></ol><p>卷积神经网络靠底部（前面）的层激活包含关于图像的局部信息，靠近顶部（后面）的层则包含更加全局、抽象的信息。内容就是图像的全局、抽象的信息，所以可以用卷积神经网络靠顶部的层激活来表示图像的内容。</p><p>因此，给定一个预训练的卷积神经网络，选定一个靠顶部的层，内容损失可以使用「该层在目标图像上的激活」和「该层在生成图像上的激活」之间的 L2 范数。</p><ol start="2"><li><strong>风格损失</strong></li></ol><p>不同于内容只用一个层即可表达，风格需要多个层才能定义。风格是多种方面的，比如笔触、线条、纹理、颜色等等，这些内容会出现在不同的抽象程度上。所以风格的表达就需要捕捉所有空间尺度上提取的外观，而不仅仅是在单一尺度上。</p><p>在这种思想下，风格损失的表达，可以借助于层激活的 Gram 矩阵。这个 Gram 矩阵就是某一层的各个特征图的内积，表达了层的特征间相互关系(correlation)的映射，它就对应于这个尺度上找到的纹理(texture)的外观。而在不同的层激活内保存相似的内部相互关系，就可以认为是“风格”了。</p><p>那么，我们就可以用生成图像和风格参考图像在不同层上保持的纹理，来定义风格损失了。</p><h4 id="神经风格迁移的-Keras-实现"><a href="#神经风格迁移的-Keras-实现" class="headerlink" title="神经风格迁移的 Keras 实现"></a>神经风格迁移的 Keras 实现</h4><p>神经风格迁移可以用任何预训练卷积神经网络来实现，这里选用 VGG19。</p><p>神经风格迁移的步骤如下：</p><ol><li>创建一个网络，同时计算风格参考图像、目标图像和生成图像的 VGG19 层激活;</li><li>使用这三张图像上计算的层激活来定义之前所述的损失函数;</li><li>梯度下降来将这个损失函数最小化。</li></ol><p>在开始构建网络前，先定义风格参考图像和目标图像的路径。如果图像尺寸差异很大，风格迁移会比较困难，所以这里我们还统一定义一下尺寸：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用及时执行模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义初始变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.image <span class="keyword">import</span> load_img, img_to_array</span><br><span class="line"></span><br><span class="line">target_image_path = <span class="string">&#x27;img/portrait.jpg&#x27;</span></span><br><span class="line">style_referencce_image_path = <span class="string">&#x27;img/transfer_style_reference.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line">width, height = load_img(target_image_path).size</span><br><span class="line">img_height = <span class="number">400</span></span><br><span class="line">img_width = width * img_height // height</span><br></pre></td></tr></table></figure><p>这里图片我选择了：</p><ul><li>transfer_style_reference: 文森特·梵高《麦田里的丝柏树》（<em>A Wheatfield, with Cypresses</em>），1889年，收藏于纽约大都会博物馆。</li><li>portrait: 保罗·高更《不列塔尼牧人》(<em>The Swineherd, Brittany</em>)，1888年，收藏于美国加州洛杉矶郡立美术馆。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtv5qecwtj31g20n1u0x.jpg" alt="麦田里的丝柏树与不列塔尼牧人"></p><p>接下来，我们需要一些辅助函数，用于图像的加载、处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 辅助函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> vgg19</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_image</span>(<span class="params">image_path</span>):</span></span><br><span class="line">    img = load_img(image_path, target_size=(img_height, img_width))</span><br><span class="line">    img = img_to_array(img)</span><br><span class="line">    img = np.expand_dims(img, axis=<span class="number">0</span>)</span><br><span class="line">    img = vgg19.preprocess_input(img)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deprocess_image</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="comment"># vgg19.preprocess_input 会减去ImageNet的平均像素值，使其中心为0。这里做逆操作：</span></span><br><span class="line">    x[:, :, <span class="number">0</span>] += <span class="number">103.939</span></span><br><span class="line">    x[:, :, <span class="number">1</span>] += <span class="number">116.779</span></span><br><span class="line">    x[:, :, <span class="number">2</span>] += <span class="number">123.680</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># BGR -&gt; RGB</span></span><br><span class="line">    x = x[:, :, ::-<span class="number">1</span>]</span><br><span class="line">    x = np.clip(x, <span class="number">0</span>, <span class="number">255</span>).astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>下面构建 VGG19 网络：接收三张图像的 batch 作为输入，三张图像分别是风格参考图像、 目标图像的 constant 和一个用于保存生成图像的 placeholder。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line">target_image = K.constant(preprocess_image(target_image_path))</span><br><span class="line">style_reference_image = K.constant(preprocess_image(style_referencce_image_path))</span><br><span class="line">combination_image = K.placeholder((<span class="number">1</span>, img_height, img_width, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">input_tensor = K.concatenate([target_image,</span><br><span class="line">                              style_reference_image,</span><br><span class="line">                              combination_image], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">model = vgg19.VGG19(input_tensor=input_tensor,</span><br><span class="line">                    weights=<span class="string">&#x27;imagenet&#x27;</span>,</span><br><span class="line">                    include_top=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Model loaded.&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Model loaded.</code></pre><p>定义内容损失，保证目标图像和生成图像在网络顶层的结果相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内容损失</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">content_loss</span>(<span class="params">base, combination</span>):</span></span><br><span class="line">    <span class="keyword">return</span> K.<span class="built_in">sum</span>(K.square(combination - base))</span><br></pre></td></tr></table></figure><p>然后是风格损失，计算输入矩阵的 Gram 矩阵，借助用 Gram 矩阵计算风格损失：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 风格损失</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gram_matrix</span>(<span class="params">x</span>):</span></span><br><span class="line">    features = K.batch_flatten(K.permute_dimensions(x, (<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">    gram = K.dot(features, K.transpose(features))</span><br><span class="line">    <span class="keyword">return</span> gram</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">style_loss</span>(<span class="params">style, combination</span>):</span></span><br><span class="line">    S = gram_matrix(style)</span><br><span class="line">    C = gram_matrix(combination)</span><br><span class="line">    channels = <span class="number">3</span></span><br><span class="line">    size = img_height * img_width</span><br><span class="line">    <span class="keyword">return</span> K.<span class="built_in">sum</span>(K.square(S - C)) / (<span class="number">4.0</span> * (channels ** <span class="number">2</span>) * (size ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>这里我们再额外定义一个「总变差损失」(total variation loss)，促使生成图像具有空间连续性，避免结果过度像素化，相当于一个正则化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总变差损失</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_variation_loss</span>(<span class="params">x</span>):</span></span><br><span class="line">    a = K.square(</span><br><span class="line">        x[:, :img_height - <span class="number">1</span>, :img_width - <span class="number">1</span>, :] - </span><br><span class="line">        x[:, <span class="number">1</span>:, :img_width - <span class="number">1</span>, :])</span><br><span class="line">    b = K.square(</span><br><span class="line">        x[:, :img_height - <span class="number">1</span>, :img_width - <span class="number">1</span>, :] - </span><br><span class="line">        x[:, :img_height - <span class="number">1</span>, <span class="number">1</span>:, :])</span><br><span class="line">    <span class="keyword">return</span> K.<span class="built_in">sum</span>(K.<span class="built_in">pow</span>(a + b, <span class="number">1.25</span>))</span><br></pre></td></tr></table></figure><p>现在考虑具体的损失计算：在计算内容损失时，我们需要一个靠顶部的层；对于风格损失，我们需要使用一系列层，既包括顶层也包括底层；最后还需要添加总变差损失。最终的损失就是这三类损失的加权平均。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义需要最小化的最终损失</span></span><br><span class="line"></span><br><span class="line">outputs_dict = &#123;layer.name: layer.output <span class="keyword">for</span> layer <span class="keyword">in</span> model.layers&#125;</span><br><span class="line"></span><br><span class="line">content_layer = <span class="string">&#x27;block5_conv2&#x27;</span></span><br><span class="line">style_layers = [<span class="string">f&#x27;block<span class="subst">&#123;i&#125;</span>_conv1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">total_variation_weight = <span class="number">1e-4</span></span><br><span class="line">style_weight = <span class="number">1.0</span></span><br><span class="line">content_weight = <span class="number">0.025</span>  <span class="comment"># content_weight越大，目标内容更容易在生成图像中越容易识别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容损失</span></span><br><span class="line">loss = K.variable(<span class="number">0.</span>)</span><br><span class="line">layer_features = outputs_dict[content_layer]</span><br><span class="line">target_image_features = layer_features[<span class="number">0</span>, :, :, :]</span><br><span class="line">combination_features = layer_features[<span class="number">2</span>, :, :, :]</span><br><span class="line">loss = loss + content_weight * content_loss(target_image_features, combination_features)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 风格损失</span></span><br><span class="line"><span class="keyword">for</span> layer_name <span class="keyword">in</span> style_layers:</span><br><span class="line">    layer_features = outputs_dict[layer_name]</span><br><span class="line">    style_reference_features = layer_features[<span class="number">1</span>, :, :, :]</span><br><span class="line">    combination_features = layer_features[<span class="number">2</span>, :, :, :]</span><br><span class="line">    sl = style_loss(style_reference_features, combination_features)</span><br><span class="line">    loss = loss + (style_weight / <span class="built_in">len</span>(style_layers)) * sl</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 总变差损失</span></span><br><span class="line">loss = loss + total_variation_weight * total_variation_loss(combination_image)</span><br></pre></td></tr></table></figure><p>最后就是梯度下降过程了。这里调用 scipy，用 <code>L-BFGS</code> 算法进行最优化。</p><p>为了快速计算，我们创建一个 Evaluator 类，同时计算损失值和梯度值，在第一次调用时会返回损失值，同时缓存梯度值用于下一次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置梯度下降过程</span></span><br><span class="line"></span><br><span class="line">grads = K.gradients(loss, combination_image)[<span class="number">0</span>]</span><br><span class="line">fetch_loss_and_grads = K.function([combination_image], [loss, grads])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evaluator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.loss_value = <span class="literal">None</span></span><br><span class="line">        self.grads_values = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> self.loss_value <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">        x = x.reshape((<span class="number">1</span>, img_height, img_width, <span class="number">3</span>))</span><br><span class="line">        outs = fetch_loss_and_grads([x])</span><br><span class="line">        loss_value = outs[<span class="number">0</span>]</span><br><span class="line">        grad_values = outs[<span class="number">1</span>].flatten().astype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line">        self.loss_value = loss_value</span><br><span class="line">        self.grads_values = grad_values</span><br><span class="line">        <span class="keyword">return</span> self.loss_value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grads</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> self.loss_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        grad_values = np.copy(self.grads_values)</span><br><span class="line">        self.loss_value = <span class="literal">None</span></span><br><span class="line">        self.grad_values = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> grad_values</span><br><span class="line">        </span><br><span class="line">evaluator = Evaluator()</span><br></pre></td></tr></table></figure><p>最后的最后，调用 SciPy 的 L-BFGS 算法来运行梯度上升过程，每一次迭代(20 步梯度上升)后都保存当前的生成图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> fmin_l_bfgs_b</span><br><span class="line"><span class="keyword">from</span> imageio <span class="keyword">import</span> imsave</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">iterations = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result_fname</span>(<span class="params">iteration</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;results/result_at_iteration_<span class="subst">&#123;iteration&#125;</span>.png&#x27;</span></span><br><span class="line"></span><br><span class="line">x = preprocess_image(target_image_path)</span><br><span class="line">x = x.flatten()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    print(<span class="string">&#x27;Start of iteration&#x27;</span>, i)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    x, min_val, info = fmin_l_bfgs_b(evaluator.loss,</span><br><span class="line">                                     x,</span><br><span class="line">                                     fprime=evaluator.grads,</span><br><span class="line">                                     maxfun=<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">&#x27;  Current loss value:&#x27;</span>, min_val)</span><br><span class="line">    </span><br><span class="line">    img = x.copy().reshape((img_height, img_width, <span class="number">3</span>))</span><br><span class="line">    img = deprocess_image(img)</span><br><span class="line">    fname = result_fname(i)</span><br><span class="line">    imsave(fname, img)</span><br><span class="line">    print(<span class="string">&#x27;  Image saved as&#x27;</span>, fname)</span><br><span class="line">    </span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(<span class="string">f&#x27;  Iteration <span class="subst">&#123;i&#125;</span> completed in <span class="subst">&#123;end_time - start_time&#125;</span> s&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Start of iteration 0  Current loss value: 442468450.0  Image saved as results/result_at_iteration_0.png  Iteration 0 completed in 177.57321500778198 s...Start of iteration 19  Current loss value: 44762796.0  Image saved as results/result_at_iteration_19.png  Iteration 19 completed in 177.95070385932922 s</code></pre><p>把结果和原图放在一起比较一下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu38838haj317h0u0b2b.jpg" alt="结果1"></p><p>再看一个例子：风格参考还是用梵高的《麦田里的丝柏树》，内容用米勒的《拾穗者》(Des glaneuses，1857年，巴黎奥塞美术馆)。比较有意思的是，梵高本人画过一幅部分模仿《拾穗者》的《夕阳下两位农妇开掘积雪覆盖的田地》(Zwei grabende Bäuerinnen auf schneebedecktem Feld)：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6d9c19jj30vr0u0u0x.jpg" alt="结果2"></p><p>可以看到，我们的机器只是简单粗暴的风格迁移，而大师本人会在模仿中再创作。</p><p>最后，补充一点。这个风格迁移算法的运行比较慢，但足够简单。要实现快速风格迁移，可以考虑：首先利用这里介绍的方法，固定一张风格参考图像，给不同的内容图像，生成一大堆「输入-输出」训练样例，拿这些「输入-输出」去训练一个简单的卷积神经网络来学习这个特定风格的变换(输入-&gt;输出)。完成之后，对一张图像进行特定风格的迁移就非常快了，做一次前向传递就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之DeepDream</title>
      <link href="/2020/08/21/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_2/"/>
      <url>/2020/08/21/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_2/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第8章  生成式深度学习</strong> (Chapter 8. <em>Generative deep learning</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="8-2-DeepDream"><a href="#8-2-DeepDream" class="headerlink" title="8.2 DeepDream"></a>8.2 DeepDream</h2><blockquote><p>DeepDream</p></blockquote><p>DeepDream 是一种让机器修改图像技术，它利用卷积神经网络，可以作出很迷幻的图像：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghqnj1501xj313t0u0e84.jpg" alt="DeepDream 输出图像示例"></p><p>由于 DeepDream 用的 CNN 是在 ImageNet 上训练的，而 ImageNet 里有大量的动物图片，所以，DeepDream 生成的图像里有很多动物、动物的一部分的伪影。</p><p>DeepDream 使用的算法与卷积神经网络过滤器可视化技术很类似。回忆一下，卷积神经网络过滤器可视化所做的操作是：反向运行卷积神经网络，从一张带随机噪点的空白图像输入，做梯度上升，使某过滤器激活最大化。</p><p>DeepDream  与过滤器可视化的主要区别在于：</p><ul><li>在 DeepDream 中，我们尝试将所有层的激活最大化，而不只是某一层，这样，会有大量的可视化特征混合在一起——生成更加迷幻的图像。</li><li>从一张现有的图像开始，而不是从随机噪点的输入开始，这样生成的图像中会包含输入图像中已存在的视觉模式，并以将其中的一些元素扭曲——生成更加迷幻的图像。</li><li>输入图像会在不同的尺度上进行处理——这些尺度称为「八度」(octave)，这可以提高输出的质量。 </li></ul><h3 id="用-Keras-实现-DeepDream"><a href="#用-Keras-实现-DeepDream" class="headerlink" title="用 Keras 实现 DeepDream"></a>用 Keras 实现 DeepDream</h3><p>首先，我们需要选定一个在 ImageNet 上预训练的卷积神经网络：VGG16、Inception、ResNet50 等等都可以。实践证明，Inception 可以生成的比较好，所以这里我们使用 Keras 内置的 Inception V3 模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用及时执行模式</span></span><br><span class="line"><span class="comment"># See https://github.com/tensorflow/tensorflow/issues/33135</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载预训练的 Inception V3 模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> inception_v3</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line">K.set_learning_phase(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">model = inception_v3.InceptionV3(weights=<span class="string">&#x27;imagenet&#x27;</span>, include_top=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><pre><code>WARNING:tensorflow:From &lt;ipython-input-3-aa9be14f7cc2&gt;:6: set_learning_phase (from tensorflow.python.keras.backend) is deprecated and will be removed after 2020-10-11.Instructions for updating:Simply pass a True/False value to the `training` argument of the `__call__` method of your layer or model.</code></pre><p>接下来定义损失——需要用梯度上升最大化的量。DeepDream 中，我们要同时将多个层的所有过滤器激活最大化。具体的实现是：对一组靠近顶部的层激活的 L2 范数进行加权求和，然后求出这个值的最大化。层的选择、以及权重分配对生成的结果影响很大：</p><ul><li>靠近底部的层会生成基本的几何图案；</li><li>靠近顶部的层会生成能够看出某些物品的图像（ImageNet 中的图案，比如鸟或狗）</li></ul><p>这里就随便选几个了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 Inception V3 模型的结构，在其中选择层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.keras.utils.plot_model(model)</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghy7jy9nmhj30u05oz4qq.jpg" alt="png" style="zoom:5%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DeepDream 配置</span></span><br><span class="line"></span><br><span class="line">layer_contributions = &#123;</span><br><span class="line">    <span class="string">&#x27;mixed4&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;mixed5&#x27;</span>: <span class="number">3.0</span>,</span><br><span class="line">    <span class="string">&#x27;mixed6&#x27;</span>: <span class="number">2.0</span>,</span><br><span class="line">    <span class="string">&#x27;mixed7&#x27;</span>: <span class="number">1.5</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求对于这些被选中层的损失：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义需要最大化的损失</span></span><br><span class="line"></span><br><span class="line">layer_dict = <span class="built_in">dict</span>([(layer.name, layer) <span class="keyword">for</span> layer <span class="keyword">in</span> model.layers])</span><br><span class="line"></span><br><span class="line">loss = K.variable(<span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> layer_name <span class="keyword">in</span> layer_contributions:</span><br><span class="line">    coeff = layer_contributions[layer_name]</span><br><span class="line">    activation = layer_dict[layer_name].output</span><br><span class="line">    </span><br><span class="line">    scaling = K.prod(K.cast(K.shape(activation), <span class="string">&#x27;float32&#x27;</span>))</span><br><span class="line">    <span class="comment"># loss += coeff * K.sum(K.square(activation[:, 2: -2, :])) / scaling</span></span><br><span class="line">    <span class="comment"># 应该用下面的代码👇。参考：https://github.com/fchollet/deep-learning-with-python-notebooks/issues/43</span></span><br><span class="line">    loss = loss + coeff * K.<span class="built_in">sum</span>(K.square(activation[:, <span class="number">2</span>: -<span class="number">2</span>, :])) / scaling</span><br></pre></td></tr></table></figure><p>对损失做梯度上升：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度上升过程</span></span><br><span class="line"></span><br><span class="line">dream = model.<span class="built_in">input</span></span><br><span class="line"></span><br><span class="line">grads = K.gradients(loss, dream)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">grads /= K.maximum(K.mean(K.<span class="built_in">abs</span>(grads)), <span class="number">1e-7</span>)</span><br><span class="line"></span><br><span class="line">outputs = [loss, grads]</span><br><span class="line">fetch_loss_and_grads = K.function([dream], outputs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_loss_and_grads</span>(<span class="params">x</span>):</span></span><br><span class="line">    outs = fetch_loss_and_grads([x])</span><br><span class="line">    loss_value = outs[<span class="number">0</span>]</span><br><span class="line">    grad_values = outs[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> loss_value, grad_values</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_ascent</span>(<span class="params">x, iterations, step, max_loss=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        loss_value, grad_values = eval_loss_and_grads(x)</span><br><span class="line">        <span class="keyword">if</span> max_loss <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> loss_value &gt; max_loss:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">f&#x27;   loss value at <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;loss_value&#125;</span>&#x27;</span>)</span><br><span class="line">        x += step * grad_values</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>最后，实现 DeepDream 算法：先定义一个尺度(scales，也叫做八度，octaves)列表，里面包含要处理的图像。后一个尺度的图像比前一个放大一定的倍数。DeepDream 要按照这个列表从最小到最大，在当前尺度运行梯度上升，然后将得到的图像放大。放大之后，图像会变得模糊，所以还要将丢失的细节重新注入到图像中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghrruc28b5j31o40u0nly.jpg" alt="DeepDream 过程:空间处理尺度的连续放大(八度)与放大时重新注入细节"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 辅助函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_img</span>(<span class="params">img, size</span>):</span></span><br><span class="line">    img = np.copy(img)</span><br><span class="line">    factors = (<span class="number">1</span>, </span><br><span class="line">               <span class="built_in">float</span>(size[<span class="number">0</span>]) / img.shape[<span class="number">1</span>], </span><br><span class="line">               <span class="built_in">float</span>(size[<span class="number">1</span>]) / img.shape[<span class="number">2</span>], </span><br><span class="line">               <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> scipy.ndimage.zoom(img, factors, order=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_img</span>(<span class="params">img, fname</span>):</span></span><br><span class="line">    pil_img = deprocess_image(np.copy(img))</span><br><span class="line">    <span class="comment"># scipy.misc.imsave(fname, pil_img)</span></span><br><span class="line">    imageio.imsave(fname, pil_img)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_image</span>(<span class="params">image_path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    用于打开图像，改变图像大小，并将图像格式转换为 Inception V3 模型能够处理的张量</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    img = image.load_img(image_path)</span><br><span class="line">    img = image.img_to_array(img)</span><br><span class="line">    img = np.expand_dims(img, axis=<span class="number">0</span>)</span><br><span class="line">    img = inception_v3.preprocess_input(img)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deprocess_image</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将一个张量转换为有效图像</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">        x = x.reshape((<span class="number">3</span>, x.shape[<span class="number">2</span>], x.shape[<span class="number">3</span>]))</span><br><span class="line">        x = x.transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = x.reshape((x.shape[<span class="number">1</span>], x.shape[<span class="number">2</span>], <span class="number">3</span>))</span><br><span class="line">        </span><br><span class="line">    x /= <span class="number">2.</span></span><br><span class="line">    x += <span class="number">0.5</span></span><br><span class="line">    x *= <span class="number">255.</span></span><br><span class="line">    x = np.clip(x, <span class="number">0</span>, <span class="number">255</span>).astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在多个连续尺度上运行梯度上升</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">step = <span class="number">0.01</span>     <span class="comment"># 梯度上升的步长</span></span><br><span class="line">num_octave = <span class="number">3</span>  <span class="comment"># 尺度个数</span></span><br><span class="line">octave_scale = <span class="number">1.4</span> <span class="comment"># 两个尺度的大小比例</span></span><br><span class="line">iterations = <span class="number">20</span> <span class="comment"># 在每个尺度上运行梯度上升的步数</span></span><br><span class="line"></span><br><span class="line">max_loss = <span class="number">10.</span>  <span class="comment"># 损失上升的太大时中止梯度上升，以免得到丑陋的伪影</span></span><br><span class="line"></span><br><span class="line">base_image_path = <span class="string">&#x27;./img.png&#x27;</span></span><br><span class="line"></span><br><span class="line">img = preprocess_image(base_image_path)</span><br><span class="line"></span><br><span class="line">original_shape = img.shape[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">successive_shapes = [original_shape]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_octave):</span><br><span class="line">    shape = <span class="built_in">tuple</span>([dim // (octave_scale ** i)</span><br><span class="line">                  <span class="keyword">for</span> dim <span class="keyword">in</span> original_shape])</span><br><span class="line">    successive_shapes.append(shape)</span><br><span class="line">successive_shapes = successive_shapes[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">original_img = np.copy(img)</span><br><span class="line">shrunk_original_img = resize_img(img, successive_shapes[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> shape <span class="keyword">in</span> successive_shapes:</span><br><span class="line">    print(<span class="string">&#x27;Processing image shape&#x27;</span>, shape)</span><br><span class="line">    img = resize_img(img, shape)</span><br><span class="line">    img = gradient_ascent(img,</span><br><span class="line">                          iterations=iterations,</span><br><span class="line">                          step=step,</span><br><span class="line">                          max_loss=max_loss)</span><br><span class="line">    upscaled_shrunk_original_img = resize_img(shrunk_original_img, shape)</span><br><span class="line">    same_size_original = resize_img(original_img, shape)</span><br><span class="line">    lost_detail = same_size_original - upscaled_shrunk_original_img</span><br><span class="line">    </span><br><span class="line">    img += lost_detail</span><br><span class="line">    shrunk_original_img = resize_img(original_img, shape)</span><br><span class="line">    save_img(img, fname=<span class="string">f&#x27;dream_at_scale_<span class="subst">&#123;shape&#125;</span>.png&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">save_img(img, fname=<span class="string">&#x27;final_dream.png&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Processing image shape (510.0, 510.0)   loss value at 0: 0.7559041976928711   loss value at 1: 0.8942177295684814   ...   loss value at 18: 6.890047073364258   loss value at 19: 7.1789984703063965Processing image shape (714.0, 714.0)   loss value at 0: 1.6531521081924438   loss value at 1: 2.5666146278381348   ...   loss value at 18: 9.60411548614502   loss value at 19: 9.890054702758789Processing image shape (1000, 1000)   loss value at 0: 1.6969424486160278   loss value at 1: 2.754427909851074   ...   loss value at 17: 9.593267440795898   loss value at 18: 9.928627014160156</code></pre><p>结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghso9lpohzj31aq0li7wi.jpg" alt="DeepDream结果"></p><p>可以看到 DeepDream 在 final_dream 图片里，画上了几只狗🐶。</p><p>注：由于 Inception V3 原始训练的尺寸的缘故，这里实现的 DeepDream 实现在尺寸介于 300×300 和 400×400 之间的图像上能够得到更好的结果，不过这不是严格的限制，任何尺寸的都是可以的。</p><hr><p>注：使用 TensorfFlow 2 的 eager 模式，也可以很容易地实现一个更好的 DeepDream，详见<a href="https://github.com/tensorflow/docs/blob/master/site/en/tutorials/generative/deepdream.ipynb">这篇 TensorFlow 的官方教程</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之LSTM文本生成</title>
      <link href="/2020/08/20/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_1/"/>
      <url>/2020/08/20/DeepLearningWithPython/Deep-Learning%20with-Python-ch8_1/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第8章  生成式深度学习</strong> (Chapter 8. <em>Generative deep learning</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="8-1-Text-generation-with-LSTM"><a href="#8-1-Text-generation-with-LSTM" class="headerlink" title="8.1 Text generation with LSTM"></a>8.1 Text generation with LSTM</h2><blockquote><p>使用 LSTM 生成文本</p></blockquote><p>以前有人说过：“generating sequential data is the closest computers get to dreaming”，让计算机生成序列是很有魅力的事情。我们将以文本生成为例，探讨如何将循环神经网络用于生成序列数据。这项技术也可以用于音乐的生成、语音合成、聊天机器人对话生成、甚至是电影剧本的编写等等。</p><p>其实，我们现在熟知的 LSTM 算法，最早被开发出来的时候，就是用于逐字符地生成文本的。</p><h3 id="序列数据的生成"><a href="#序列数据的生成" class="headerlink" title="序列数据的生成"></a>序列数据的生成</h3><p>用深度学习生成序列的通用方法，就是训练一个网络(一般用 RNN 或 CNN)，输入前面的 Token，预测序列中接下来的 Token。</p><p>说的术语化一些：给定前面的 Token，能够对下一个 Token 的概率进行建模的网络叫作「语言模型(language model)」。语言模型能够捕捉到语言的统计结构 ——「潜在空间(latent space)」。训练好一个语言模型，输入初始文本字符串（称为「条件数据」，conditioning data），从语言模型中采样，就可以生成新 Token，把新的 Token 加入条件数据中，再次输入，重复这个过程就可以生成出任意长度的序列。</p><p>我们从一个简单的例子开始：用一个 LSTM 层，输入文本语料的 N 个字符组成的字符串，训练模型来生成第 N+1 个字符。模型的输出是做 softmax，在所有可能的字符上，得到下一个字符的概率分布。这个模型叫作「字符级的神经语言模型」(character-level neural language model)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghq58v9qd6j319c0ka41y.jpg" alt="使用语言模型逐个字符生成文本的过程"></p><h3 id="采样策略"><a href="#采样策略" class="headerlink" title="采样策略"></a>采样策略</h3><p>使用字符级的神经语言模型生成文本时，最重要的问题是如何选择下一个字符。这里有几张常用方法：</p><ul><li>贪婪采样(greedy sampling)：始终选择可能性最大的下一个字符。这个方法很可能得到重复的、可预测的字符串，而且可能意思不连贯。（输入法联想）</li><li>纯随机采样：从均匀概率分布中抽取下一个字符，其中每个字符的概率相同。这样随机性太高，几乎不会生成出有趣的内容。（就是胡乱输出字符的组合）</li><li>随机采样(stochastic sampling)：根据语言模型的结果，如果下一个字符是 e 的概率为 0.3，那么你会有 30% 的概率选择它。有一点的随机性，让生成的内容更<del>随意</del>富有变化，但又不是完全随机，输出可以比较有意思。</li></ul><p>随机采样看上去很好，很有创造性，但有个问题是无法控制随机性的大小：随机性越大，可能富有创造性，但可能胡乱输出；随机性越小，可能更接近真实词句，但太死板、可预测。</p><p>为了在采样过程中控制随机性的大小，引入一个参数：「softmax 温度」(softmax temperature)，用于表示采样概率分布的熵，即表示所选择的下一个字符会有多么出人意料或多么可预测：</p><ul><li>更高的温度：熵更大的采样分布，会生成更加出人意料、更加无结构的数据；</li><li>更低的温度：对应更小的随机性，会生成更加可预测的数据。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghq692zm1nj316f0u0k9r.jpg" alt="对同一个概率分布进行不同的重新加权：更低的温度=更确定，更高的温度=更随机"></p><p>具体的实现是，给定 temperature 值，对模型的 softmax 输出重新加权，得到新的概率分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rewight_distribution</span>(<span class="params">original_distributon, temperature=<span class="number">0.5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    对于不同的 softmax 温度，对概率分布进行重新加权</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    distribution = np.log(original_distribution) / temperature</span><br><span class="line">    distribution = np.exp(distribution)</span><br><span class="line">    <span class="keyword">return</span> distribution / np.<span class="built_in">sum</span>(distribution)</span><br></pre></td></tr></table></figure><h3 id="字符级-LSTM-文本生成实现"><a href="#字符级-LSTM-文本生成实现" class="headerlink" title="字符级 LSTM 文本生成实现"></a>字符级 LSTM 文本生成实现</h3><p>理论就上面那些了，现在，我们要用 Keras 来实现字符级的 LSTM 文本生成了。</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>首先，我们需要大量的文本数据(语料，corpus)来训练语言模型。可以去找足够大的一个或多个文本文件：维基百科、各种书籍等都可。这里我们选择用一些尼采的作品（英文译本），这样我们学习出来的语言模型将是有尼采的写作风格和主题的。（插：我，我以前自己写野生模型玩，都是用鲁迅😂）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载语料，并将其转换为全小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">path = keras.utils.get_file(</span><br><span class="line">    <span class="string">&#x27;nietzsche.txt&#x27;</span>, </span><br><span class="line">    origin=<span class="string">&#x27;https://s3.amazonaws.com/text-datasets/nietzsche.txt&#x27;</span>)</span><br><span class="line">text = <span class="built_in">open</span>(path).read().lower()</span><br><span class="line">print(<span class="string">&#x27;Corpus length:&#x27;</span>, <span class="built_in">len</span>(text))</span><br></pre></td></tr></table></figure><pre><code>/usr/local/Cellar/python/3.7.6_1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject  return f(*args, **kwds)/usr/local/Cellar/python/3.7.6_1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject  return f(*args, **kwds)Downloading data from https://s3.amazonaws.com/text-datasets/nietzsche.txt606208/600901 [==============================] - 430s 709us/stepCorpus length: 600893</code></pre><p>接下来，我们要把文本做成数据 (向量化)：从 text 里提取长度为 <code>maxlen</code> 的序列(序列之间存在部分重叠)，进行 one-hot 编码，然后打包成 <code>(sequences, maxlen, unique_characters)</code> 形状的。同时，还需要准备数组 <code>y</code>，包含对应的目标，即在每一个所提取的序列之后出现的字符(也是 one-hot 编码的)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字符序列向量化</span></span><br><span class="line"></span><br><span class="line">maxlen = <span class="number">60</span>     <span class="comment"># 每个序列的长度</span></span><br><span class="line">step = <span class="number">3</span>        <span class="comment"># 每 3 个字符采样一个新序列</span></span><br><span class="line">sentences = []  <span class="comment"># 保存所提取的序列</span></span><br><span class="line">next_chars = [] <span class="comment"># sentences 的下一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(text) - maxlen, step):</span><br><span class="line">    sentences.append(text[i: i+maxlen])</span><br><span class="line">    next_chars.append(text[i+maxlen])</span><br><span class="line">print(<span class="string">&#x27;Number of sequences:&#x27;</span>, <span class="built_in">len</span>(sentences))</span><br><span class="line"></span><br><span class="line">chars = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(text)))</span><br><span class="line">char_indices = <span class="built_in">dict</span>((char, chars.index(char)) <span class="keyword">for</span> char <span class="keyword">in</span> chars)</span><br><span class="line"><span class="comment"># 插：上面这两行代码 6</span></span><br><span class="line">print(<span class="string">&#x27;Unique characters:&#x27;</span>, <span class="built_in">len</span>(chars))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Vectorization...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = np.zeros((<span class="built_in">len</span>(sentences), maxlen, <span class="built_in">len</span>(chars)), dtype=np.<span class="built_in">bool</span>)</span><br><span class="line">y = np.zeros((<span class="built_in">len</span>(sentences), <span class="built_in">len</span>(chars)), dtype=np.<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, sentence <span class="keyword">in</span> <span class="built_in">enumerate</span>(sentences):</span><br><span class="line">    <span class="keyword">for</span> t, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(sentence):</span><br><span class="line">        x[i, t, char_indices[char]] = <span class="number">1</span></span><br><span class="line">    y[i, char_indices[next_chars[i]]] = <span class="number">1</span></span><br></pre></td></tr></table></figure><pre><code>Number of sequences: 200278Unique characters: 57Vectorization...</code></pre><h4 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h4><p>我们要用到的网络其实很简单，一个 LSTM 层 + 一个 softmax 激活的 Dense 层就可以了。其实并不一定要用 LSTM，用一维卷积层也是可以生成序列的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于预测下一个字符的单层 LSTM 模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> LSTM, Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(<span class="number">128</span>, input_shape=(maxlen, <span class="built_in">len</span>(chars))))</span><br><span class="line">model.add(Dense(<span class="built_in">len</span>(chars), activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模型编译配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line">optimizer = optimizers.RMSprop(lr=<span class="number">0.01</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=optimizer)</span><br></pre></td></tr></table></figure><h4 id="训练语言模型并从中采样"><a href="#训练语言模型并从中采样" class="headerlink" title="训练语言模型并从中采样"></a>训练语言模型并从中采样</h4><p>给定一个语言模型和一个种子文本片段，就可以通过重复以下操作来生成新的文本：</p><ol><li>给定目前已有文本，从模型中得到下一个字符的概率分布；</li><li>根据某个温度对分布进行重新加权；</li><li>根据重新加权后的分布对下一个字符进行随机采样；</li><li>将新字符添加到文本末尾。</li></ol><p>在训练模型之前，我们先把「采样函数」写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">preds, temperature=<span class="number">1.0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    对模型得到的原始概率分布重新加权，并从中抽取一个字符索引</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    preds = np.asarray(preds).astype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line">    preds = np.log(preds) / temperature</span><br><span class="line">    exp_preds = np.exp(preds)</span><br><span class="line">    preds = exp_preds / np.<span class="built_in">sum</span>(exp_preds)</span><br><span class="line">    probas = np.random.multinomial(<span class="number">1</span>, preds, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> np.argmax(probas)</span><br></pre></td></tr></table></figure><p>最后，再来训练并生成文本。我们在每轮完成后都使用一系列不同的温度值来生成文本，这样就可以看到，随着模型收敛，生成的文本如何变化，以及温度对采样策略的影响：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本生成循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">60</span>):    <span class="comment"># 训练 60 个轮次</span></span><br><span class="line">    print(<span class="string">f&#x27;👉\033[1;35m epoch <span class="subst">&#123;epoch&#125;</span> \033[0m&#x27;</span>)    <span class="comment"># print(&#x27;epoch&#x27;, epoch)</span></span><br><span class="line">    </span><br><span class="line">    model.fit(x, y,</span><br><span class="line">              batch_size=<span class="number">128</span>,</span><br><span class="line">              epochs=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    start_index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(text) - maxlen - <span class="number">1</span>)</span><br><span class="line">    generated_text = text[start_index: start_index + maxlen]</span><br><span class="line">    print(<span class="string">f&#x27;  📖 Generating with seed: &quot;\033[1;32;43m<span class="subst">&#123;generated_text&#125;</span>\033[0m&quot;&#x27;</span>)    <span class="comment"># print(f&#x27; Generating with seed: &quot;&#123;generated_text&#125;&quot;&#x27;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> temperature <span class="keyword">in</span> [<span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.2</span>]:</span><br><span class="line">        print(<span class="string">f&#x27;\n   \033[1;36m 🌡️ temperature: <span class="subst">&#123;temperature&#125;</span>\033[0m&#x27;</span>)    <span class="comment"># print(&#x27;\n  temperature:&#x27;, temperature)</span></span><br><span class="line">        print(generated_text, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):    <span class="comment"># 生成 400 个字符</span></span><br><span class="line">            <span class="comment"># one-hot 编码目前有的文本</span></span><br><span class="line">            sampled = np.zeros((<span class="number">1</span>, maxlen, <span class="built_in">len</span>(chars)))</span><br><span class="line">            <span class="keyword">for</span> t, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(generated_text):</span><br><span class="line">                sampled[<span class="number">0</span>, t, char_indices[char]] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 预测，采样，生成下一字符</span></span><br><span class="line">            preds = model.predict(sampled, verbose=<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">            next_index = sample(preds, temperature)</span><br><span class="line">            next_char = chars[next_index]</span><br><span class="line">            print(next_char, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            generated_text = generated_text[<span class="number">1</span>:] + next_char</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><pre><code>👉 epoch 1 1565/1565 [==============================] - 170s 108ms/step - loss: 1.4089  📖 Generating with seed: &quot;ary!--will at least be entitled to demand in return thatpsy&quot;    🌡️ temperature: 0.2ary!--will at least be entitled to demand in return thatpsychological senses of the the most comprehensed that is a sense of a perhaps the experience of the heart the present that the profound that the experience of the exploition and present that is a self and the present that is a more of the senses of a more and the sense of a more art and the the exploition and self-contempt of a perhaps the superiom and perhaps the contempt of the superiom and all th    🌡️ temperature: 0.5superiom and perhaps the contempt of the superiom and all the instance and plays place of comprehensed and so in morals and all the auther to present mettoral of the senses and fellines to have the conceive that thepossibility of the expendeness, the hasters as how to really expendened andall that the forenies; and all the most consequently comes that the most constanter to constantering only all the expearated the expendeness is in the delight and one w    🌡️ temperature: 1.0l the expearated the expendeness is in the delight and one would be persists more and world, others which in the utility of the fellowsamong and deceeth, virtuery, mode. onesoul the most conterrites and ly under that conservate to mapt of the own toweration here old taste inilt, the &quot;frew-wellto openhanss&quot;--and the way could easily hamint; becoming being, thrien himself, very deteruence who usked slaver and own scientification, of the eever,&quot; wandundou    🌡️ temperature: 1.2ed slaver and own scientification, of the eever,&quot; wandundoupible &quot;befost suldeces.&quot; it weim even astreated drwadged,owing parits, word of hister&quot;enocest.-sychea, that that words in the savery: y allverowed&quot;, when and liqksis felling, them soperation of clentousand blendiers.the pleasrvation humiturring, likeford of feit-rum. i must &quot;nrightenmy,&quot; beneveral man.&quot; the goods-the cerses is christrantss and lightence--not man goemin love,frro-akem.y tix--------------------...👉 epoch 30 1565/1565 [==============================] - 452s 289ms/step - loss: 1.2692  📖 Generating with seed: &quot;y system of morals, is that it is along constraint. in orde&quot;    🌡️ temperature: 0.2y system of morals, is that it is along constraint. in order to be stronger and according to the same the standand, as a men and sanctity, and all the sense of the strength to the sense of the strong the striving of the strong the striving of the sense of the same this consequently and something and in a man with the sense of the sense of the same the strong of the same the sense of the strength to the sense of the same the artist the strong more and the     🌡️ temperature: 0.5to the sense of the same the artist the strong more and the intellectually in the called bet of the more of such as something of standand, the experience and profound, and in the delusions of the morality of the propeted and the more of a good and one has a sorts of the constitute in the same the religionin the same the human condition, the old proper all this taste which seeming and the standand, and are to the person of the strength and the latten more     🌡️ temperature: 1.0, and are to the person of the strength and the latten more matter, fith, niquet of nature of rove seemsion and proxible is itself, it has final &quot;genion&quot; in coptent,and un so larmor, romant.bicident, with which fur one remain echo ofcalled in this acqueis forceek of consciate convoled,asceticiliesinvaluable demardinatid.          he in respons himons, which, a engliches bad hope feels these see,fermines &quot;only he will&quot;n--as stapty pullens of bad a    🌡️ temperature: 1.2se see,fermines &quot;only he will&quot;n--as stapty pullens of bad adaval inexcepning at the unvery in all, whose in--that is a power be many trainitg prtunce--by the crueled him is everynoble,as he society of thissneke viged, has to telless all juscallers. we megnant cominghik, as gray illow and of holy este, &quot;the knowing&quot; how videly upon the adventive. there is discived and it attine to jesubuc&#39;--the .=--whatliveda! iapower, profoundc: of himself, it is lie--------------------...👉 epoch 59 1565/1565 [==============================] - 173s 110ms/step - loss: 1.2279  📖 Generating with seed: &quot;inward self-contempt, seek to get out ofthe business, no ma&quot;    🌡️ temperature: 0.2inward self-contempt, seek to get out ofthe business, no may be only and the ascetiably sense of the real and the sense of the more sense of the community of the moral and profound the way there is the sense of the most contempt of the spirit in a perceive, and the interpreting the sense of the world as it is the soul is the artist of the sense and the world as in the entirecomplication of the world as it is the strong of the most profound to the world a    🌡️ temperature: 0.5orld as it is the strong of the most profound to the world as the self nowadays to me that all the artifure in the mother of significance of the roman and we are this from the strength of existing and faith enthurable to the discover of the contrain toreligious were and self-grades the world with the way to the present think there are also all the plato-pit firels made a weart for the person of the rank on a way of the ethical prombates, to reason of the     🌡️ temperature: 1.0he rank on a way of the ethical prombates, to reason of the mortand: that pureon good lack as has refree, in a herore proposition ispronouncethe last the reasonably book of will calued and vexeme, and no means mentary honour pertimate our new, conversations. it is thatthe sense ciertably with our distins of the remare of counter that german &quot;miswome centurially instinct&quot; in course,. hsyaulity he in their minds and matter of mystimalsing of itplupetin    🌡️ temperature: 1.2y he in their minds and matter of mystimalsing of itplupeting.t his asserated approysely to special,are devial.; the finerevingsin orieicalous also mistakeng time, a :     thisbenurion andeuropean voightryands centuries: it problem as place into the errords for triubtly etsibints, vetter after distrinitionn, where it lacking sole .=-vow accorded.12u borany utmansishe and diffire being savest hiscardij(l qualition. neeked upon thisessentially, his --------------------</code></pre><p> 利用更多的数据训练更大的模型，训练时间更长，生成的样本会更连贯、更真实。但是，这样生成的文本并没有任何意义。机器所做的仅仅是从统计模型中对数据进行采样，它并没有理解人类的语言，也不知道自己在说什么。</p><h3 id="附：基于词嵌入的文本生成"><a href="#附：基于词嵌入的文本生成" class="headerlink" title="附：基于词嵌入的文本生成"></a>附：基于词嵌入的文本生成</h3><p>如果要生成中文文本，我们的汉字太多了，逐字符去做我认为不是很好的选择。所以可以考虑基于词嵌入来生成文本。在之前的字符级 LSTM 文本生成的基础上，将编码/解码方式稍作修改、添加 Embedding 层即可实现一个初级的基于词嵌入的文本生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba    <span class="comment"># 使用 jieba 做中文分词</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入文本</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;~/Desktop/txt_zh_cn.txt&#x27;</span></span><br><span class="line">text = <span class="built_in">open</span>(path).read().lower()</span><br><span class="line">print(<span class="string">&#x27;Corpus length:&#x27;</span>, <span class="built_in">len</span>(text))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文本序列向量化</span></span><br><span class="line"></span><br><span class="line">maxlen = <span class="number">60</span>     <span class="comment"># 每个序列的长度</span></span><br><span class="line">step = <span class="number">3</span>        <span class="comment"># 每 3 个 token 采样一个新序列</span></span><br><span class="line">sentences = []  <span class="comment"># 保存所提取的序列</span></span><br><span class="line">next_tokens = []  <span class="comment"># sentences 的下一个 token</span></span><br><span class="line"></span><br><span class="line">token_text = <span class="built_in">list</span>(jieba.cut(text))</span><br><span class="line"></span><br><span class="line">tokens = <span class="built_in">list</span>(<span class="built_in">set</span>(token_text))</span><br><span class="line">tokens_indices = &#123;token: tokens.index(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens&#125;</span><br><span class="line">print(<span class="string">&#x27;Number of tokens:&#x27;</span>, <span class="built_in">len</span>(tokens))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(token_text) - maxlen, step):</span><br><span class="line">    sentences.append(</span><br><span class="line">        <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> t: tokens_indices[t], token_text[i: i+maxlen])))</span><br><span class="line">    next_tokens.append(tokens_indices[token_text[i+maxlen]])</span><br><span class="line">print(<span class="string">&#x27;Number of sequences:&#x27;</span>, <span class="built_in">len</span>(sentences))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目标 one-hot 编码</span></span><br><span class="line">next_tokens_one_hot = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> next_tokens:</span><br><span class="line">    y = np.zeros((<span class="built_in">len</span>(tokens),), dtype=np.<span class="built_in">bool</span>)</span><br><span class="line">    y[i] = <span class="number">1</span></span><br><span class="line">    next_tokens_one_hot.append(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做成数据集</span></span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices((sentences, next_tokens_one_hot))</span><br><span class="line">dataset = dataset.shuffle(buffer_size=<span class="number">4096</span>)</span><br><span class="line">dataset = dataset.batch(<span class="number">128</span>)</span><br><span class="line">dataset = dataset.prefetch(buffer_size=tf.data.experimental.AUTOTUNE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建、编译模型</span></span><br><span class="line"></span><br><span class="line">model = models.Sequential([</span><br><span class="line">    layers.Embedding(<span class="built_in">len</span>(tokens), <span class="number">256</span>),</span><br><span class="line">    layers.LSTM(<span class="number">256</span>),</span><br><span class="line">    layers.Dense(<span class="built_in">len</span>(tokens), activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">optimizer = optimizers.RMSprop(lr=<span class="number">0.1</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=optimizer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">preds, temperature=<span class="number">1.0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    对模型得到的原始概率分布重新加权，并从中抽取一个 token 索引</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    preds = np.asarray(preds).astype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line">    preds = np.log(preds) / temperature</span><br><span class="line">    exp_preds = np.exp(preds)</span><br><span class="line">    preds = exp_preds / np.<span class="built_in">sum</span>(exp_preds)</span><br><span class="line">    probas = np.random.multinomial(<span class="number">1</span>, preds, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> np.argmax(probas)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line">callbacks_list = [</span><br><span class="line">    keras.callbacks.ModelCheckpoint(  <span class="comment"># 在每轮完成后保存权重</span></span><br><span class="line">        filepath=<span class="string">&#x27;text_gen.h5&#x27;</span>,</span><br><span class="line">        monitor=<span class="string">&#x27;loss&#x27;</span>,</span><br><span class="line">        save_best_only=<span class="literal">True</span>,</span><br><span class="line">    ),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(  <span class="comment"># 不再改善时降低学习率</span></span><br><span class="line">        monitor=<span class="string">&#x27;loss&#x27;</span>,</span><br><span class="line">        factor=<span class="number">0.5</span>,</span><br><span class="line">        patience=<span class="number">1</span>,</span><br><span class="line">    ),</span><br><span class="line">    keras.callbacks.EarlyStopping(  <span class="comment"># 不再改善时中断训练</span></span><br><span class="line">        monitor=<span class="string">&#x27;loss&#x27;</span>,</span><br><span class="line">        patience=<span class="number">3</span>,</span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model.fit(dataset, epochs=<span class="number">30</span>, callbacks=callbacks_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本生成</span></span><br><span class="line"></span><br><span class="line">start_index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(text) - maxlen - <span class="number">1</span>)</span><br><span class="line">generated_text = text[start_index: start_index + maxlen]</span><br><span class="line">print(<span class="string">f&#x27; 📖 Generating with seed: &quot;<span class="subst">&#123;generated_text&#125;</span>&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temperature <span class="keyword">in</span> [<span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.2</span>]:</span><br><span class="line">    print(<span class="string">&#x27;\n  🌡️ temperature:&#x27;</span>, temperature)</span><br><span class="line">    print(generated_text, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):    <span class="comment"># 生成 100 个 token</span></span><br><span class="line">        <span class="comment"># 编码当前文本</span></span><br><span class="line">        text_cut = jieba.cut(generated_text)</span><br><span class="line">        sampled = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> text_cut:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> tokens_indices:</span><br><span class="line">                sampled.append(tokens_indices[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sampled.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预测，采样，生成下一个 token</span></span><br><span class="line">        preds = model.predict(sampled, verbose=<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">        next_index = sample(preds, temperature)</span><br><span class="line">        next_token = tokens[next_index]</span><br><span class="line">        print(next_token, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        generated_text = generated_text[<span class="number">1</span>:] + next_token</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我用一些鲁迅的文章去训练，得到的结果大概是这样的：</p><blockquote><p>忘却一样，佳作有些这就……在未庄一阵，但游街正是倒不如是几年攻击罢一堆去再的是有怕就准的话是未庄指也添未庄不朽大家９转５，公共未庄他的他了虽然还成了，但豆种他女人是未庄很的窜的寻也的并我—水生是但收正是本但太爷两个要五是几乎太爷终于硬辫子</p></blockquote><p>可以看到，这些句子都说不通，看着很难受。所以我们还可以把分 token 的方法改一改，不是分词，而是去分句子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text = text.replace(<span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27; ，&#x27;</span>).replace(<span class="string">&#x27;。&#x27;</span>, <span class="string">&#x27; 。&#x27;</span>).replace(<span class="string">&#x27;？&#x27;</span>, <span class="string">&#x27; ？&#x27;</span>).replace(<span class="string">&#x27;：&#x27;</span>, <span class="string">&#x27; ：&#x27;</span>)</span><br><span class="line">token_text = tf.keras.preprocessing.text.text_to_word_sequence(text, split=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>其他的地方基本不变，这样也可以得到比较有意思的文本。比如这是我用一些余秋雨的文章去训练的结果：</p><blockquote><p>几个短衣人物也和他同坐在一处这车立刻走动了，贝壳天气还早，赊了两碗酒没有吃过人的孩子，米要钱买这一点粗浅事情都不知道……天气还早不妨事么他……全屋子都很静这时红鼻子老拱的小曲，而且又破费了二十千的赏钱，他一定须在夜里的十二点钟才回家。</p></blockquote><hr><p>By(“CDFMLR”, “2020-08-20”);</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之模型优化</title>
      <link href="/2020/08/19/DeepLearningWithPython/Deep-Learning%20with-Python-ch7_3/"/>
      <url>/2020/08/19/DeepLearningWithPython/Deep-Learning%20with-Python-ch7_3/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第7章  高级的深度学习最佳实践</strong> (Chapter 7. <em>Advanced deep-learning best practices</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="7-3-Getting-the-most-out-of-your-models"><a href="#7-3-Getting-the-most-out-of-your-models" class="headerlink" title="7.3 Getting the most out of your models"></a>7.3 Getting the most out of your models</h2><blockquote><p>让模型性能发挥到极致</p></blockquote><p>如果你只是想搞出个还不错的模型，无脑随便尝试各种网络架构基本就可以了。但如果你要开发出性能卓越、做到极致的模型，你就需要考虑一下后文给出的技巧。</p><h3 id="高级架构模式"><a href="#高级架构模式" class="headerlink" title="高级架构模式"></a>高级架构模式</h3><p>想要构架卓越的模型，你应该认识「残差连接」、「标准化」和「深度可分离卷积」这几个常用的“设计模式”。</p><h4 id="残差连接"><a href="#残差连接" class="headerlink" title="残差连接"></a>残差连接</h4><blockquote><p>注：这一段是在 7.1 里写的，这里只是复制过来让这一部分更加完整。</p></blockquote><p>残差连接(residual connection) 是一种现在很常用的组件，它解决了大规模深度学习模型梯度消失和表示瓶颈问题。通常，向任何多于 10 层的模型中添加残差连接，都可能会有所帮助。</p><ul><li>梯度消失：就是经过的层多了，之前学到的表示变得模糊，甚至完全丢失，导致网络无法训练。</li><li>表示瓶颈：堆叠起来层，后一层只能访问到前一层学到的东西。如果某一层太小（激活中能够塞入的信息少）就把信息卡下来，出现瓶颈了。</li></ul><p>残差连接是让前面某层的输出作为后面某层的输入（在网络中创造捷径）。前面层的输出并没有与后面层的激活连接在一起，而是与后面层的激活相加（若形状不同，用线性变换将前面层的激活改变成目标形状）。</p><blockquote><p>注：线性变换可以用不带激活的 Dense 层，或着在 CNN 中用不带激活 1×1 卷积。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">x = ...</span><br><span class="line"></span><br><span class="line">y = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">y = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(y)</span><br><span class="line">y = layers.MaxPooling2D(<span class="number">2</span>, strides=<span class="number">2</span>)(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形状不同，要做线性变换：</span></span><br><span class="line">residual = layers.Conv2D(<span class="number">128</span>, <span class="number">1</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)  <span class="comment"># 使用 1×1 卷积，将 x 线性下采样为与 y 具有相同的形状</span></span><br><span class="line"></span><br><span class="line">y = layers.add([y, residual])</span><br></pre></td></tr></table></figure><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>标准化(normalization)，用于让模型看到的不同样本彼此之间更加相似，有助于模型的优化和泛化。</p><p>最常见的数据标准化，就是使数据均值为 0、方差为 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normalized_data = (data - np.mean(data, axis=...)) / np.std(data, axis=...)</span><br></pre></td></tr></table></figure><p>我们都知道在将数据输入模型之前对数据做标准化。但在网络的每一次变换之后，我们也应该考虑数据标准化。每一层输出之后，可能之前的标准化就被破坏了，我们需要考虑这个问题。</p><p><strong>批标准化</strong>(batch normalization)就是解决这个问题的一种方法：训练过程中，它会在内部保存已读取每批数据均值和方差的指数移动平均值。因此，训练过程中均值和方差随时间发生变化，批标准化也可以适应性地将数据标准化。这个方法有助于梯度传播，允许更深的网络（类似于残差连接）。</p><p>Keras 中批标准化用 <code>BatchNormalization</code> 层实现，通常在卷积层或密集连接层之后使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Conv</span></span><br><span class="line">conv_model.add(layers.Conv2D(<span class="number">32</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">conv_model.add(layers.BatchNormalization())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dense</span></span><br><span class="line">dense_model.add(layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">dense_model.add(layers.BatchNormalization())</span><br></pre></td></tr></table></figure><p>BatchNormalization 层接收一个 axis 参数，它指定应该对哪个特征轴做标准化，默认值是 -1。对于 Keras 默认的 Dense、Conv1D、RNN 和 Conv2D 这个都是对的。但对于 <code>data_format</code> 设为 <code>&quot;channels_first&quot;</code> 的 Conv2D，特征轴是 1，所以需要设置 <code>axis=1</code>。</p><h4 id="深度可分离卷积"><a href="#深度可分离卷积" class="headerlink" title="深度可分离卷积"></a>深度可分离卷积</h4><p>深度可分离卷积层(depthwise separable convolution)，在 Keras 中叫写作 <code>SeparableConv2D</code>，作用和普通的 Conv2D 是一样的。但 SeparableConv2D 比 Conv2D 更轻量、训练更快、精度更高。</p><p>SeparableConv2D 层对输入的每个通道分别执行空间卷积，然后通过逐点卷积(1×1 卷积)整合输出结果。这么做就将空间特征学习和通道特征学习分开了，往往能够使用更少的数据学到更好的表示。（这和以前提过的 Xception 模型很类似。事实上，深度可分离卷积是 Xception 架构的基础）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghpi4ytqqvj318a0koadm.jpg" alt="深度可分离卷积: 深度卷积 + 逐点卷积"></p><p>对于数据比较少的数据，从头开始训练的画，这个东西很有用，例如下面是个图像分类任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential, Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">height = <span class="number">64</span></span><br><span class="line">width = <span class="number">64</span></span><br><span class="line">channels = <span class="number">3</span></span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.SeparableConv2D(<span class="number">32</span>, <span class="number">3</span>, </span><br><span class="line">                                 activation=<span class="string">&#x27;relu&#x27;</span>, </span><br><span class="line">                                 input_shape=(height, width, channels,)))</span><br><span class="line">model.add(layers.SeparableConv2D(<span class="number">64</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.SeparableConv2D(<span class="number">64</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.SeparableConv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.SeparableConv2D(<span class="number">64</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.SeparableConv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.GlobalAveragePooling2D())</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对于更大型的任务时，上 Xception 就更好了。</p><h3 id="超参数优化"><a href="#超参数优化" class="headerlink" title="超参数优化"></a>超参数优化</h3><p>除了使用高级架构模式，超参数优化也是个值得一提的工作。我们写模型的时候需要决定很多超参数：</p><p>模型中堆叠多少层，每层包含多少个单元，用什么激活函数……</p><p>调节这些超参数并没有固定的规则，主要是靠直觉和反复实验。这种反复实验，可能性太多，各种超参数的组合，太复杂了。一天到晚调超参数就不是人干的事，这种事情还是给机器自己去做比较好。所以我们要指定一个可以程序化的超参数调节流程：</p><ol><li>选择一组超参数</li><li>构建相应的模型</li><li>将模型在小批量数据上拟合、验证性能</li><li>选择要尝试的下一组超参数</li><li>重复上述过程（2～4）</li><li>选出上面实验中的最佳超参数</li></ol><p>这个过程的关键在于，给定多组可选的超参数，利用「历史验证性能」来自动选择下一组需要评估的超参数。可以用「简单随机搜索」、「贝叶斯优化」、「遗传算法」等算法完成这个工作。</p><p>更新超参数其实是很难的，每次尝试的计算代价太大，每次都要从头训练一次；而且超参数是不连续、不可微的，不能用梯度下降之类的算法。</p><p>所以，其实自动的超参数优化现在还不成熟，可用的工具十分有限。不过还是有好些库可以用来自动调节 Keras 的超参数的:</p><ul><li><a href="https://github.com/maxpumperla/hyperas">Hyperas</a>，这个库比较老牌，也是书上提到的，但截止 2020 年 8 月，已经好几个月没提交了；</li><li><a href="https://github.com/keras-team/keras-tuner">Keras Tuner</a> ，这个库比较新，是我前几天看到的，Star 数已经和 Hyperas 持平了。</li><li>…</li></ul><p><strong>注意</strong>：自动超参数的调节，本质上是在验证数据上训练超参数。在做大规模超参数自动优化时，一定要注意，验证集过拟合的问题！</p><h3 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h3><p>模型集成(model ensembling)，也是一种很强大的技术。模型集成，是指将一系列不同模型的预测结果汇集到一起，从而得到更好的预测结果。</p><p>对于同一个问题，不同的模型，虽然可能都能比较好的解决问题，但正如盲人摸象，可能每个模型都得到了数据真相的一部分，但不是全部真相。将各种观点汇集在一起，就可能得到对数据更加准确的描述。在这种想法下，可以说，将很多模型集成到一起，必然可以打败任何单个模型。</p><p>对于模型集成，使用的模型的多样性十分重要。Diversity is strength. 用来集成的模型应该尽可能好，同时尽可能不同。相同的网络，使用不同的随机初始化多次独立训练，然后集成，这样意义就不大了。更好的做法应该是使用架构非常不同的模型去集成，这样各个模型的偏差在不同方向上，集成让偏差会彼此抵消，结果才会更加稳定、准确。</p><p>以分类问题为例，首先，我们有了一些不同的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preds_a = model_a.predict(x_val)</span><br><span class="line">preds_b = model_b.predict(x_val)</span><br><span class="line">preds_c = model_c.predict(x_val)</span><br><span class="line">preds_d = model_d.predict(x_val)</span><br></pre></td></tr></table></figure><p>可以用多种不同的方法来集成它们，最简单的办法是，取平均：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_preds = <span class="number">0.25</span> * (preds_a + preds_b + preds_c + preds_d)</span><br></pre></td></tr></table></figure><p>由于每一个模型的性能会有差距，所以更好的办法是加权平均：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_preds = <span class="number">0.5</span> * preds_a + <span class="number">0.25</span> * preds_b + <span class="number">0.1</span> * preds_c + <span class="number">0.15</span> * preds_d</span><br></pre></td></tr></table></figure><p>其中的权重，可以使用基于经验给出、使用随机搜索或者其他优化算法得到。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之Keras回调函数与TensorBoard</title>
      <link href="/2020/08/18/DeepLearningWithPython/Deep-Learning%20with-Python-ch7_2/"/>
      <url>/2020/08/18/DeepLearningWithPython/Deep-Learning%20with-Python-ch7_2/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第7章  高级的深度学习最佳实践</strong> (Chapter 7. <em>Advanced deep-learning best practices</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="7-2-Inspecting-and-monitoring-deep-learning-models-using-Keras-callbacks-and-TensorBoard"><a href="#7-2-Inspecting-and-monitoring-deep-learning-models-using-Keras-callbacks-and-TensorBoard" class="headerlink" title="7.2 Inspecting and monitoring deep-learning models using Keras callbacks and TensorBoard"></a>7.2 Inspecting and monitoring deep-learning models using Keras callbacks and TensorBoard</h2><blockquote><p>使用 Keras 回调函数和 TensorBoard 来检查并监控深度学习模型</p></blockquote><p>用 model.fit() 开启一个复杂的训练任务后，我们就只能干等着，在结束前都不知道它有没有正确工作，也无法控制它，好似抛出了一架纸飞机，任它随风去往不确定的远方。比起这样不受控制的纸飞机，或许我们更希望要一台智能的无人机，可以感知环境，将数据发回给我们，并基于当前状态自主航行。 Keras 的回调函数与 TensorBoard 这样的工具就可以帮我们把“纸飞机”改造成“智能的无人机”。</p><h3 id="训练中将回调函数作用于模型"><a href="#训练中将回调函数作用于模型" class="headerlink" title="训练中将回调函数作用于模型"></a>训练中将回调函数作用于模型</h3><p>我们在训练模型的时候，一开始是不知道要跑多少轮的，我们只能让它跑足够多的轮次，然后手动找出一个最佳的轮次数，重新用这个最佳轮次数去训练模型，这样相当耗时。所以，我们更希望当模型观测到验证损失不再改善时就自动停止训练。</p><p>这种操作就可以用 Keras 回调函数（callback）完成：Keras 提供了很多有用的 callback，放在 <code>keras.callbacks</code> 里，自动停止训练只是其中一种用法。</p><p>Callback 会在训练过程中的不同时间点被模型调用，它可以访问模型的状态，并可以采取一些行动，例如：</p><ul><li>模型检查点：在训练过程中的不同时间点保存模型的当前权重</li><li>提前终止：验证损失不再改善时中断训练</li><li>动态调节参数值：例如动态调整优化器的学习率</li><li>记录训练指标和验证指标：用这些指标就可以将模型学到的表示可视化</li><li>…</li></ul><h4 id="使用-callback"><a href="#使用-callback" class="headerlink" title="使用 callback"></a>使用 callback</h4><p>Keras 内置了许多有用的 callback，例如：</p><ul><li><code>ModelCheckpoint</code>：在训练过程中保存训练到某些状态的模型。可以用来持续不断地保存模型，也可以选择性地保存目前的最佳模型；</li><li><code>EarlyStopping</code>：监控的目标指标，如果在设定的轮数内不再改善，则中断训练；</li><li><code>ReduceLROnPlateau</code>：在验证损失不再改善时（遇到loss plateau），降低学习率。</li></ul><p>这些 callback 的使用也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">callbacks_list = [</span><br><span class="line">    <span class="comment"># 在每轮完成后保存权重</span></span><br><span class="line">    keras.callbacks.ModelCheckpoint(</span><br><span class="line">        filepath=<span class="string">&#x27;my_model.h5&#x27;</span>,  <span class="comment"># 保存文件的路径</span></span><br><span class="line">        monitor=<span class="string">&#x27;val_loss&#x27;</span>,      <span class="comment"># monitor：要验证的指标</span></span><br><span class="line">        save_best_only=<span class="literal">True</span>,     <span class="comment"># 只保存让 monitor 指标最好的模型（如果 monitor 没有改善，就不保存）</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 不再改善时中断训练</span></span><br><span class="line">    keras.callbacks.EarlyStopping(</span><br><span class="line">        monitor=<span class="string">&#x27;acc&#x27;</span>,           <span class="comment"># 要验证的指标</span></span><br><span class="line">        patience=<span class="number">10</span>,             <span class="comment"># 如果 monitor 在多于 patience 轮内（比如这里就是10+1=11轮）没有改善，则中断训练</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 不再改善时降低学习率</span></span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(</span><br><span class="line">        monitor=<span class="string">&#x27;val_loss&#x27;</span>,    <span class="comment"># 要验证的指标</span></span><br><span class="line">        factor=<span class="number">0.1</span>,            <span class="comment"># 触发时：学习率 *= factor</span></span><br><span class="line">        patience=<span class="number">5</span>,            <span class="comment"># monitor 在 patience 轮内没有改善，则触发降低学习率</span></span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, </span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])    <span class="comment"># 在 callback 里用到了 acc 做指标，所以这里的 metrics 里要有 acc</span></span><br><span class="line"></span><br><span class="line">model.fit(x, y, </span><br><span class="line">          epochs=<span class="number">10</span>, </span><br><span class="line">          batch_size=<span class="number">32</span>, </span><br><span class="line">          callbacks=callbacks_list,     <span class="comment"># 训练时使用这些回调</span></span><br><span class="line">          validation_data=(x_val, y_val))  <span class="comment"># callback 里用到了 val，所以这里必须有 val</span></span><br></pre></td></tr></table></figure><h4 id="编写自己的回调函数"><a href="#编写自己的回调函数" class="headerlink" title="编写自己的回调函数"></a>编写自己的回调函数</h4><p>除了使用 Keras 内置的回调，还可以自己写 callback 来完成内置没有的操作。</p><p>自己写回调通过创建 <code>keras.callbacks.Callback</code> 的子类来实现。和写游戏脚本很类似，在这个子类中实现一些方法，然后这些方法就会在训练过程中的特定时间点被调用：</p><table><thead><tr><th>方法</th><th>被调用的时间</th></tr></thead><tbody><tr><td>on_epoch_begin</td><td>在每轮开始时被调用</td></tr><tr><td>on_epoch_end</td><td>在每轮结束时被调用</td></tr><tr><td></td><td></td></tr><tr><td>on_batch_begin</td><td>在处理每个批量之前被调用</td></tr><tr><td>on_batch_end</td><td>在处理每个批量之后被调用</td></tr><tr><td></td><td></td></tr><tr><td>on_train_begin</td><td>在训练开始时被调用</td></tr><tr><td>on_train_end</td><td>在训练结束时被调用</td></tr></tbody></table><p>这些方法接受一个 logs 参数（dict类型的），里面包含前一个epoch 或 batch 或 train 的信息，包括训练指标、验证指标之类的。</p><p>在这些方法中，还可以访问：</p><ul><li><code>self.model</code>: 调用回调的模型实例;</li><li><code>self.validation_data</code>: fit 传入的验证数据;</li></ul><p>例如，我们编写一个自定义回调函数，在每轮结束后将模型每层对验证集的第一个样本的激活计算值保存下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivationLogger</span>(<span class="params">keras.callbacks.Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_model</span>(<span class="params">self, model</span>):</span>  <span class="comment"># 在训练之前由父模型调用，告诉回调函数是哪个模型在调用它</span></span><br><span class="line">        self.model = model</span><br><span class="line">        layer_outputs = [layer.output <span class="keyword">for</span> layer <span class="keyword">in</span> model.layers]</span><br><span class="line">        self.activations_model = keras.models.Model(model.<span class="built_in">input</span>, layer_outputs)  <span class="comment"># 模型实例，返回每层的激活</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span>(<span class="params">self, epoch, logs=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.validation_data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Requires validation_data.&#x27;</span>)</span><br><span class="line">        validation_sample = self.validation_data[<span class="number">0</span>][<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">        activations = self.activations_model.predict(validation_sample)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;activations_at_epoch_<span class="subst">&#123;epoch&#125;</span>.npz&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            np.savez(f, activations)</span><br></pre></td></tr></table></figure><h3 id="TensorBoard-简介-TensorFlow-的可视化框架"><a href="#TensorBoard-简介-TensorFlow-的可视化框架" class="headerlink" title="TensorBoard 简介: TensorFlow 的可视化框架"></a>TensorBoard 简介: TensorFlow 的可视化框架</h3><p>为了做出更好模型，除了思考构架、编写代码，我们还需要获取关于模型的信息、了解训练过程中模型内部正在发生什么，并用这些信息来知道我们再思考、再优化模型。</p><p>思考是在你的脑子里完成的，编写模型的代码可以用 Keras API 轻松实现，而了解模型可以借用 TensorBoard。TensorBoard 是内置于 TensorFlow 中的基于浏览器的可视化工具，它能在训练过程中让你可视化地监控模型内部发生的一切。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp9tjfuzcj312g0d6acp.jpg" alt="取得进展的循环"></p><p>TensorBoard 主要有一下几个作用：</p><ul><li>在训练过程中以可视化的方式监控指标</li><li>将模型架构可视化</li><li>将激活和梯度的直方图可视化</li><li>以三维的形式研究嵌入</li></ul><p>我们在 IMDB 情感分析任务上训练一个一维卷积神经网络，来演示 TensorBoard 的使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> sequence</span><br><span class="line"></span><br><span class="line">max_features = <span class="number">2000</span></span><br><span class="line">max_len = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_features)</span><br><span class="line">x_train = sequence.pad_sequences(x_train, maxlen=max_len)</span><br><span class="line">x_test = sequence.pad_sequences(x_test, maxlen=max_len)</span><br><span class="line"></span><br><span class="line">model = keras.models.Sequential()</span><br><span class="line">model.add(layers.Embedding(max_features, <span class="number">128</span>,</span><br><span class="line">                           input_length=max_len,</span><br><span class="line">                           name=<span class="string">&#x27;embed&#x27;</span>))</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">7</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPool1D(<span class="number">5</span>))</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">7</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.GlobalMaxPooling1D())</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embed (Embedding)            (None, 500, 128)          256000    _________________________________________________________________conv1d (Conv1D)              (None, 494, 32)           28704     _________________________________________________________________max_pooling1d (MaxPooling1D) (None, 98, 32)            0         _________________________________________________________________conv1d_1 (Conv1D)            (None, 92, 32)            7200      _________________________________________________________________global_max_pooling1d (Global (None, 32)                0         _________________________________________________________________dense (Dense)                (None, 1)                 33        =================================================================Total params: 291,937Trainable params: 291,937Non-trainable params: 0_________________________________________________________________</code></pre><p>要使用 TensorBoard，在开始训练之前还需要做一些准备。首先，为 TensorBoard 需要的日志文件创建一个目录，并开启 TensorBoard 的服务。在 shell 里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir my_log_dir</span></span><br></pre></td></tr></table></figure><p>或者，在 Jupyter Notebook 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mkdir my_log_dir</span><br></pre></td></tr></table></figure><p>然后，实例化一个 TensorBoard 回调函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tensorboard_callback = tf.keras.callbacks.TensorBoard(</span><br><span class="line">    log_dir=<span class="string">&#x27;my_log_dir&#x27;</span>,  <span class="comment"># 日志文件的储存位置</span></span><br><span class="line">    histogram_freq=<span class="number">1</span>,      <span class="comment"># 每 histogram_freq 轮之后记录激活直方图</span></span><br><span class="line">    embeddings_freq=<span class="number">1</span>,     <span class="comment"># 每 histogram_freq 轮之后记录词嵌入</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后，在训练时使用这个回调就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history = model.fit(x_train, y_train, </span><br><span class="line">                    epochs=<span class="number">20</span>, </span><br><span class="line">                    batch_size=<span class="number">128</span>, </span><br><span class="line">                    validation_split=<span class="number">0.2</span>, </span><br><span class="line">                    callbacks=[tensorboard_callback])</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/20157/157 [==============================] - 25s 156ms/step - loss: 0.6376 - acc: 0.6424 - val_loss: 0.7053 - val_acc: 0.7210Epoch 2/20157/157 [==============================] - 24s 152ms/step - loss: 0.4426 - acc: 0.8489 - val_loss: 0.5328 - val_acc: 0.8378Epoch 3/20157/157 [==============================] - 25s 161ms/step - loss: 0.3988 - acc: 0.8807 - val_loss: 0.4488 - val_acc: 0.8688Epoch 4/20157/157 [==============================] - 24s 155ms/step - loss: 0.3680 - acc: 0.8965 - val_loss: 0.5022 - val_acc: 0.8714Epoch 5/20157/157 [==============================] - 25s 162ms/step - loss: 0.3123 - acc: 0.9168 - val_loss: 0.4771 - val_acc: 0.8688Epoch 6/20157/157 [==============================] - 25s 162ms/step - loss: 0.2550 - acc: 0.9387 - val_loss: 0.7022 - val_acc: 0.8640Epoch 7/20157/157 [==============================] - 24s 156ms/step - loss: 0.2419 - acc: 0.9470 - val_loss: 0.7245 - val_acc: 0.8758Epoch 8/20157/157 [==============================] - 27s 170ms/step - loss: 0.1864 - acc: 0.9671 - val_loss: 0.8042 - val_acc: 0.8718Epoch 9/20157/157 [==============================] - 30s 189ms/step - loss: 0.1548 - acc: 0.9776 - val_loss: 0.9950 - val_acc: 0.8490Epoch 10/20157/157 [==============================] - 36s 228ms/step - loss: 0.1361 - acc: 0.9844 - val_loss: 0.8995 - val_acc: 0.8714Epoch 11/20157/157 [==============================] - 35s 220ms/step - loss: 0.1297 - acc: 0.9858 - val_loss: 0.9611 - val_acc: 0.8694Epoch 12/20157/157 [==============================] - 33s 210ms/step - loss: 0.1184 - acc: 0.9884 - val_loss: 1.0366 - val_acc: 0.8706Epoch 13/20157/157 [==============================] - 29s 187ms/step - loss: 0.1156 - acc: 0.9877 - val_loss: 1.0596 - val_acc: 0.8700Epoch 14/20157/157 [==============================] - 30s 191ms/step - loss: 0.1101 - acc: 0.9894 - val_loss: 1.1298 - val_acc: 0.8566Epoch 15/20157/157 [==============================] - 25s 162ms/step - loss: 0.1098 - acc: 0.9903 - val_loss: 1.1452 - val_acc: 0.8652Epoch 16/20157/157 [==============================] - 26s 166ms/step - loss: 0.1058 - acc: 0.9909 - val_loss: 1.1963 - val_acc: 0.8692Epoch 17/20157/157 [==============================] - 26s 165ms/step - loss: 0.1119 - acc: 0.9903 - val_loss: 1.2531 - val_acc: 0.8686Epoch 18/20157/157 [==============================] - 30s 190ms/step - loss: 0.1058 - acc: 0.9914 - val_loss: 1.2296 - val_acc: 0.8678Epoch 19/20157/157 [==============================] - 25s 161ms/step - loss: 0.1056 - acc: 0.9916 - val_loss: 1.2272 - val_acc: 0.8666Epoch 20/20157/157 [==============================] - 25s 160ms/step - loss: 0.1086 - acc: 0.9904 - val_loss: 1.2287 - val_acc: 0.8682</code></pre><p>开始训练之后，就可以开启 TensorBoard 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tensorboard --logdir=my_log_dir</span></span><br></pre></td></tr></table></figure><p>或者在 Jupyter Notebook 里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%load_ext tensorboard</span><br><span class="line">%tensorboard --logdir=my_log_dir</span><br></pre></td></tr></table></figure><p>现在就可以在浏览器中打开 <code>http://localhost:6006</code> 来查看 TensorBoard 的可视化模型的训练过程了。</p><ul><li>Scalars 标签页中，可以看到训练过程中精度、损失的变化曲线，和我们之前每次训练完之后用 plt 画的是同样的内容，不过在  TensorBoard 里你可以随时刷新去看，不用等到训练完成；</li><li>Graph 标签页中，显示的是 Keras 模型背后的底层 TensorFlow 运算图的可视化，这个底层运算图比我们的 Keras 模型复杂，这就是 Keras 为我们简化的工作，Keras 让我们不去接触那些复杂的东西，让工作流程变得非常简单；如果你想看 Keras 模型本身的图表示，可以用 <code>keras.utils.plot_model</code>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.keras.utils.plot_model(model, show_shapes=<span class="literal">True</span>, to_file=<span class="string">&#x27;model.png&#x27;</span>)</span><br><span class="line"><span class="comment"># show_shapes=True 可以把各层的输入输出张量形状显示出来</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghurzd5lj0j30fd0jzq4p.jpg" alt="png"></p><ul><li>Histograms 标签页中，有每层的激活值直方图；</li><li>Projector 标签页中，有我们的词表中 2000 个单词的词嵌入空间关系。这是由 Embedding 层学习到的 128 维的嵌入空间用 PCA 之类的算法降到 2 维或者 3 维后得到的“投影”影像。如果你对里面每个点的意义感兴趣，可以点击某个点，查看其编号，然后用下面的代码还原出单词来看看：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index_word = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> imdb.get_word_index().items()&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_word_of_index</span>(<span class="params">idx</span>):</span>  <span class="comment"># idx 输入看到的词编号</span></span><br><span class="line">    print(index_word[idx])</span><br><span class="line"></span><br><span class="line">show_word_of_index(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><pre><code>ever</code></pre>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之Keras函数式API</title>
      <link href="/2020/08/17/DeepLearningWithPython/Deep-Learning%20with-Python-ch7_1/"/>
      <url>/2020/08/17/DeepLearningWithPython/Deep-Learning%20with-Python-ch7_1/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第7章  高级的深度学习最佳实践</strong> (Chapter 7. <em>Advanced deep-learning best practices</em>) 的笔记之一。</p><p>[TOC]</p><h2 id="7-1-Going-beyond-the-Sequential-model-the-Keras-functional-API"><a href="#7-1-Going-beyond-the-Sequential-model-the-Keras-functional-API" class="headerlink" title="7.1 Going beyond the Sequential model: the Keras functional API"></a>7.1 Going beyond the Sequential model: the Keras functional API</h2><blockquote><p>不用 Sequential 模型的解决方案：Keras 函数式 API</p></blockquote><p>我们之前用的 Sequential 模型是最基础、但常用的一种模型，它只有一个输入和一个输出，整个网络由层线性堆叠而成。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghntkt18rxj30co0hi0tn.jpg" alt="Sequential 模型:层的线性堆叠"></p><p>但是，有时我们的网络需要多个输入。比如预测衣服价格，输入商品信息、文本描述、图片，这三类信息应该分别用 Dense、RNN、CNN 处理，提取出信息后用一个合并模块把所有各种信息综合起来最终预测价格：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghntomauikj30vo0c03zu.jpg" alt="一个多输入模型"></p><p>也有时，我们的网络需要多个输出（多个头）。比如输入一个小说，我们希望得到小说的分类，并推测写作时间。这个问题应该使用一个共用的模块去处理文本，提取信息，然后分别交给小说分类器、日期回归器去预测分类、写作时间：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghntrygsgsj30oq0jstak.jpg" alt="一个多输出(或多头)模型"></p><p>还有时，有些复杂的网络会使用非线性的网络拓扑结构。比如一种叫 Inception 的东西，输入会被多个并行的卷积分支处理，然后将这些分支的输出合并为单个张量；还有种叫 residual connection （残差连接）的方法，将前面的输出张量与后面的输出张量相加，从而将前面的表示重新注入下游数据流中，防止信息处理流程中的信息损失：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghntzbsxzoj31880miaic.jpg" alt="Inception 模块:层组成的子图，具有多个并行卷积分支；残差连接:通过特征图相加将前面的信息重新注入下游数据"></p><p>这些网络都是图状(graph-like)的，是个网络结构，而不是 Sequential 那样的线性堆叠。要在 Keras 中实现这种复杂的模型，就需要使用 Keras 的函数式 API。</p><h3 id="函数式-API"><a href="#函数式-API" class="headerlink" title="函数式 API"></a>函数式 API</h3><p>Keras 的函数式 API 把层当作函数来使用，接收张量并返回张量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Input, layers</span><br><span class="line"></span><br><span class="line">input_tensor = Input(shape=(<span class="number">32</span>, ))    <span class="comment"># 输入张量</span></span><br><span class="line">dense = layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>)    <span class="comment"># 层函数</span></span><br><span class="line">output_tensor = dense(input_tensor)   <span class="comment"># 输出张量 </span></span><br></pre></td></tr></table></figure><p>我们来用函数式 API 构建一个简单网络，和 Sequential 做比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sequential 模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">seq_model = Sequential()</span><br><span class="line">seq_model.add(layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">64</span>, )))</span><br><span class="line">seq_model.add(layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">seq_model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">seq_model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_1 (Dense)              (None, 32)                2080      _________________________________________________________________dense_2 (Dense)              (None, 32)                1056      _________________________________________________________________dense_3 (Dense)              (None, 10)                330       =================================================================Total params: 3,466Trainable params: 3,466Non-trainable params: 0_________________________________________________________________</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数式 API 模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">input_tensor = Input(shape=(<span class="number">64</span>, ))</span><br><span class="line">x = layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(input_tensor)</span><br><span class="line">x = layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">output_tensor = layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">func_model = Model(input_tensor, output_tensor)</span><br><span class="line"></span><br><span class="line">func_model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;functional_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================input_2 (InputLayer)         [(None, 64)]              0         _________________________________________________________________dense_4 (Dense)              (None, 32)                2080      _________________________________________________________________dense_5 (Dense)              (None, 32)                1056      _________________________________________________________________dense_6 (Dense)              (None, 10)                330       =================================================================Total params: 3,466Trainable params: 3,466Non-trainable params: 0_________________________________________________________________</code></pre><p>Model 对象实例化的时候，只需给出输入张量和输入张量变换(经过各种层)得到的输出张量。Keras 会在自动找出从 input_tensor 到 output_tensor 所包含的每一层，并将这些层组合成一个图状的数据结构——一个 Model。</p><p>注意，output_tensor 必须是由对应的 input_tensor 变换得到的。如果用不相关的输入张量和输出张量来构建 Model，会爆 Graph disconnected 的 ValueError (书上写的 keras 是 RuntimeError，tf.keras 是 ValueError)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unrelated_input = Input(shape=(<span class="number">32</span>,))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bad_model = Model(unrelated_input, output_tensor)</span><br><span class="line"><span class="meta">... </span><span class="comment"># Traceback</span></span><br><span class="line">ValueError: Graph disconnected: cannot obtain value <span class="keyword">for</span> tensor Tensor(<span class="string">&quot;input_2:0&quot;</span>, shape=(<span class="literal">None</span>, <span class="number">64</span>), dtype=float32) at layer <span class="string">&quot;dense_4&quot;</span>. The following previous layers were accessed without issue: []</span><br></pre></td></tr></table></figure><p>也就是说，无法从指定的输入连接到输出形成一张图（Graph，那种数据结构，网络的那种）啦。</p><p>对这种函数式 API 构建的网络，编译、训练或评估都和 Sequential 相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">func_model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机训练数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x_train = np.random.random((<span class="number">1000</span>, <span class="number">64</span>))</span><br><span class="line">y_train = np.random.random((<span class="number">1000</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">func_model.fit(x_train, y_train, epochs=<span class="number">10</span>, batch_size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估</span></span><br><span class="line">score = func_model.evaluate(x_train, y_train)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/108/8 [==============================] - 0s 1ms/step - loss: 33.5245Epoch 2/108/8 [==============================] - 0s 1ms/step - loss: 38.1499Epoch 3/108/8 [==============================] - 0s 2ms/step - loss: 42.0662Epoch 4/108/8 [==============================] - 0s 1ms/step - loss: 46.1707Epoch 5/108/8 [==============================] - 0s 813us/step - loss: 50.6095Epoch 6/108/8 [==============================] - 0s 1ms/step - loss: 54.8778Epoch 7/108/8 [==============================] - 0s 1ms/step - loss: 59.6547Epoch 8/108/8 [==============================] - 0s 1ms/step - loss: 64.5255Epoch 9/108/8 [==============================] - 0s 1ms/step - loss: 69.2659Epoch 10/108/8 [==============================] - 0s 685us/step - loss: 74.570732/32 [==============================] - 0s 617us/step - loss: 78.1296</code></pre><h3 id="多输入模型"><a href="#多输入模型" class="headerlink" title="多输入模型"></a>多输入模型</h3><p>函数式 API 可用于构建具有多个输入的模型。多个输入的模型，通常会在某个点把不同分支用一个可以组合张量的层合并起来。组合张量，可以用相加、连接等，在 keras 中提供了诸如 <code>keras.layers.add</code>、<code>keras.layers.concatenate</code> 等的层来完成这些操作。</p><p>看一个具体的例子，做一个问答模型。典型的问答模型要使用两个输入：</p><ul><li>问题文本</li><li>提供用于回答问题的信息文本(比如相关的新闻文章)</li></ul><p>模型要生成（输出）一个回答。最简单的情况是只回答一个词，我们可以通过面向某些预定义的词表，把输出做 softmax 得到结果。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnvld5q4aj310q0imq4k.jpg" alt="问答模型"></p><p>用函数式 API 来实现这个模型，我们先构建两个独立分支，将 reference text 和 question 分别表示成向量，然后连接这两个向量，在连接完成等到的表示上添加一个 softmax 分类器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Input</span><br><span class="line"></span><br><span class="line">text_vocabulary_size = <span class="number">10000</span></span><br><span class="line">question_vocabulary_size = <span class="number">10000</span></span><br><span class="line">answer_vocabulary_size = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考</span></span><br><span class="line">text_input = Input(shape=(<span class="literal">None</span>, ), dtype=<span class="string">&#x27;int32&#x27;</span>, name=<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">embedded_text = layers.Embedding(text_vocabulary_size, <span class="number">64</span>)(text_input)</span><br><span class="line">encoded_text = layers.LSTM(<span class="number">32</span>)(embedded_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题</span></span><br><span class="line">question_input = Input(shape=(<span class="literal">None</span>, ), dtype=<span class="string">&#x27;int32&#x27;</span>, name=<span class="string">&#x27;question&#x27;</span>)</span><br><span class="line">embedded_question = layers.Embedding(question_vocabulary_size, <span class="number">32</span>)(question_input)</span><br><span class="line">encoded_question = layers.LSTM(<span class="number">16</span>)(embedded_question)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并参考、问题分支</span></span><br><span class="line">concatenated = layers.concatenate([encoded_text, encoded_question], axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顶层分类器</span></span><br><span class="line">answer = layers.Dense(anser_vocabulary_size, activation=<span class="string">&#x27;softmax&#x27;</span>)(concatenated)</span><br><span class="line"></span><br><span class="line">model = Model([text_input, question_input], answer, name=<span class="string">&#x27;QA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, </span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;QA&quot;__________________________________________________________________________________________________Layer (type)                    Output Shape         Param #     Connected to                     ==================================================================================================text (InputLayer)               [(None, None)]       0                                            __________________________________________________________________________________________________question (InputLayer)           [(None, None)]       0                                            __________________________________________________________________________________________________embedding_13 (Embedding)        (None, None, 64)     640000      text[0][0]                       __________________________________________________________________________________________________embedding_14 (Embedding)        (None, None, 32)     320000      question[0][0]                   __________________________________________________________________________________________________lstm_13 (LSTM)                  (None, 32)           12416       embedding_13[0][0]               __________________________________________________________________________________________________lstm_14 (LSTM)                  (None, 16)           3136        embedding_14[0][0]               __________________________________________________________________________________________________concatenate_6 (Concatenate)     (None, 48)           0           lstm_13[0][0]                                                                                     lstm_14[0][0]                    __________________________________________________________________________________________________dense_13 (Dense)                (None, 500)          24500       concatenate_6[0][0]              ==================================================================================================Total params: 1,000,052Trainable params: 1,000,052Non-trainable params: 0__________________________________________________________________________________________________</code></pre><p>在训练这种多输入模型的时候，可以传输入组成的列表，对于指定了 name 的 input 也可以传一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">num_samples = <span class="number">1000</span></span><br><span class="line">max_length = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">text = np.random.randint(<span class="number">1</span>, text_vocabulary_size, </span><br><span class="line">                         size=(num_samples, max_length))</span><br><span class="line">question = np.random.randint(<span class="number">1</span>, question_vocabulary_size, </span><br><span class="line">                             size=(num_samples, max_length))</span><br><span class="line">answers = np.random.randint(<span class="number">0</span>, <span class="number">1</span>, </span><br><span class="line">                            size=(num_samples, answer_vocabulary_size)) <span class="comment"># one-hot 编码的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1. 传列表</span></span><br><span class="line">model.fit([text, question], answers, epochs=<span class="number">2</span>, batch_size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2. 传字典</span></span><br><span class="line">model.fit(&#123;<span class="string">&#x27;text&#x27;</span>: text, <span class="string">&#x27;question&#x27;</span>: question&#125;, answers, epochs=<span class="number">2</span>, batch_size=<span class="number">128</span>)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/28/8 [==============================] - 0s 54ms/step - loss: 0.0000e+00 - acc: 0.0000e+00Epoch 2/28/8 [==============================] - 0s 57ms/step - loss: 0.0000e+00 - acc: 0.0000e+00Epoch 1/28/8 [==============================] - 0s 53ms/step - loss: 0.0000e+00 - acc: 0.0000e+00Epoch 2/28/8 [==============================] - 0s 54ms/step - loss: 0.0000e+00 - acc: 0.0000e+00&lt;tensorflow.python.keras.callbacks.History at 0x13e55f9d0&gt;</code></pre><h3 id="多输出模型"><a href="#多输出模型" class="headerlink" title="多输出模型"></a>多输出模型</h3><p>用函数式 API 来构建具有多个输出(多头)的模型也很方便。例如，我们要做一个试图同时预测数据的不同性质的网络：输入某人的一些社交媒体发帖，尝试预测该人的年龄、性别和收入水平属性：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gho2fgeqwrj30q40bit9u.jpg" alt="具有三个头的社交媒体模型"></p><p>具体的实现很简单，在最后分别写 3 个不同的输出就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Conv1D, MaxPooling1D, GlobalMaxPool1D, Dense</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line">vocabulary_size = <span class="number">50000</span></span><br><span class="line">num_income_groups = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">posts_input = Input(shape=(<span class="literal">None</span>,), dtype=<span class="string">&#x27;int32&#x27;</span>, name=<span class="string">&#x27;posts&#x27;</span>)</span><br><span class="line">embedded_post = layers.Embedding(<span class="number">256</span>, vocabulary_size)(posts_input)</span><br><span class="line">x = Conv1D(<span class="number">128</span>, <span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(embedded_post)</span><br><span class="line">x = MaxPooling1D(<span class="number">5</span>)(x)</span><br><span class="line">x = Conv1D(<span class="number">256</span>, <span class="number">5</span>, activation=<span class="string">&quot;relu&quot;</span>)(x)</span><br><span class="line">x = Conv1D(<span class="number">256</span>, <span class="number">5</span>, activation=<span class="string">&quot;relu&quot;</span>)(x)</span><br><span class="line">x = MaxPooling1D(<span class="number">5</span>)(x)</span><br><span class="line">x = Conv1D(<span class="number">256</span>, <span class="number">5</span>, activation=<span class="string">&quot;relu&quot;</span>)(x)</span><br><span class="line">x = Conv1D(<span class="number">256</span>, <span class="number">5</span>, activation=<span class="string">&quot;relu&quot;</span>)(x)</span><br><span class="line">x = GlobalMaxPool1D()(x)</span><br><span class="line">x = Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多个头（输出）</span></span><br><span class="line">age_prediction = Dense(<span class="number">1</span>, name=<span class="string">&#x27;age&#x27;</span>)(x)</span><br><span class="line">income_prediction = Dense(num_income_groups, activation=<span class="string">&#x27;softmax&#x27;</span>, name=<span class="string">&#x27;income&#x27;</span>)(x)</span><br><span class="line">gender_prediction = Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>, name=<span class="string">&#x27;gender&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">model = Model(posts_input, [age_prediction, income_prediction, gender_prediction])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;functional_6&quot;__________________________________________________________________________________________________Layer (type)                    Output Shape         Param #     Connected to                     ==================================================================================================posts (InputLayer)              [(None, None)]       0                                            __________________________________________________________________________________________________embedding_15 (Embedding)        (None, None, 50000)  12800000    posts[0][0]                      __________________________________________________________________________________________________conv1d (Conv1D)                 (None, None, 128)    32000128    embedding_15[0][0]               __________________________________________________________________________________________________max_pooling1d (MaxPooling1D)    (None, None, 128)    0           conv1d[0][0]                     __________________________________________________________________________________________________conv1d_1 (Conv1D)               (None, None, 256)    164096      max_pooling1d[0][0]              __________________________________________________________________________________________________conv1d_2 (Conv1D)               (None, None, 256)    327936      conv1d_1[0][0]                   __________________________________________________________________________________________________max_pooling1d_1 (MaxPooling1D)  (None, None, 256)    0           conv1d_2[0][0]                   __________________________________________________________________________________________________conv1d_3 (Conv1D)               (None, None, 256)    327936      max_pooling1d_1[0][0]            __________________________________________________________________________________________________conv1d_4 (Conv1D)               (None, None, 256)    327936      conv1d_3[0][0]                   __________________________________________________________________________________________________global_max_pooling1d (GlobalMax (None, 256)          0           conv1d_4[0][0]                   __________________________________________________________________________________________________dense_14 (Dense)                (None, 128)          32896       global_max_pooling1d[0][0]       __________________________________________________________________________________________________age (Dense)                     (None, 1)            129         dense_14[0][0]                   __________________________________________________________________________________________________income (Dense)                  (None, 10)           1290        dense_14[0][0]                   __________________________________________________________________________________________________gender (Dense)                  (None, 1)            129         dense_14[0][0]                   ==================================================================================================Total params: 45,982,476Trainable params: 45,982,476Non-trainable params: 0__________________________________________________________________________________________________</code></pre><p><strong>多头模型的编译</strong></p><p>在编译这种模型的时候，由于是有不同的目标，所以要注意需要对网络的各个头指定不同的损失函数。</p><p>但梯度下降的作用只能是将一个标量最小化，所以在 Keras 中，编译时为不同输出指定的不同损失，到了训练中，会被相加得到一个全局损失，训练过程就是将这个全局损失最小化。</p><p>在这种情况下，如果损失贡献严重不平衡，模型就会优先去优化损失数值最大的任务，而不考虑其他任务。为了解决这个问题，可以为不同的损失加权。例如 mse 的损失值通常是 3~5，binary_crossentropy 的损失值通常低至 0.1，为了平衡损失贡献，我们可以让 binary_crossentropy 的权重取 10、mse 损失的权重取 0.5。</p><p>多个损失以及加权的指定都是使用列表或字典来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=[<span class="string">&#x27;mse&#x27;</span>, <span class="string">&#x27;categorical_crossentropy&#x27;</span>, <span class="string">&#x27;binary_crossentropy&#x27;</span>],</span><br><span class="line">              loss_weights=[<span class="number">0.25</span>, <span class="number">1.</span>, <span class="number">10.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者如果有对输出层命名的话，可以用字典：</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=&#123;<span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;income&#x27;</span>: <span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;binary_crossentropy&#x27;</span>&#125;,</span><br><span class="line">              loss_weights=&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">0.25</span>,</span><br><span class="line">                            <span class="string">&#x27;income&#x27;</span>: <span class="number">1.</span>,</span><br><span class="line">                            <span class="string">&#x27;gender&#x27;</span>: <span class="number">10.</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>多头模型的训练</strong></p><p>训练这种模型的时候，把目标输出用列表或字典传递就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model.fit(posts, [age_targets, income_targets, gender_targets],</span><br><span class="line">          epochs=<span class="number">10</span>, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">model.fit(posts, &#123;<span class="string">&#x27;age&#x27;</span>: age_targets,</span><br><span class="line">                  <span class="string">&#x27;income&#x27;</span>: income_targets,</span><br><span class="line">                  <span class="string">&#x27;gender&#x27;</span>: gender_targets&#125;,</span><br><span class="line">          epochs=<span class="number">10</span>, batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure><h3 id="层的有向无环图"><a href="#层的有向无环图" class="headerlink" title="层的有向无环图"></a>层的有向无环图</h3><p>利用函数式 API，除了构建多输入和多输出的模型，我们还可以实现具有复杂的内部拓扑结构的网络。</p><p>实际上 Keras 中的神经网络可以是由层组成的任意有向无环图。比较著名的图结构的组件有 Inception 模块和残差连接。</p><h4 id="Inception-模块"><a href="#Inception-模块" class="headerlink" title="Inception 模块"></a>Inception 模块</h4><p>Inception 是模块的堆叠，其中的每个模块看起来像是小型的独立网络，这些模块被分为多个并行分支，最后将所得到的特征连接到一起。这种操作可以让网络分别学习图片的空间特征和逐通道的特征，这样会比用一个网络去同时学习这些特征更加有效。</p><p>下图是一个简化的 Inception V3 模块：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gho3zlsj9bj31200j6act.jpg" alt="Inception 模块"></p><blockquote><p>注：这里用的 1x1 的卷积，叫作逐点卷积(pointwise convolution)，是 Inception 模块的特色。<br>它一次只查看一个像素，计算得到的特征就能够将输入的各通道中的信息混合在一起，但又不会混入空间信息。<br>这样就实现了区分开通道特征学习和空间特征学习。</p></blockquote><p>用函数式 API 可以实现它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">x = Input(shape=(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">3</span>))    <span class="comment"># RGB 图片</span></span><br><span class="line"></span><br><span class="line">branch_a = layers.Conv2D(<span class="number">128</span>, <span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">branch_b = layers.Conv2D(<span class="number">128</span>, <span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">branch_b = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(branch_b)</span><br><span class="line"></span><br><span class="line">branch_c = layers.AveragePooling2D(<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">branch_c = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(branch_c)</span><br><span class="line"></span><br><span class="line">branch_d = layers.Conv2D(<span class="number">128</span>, <span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">branch_d = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(branch_d)</span><br><span class="line">branch_d = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(branch_d)</span><br><span class="line"></span><br><span class="line">output = layers.concatenate([branch_a, branch_b, branch_c, branch_d], axis=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其实，Keras 内置了完整的 Inception V3 架构。可以通过 <code>keras.applications.inception_v3.InceptionV3</code> 去调用。</p><p>与 Inception 相关的，还有一个叫做 <strong>Xception</strong> 的东西。Xception 这个词是 extreme inception（极端 Inception）的意思，它是一种比较极端的 Inception，它将通道特征学习与空间特征学习完全分离开。Xception 的参数个数与 Inception V3 大致相同，但它对参数的使用效率更高，所以在大规模数据集上的运行性能更好、精度更高。</p><h4 id="残差连接"><a href="#残差连接" class="headerlink" title="残差连接"></a>残差连接</h4><p>残差连接(residual connection) 是一种现在很常用的组件，它解决了大规模深度学习模型梯度消失和表示瓶颈问题。通常，向任何多于 10 层的模型中添加残差连接，都可能会有所帮助。</p><ul><li>梯度消失：就是经过的层多了，之前学到的表示变得模糊，甚至完全丢失，导致网络无法训练。</li><li>表示瓶颈：堆叠起来层，后一层只能访问到前一层学到的东西。如果某一层太小（激活中能够塞入的信息少）就把信息卡下来，出现瓶颈了。</li></ul><p>残差连接是让前面某层的输出作为后面某层的输入（在网络中创造捷径）。前面层的输出并没有与后面层的激活连接在一起，而是与后面层的激活相加（若形状不同，用线性变换将前面层的激活改变成目标形状）。</p><blockquote><p>注：线性变换可以用不带激活的 Dense 层，或着在 CNN 中用不带激活 1×1 卷积。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">x = ...</span><br><span class="line"></span><br><span class="line">y = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">y = layers.Conv2D(<span class="number">128</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(y)</span><br><span class="line">y = layers.MaxPooling2D(<span class="number">2</span>, strides=<span class="number">2</span>)(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形状不同，要做线性变换：</span></span><br><span class="line">residual = layers.Conv2D(<span class="number">128</span>, <span class="number">1</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)  <span class="comment"># 使用 1×1 卷积，将 x 线性下采样为与 y 具有相同的形状</span></span><br><span class="line"></span><br><span class="line">y = layers.add([y, residual])</span><br></pre></td></tr></table></figure><h4 id="共享层权重"><a href="#共享层权重" class="headerlink" title="共享层权重"></a>共享层权重</h4><p>使用函数式 API，还有一种操作是<strong>多次使用一个层实例</strong>。对同一个层实例调用多次，则可以重复使用相同的权重。利用这种特性，可以构建出具有共享分支的模型，即几个分支全都共享相同的知识并执行相同的运算。</p><p>例如，我们想要评估两个句子之间的语义相似度。这个模型有输入两个句子，输出一个范围在 0~1 的分数，值越大则句意越相似。</p><p>在这个问题中，两个输入句子是可以互换的（句子 A 相对于 B 的相似度等于 B 相对于 A 的相似度）。因此，不应该学习两个单独的模型来分别处理两个输入句子。而应该用一个 LSTM 层来处理两个句子。这个 LSTM 层的表示(权重)是同时从两个输入学习来的。这种模型称为连体 LSTM (Siamese LSTM)或共享 LSTM (shared LSTM)。</p><p>这样的模型使用 Keras 函数式 API 中的层共享实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line">lstm = layers.LSTM(<span class="number">32</span>)  <span class="comment"># 只示例化一个 LSTM</span></span><br><span class="line"></span><br><span class="line">left_input = Input(shape=(<span class="literal">None</span>, <span class="number">128</span>))</span><br><span class="line">left_output = lstm(left_input)</span><br><span class="line"></span><br><span class="line">right_input = Input(shape=(<span class="literal">None</span>, <span class="number">128</span>))</span><br><span class="line">right_output = lstm(right_input)</span><br><span class="line"></span><br><span class="line">merged = layers.concatenate([left_output, right_output], axis=-<span class="number">1</span>)</span><br><span class="line">predictions = layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(merged)</span><br><span class="line"></span><br><span class="line">model = Model([left_input, right_input], predictions)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;functional_8&quot;__________________________________________________________________________________________________Layer (type)                    Output Shape         Param #     Connected to                     ==================================================================================================input_13 (InputLayer)           [(None, None, 128)]  0                                            __________________________________________________________________________________________________input_14 (InputLayer)           [(None, None, 128)]  0                                            __________________________________________________________________________________________________lstm_15 (LSTM)                  (None, 32)           20608       input_13[0][0]                                                                                    input_14[0][0]                   __________________________________________________________________________________________________concatenate_13 (Concatenate)    (None, 64)           0           lstm_15[0][0]                                                                                     lstm_15[1][0]                    __________________________________________________________________________________________________dense_15 (Dense)                (None, 1)            65          concatenate_13[0][0]             ==================================================================================================Total params: 20,673Trainable params: 20,673Non-trainable params: 0__________________________________________________________________________________________________</code></pre><h4 id="将模型作为层"><a href="#将模型作为层" class="headerlink" title="将模型作为层"></a>将模型作为层</h4><p>在 Keras 中，我们可以把模型当作层使用（把模型现象为一个大的层），Sequential 类和 Model 类都可以当层用。直接像层一样去函数式地调用就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = model(x)</span><br><span class="line">y1, y2 = model_with_multi_inputs_and_outputs([x1, x2])</span><br></pre></td></tr></table></figure><p>例如，我们处理双摄像头作为输入的视觉模型（这种模型可以感知深度）。我们一个用 applications.Xception 模型作为层，并使用前面的共享层的方法来实现这个网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> applications</span><br><span class="line"></span><br><span class="line">xception_base = applications.Xception(weights=<span class="literal">None</span>, include_top=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">left_input = Input(shape=(<span class="number">250</span>, <span class="number">250</span>, <span class="number">3</span>))</span><br><span class="line">right_input = Input(shape=(<span class="number">250</span>, <span class="number">250</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">left_features = xception_base(left_input)</span><br><span class="line">right_input = xception_base(right_input)</span><br><span class="line"></span><br><span class="line">merged_features = layers.concatenate([left_features, right_input], axis=-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">By(<span class="string">&quot;CDFMLR&quot;</span>, <span class="string">&quot;2020-08-17&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之用卷积神经网络处理序列</title>
      <link href="/2020/08/14/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_4/"/>
      <url>/2020/08/14/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_4/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第6章  深度学习用于文本和序列</strong> (Chapter 6. <em>Deep learning for text and sequences</em>) 的笔记。</p><p>[TOC]</p><h2 id="6-4-Sequence-processing-with-convnets"><a href="#6-4-Sequence-processing-with-convnets" class="headerlink" title="6.4 Sequence processing with convnets"></a>6.4 Sequence processing with convnets</h2><blockquote><p>用卷积神经网络处理序列</p></blockquote><p>卷积神经网络可以有效利用数据，提取局部特征，将表示模块化。由于这种特效，CNN 不但善于处理计算机时间问题，也可以高效处理序列问题，在有些序列问题上，CNN 的效果、效率甚至可以超过 RNN。</p><p>不同于处理图像用的二维 Conv2D，时间序列是一维的，所以要用一维卷积神经网络来处理。</p><h3 id="序列数据的一维卷积、池化"><a href="#序列数据的一维卷积、池化" class="headerlink" title="序列数据的一维卷积、池化"></a>序列数据的一维卷积、池化</h3><p>和二维的卷积类似，一维卷积从序列中提取局部的片段（子序列），然后对每个片段做相同的变换。一维的卷积窗口是时间轴上的一维窗口。该运算的性质可以保证，在前面某个位置学到的模式稍后可以在其他位置被识出来（具有时间平移不变性）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmwvss1ibj317a0msn02.jpg" alt="一维卷积神经网络的工作原理:每个输出时间步都是利用输入序列在时间维度上的一小段得到的"></p><p>一维的池化运算，也和二维池化运算类似：从输入中提取一维片段，输出其中的最大值(最大池化)或平均值(平均池化)。该运算也是用来降低数据的长度的(做子采样)。</p><h3 id="实现一维卷积神经网络"><a href="#实现一维卷积神经网络" class="headerlink" title="实现一维卷积神经网络"></a>实现一维卷积神经网络</h3><p>在 Keras 中，一维卷积神经网络用 Conv1D 层来表示。用法和 Conv2D 很类似，它接收形状为 <code>(samples, time, features)</code> 的输入，返回还是这个形状的。注意，它的窗口是在 time 上的，即输入的第二个轴。Conv2D 里我们的窗口一般用 3x3、5x5 这样的，对应的 Conv1D 里，我们一般取 7 或 9 的窗口大小。</p><p>常情况下，我们都将 Conv1D 层和 MaxPooling1D 层堆叠在一起，在所有卷积池化堆叠的最后，再用一个全局池化运算或展平的操作。</p><p>还是以 IMDB 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> sequence</span><br><span class="line"></span><br><span class="line">max_features = <span class="number">10000</span></span><br><span class="line">max_len = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Loading data...&#x27;</span>)</span><br><span class="line">(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_features)</span><br><span class="line">print(<span class="built_in">len</span>(x_train), <span class="string">&#x27;train sequences&#x27;</span>)</span><br><span class="line">print(<span class="built_in">len</span>(x_test), <span class="string">&#x27;test sequences&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Pad sequences (samples x time)&#x27;</span>)</span><br><span class="line">x_train = sequence.pad_sequences(x_train, maxlen=max_len)</span><br><span class="line">x_test = sequence.pad_sequences(x_test, maxlen=max_len)</span><br><span class="line">print(<span class="string">&#x27;x_train shape:&#x27;</span>, x_train.shape)</span><br><span class="line">print(<span class="string">&#x27;x_test shape:&#x27;</span>, x_test.shape)</span><br></pre></td></tr></table></figure><pre><code>Loading data...25000 train sequences25000 test sequencesPad sequences (samples x time)x_train shape: (25000, 500)x_test shape: (25000, 500)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制历史</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_acc_and_loss</span>(<span class="params">history</span>):</span></span><br><span class="line"></span><br><span class="line">    epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(history.history[<span class="string">&#x27;loss&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">        val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">        plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&#x27;No acc. Skip&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        plt.figure()</span><br><span class="line"></span><br><span class="line">    loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">    plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 IMDB 上训练并评估一个简单的一维卷积神经网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Embedding(max_features, <span class="number">128</span>, input_length=max_len))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">7</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling1D(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">7</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.GlobalMaxPooling1D())</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(lr=<span class="number">1e-4</span>),</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">history = model.fit(x_train, y_train,</span><br><span class="line">                    epochs=<span class="number">10</span>,</span><br><span class="line">                    batch_size=<span class="number">128</span>,</span><br><span class="line">                    validation_split=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding (Embedding)        (None, 500, 128)          1280000   _________________________________________________________________conv1d (Conv1D)              (None, 494, 32)           28704     _________________________________________________________________max_pooling1d (MaxPooling1D) (None, 98, 32)            0         _________________________________________________________________conv1d_1 (Conv1D)            (None, 92, 32)            7200      _________________________________________________________________global_max_pooling1d (Global (None, 32)                0         _________________________________________________________________dense (Dense)                (None, 1)                 33        =================================================================Total params: 1,315,937Trainable params: 1,315,937Non-trainable params: 0_________________________________________________________________Epoch 1/10157/157 [==============================] - 30s 188ms/step - loss: 0.9049 - acc: 0.5124 - val_loss: 0.6875 - val_acc: 0.5566Epoch 2/10157/157 [==============================] - 28s 178ms/step - loss: 0.6724 - acc: 0.6433 - val_loss: 0.6699 - val_acc: 0.6394...Epoch 9/10157/157 [==============================] - 27s 174ms/step - loss: 0.2445 - acc: 0.9171 - val_loss: 0.4238 - val_acc: 0.8666Epoch 10/10157/157 [==============================] - 27s 170ms/step - loss: 0.2211 - acc: 0.9277 - val_loss: 0.4305 - val_acc: 0.8746</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghq3bm3j93j30af07c3yq.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghq3bkuud0j30af07c0sy.jpg" alt="png"></p><p>虽然结果略比 RNN 差，但还是挺不错的，而且训练起来比 LSTM 快。</p><h3 id="结合-CNN-和-RNN-处理长序列"><a href="#结合-CNN-和-RNN-处理长序列" class="headerlink" title="结合 CNN 和 RNN 处理长序列"></a>结合 CNN 和 RNN 处理长序列</h3><p>一维卷积神经网络是把序列分成片段去学习的，对时间顺序不敏感。所以对于那些序列的顺序影响重大的问题来说，CNN 表现的远不如 RNN。例如，耶拿数据集(气温预测)问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data_dir = <span class="string">&quot;/Volumes/WD/Files/dataset/jena_climate&quot;</span></span><br><span class="line">fname = os.path.join(data_dir, <span class="string">&#x27;jena_climate_2009_2016.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(fname)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">lines = data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">header = lines[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">lines = lines[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">float_data = np.zeros((<span class="built_in">len</span>(lines), <span class="built_in">len</span>(header) - <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">    values = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> line.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>:]]</span><br><span class="line">    float_data[i, :] = values</span><br><span class="line">    </span><br><span class="line">mean = float_data[:<span class="number">200000</span>].mean(axis=<span class="number">0</span>)</span><br><span class="line">float_data -= mean</span><br><span class="line">std = float_data[:<span class="number">200000</span>].std(axis=<span class="number">0</span>)</span><br><span class="line">float_data /= std</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">data, lookback, delay, min_index, max_index,</span></span></span><br><span class="line"><span class="function"><span class="params">              shuffle=<span class="literal">False</span>, batch_size=<span class="number">128</span>, step=<span class="number">6</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> max_index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        max_index = <span class="built_in">len</span>(data) - delay - <span class="number">1</span></span><br><span class="line">    i = min_index + lookback</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            rows = np.random.randint(</span><br><span class="line">                min_index + lookback, max_index, size=batch_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i + batch_size &gt;= max_index:</span><br><span class="line">                i = min_index + lookback</span><br><span class="line">            rows = np.arange(i, <span class="built_in">min</span>(i + batch_size, max_index))</span><br><span class="line">            i += <span class="built_in">len</span>(rows)</span><br><span class="line"></span><br><span class="line">        samples = np.zeros((<span class="built_in">len</span>(rows),</span><br><span class="line">                           lookback // step,</span><br><span class="line">                           data.shape[-<span class="number">1</span>]))</span><br><span class="line">        targets = np.zeros((<span class="built_in">len</span>(rows),))</span><br><span class="line">        <span class="keyword">for</span> j, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(rows):</span><br><span class="line">            indices = <span class="built_in">range</span>(rows[j] - lookback, rows[j], step)</span><br><span class="line">            samples[j] = data[indices]</span><br><span class="line">            targets[j] = data[rows[j] + delay][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">yield</span> samples, targets</span><br><span class="line">        </span><br><span class="line">lookback = <span class="number">1440</span></span><br><span class="line">step = <span class="number">6</span></span><br><span class="line">delay = <span class="number">144</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">train_gen = generator(float_data,</span><br><span class="line">                      lookback=lookback,</span><br><span class="line">                      delay=delay,</span><br><span class="line">                      min_index=<span class="number">0</span>,</span><br><span class="line">                      max_index=<span class="number">200000</span>,</span><br><span class="line">                      shuffle=<span class="literal">True</span>,</span><br><span class="line">                      step=step, </span><br><span class="line">                      batch_size=batch_size)</span><br><span class="line">val_gen = generator(float_data,</span><br><span class="line">                    lookback=lookback,</span><br><span class="line">                    delay=delay,</span><br><span class="line">                    min_index=<span class="number">200001</span>,</span><br><span class="line">                    max_index=<span class="number">300000</span>,</span><br><span class="line">                    step=step,</span><br><span class="line">                    batch_size=batch_size)</span><br><span class="line">test_gen = generator(float_data,</span><br><span class="line">                     lookback=lookback,</span><br><span class="line">                     delay=delay,</span><br><span class="line">                     min_index=<span class="number">300001</span>,</span><br><span class="line">                     max_index=<span class="literal">None</span>,</span><br><span class="line">                     step=step,</span><br><span class="line">                     batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">val_steps = (<span class="number">300000</span> - <span class="number">200001</span> - lookback) // batch_size</span><br><span class="line"></span><br><span class="line">test_steps = (<span class="built_in">len</span>(float_data) - <span class="number">300001</span> - lookback) // batch_size</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在耶拿数据集上训练并评估一个简单的一维卷积神经网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                        input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.MaxPooling1D(<span class="number">3</span>))</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling1D(<span class="number">3</span>))</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.GlobalMaxPooling1D())</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen,</span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>,</span><br><span class="line">                              epochs=<span class="number">20</span>,</span><br><span class="line">                              validation_data=val_gen,</span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>WARNING:tensorflow:From &lt;ipython-input-6-02e34f317812&gt;:22: Model.fit_generator (from tensorflow.python.keras.engine.training) is deprecated and will be removed in a future version.Instructions for updating:Please use Model.fit, which supports generators.Epoch 1/20500/500 [==============================] - 27s 54ms/step - loss: 0.4144 - val_loss: 0.4308Epoch 2/20500/500 [==============================] - 26s 52ms/step - loss: 0.3620 - val_loss: 0.4306...Epoch 19/20500/500 [==============================] - 22s 43ms/step - loss: 0.2450 - val_loss: 0.4603Epoch 20/20500/500 [==============================] - 21s 41ms/step - loss: 0.2453 - val_loss: 0.4721</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghq3bl7gimj30al07caac.jpg" alt="png"></p><p>这还不如咱用的那个常识法呢，可见顺序信息对这个问题还是非常关键的。为了学到顺序上的信息，同时保持卷积神经网络的速度和轻量，我们可以结合使用 CNN 和 RNN。</p><p>我们可以在 RNN 前面使用 Conv1D。对于非常长的序列 (比如包含上千个时间步)，直接用 RNN 处理起来太慢、甚至无法处理。在 RNN 前面加上一些 Conv1D 就可以把过长的输入序列转换(下采样)为由高级特征组成的更短序列，然后再用 RNN 去处理有可以学到顺序敏感的信息。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmy56fkp4j30ji0ncgni.jpg" alt="结合一维 CNN 和 RNN 来处理长序列"></p><p>我们用这种方法再做一次气温预测问题，由于这种方法可以学习更长的序列，我们可以让网络查看更早的数据(增大数据生成器的 lookback 参数)，也可以让网络查看分辨率更高的时间序列（减小生成器的 step 参数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">step = <span class="number">3</span>  <span class="comment"># 30 分钟一步，比以前缩短了一半</span></span><br><span class="line">lookback = <span class="number">720</span></span><br><span class="line">delay = <span class="number">144</span></span><br><span class="line"></span><br><span class="line">train_gen = generator(float_data,</span><br><span class="line">                      lookback=lookback,</span><br><span class="line">                      delay=delay,</span><br><span class="line">                      min_index=<span class="number">0</span>,</span><br><span class="line">                      max_index=<span class="number">200000</span>,</span><br><span class="line">                      shuffle=<span class="literal">True</span>,</span><br><span class="line">                      step=step)</span><br><span class="line"></span><br><span class="line">val_gen = generator(float_data,</span><br><span class="line">                    lookback=lookback,</span><br><span class="line">                    delay=delay,</span><br><span class="line">                    min_index=<span class="number">200001</span>,</span><br><span class="line">                    max_index=<span class="number">300000</span>,</span><br><span class="line">                    step=step)</span><br><span class="line"></span><br><span class="line">test_gen = generator(float_data,</span><br><span class="line">                     lookback=lookback,</span><br><span class="line">                     delay=delay,</span><br><span class="line">                     min_index=<span class="number">300001</span>,</span><br><span class="line">                     max_index=<span class="literal">None</span>,</span><br><span class="line">                     step=step)</span><br><span class="line"></span><br><span class="line">val_steps = (<span class="number">300000</span> - <span class="number">200001</span> - lookback) // <span class="number">128</span></span><br><span class="line">test_steps = (<span class="built_in">len</span>(float_data) - <span class="number">300001</span> - lookback) // <span class="number">128</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Conv1D + GRU</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                        input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.MaxPooling1D(<span class="number">3</span>))</span><br><span class="line">model.add(layers.Conv1D(<span class="number">32</span>, <span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.GRU(<span class="number">32</span>, dropout=<span class="number">0.1</span>, recurrent_dropout=<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen,</span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>,</span><br><span class="line">                              epochs=<span class="number">20</span>,</span><br><span class="line">                              validation_data=val_gen,</span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_2&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv1d_5 (Conv1D)            (None, None, 32)          2272      _________________________________________________________________max_pooling1d_3 (MaxPooling1 (None, None, 32)          0         _________________________________________________________________conv1d_6 (Conv1D)            (None, None, 32)          5152      _________________________________________________________________gru (GRU)                    (None, 32)                6336      _________________________________________________________________dense_2 (Dense)              (None, 1)                 33        =================================================================Total params: 13,793Trainable params: 13,793Non-trainable params: 0_________________________________________________________________Epoch 1/20500/500 [==============================] - 49s 97ms/step - loss: 0.3301 - val_loss: 0.3056Epoch 2/20500/500 [==============================] - 47s 95ms/step - loss: 0.2950 - val_loss: 0.2750...Epoch 19/20500/500 [==============================] - 53s 106ms/step - loss: 0.2029 - val_loss: 0.3107Epoch 20/20500/500 [==============================] - 53s 106ms/step - loss: 0.2011 - val_loss: 0.3112</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghq3blng5dj30al07c3yt.jpg" alt="png"></p><p>从验证损失来看，这种架构的效果不如只用正则化 GRU，但速度要快很多。它查看了两倍的数据量，在本例中可能不是非常有用，但对于其他数据集可能非常重要。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">By(<span class="string">&quot;CDFMLR&quot;</span>, <span class="string">&quot;2020-08-14&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之循环神经网络的高级用法</title>
      <link href="/2020/08/13/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_3/"/>
      <url>/2020/08/13/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_3/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第6章  深度学习用于文本和序列</strong> (Chapter 6. <em>Deep learning for text and sequences</em>) 的笔记。</p><p>[TOC]</p><h2 id="6-3-Advanced-usage-of-recurrent-neural-networks"><a href="#6-3-Advanced-usage-of-recurrent-neural-networks" class="headerlink" title="6.3 Advanced usage of recurrent neural networks"></a>6.3 Advanced usage of recurrent neural networks</h2><blockquote><p>循环神经网络的高级用法</p></blockquote><p>今回，我们通过一个实例，来了解循环神经网络的几个技巧：循环 dropout， 堆叠循环层，双向循环层。</p><h3 id="温度预测问题"><a href="#温度预测问题" class="headerlink" title="温度预测问题"></a>温度预测问题</h3><p>我们将使用某气象站记录的天气时间序列数据集（耶拿数据集），在这个数据集中，有每 10 分钟记录的 14 个量(比如气温、气压、湿度、风向等)，这个数据集里有好多年的记录，这里我们只选用 2009—2016 年的。用这个数据集来构建模型，最后目标是输入最近的一些数据(几天的数据点)，预测未来 24 小时的气温。</p><p>首先，下载并解压这个数据集：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Somewhere</span><br><span class="line">mkdir jena_climate</span><br><span class="line"><span class="built_in">cd</span> jena_climate</span><br><span class="line">wget https://s3.amazonaws.com/keras-datasets/jena_climate_2009_2016.csv.zip</span><br><span class="line">unzip jena_climate_2009_2016.csv.zip</span><br></pre></td></tr></table></figure><p>看一下数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">data_dir = <span class="string">&quot;/Volumes/WD/Files/dataset/jena_climate&quot;</span></span><br><span class="line">fname = os.path.join(data_dir, <span class="string">&#x27;jena_climate_2009_2016.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(fname) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">lines = data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">header = lines[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">lines = lines[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">print(header)</span><br><span class="line">print(<span class="built_in">len</span>(lines))</span><br><span class="line">print(lines[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[&#39;&quot;Date Time&quot;&#39;, &#39;&quot;p (mbar)&quot;&#39;, &#39;&quot;T (degC)&quot;&#39;, &#39;&quot;Tpot (K)&quot;&#39;, &#39;&quot;Tdew (degC)&quot;&#39;, &#39;&quot;rh (%)&quot;&#39;, &#39;&quot;VPmax (mbar)&quot;&#39;, &#39;&quot;VPact (mbar)&quot;&#39;, &#39;&quot;VPdef (mbar)&quot;&#39;, &#39;&quot;sh (g/kg)&quot;&#39;, &#39;&quot;H2OC (mmol/mol)&quot;&#39;, &#39;&quot;rho (g/m**3)&quot;&#39;, &#39;&quot;wv (m/s)&quot;&#39;, &#39;&quot;max. wv (m/s)&quot;&#39;, &#39;&quot;wd (deg)&quot;&#39;]42055101.01.2009 00:10:00,996.52,-8.02,265.40,-8.90,93.30,3.33,3.11,0.22,1.94,3.12,1307.75,1.03,1.75,152.30</code></pre><p>把数据放到 Numpy 数组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">float_data = np.zeros((<span class="built_in">len</span>(lines), <span class="built_in">len</span>(header)-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">    values = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> line.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>:]]</span><br><span class="line">    float_data[i, :] = values</span><br><span class="line">    </span><br><span class="line">print(float_data.shape)</span><br></pre></td></tr></table></figure><pre><code>(420551, 14)</code></pre><p>我们把气温的变化画出来，周期性很明显：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">temp = float_data[:, <span class="number">1</span>]</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(temp)), temp)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fpz4dlj30ak070jru.jpg" alt="png"></p><p>再看看前 10 天的数据（数据 10 分钟记一条，所以 1 天是 144 条）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1440</span>), temp[: <span class="number">1440</span>])</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fpi8mwj30ak070aaa.jpg" alt="png"></p><p>这个图可以看出是个冬天的，每天的气温变化也是有周期性的（后面几天比较明显）。</p><p>接下来就要开始尝试做预测模型的工作了。首先明确一下我们的问题：给定过去 <code>lookback</code> 个时间步(10分钟一个)，我们没 <code>steps</code> 步采样一次，让你去预测未来 <code>delay</code> 时间步的气温：</p><ul><li><code>lookback = 720</code>: 过去5天的观察数据</li><li><code>steps = 6</code>: 每小时采样一次观察数据</li><li><code>delay = 144</code>: 目标是未来24小时</li></ul><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><ol><li>数据标准化：让各种特征在数量上差距不大</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据标准化</span></span><br><span class="line"></span><br><span class="line">mean = float_data[:<span class="number">200000</span>].mean(axis=<span class="number">0</span>)</span><br><span class="line">float_data -= mean</span><br><span class="line">std = float_data[:<span class="number">200000</span>].std(axis=<span class="number">0</span>)</span><br><span class="line">float_data /= std</span><br></pre></td></tr></table></figure><ol start="2"><li>把数据放到一个生成器，yield 出 <code>(samples, targets)</code>，samples 是输入的数据批，targets 是对应的目标温度数组。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成时间序列样本及其目标的生成器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">data,     <span class="comment"># 原始数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">              lookback, <span class="comment"># 输入数据包括过去多少个时间步</span></span></span></span><br><span class="line"><span class="function"><span class="params">              delay,    <span class="comment"># 目标是未来的多少个时间步</span></span></span></span><br><span class="line"><span class="function"><span class="params">              min_index, max_index,  <span class="comment"># 指定从 data 的那个部分抽取</span></span></span></span><br><span class="line"><span class="function"><span class="params">              shuffle=<span class="literal">False</span>,   <span class="comment"># 打乱样本 or 按顺序抽取</span></span></span></span><br><span class="line"><span class="function"><span class="params">              batch_size=<span class="number">128</span>,  <span class="comment"># 每批的样本数</span></span></span></span><br><span class="line"><span class="function"><span class="params">              step=<span class="number">6</span></span>):</span>         <span class="comment"># 数据采样的周期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> max_index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        max_index = <span class="built_in">len</span>(data) - delay - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    i = min_index + lookback</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            rows = np.random.randint(min_index + lookback, max_index, size=batch_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i + batch_size &gt;= max_index:</span><br><span class="line">                i = min_index + lookback</span><br><span class="line">            rows = np.arange(i, <span class="built_in">min</span>(i + batch_size, max_index))</span><br><span class="line">            i += <span class="built_in">len</span>(rows)</span><br><span class="line">            </span><br><span class="line">        samples = np.zeros((<span class="built_in">len</span>(rows), lookback // step, data.shape[-<span class="number">1</span>]))</span><br><span class="line">        targets = np.zeros((<span class="built_in">len</span>(rows), ))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(rows):</span><br><span class="line">            indices = <span class="built_in">range</span>(rows[j] - lookback, rows[j], step)</span><br><span class="line">            samples[j] = data[indices]</span><br><span class="line">            targets[j] = data[rows[j] + delay][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> samples, targets</span><br></pre></td></tr></table></figure><p>调用这个生成器，实例化训练集生成器、验证集生成器、测试集生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备训练生成器、验证生成器和测试生成器</span></span><br><span class="line"></span><br><span class="line">lookback = <span class="number">1440</span></span><br><span class="line">step = <span class="number">6</span></span><br><span class="line">delay = <span class="number">144</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">train_gen = generator(float_data, </span><br><span class="line">                      lookback=lookback, </span><br><span class="line">                      delay=delay, </span><br><span class="line">                      min_index=<span class="number">0</span>, </span><br><span class="line">                      max_index=<span class="number">200000</span>, </span><br><span class="line">                      shuffle=<span class="literal">True</span>, </span><br><span class="line">                      step=step, </span><br><span class="line">                      batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">val_gen = generator(float_data, </span><br><span class="line">                    lookback=lookback, </span><br><span class="line">                    delay=delay, </span><br><span class="line">                    min_index=<span class="number">200001</span>, </span><br><span class="line">                    max_index=<span class="number">300000</span>, </span><br><span class="line">                    step=step, </span><br><span class="line">                    batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">test_gen = generator(float_data, </span><br><span class="line">                     lookback=lookback, </span><br><span class="line">                     delay=delay, </span><br><span class="line">                     min_index=<span class="number">300001</span>, </span><br><span class="line">                     max_index=<span class="literal">None</span>, </span><br><span class="line">                     step=step, </span><br><span class="line">                     batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证和测试需要抽取多少次：</span></span><br><span class="line">val_steps = (<span class="number">300000</span> - <span class="number">200001</span> - lookback)  // batch_size</span><br><span class="line">test_steps = (<span class="built_in">len</span>(float_data) - <span class="number">300001</span> - lookback)  // batch_size</span><br></pre></td></tr></table></figure><h4 id="一种常识的、非机器学习的基准方法"><a href="#一种常识的、非机器学习的基准方法" class="headerlink" title="一种常识的、非机器学习的基准方法"></a>一种常识的、非机器学习的基准方法</h4><p>我们假设温度的时间序列是连续的，并且每天的温度是周期性变化的。这种情况下，可以大胆假设未来 24 小时的温度等于当前的温度。</p><p>我们就以此基于常识的非机器学习方法作为基准，用平均绝对误差(MAE)为指标来评估衡量它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mae = np.mean(np.<span class="built_in">abs</span>(preds - targets))</span><br></pre></td></tr></table></figure><p>我们之后做的机器学习模型应该超过这个基准，才能说明机器学习是有效的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算基于常识的基准方法的 MAE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_naive_method</span>():</span></span><br><span class="line">    batch_maes = []</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(val_steps):</span><br><span class="line">        samples, targets = <span class="built_in">next</span>(val_gen)</span><br><span class="line">        preds = samples[:, -<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        mae = np.mean(np.<span class="built_in">abs</span>(preds - targets))</span><br><span class="line">        batch_maes.append(mae)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.mean(batch_maes)</span><br><span class="line">    </span><br><span class="line">mae = evaluate_naive_method()</span><br><span class="line">celsius_mae = mae * std[<span class="number">1</span>]</span><br><span class="line">print(<span class="string">f&#x27;mae=<span class="subst">&#123;mae&#125;</span>, 温度的平均绝对误差=<span class="subst">&#123;celsius_mae&#125;</span>°C&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>mae=0.2897359729905486, 温度的平均绝对误差=2.564887434980494°C</code></pre><p>这个误差还是比较大的，所以接下来的目标就是用深度学习的方法来超过这个基准。</p><h4 id="机器学习基准方法"><a href="#机器学习基准方法" class="headerlink" title="机器学习基准方法"></a>机器学习基准方法</h4><p>在用复杂的、计算代价高的网络(比如 RNN)之前，最好先尝试一下简单的模型能否解决问题。</p><p>所以这里我们先用一个简单的全连接网络来尝试处理天气预测问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot_acc_and_loss: 绘制训练历史的实用函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_acc_and_loss</span>(<span class="params">history</span>):</span></span><br><span class="line"></span><br><span class="line">    epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(history.history[<span class="string">&#x27;loss&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">        val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">        plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&#x27;No acc. Skip&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        plt.figure()</span><br><span class="line"></span><br><span class="line">    loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">    plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Flatten(input_shape=(lookback // step, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen, </span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>, </span><br><span class="line">                              epochs=<span class="number">20</span>, </span><br><span class="line">                              validation_data=val_gen, </span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/20500/500 [==============================] - 10s 20ms/step - loss: 1.7705 - val_loss: 1.0356Epoch 2/20500/500 [==============================] - 11s 21ms/step - loss: 0.5680 - val_loss: 0.3472...Epoch 19/20500/500 [==============================] - 10s 21ms/step - loss: 0.2027 - val_loss: 0.3235Epoch 20/20500/500 [==============================] - 11s 22ms/step - loss: 0.2001 - val_loss: 0.3275</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fw74h7j30af07cglx.jpg" alt="png"></p><p>虽然这个结果里有一部分超过了不机器学习的基准方法，但不够可靠。事实上，要超越基于尝试的基准方法是不容易的，我们的尝试中包含了很多机器难以学到的有用的信息。一般来说，对这种用简单高效解的问题来说，除非我们硬编码让模型去使用这种简单方法，否则靠机器去学习参数是很难找到这个简单模型并进一步改进的。</p><h4 id="循环网络基准方法"><a href="#循环网络基准方法" class="headerlink" title="循环网络基准方法"></a>循环网络基准方法</h4><p>刚才的全连接网络一开始就用一个 Flatten 把时间序列展平了，所以那个模型实际上是没有考虑『时间』的概念的。要利用起时间的顺序，我们就可以考虑使用循环网络。这次，我们将使用 GRU 层而不是 LSTM：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练并评估一个基于 GRU 的模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.GRU(<span class="number">32</span>, input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen, </span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>, </span><br><span class="line">                              epochs=<span class="number">20</span>, </span><br><span class="line">                              validation_data=val_gen, </span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/20500/500 [==============================] - 58s 116ms/step - loss: 0.3069 - val_loss: 0.2687Epoch 2/20500/500 [==============================] - 56s 113ms/step - loss: 0.2850 - val_loss: 0.2692...Epoch 19/20500/500 [==============================] - 62s 124ms/step - loss: 0.2090 - val_loss: 0.2971Epoch 20/20500/500 [==============================] - 64s 128ms/step - loss: 0.2039 - val_loss: 0.2995</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fqpvawj30al07cq38.jpg" alt="png"></p><p>在开始过拟合之前，最好的结果的温度误差是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">0.2624</span> * std[<span class="number">1</span>], <span class="string">&#x27;°C&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>2.3228957591704926 °C</code></pre><p>比一开始的常识模型优秀了。但我们看到，后面过拟合了，在 RNN 里，我们可以用循环 dropout 来对抗过拟合。</p><h3 id="循环-dropout"><a href="#循环-dropout" class="headerlink" title="循环 dropout"></a>循环 dropout</h3><p>我们在前馈网络里面使用 dropout，就是将某一层的输入单元随机得设为0。但在 RNNs 里没有那么简单，在循环层之前使用 dropout 只会阻碍学习，而对结果没有帮助，所以要在循环层中使用 droput。</p><p>在循环层中使用 dropout 必须对每个 timestep 使用相同的 mask（掩码，即舍弃单元），掩码不能随 timestep 的改变而有所不同。同时，对于 LSTM、GRU 等循环层，还要将一个不随时间改变的『循环 dropout 掩码』作用于层的内部循环激活。Keras 的 循环层中都内置了这两种 dropout 的实现，只需通过参数 <code>dropout</code> 和 <code>recurrent_dropout</code> 指定 dropout 的比例即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练并评估一个使用 dropout 正则化的基于 GRU 的模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.GRU(<span class="number">32</span>, </span><br><span class="line">                     dropout=<span class="number">0.4</span>, </span><br><span class="line">                     recurrent_dropout=<span class="number">0.4</span>, </span><br><span class="line">                     input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen, </span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>, </span><br><span class="line">                              epochs=<span class="number">40</span>,    <span class="comment"># 使用了 dropout 的网络需要更长的时间才能收敛</span></span><br><span class="line">                              validation_data=val_gen, </span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/40500/500 [==============================] - 101s 202ms/step - loss: 0.3491 - val_loss: 0.2865Epoch 2/40500/500 [==============================] - 90s 180ms/step - loss: 0.3200 - val_loss: 0.2826...Epoch 39/40500/500 [==============================] - 98s 196ms/step - loss: 0.2510 - val_loss: 0.3111Epoch 40/40500/500 [==============================] - 101s 202ms/step - loss: 0.2517 - val_loss: 0.3115</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1frgpbwj30al07caae.jpg" alt="png"></p><p>这个做出来没有书上好，不知道为什么。</p><h3 id="循环层的堆叠"><a href="#循环层的堆叠" class="headerlink" title="循环层的堆叠"></a>循环层的堆叠</h3><p>解决了过拟合的问题，现在要进一步提高精度。刚才只用了一个循环层，可以考虑再加几个，堆叠起来，增加网络容量。实际上，循环层的堆叠不用堆的特别多，谷歌翻译也只用了7个超大的LSTM层堆叠在一起。</p><p>在 Keras 中堆叠循环层，记得中间层应该返回完整的 3D 输出序列张量，不能只返回最后一个时间步的输出(这个行为是默认的)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.GRU(<span class="number">32</span>,</span><br><span class="line">                     dropout=<span class="number">0.1</span>,</span><br><span class="line">                     recurrent_dropout=<span class="number">0.5</span>,</span><br><span class="line">                     return_sequences=<span class="literal">True</span>,  <span class="comment"># 输出完整输出序列</span></span><br><span class="line">                     input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.GRU(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                     dropout=<span class="number">0.1</span>, </span><br><span class="line">                     recurrent_dropout=<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen,</span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>,</span><br><span class="line">                              epochs=<span class="number">40</span>,</span><br><span class="line">                              validation_data=val_gen,</span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/40500/500 [==============================] - 225s 450ms/step - loss: 0.3214 - val_loss: 0.2784Epoch 2/40500/500 [==============================] - 229s 459ms/step - loss: 0.3029 - val_loss: 0.2721...Epoch 39/40500/500 [==============================] - 229s 458ms/step - loss: 0.1840 - val_loss: 0.3365Epoch 40/40500/500 [==============================] - 219s 438ms/step - loss: 0.1839 - val_loss: 0.3343</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fv5uonj30al07cjrr.jpg" alt="png"></p><p>这个也和书上有所差距。但可以看出，堆叠循环层并没有带来太多的性能提升。</p><h3 id="双向-RNN"><a href="#双向-RNN" class="headerlink" title="双向 RNN"></a>双向 RNN</h3><p>Bidirectional RNNs (双向循环网络) 是 RNN 的变种，有时可以比 RNN 性能更好，尤其是在自然语言处理上，双向 RNN 被称为深度学习 NLP 的瑞士军队。</p><p>RNN 是依赖于序列的时间或者其他顺序的，打乱或反转时间步，RNN 从序列中提取的表示就完全不同了。利用了 RNN 对顺序的这种敏感性，双向 RNN 包含两个普通 RNN，分别沿正序和逆序对输入序列进行处理，最后将它们学到的表示合在一起，这样就可能学习到被单向 RNN 忽略的模式。</p><p>之前，我们默认按时间顺序去训练，现在我们可以试试逆序去处理。要逆序，只需在数据生成器最后方向输出就行了 <code>yield samples[:, ::-1, :], targets)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_order_generator</span>(<span class="params">data, lookback, delay, min_index, max_index,</span></span></span><br><span class="line"><span class="function"><span class="params">                            shuffle=<span class="literal">False</span>, batch_size=<span class="number">128</span>, step=<span class="number">6</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> max_index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        max_index = <span class="built_in">len</span>(data) - delay - <span class="number">1</span></span><br><span class="line">    i = min_index + lookback</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            rows = np.random.randint(</span><br><span class="line">                min_index + lookback, max_index, size=batch_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i + batch_size &gt;= max_index:</span><br><span class="line">                i = min_index + lookback</span><br><span class="line">            rows = np.arange(i, <span class="built_in">min</span>(i + batch_size, max_index))</span><br><span class="line">            i += <span class="built_in">len</span>(rows)</span><br><span class="line"></span><br><span class="line">        samples = np.zeros((<span class="built_in">len</span>(rows),</span><br><span class="line">                           lookback // step,</span><br><span class="line">                           data.shape[-<span class="number">1</span>]))</span><br><span class="line">        targets = np.zeros((<span class="built_in">len</span>(rows),))</span><br><span class="line">        <span class="keyword">for</span> j, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(rows):</span><br><span class="line">            indices = <span class="built_in">range</span>(rows[j] - lookback, rows[j], step)</span><br><span class="line">            samples[j] = data[indices]</span><br><span class="line">            targets[j] = data[rows[j] + delay][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">yield</span> samples[:, ::-<span class="number">1</span>, :], targets</span><br><span class="line">        </span><br><span class="line">train_gen_reverse = reverse_order_generator(</span><br><span class="line">    float_data,</span><br><span class="line">    lookback=lookback,</span><br><span class="line">    delay=delay,</span><br><span class="line">    min_index=<span class="number">0</span>,</span><br><span class="line">    max_index=<span class="number">200000</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">    step=step, </span><br><span class="line">    batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">val_gen_reverse = reverse_order_generator(</span><br><span class="line">    float_data,</span><br><span class="line">    lookback=lookback,</span><br><span class="line">    delay=delay,</span><br><span class="line">    min_index=<span class="number">200001</span>,</span><br><span class="line">    max_index=<span class="number">300000</span>,</span><br><span class="line">    step=step,</span><br><span class="line">    batch_size=batch_size)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.GRU(<span class="number">32</span>, input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen_reverse,</span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>,</span><br><span class="line">                              epochs=<span class="number">20</span>,</span><br><span class="line">                              validation_data=val_gen_reverse,</span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/20500/500 [==============================] - 61s 121ms/step - loss: 0.4796 - val_loss: 0.4788Epoch 2/20500/500 [==============================] - 58s 117ms/step - loss: 0.4488 - val_loss: 0.4791...Epoch 19/20500/500 [==============================] - 57s 114ms/step - loss: 0.2202 - val_loss: 0.3657Epoch 20/20500/500 [==============================] - 57s 114ms/step - loss: 0.2165 - val_loss: 0.3560</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1ftcyyej30al07cq38.jpg" alt="png"></p><p>这个效果并不好。是这样的，对于气温预测，当然是近期的数据比较有用、而很长时间之前的信息意义不大，循环层随着 timesteps 的前进会丢失一些老的信息，所以这个问题用正序的结果比逆序的结果好。</p><p>但对于文本信息的处理，一个单词对理解句子的重要性通常并不取决于它在句子中的位置。也就是说，虽然单词顺序对理解语言很重要，但使用哪种顺序并不重要。所以，在处理一些文本问题时，正序和逆序可能得到很类似的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> sequence</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"></span><br><span class="line"><span class="comment"># Number of words to consider as features</span></span><br><span class="line">max_features = <span class="number">10000</span></span><br><span class="line"><span class="comment"># Cut texts after this number of words (among top max_features most common words)</span></span><br><span class="line">maxlen = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load data</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_features)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reverse sequences</span></span><br><span class="line">x_train = [x[::-<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train]</span><br><span class="line">x_test = [x[::-<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_test]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pad sequences</span></span><br><span class="line">x_train = sequence.pad_sequences(x_train, maxlen=maxlen)</span><br><span class="line">x_test = sequence.pad_sequences(x_test, maxlen=maxlen)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Embedding(max_features, <span class="number">128</span>))</span><br><span class="line">model.add(layers.LSTM(<span class="number">32</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">history = model.fit(x_train, y_train,</span><br><span class="line">                    epochs=<span class="number">10</span>,</span><br><span class="line">                    batch_size=<span class="number">128</span>,</span><br><span class="line">                    validation_split=<span class="number">0.2</span>)</span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/10157/157 [==============================] - 53s 339ms/step - loss: 0.4945 - acc: 0.7638 - val_loss: 0.4783 - val_acc: 0.8256Epoch 2/10157/157 [==============================] - 54s 345ms/step - loss: 0.3198 - acc: 0.8755 - val_loss: 0.5395 - val_acc: 0.7596...Epoch 9/10157/157 [==============================] - 54s 344ms/step - loss: 0.1241 - acc: 0.9590 - val_loss: 0.4496 - val_acc: 0.8566Epoch 10/10157/157 [==============================] - 55s 352ms/step - loss: 0.1178 - acc: 0.9600 - val_loss: 0.4134 - val_acc: 0.8720</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fo9r8jj30as07ct91.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fsgihij30af07c74j.jpg" alt="png"></p><p>这个逆序训练的 IMDB 结果和正序的区别不大。</p><p>如果我们把正序和逆序结合起来，从不同的视角去查看数据，相互补充被彼此忽略的内容，就有可能提高模型的性能。这就是双向 RNN 要做的事。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmsndu024j311s0jejtx.jpg" alt="双向 RNN 层的工作原理"></p><p>在 Keras 中，使用 Bidirectional 层来实现双向 RNN：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 IMDB 上训练并评估一个双向 LSTM</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Embedding(max_features, <span class="number">32</span>))</span><br><span class="line">model.add(layers.Bidirectional(layers.LSTM(<span class="number">32</span>)))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">history = model.fit(x_train, y_train, epochs=<span class="number">10</span>, batch_size=<span class="number">128</span>, validation_split=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/10157/157 [==============================] - 50s 317ms/step - loss: 0.5840 - acc: 0.6994 - val_loss: 0.4705 - val_acc: 0.7818Epoch 2/10157/157 [==============================] - 45s 285ms/step - loss: 0.3490 - acc: 0.8637 - val_loss: 0.4346 - val_acc: 0.7974...Epoch 9/10157/157 [==============================] - 45s 288ms/step - loss: 0.1411 - acc: 0.9537 - val_loss: 0.4225 - val_acc: 0.8778Epoch 10/10157/157 [==============================] - 45s 289ms/step - loss: 0.1249 - acc: 0.9589 - val_loss: 0.6158 - val_acc: 0.8424</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fuitdmj30al07cjro.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fvl6rsj30af07ct90.jpg" alt="png"></p><p>接下来，我们尝试将双向 RNN 的方法应用于温度预测任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(layers.Bidirectional(</span><br><span class="line">    layers.GRU(<span class="number">32</span>), input_shape=(<span class="literal">None</span>, float_data.shape[-<span class="number">1</span>])))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=RMSprop(), loss=<span class="string">&#x27;mae&#x27;</span>)</span><br><span class="line">history = model.fit_generator(train_gen,</span><br><span class="line">                              steps_per_epoch=<span class="number">500</span>,</span><br><span class="line">                              epochs=<span class="number">40</span>,</span><br><span class="line">                              validation_data=val_gen,</span><br><span class="line">                              validation_steps=val_steps)</span><br><span class="line">plot_acc_and_loss(history)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/40500/500 [==============================] - 81s 163ms/step - loss: 0.3022 - val_loss: 0.2796Epoch 2/40500/500 [==============================] - 76s 151ms/step - loss: 0.2761 - val_loss: 0.2619...Epoch 39/40500/500 [==============================] - 76s 152ms/step - loss: 0.1338 - val_loss: 0.3413Epoch 40/40500/500 [==============================] - 76s 152ms/step - loss: 0.1322 - val_loss: 0.3445</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghp1fp3nl0j30al07caae.jpg" alt="png"></p><h3 id="Going-even-further"><a href="#Going-even-further" class="headerlink" title="Going even further"></a>Going even further</h3><p>接下来还可以通过尝试，更进一步提高模型的能力：</p><ul><li>增加层的单元个数</li><li>调节 RMSprop 的学习率</li><li>尝试用 LSTM 层代替 GRU 层</li><li>在循环层上面(后面)使用更大的密集连接回归器（更大的 Dense 层或 Dense 层的堆叠）</li><li>在测试集上运行性能最佳的模型，防止模型对验证集过拟合</li></ul><p>最后，温馨提示：不要用这个搞气温预测的方法去预测证券价格哦。在市场上，过去的表现并不能很好地预测未来的收益：Looking in the rear-view mirror is a bad way to drive.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之理解循环神经网络</title>
      <link href="/2020/08/12/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_2/"/>
      <url>/2020/08/12/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_2/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第6章  深度学习用于文本和序列</strong> (Chapter 6. <em>Deep learning for text and sequences</em>) 的笔记。</p><p>[TOC]</p><h2 id="6-2-Understanding-recurrent-neural-networks"><a href="#6-2-Understanding-recurrent-neural-networks" class="headerlink" title="6.2 Understanding recurrent neural networks"></a>6.2 Understanding recurrent neural networks</h2><blockquote><p>理解循环神经网络</p></blockquote><p>之前我们用的全连接网络和卷积神经网络都有是被叫做 feedforward networks (前馈网络) 的。这种网络是无记忆的，也就是说，它们单独处理每个输入，在输入与输入之间没有保存任何状态。在这种网络中，我们要处理时间/文本等序列，就必须把一个完整的序列处理成一个大张量，整个的传到网络中，让模型一次看完整个序列。</p><p>这个显然和我们人类阅读、学习文本等信息的方式有所区别。我们不是一眼看完整本书的，我们要一个词一个词地看，眼睛不停移动获取新的数据的同时，记住之前的内容，将新的、旧的内容联系在一起来理解整句话的意思。说抽象一些，我们会保存一个关于所处理内容的内部模型，这个模型根据过去的信息构建，并随着新信息的进入而不断更新。我们都是以这种渐进的方式处理信息的。</p><p>按照这种思想，我们又得到一种新的模型，叫做<strong>循环神经网络</strong>(recurrent neural network, RNN)，这网络会遍历处理所有序列元素，并保存一个记录已查看内容相关信息的状态(state)。而在处理下一条序列之时，RNN 状态会被重置。使用 RNN 时，我们仍可以将一个序列整个的输出网络，不过在网络内部，数据不再是直接被整个处理，而是自动对序列元素进行遍历。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghgvghuih9j30iy0ict9s.jpg" alt="循环网络:带有环的网络"></p><p>为了理解循环神经网络，我们用 Numpy 手写一个玩具版的 RNN 前向传递。考虑处理形状为 <code>(timesteps, input_features)</code> 的一条序列，RNN 在 timesteps 上做迭代，将当前 timestep 的 input_features 与前一步得到的状态结合算出这一步的输出，然后将这个输出保存为新的状态供下一步使用。第一步时，没有状态，因此将状态初始化为一个全零向量，称为网络的初始状态。</p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state_t = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> input_t <span class="keyword">in</span> input_sequence:</span><br><span class="line">    output_t = f(input_t, state_t)</span><br><span class="line">    state_t = output_t</span><br></pre></td></tr></table></figure><p>这里的 <code>f(...)</code> 其实和我们的 Dense 层比较类似，但这里不仅处理输出，还要同时加入状态的影响。所以它就需要包含 3 个参数：分别作用与输出和状态的矩阵 W、U，以及偏移向量 b:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">input_t, state_t</span>):</span></span><br><span class="line">    <span class="keyword">return</span> activation(</span><br><span class="line">        dot(W, input_t) + dot(U, state_t) + b</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>画个图来表示这个程序：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghh2b81pn9j31520j276a.jpg" alt="一个简单的 RNN，沿时间展开"></p><p>下面把它写成真实的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义各种维度大小</span></span><br><span class="line">timesteps = <span class="number">100</span></span><br><span class="line">input_features = <span class="number">32</span></span><br><span class="line">output_features = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">inputs = np.random.random((timesteps, input_features))</span><br><span class="line"></span><br><span class="line">state_t = np.zeros((output_features))</span><br><span class="line"></span><br><span class="line">W = np.random.random((output_features, input_features))</span><br><span class="line">U = np.random.random((output_features, output_features))</span><br><span class="line">b = np.random.random((output_features))</span><br><span class="line"></span><br><span class="line">successive_outputs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> input_t <span class="keyword">in</span> inputs:    <span class="comment"># input_t: (input_features, )</span></span><br><span class="line">    output_t = np.tanh(   <span class="comment"># output_t: (output_features, )</span></span><br><span class="line">        np.dot(W, input_t) + np.dot(U, state_t) + b</span><br><span class="line">    )</span><br><span class="line">    successive_outputs.append(output_t)</span><br><span class="line">    </span><br><span class="line">    state_t = output_t</span><br><span class="line">    </span><br><span class="line">final_output_sequence = np.stack(successive_outputs, axis=<span class="number">0</span>)  <span class="comment"># (timesteps, output_features)</span></span><br><span class="line"></span><br><span class="line">print(successive_outputs[-<span class="number">1</span>].shape)</span><br><span class="line">print(final_output_sequence.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>(64,)(100, 64)</code></pre><p>在这里，我们最终输出是一个形状为 (timesteps, output_features) ，是所有 timesteps 的结果拼起来的。但实际上，我们一般只用最后一个结果 <code>successive_outputs[-1]</code> 就行了，这个里面已经包含了之前所有步骤的结果，即包含了整个序列的信息。</p><h3 id="Keras-中的循环层"><a href="#Keras-中的循环层" class="headerlink" title="Keras 中的循环层"></a>Keras 中的循环层</h3><p>把刚才这个玩具版本再加工一下，让它能接收形状为 <code>(batch_size, timesteps, input_features)</code> 的输入，批量去处理，就得到了 keras 中的 <code>SimpleRNN</code> 层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> SimpleRNN</span><br></pre></td></tr></table></figure><p>这个 SimpleRNN 层和 keras 中的其他循环层都有两种可选的输出模式：</p><table><thead><tr><th>输出形状</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td><code>(batch_size, timesteps, output_features)</code></td><td>输出每个 timestep 输出的完整序列</td><td>return_sequences=True</td></tr><tr><td><code>(batch_size, output_features)</code></td><td>只返回每个序列的最终输出</td><td>return_sequences=False (默认)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只返回最后一个时间步的输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding, SimpleRNN</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(<span class="number">10000</span>, <span class="number">32</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>))</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding (Embedding)        (None, None, 32)          320000    _________________________________________________________________simple_rnn (SimpleRNN)       (None, 32)                2080      =================================================================Total params: 322,080Trainable params: 322,080Non-trainable params: 0_________________________________________________________________</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回完整的状态序列</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(<span class="number">10000</span>, <span class="number">32</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>, return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_2&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_2 (Embedding)      (None, None, 32)          320000    _________________________________________________________________simple_rnn_2 (SimpleRNN)     (None, None, 32)          2080      =================================================================Total params: 322,080Trainable params: 322,080Non-trainable params: 0_________________________________________________________________</code></pre><p>如果我们要堆叠使用多个 RNN 层的时候，中间的层必须返回完整的状态序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆叠多个 RNN 层，中间层返回完整的状态序列</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(<span class="number">10000</span>, <span class="number">32</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>, return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>, return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>, return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>))    <span class="comment"># 最后一层要最后一个输出就行了</span></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_3&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_3 (Embedding)      (None, None, 32)          320000    _________________________________________________________________simple_rnn_3 (SimpleRNN)     (None, None, 32)          2080      _________________________________________________________________simple_rnn_4 (SimpleRNN)     (None, None, 32)          2080      _________________________________________________________________simple_rnn_5 (SimpleRNN)     (None, None, 32)          2080      _________________________________________________________________simple_rnn_6 (SimpleRNN)     (None, 32)                2080      =================================================================Total params: 328,320Trainable params: 328,320Non-trainable params: 0_________________________________________________________________</code></pre><p>接下来，我们尝试用 RNN 再次处理 IMDB 问题。首先，准备数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备 IMDB 数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> sequence</span><br><span class="line"></span><br><span class="line">max_features = <span class="number">10000</span></span><br><span class="line">maxlen = <span class="number">500</span></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Loading data...&#x27;</span>)</span><br><span class="line">(input_train, y_train), (input_test, y_test) = imdb.load_data(num_words=max_features)</span><br><span class="line">print(<span class="built_in">len</span>(input_train), <span class="string">&#x27;train sequences&#x27;</span>)</span><br><span class="line">print(<span class="built_in">len</span>(input_test), <span class="string">&#x27;test sequences&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Pad sequences (samples x time)&#x27;</span>)</span><br><span class="line">input_train = sequence.pad_sequences(input_train, maxlen=maxlen)</span><br><span class="line">input_test = sequence.pad_sequences(input_test, maxlen=maxlen)</span><br><span class="line">print(<span class="string">&#x27;input_train shape:&#x27;</span>, input_train.shape)</span><br><span class="line">print(<span class="string">&#x27;input_train shape:&#x27;</span>, input_test.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>Loading data...25000 train sequences25000 test sequencesPad sequences (samples x time)input_train shape: (25000, 500)input_train shape: (25000, 500)</code></pre><p>构建并训练网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Embedding 层和 SimpleRNN 层来训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding, SimpleRNN, Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(max_features, <span class="number">32</span>))</span><br><span class="line">model.add(SimpleRNN(<span class="number">32</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, </span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">history = model.fit(input_train, y_train, </span><br><span class="line">                    epochs=<span class="number">10</span>, </span><br><span class="line">                    batch_size=<span class="number">128</span>, </span><br><span class="line">                    validation_split=<span class="number">0.2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_4&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_4 (Embedding)      (None, None, 32)          320000    _________________________________________________________________simple_rnn_7 (SimpleRNN)     (None, 32)                2080      _________________________________________________________________dense (Dense)                (None, 1)                 33        =================================================================Total params: 322,113Trainable params: 322,113Non-trainable params: 0_________________________________________________________________Epoch 1/10157/157 [==============================] - 17s 107ms/step - loss: 0.6445 - acc: 0.6106 - val_loss: 0.6140 - val_acc: 0.6676Epoch 2/10157/157 [==============================] - 20s 129ms/step - loss: 0.4139 - acc: 0.8219 - val_loss: 0.4147 - val_acc: 0.8194Epoch 3/10157/157 [==============================] - 20s 124ms/step - loss: 0.3041 - acc: 0.8779 - val_loss: 0.4529 - val_acc: 0.8012Epoch 4/10157/157 [==============================] - 18s 115ms/step - loss: 0.2225 - acc: 0.9151 - val_loss: 0.3957 - val_acc: 0.8572Epoch 5/10157/157 [==============================] - 18s 115ms/step - loss: 0.1655 - acc: 0.9391 - val_loss: 0.4416 - val_acc: 0.8246Epoch 6/10157/157 [==============================] - 17s 111ms/step - loss: 0.1167 - acc: 0.9601 - val_loss: 0.4614 - val_acc: 0.8606Epoch 7/10157/157 [==============================] - 17s 109ms/step - loss: 0.0680 - acc: 0.9790 - val_loss: 0.4754 - val_acc: 0.8408Epoch 8/10157/157 [==============================] - 15s 95ms/step - loss: 0.0419 - acc: 0.9875 - val_loss: 0.5337 - val_acc: 0.8352Epoch 9/10157/157 [==============================] - 16s 99ms/step - loss: 0.0246 - acc: 0.9935 - val_loss: 0.5796 - val_acc: 0.8468Epoch 10/10157/157 [==============================] - 15s 96ms/step - loss: 0.0174 - acc: 0.9952 - val_loss: 0.7274 - val_acc: 0.7968</code></pre><p>绘制训练过程看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(acc))</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnskm7t47j30al07caac.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnskna7p7j30af07c74j.jpg" alt="png"></p><p>Emmmm，其实吧，这个模型的结果还没有第三章里面的用几个全连接层堆叠起来的模型好。原因有好几个，一个是我们这里只考虑了每个序列的前 500 个单词，还有一个是 SimpleRNN 其实并不擅长处理很长的序列。接下来，我们会看几个能表现的更好的循环层。</p><h4 id="LSTM-层和-GRU-层"><a href="#LSTM-层和-GRU-层" class="headerlink" title="LSTM 层和 GRU 层"></a>LSTM 层和 GRU 层</h4><p>在 Keras 中的循环层，除了 SimpleRNN，还有更“不simple”一些的 LSTM 层和 GRU 层，后面这两种会更常用。</p><p>SimpleRNN 是有一些问题的，理论上，在遍历到时间步 t 的时候，它应该是能留存着之前许多步以来见过的信息的，但实际的应用中，由于某种叫做 vanishing gradient problem（梯度消失问题）的现象，它并不能学到这种长期依赖。</p><p>梯度消失问题其实在层数比较多的前馈网络里面也会有发生，主要表现就是随着层数多了之后，网络无法训练了。LSTM 层和 GRU 层就是对抗这种问题而生的。</p><p><strong>LSTM</strong> 层是基于 LSTM (长短期记忆，long short-term memory) 算法的，这算法就是专门研究了处理梯度消失问题的。其实它的核心思想就是要保存信息以便后面使用，防止前面得到的信息在后面的处理中逐渐消失。</p><p>LSTM 在 SimpleRNN 的基础上，增加了一种跨越多个时间步传递信息的方法。这个新方法做的事情就像一条在序列旁边的辅助传送带，序列中的信息可以在任意位置跳上传送带， 然后被传送到更晚的时间步，并在需要时原封不动地跳回来。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghhebke5inj31p80rq78o.jpg" alt="剖析 LSTM，从 SimpleRNN 到 LSTM:添加一个携带轨道"></p><p>这里把之前 SimpleRNN 里面的权重 W、U 重命名为 Wo、Uo 了（o 表示 output）。然后加了一个“携带轨道”数据流，这个携带轨道就是用来携带信息跨越时间步的。这个携带轨道上面放着时间步 t 的 ct 信息（c 表示 carry），这些信息将与输入、状态一起进行运算，而影响传递到下一个时间步的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output_t &#x3D; activation(dot(state_t, Uo) + dot(input_t, Wo) + dot(C_t, Vo) + bo)</span><br><span class="line"></span><br><span class="line">i_t &#x3D; activation(dot(state_t, Ui) + dot(input_t, Wi) + bi)</span><br><span class="line">f_t &#x3D; activation(dot(state_t, Uf) + dot(input_t, Wf) + bf)</span><br><span class="line">k_t &#x3D; activation(dot(state_t, Uk) + dot(input_t, Wk) + bk)</span><br><span class="line"></span><br><span class="line">c_t_next &#x3D; i_t * k_t + c_t * f_t</span><br></pre></td></tr></table></figure><p>关于 LSTM 更多的细节、内部实现就不介绍了。咱完全不需要理解关于 LSTM 单元的具体架构，理解这东西就不是人干的事。我们只需要记住 LSTM 单元的作用: 允许把过去的信息稍后再次拿进来用，从而对抗梯度消失问题。</p><p>(P.S. 作者说这里是玄学，信他就行了。🤪 Emmm，这句是我胡翻的，原话是:“it may seem a bit arbitrary, but bear with me.”)</p><p><strong>GRU</strong>（Gated Recurrent Unit, 门控循环单元），书上提的比较少，参考这篇 《<a href="https://zhuanlan.zhihu.com/p/32481747">人人都能看懂的GRU</a>》，说 GRU 大概是 LSTM 的一种变种吧，二者原理区别不大、实际效果上也差不多。但 GRU 比 LSTM 新一些，它做了一些简化，更容易计算一些，但相应表示能力可能稍差一点点。</p><h4 id="Keras-中使用-LSTM"><a href="#Keras-中使用-LSTM" class="headerlink" title="Keras 中使用 LSTM"></a>Keras 中使用 LSTM</h4><p>我们还是继续用之前处理好的的 IMDB 数据来跑一个 LSTM：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(max_features, <span class="number">32</span>))</span><br><span class="line">model.add(LSTM(<span class="number">32</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, </span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(input_train, y_train, </span><br><span class="line">                    epochs=<span class="number">10</span>, </span><br><span class="line">                    batch_size=<span class="number">128</span>, </span><br><span class="line">                    validation_split=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_5&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_5 (Embedding)      (None, None, 32)          320000    _________________________________________________________________lstm (LSTM)                  (None, 32)                8320      _________________________________________________________________dense_1 (Dense)              (None, 1)                 33        =================================================================Total params: 328,353Trainable params: 328,353Non-trainable params: 0_________________________________________________________________Epoch 1/10157/157 [==============================] - 37s 236ms/step - loss: 0.5143 - acc: 0.7509 - val_loss: 0.3383 - val_acc: 0.8672Epoch 2/10157/157 [==============================] - 37s 235ms/step - loss: 0.3010 - acc: 0.8834 - val_loss: 0.2817 - val_acc: 0.8862Epoch 3/10157/157 [==============================] - 34s 215ms/step - loss: 0.2357 - acc: 0.9129 - val_loss: 0.2766 - val_acc: 0.8876Epoch 4/10157/157 [==============================] - 34s 215ms/step - loss: 0.2062 - acc: 0.9255 - val_loss: 0.4392 - val_acc: 0.8310Epoch 5/10157/157 [==============================] - 34s 215ms/step - loss: 0.1762 - acc: 0.9360 - val_loss: 0.3078 - val_acc: 0.8670Epoch 6/10157/157 [==============================] - 34s 215ms/step - loss: 0.1575 - acc: 0.9436 - val_loss: 0.3293 - val_acc: 0.8902Epoch 7/10157/157 [==============================] - 35s 222ms/step - loss: 0.1419 - acc: 0.9506 - val_loss: 0.2993 - val_acc: 0.8898Epoch 8/10157/157 [==============================] - 39s 246ms/step - loss: 0.1277 - acc: 0.9546 - val_loss: 0.4179 - val_acc: 0.8234Epoch 9/10157/157 [==============================] - 35s 225ms/step - loss: 0.1199 - acc: 0.9585 - val_loss: 0.4391 - val_acc: 0.8434Epoch 10/10157/157 [==============================] - 34s 217ms/step - loss: 0.1113 - acc: 0.9615 - val_loss: 0.4926 - val_acc: 0.8614</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(acc))</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnsko5b0pj30al07cdg3.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnskmosogj30al07cdg5.jpg" alt="png"></p><p>比 SimpleRNN 好多了。但也没比以前那种用全连接层的网络好多少，而且还比较慢(计算代价大)，其实主要是由于情感分析这样的问题，用 LSTM 去分析全局的长期性结构帮助并不是很大，LSTM 擅长的是更复杂的自然语言处理问题，比如机器翻译。用全连接的方法，其实是做了看出现了哪些词及其出现频率，这个对这种简单问题还比较有效。</p><p>然后，我们再试试书上没提的 GRU：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把 LSTM 改成用 GRU</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> GRU</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(max_features, <span class="number">32</span>))</span><br><span class="line">model.add(GRU(<span class="number">32</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, </span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(input_train, y_train, </span><br><span class="line">                    epochs=<span class="number">10</span>, </span><br><span class="line">                    batch_size=<span class="number">128</span>, </span><br><span class="line">                    validation_split=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(acc))</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_6&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_6 (Embedding)      (None, None, 32)          320000    _________________________________________________________________gru (GRU)                    (None, 32)                6336      _________________________________________________________________dense_2 (Dense)              (None, 1)                 33        =================================================================Total params: 326,369Trainable params: 326,369Non-trainable params: 0_________________________________________________________________Epoch 1/10157/157 [==============================] - 37s 238ms/step - loss: 0.5119 - acc: 0.7386 - val_loss: 0.3713 - val_acc: 0.8434Epoch 2/10157/157 [==============================] - 36s 232ms/step - loss: 0.2971 - acc: 0.8806 - val_loss: 0.3324 - val_acc: 0.8722Epoch 3/10157/157 [==============================] - 37s 235ms/step - loss: 0.2495 - acc: 0.9034 - val_loss: 0.3148 - val_acc: 0.8722Epoch 4/10157/157 [==============================] - 34s 217ms/step - loss: 0.2114 - acc: 0.9200 - val_loss: 0.3596 - val_acc: 0.8738Epoch 5/10157/157 [==============================] - 36s 231ms/step - loss: 0.1872 - acc: 0.9306 - val_loss: 0.5291 - val_acc: 0.8084Epoch 6/10157/157 [==============================] - 35s 226ms/step - loss: 0.1730 - acc: 0.9359 - val_loss: 0.3976 - val_acc: 0.8802Epoch 7/10157/157 [==============================] - 34s 217ms/step - loss: 0.1523 - acc: 0.9452 - val_loss: 0.4303 - val_acc: 0.8532Epoch 8/10157/157 [==============================] - 34s 217ms/step - loss: 0.1429 - acc: 0.9486 - val_loss: 0.4019 - val_acc: 0.8542Epoch 9/10157/157 [==============================] - 34s 217ms/step - loss: 0.1258 - acc: 0.9562 - val_loss: 0.3476 - val_acc: 0.8746Epoch 10/10157/157 [==============================] - 34s 216ms/step - loss: 0.1191 - acc: 0.9585 - val_loss: 0.3558 - val_acc: 0.8812</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnskl04gej30al07cjrn.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnsklsn9gj30af07cglv.jpg" alt="png"></p><p>所以说，结果区别不大。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之处理文本数据</title>
      <link href="/2020/08/11/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_1/"/>
      <url>/2020/08/11/DeepLearningWithPython/Deep-Learning%20with-Python-ch6_1/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第6章  深度学习用于文本和序列</strong> (Chapter 6. <em>Deep learning for text and sequences</em>) 的笔记。</p><p>[TOC]</p><h2 id="6-1-Working-with-text-data"><a href="#6-1-Working-with-text-data" class="headerlink" title="6.1  Working with text data"></a>6.1  Working with text data</h2><blockquote><p>处理文本数据</p></blockquote><p>要用深度学习的神经网络处理文本数据，和图片类似，也要把数据向量化：文本 -&gt; 数值张量。</p><p>要做这种事情可以把每个单词变成向量，也可以把字符变成向量，还可以把多个连续单词或字符(称为 <em>N-grams</em>)变成向量。</p><p>反正不管如何划分，我们把文本拆分出来的单元叫做 <em>tokens</em>（标记），拆分文本的过程叫做 <em>tokenization</em>(分词)。</p><blockquote><p>注：token 的中文翻译是“标记”😂。这些翻译都怪怪的，虽然 token 确实有标记这个意思，但把这里的 token 翻译成标记就没内味儿了。我觉得 token 是那种以一个东西代表另一个东西来使用的意思，这种 token 是一种有实体的东西，比如代金券。“标记”这个词在字典上作名词是「起标示作用的记号」的意思，而我觉得记号不是个很实体的东西。代金券不是一种记号、也就能说是标记，同样的，这里的 token 也是一种实体的东西，我觉得不能把它说成是“标记”。我不赞同这种译法，所以下文所有涉及 token 的地方统一写成 “token”，不翻译成“标记”。</p></blockquote><p>文本的向量化就是先作分词，然后把生成出来的 token 逐个与数值向量对应起来，最后拿对应的数值向量合成一个表达了原文本的张量。其中，比较有意思的是如何建立 token 和 数值向量 的联系，下面介绍两种搞这个的方法：one-hot encoding(one-hot编码) 和 token embedding(标记嵌入)，其中 token embedding 一般都用于单词，叫作词嵌入「word embedding」。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghek3mhp38j31320mg0v8.jpg" alt="文本的向量化：从文本到token再到张量"></p><h3 id="n-grams-和词袋-bag-of-words"><a href="#n-grams-和词袋-bag-of-words" class="headerlink" title="n-grams 和词袋(bag-of-words)"></a>n-grams 和词袋(bag-of-words)</h3><p>n-gram 是能从一个句子中提取出的 ≤N 个连续单词的集合。例如：「The cat sat on the mat.」</p><p>这个句子分解成 2-gram 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;The&quot;, &quot;The cat&quot;, &quot;cat&quot;, &quot;cat sat&quot;, &quot;sat&quot;,</span><br><span class="line">  &quot;sat on&quot;, &quot;on&quot;, &quot;on the&quot;, &quot;the&quot;, &quot;the mat&quot;, &quot;mat&quot;&#125;</span><br></pre></td></tr></table></figure><p>这个集合被叫做 bag-of-2-grams (二元语法袋)。</p><p>分解成 3-gram 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;The&quot;, &quot;The cat&quot;, &quot;cat&quot;, &quot;cat sat&quot;, &quot;The cat sat&quot;,</span><br><span class="line">  &quot;sat&quot;, &quot;sat on&quot;, &quot;on&quot;, &quot;cat sat on&quot;, &quot;on the&quot;, &quot;the&quot;,</span><br><span class="line">  &quot;sat on the&quot;, &quot;the mat&quot;, &quot;mat&quot;, &quot;on the mat&quot;&#125;</span><br></pre></td></tr></table></figure><p>这个集合被叫做 bag-of-3-grams (三元语法袋)。</p><p>把这东西叫做「袋」是因为它只是 tokens 组成的集合，没有原来文本的顺序和意义。把文本分成这种袋的分词方法叫做「词袋(bag-of-words)」。</p><p>由于词袋是不保存顺序的（分出来是集合，不是序列），所以一般不在深度学习里面用。但在轻量级的浅层文本处理模型里面，n-gram 和词袋还是很重要的方法的。</p><h3 id="one-hot-编码"><a href="#one-hot-编码" class="headerlink" title="one-hot 编码"></a>one-hot 编码</h3><p>one-hot 是比较基本、常用的。其做法是将每个 token 与一个唯一整数索引关联， 然后将整数索引 i 转换为长度为 N 的二进制向量(N 是词表大小)，这个向量只有第 i 个元素为 1，其余元素都为 0。</p><p>下面给出两个玩具版本的 one-hot 编码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单词级的 one-hot 编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">samples = [<span class="string">&#x27;The cat sat on the mat.&#x27;</span>, <span class="string">&#x27;The dog ate my homework.&#x27;</span>]</span><br><span class="line"></span><br><span class="line">token_index = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> sample <span class="keyword">in</span> samples:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sample.split():</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> token_index:</span><br><span class="line">            token_index[word] = <span class="built_in">len</span>(token_index) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 对样本进行分词。只考虑每个样本前 max_length 个单词</span></span><br><span class="line">max_length = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">results = np.zeros(shape=(<span class="built_in">len</span>(samples), </span><br><span class="line">                          max_length, </span><br><span class="line">                          <span class="built_in">max</span>(token_index.values()) + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i, sample <span class="keyword">in</span> <span class="built_in">enumerate</span>(samples):</span><br><span class="line">    <span class="keyword">for</span> j, word <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">enumerate</span>(sample.split()))[:max_length]:</span><br><span class="line">        index = token_index.get(word)</span><br><span class="line">        results[i, j, index] = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure><pre><code>[[[0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] [[0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符级的 one-hot 编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">samples = [<span class="string">&#x27;The cat sat on the mat.&#x27;</span>, <span class="string">&#x27;The dog ate my homework.&#x27;</span>]</span><br><span class="line"></span><br><span class="line">characters = string.printable    <span class="comment"># 所有可打印的 ASCII 字符</span></span><br><span class="line">token_index = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(characters) + <span class="number">1</span>), characters))</span><br><span class="line"></span><br><span class="line">max_length = <span class="number">50</span></span><br><span class="line">results = np.zeros((<span class="built_in">len</span>(samples), max_length, <span class="built_in">max</span>(token_index.keys()) + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i, sample <span class="keyword">in</span> <span class="built_in">enumerate</span>(samples):</span><br><span class="line">    <span class="keyword">for</span> j, character <span class="keyword">in</span> <span class="built_in">enumerate</span>(sample):</span><br><span class="line">        index = token_index.get(character)</span><br><span class="line">        results[i, j, index] = <span class="number">1.</span></span><br><span class="line">        </span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure><pre><code>[[[1. 1. 1. ... 1. 1. 1.]  [1. 1. 1. ... 1. 1. 1.]  [1. 1. 1. ... 1. 1. 1.]  ...  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]] [[1. 1. 1. ... 1. 1. 1.]  [1. 1. 1. ... 1. 1. 1.]  [1. 1. 1. ... 1. 1. 1.]  ...  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]]]</code></pre><p>Keras 内置了比刚才写的这种玩具版本强大得多的 one-hot 编码工具，在现实使用中，你应该使用这种方法，而不是使用刚才的玩具版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line"></span><br><span class="line">samples = [<span class="string">&#x27;The cat sat on the mat.&#x27;</span>, <span class="string">&#x27;The dog ate my homework.&#x27;</span>]</span><br><span class="line"></span><br><span class="line">tokenizer = Tokenizer(num_words=<span class="number">1000</span>)    <span class="comment"># 只考虑前 1000 个最常见的单词</span></span><br><span class="line">tokenizer.fit_on_texts(samples)</span><br><span class="line"></span><br><span class="line">sequences = tokenizer.texts_to_sequences(samples)    <span class="comment"># 将字符串转换为整数索引组成的列表</span></span><br><span class="line">print(<span class="string">&#x27;sequences:&#x27;</span>, sequences)</span><br><span class="line"></span><br><span class="line">one_hot_results = tokenizer.texts_to_matrix(samples, mode=<span class="string">&#x27;binary&#x27;</span>)  <span class="comment"># 直接得到 one-hot 二进制表示</span></span><br><span class="line"></span><br><span class="line">word_index = tokenizer.word_index    <span class="comment"># 单词索引，就是词表字典啦，用这个就可以还原数据</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f&#x27;one_hot_results: shape=<span class="subst">&#123;one_hot_results.shape&#125;</span>:\n&#x27;</span>, one_hot_results, )</span><br><span class="line">print(<span class="string">f&#x27;Found <span class="subst">&#123;<span class="built_in">len</span>(word_index)&#125;</span> unique tokens.&#x27;</span>, <span class="string">&#x27;word_index:&#x27;</span>, word_index)</span><br></pre></td></tr></table></figure><pre><code>sequences: [[1, 2, 3, 4, 1, 5], [1, 6, 7, 8, 9]]one_hot_results: shape=(2, 1000): [[0. 1. 1. ... 0. 0. 0.] [0. 1. 0. ... 0. 0. 0.]]Found 9 unique tokens. word_index: &#123;&#39;the&#39;: 1, &#39;cat&#39;: 2, &#39;sat&#39;: 3, &#39;on&#39;: 4, &#39;mat&#39;: 5, &#39;dog&#39;: 6, &#39;ate&#39;: 7, &#39;my&#39;: 8, &#39;homework&#39;: 9&#125;</code></pre><p>这种 one-hot 编码还有一种简单的变种叫做 <em>one-hot hashing trick</em>（one-hot 散列技巧），这个方法的思想是不对每个 token 关联唯一的整数索引，而是用哈希函数去作用，把文本直接映射成一个固定长度的向量。</p><p>用这种方法可以节省维护单词索引的内存开销，还可以实现在线编码（来一个编码一个，不影响之、之后的）；但也有一些弊端：可能出现散列冲突，编码后的数据也不能够还原。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用散列技巧的单词级的 one-hot 编码，玩具版本</span></span><br><span class="line"></span><br><span class="line">samples = [<span class="string">&#x27;The cat sat on the mat.&#x27;</span>, <span class="string">&#x27;The dog ate my homework.&#x27;</span>]</span><br><span class="line"></span><br><span class="line">dimensionality = <span class="number">1000</span>  <span class="comment"># 将单词保存为长度为 1000 的向量，单词越多这个值就要越大，不然散列冲突可能会加大</span></span><br><span class="line">max_length = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">results = np.zeros((<span class="built_in">len</span>(samples), max_length, dimensionality))</span><br><span class="line"><span class="keyword">for</span> i, sample <span class="keyword">in</span> <span class="built_in">enumerate</span>(samples):</span><br><span class="line">    <span class="keyword">for</span> j, word <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">enumerate</span>(sample.split()))[:max_length]:</span><br><span class="line">        index = <span class="built_in">abs</span>(<span class="built_in">hash</span>(word)) % dimensionality  <span class="comment"># 将单词散列到 0~dimensionality 范围内的一个随机整数索引</span></span><br><span class="line">        results[i, j, index] = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">print(results.shape)</span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure><pre><code>(2, 10, 1000)[[[0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  ...  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]] [[0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  ...  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]  [0. 0. 0. ... 0. 0. 0.]]]</code></pre><h3 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h3><p>从前面的例子中也可以看到 one-hot 的这种硬编码得到的结果向量十分稀疏，并且维度比较高。</p><p>词嵌入（word embedding）是另一种将单词与向量相关联的常用方法。这种方法可以得到比 one-hot 更加密集、低维的编码。词嵌入的结果是要从数据中学习得到的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheskpva1tj31fq0u0aeq.jpg" alt="one-hot编码与词嵌入的区别"></p><p>运用词嵌入有两种方法：</p><ol><li>利用 Embedding 层学习词嵌入：在完成着手进行的主要任务(比如文档分类或情感预测)的同时学习词嵌入：一开始使用随机的词向量，然后对词向量用与学习神经网络的权重相同的方法进行学习。</li><li>利用预训练词嵌入(pretrained word embedding)：在不同于待解决问题的机器学习任务上预训练好词嵌入，然后将其加载到模型中。</li></ol><h4 id="利用-Embedding-层学习词嵌入"><a href="#利用-Embedding-层学习词嵌入" class="headerlink" title="利用 Embedding 层学习词嵌入"></a>利用 Embedding 层学习词嵌入</h4><p>一个理想的词嵌入空间应该是可以比较完美地映射人类语言的。它是有符合现实的结构的，相近的词在空间中就应该比较接近，并且词嵌入空间中的方向也是要有意义的。例如一个比较简单的例子：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghetlonkiij30i40lmmyf.jpg" alt="词嵌入空间的简单示例"></p><p>在这个词嵌入空间中，宠物都在靠下的位置，野生动物都在靠上的位置，所以一个从下到上方向的向量就应该是表示从宠物到野生动物的，这个向量从 cat 到 tiger 或者 dog -&gt; wolf。类似的，一个从左到右的向量可以解释为从犬科到猫科，这个向量可以从 dog 到 cat，或者从 wolf 到 tiger。</p><p>再复杂一点的，比如要表示词的性别关系，将 king 向量加上 female 向量，应该得到的是 queen 向量，还有复数关系：king + plural == kings……</p><p>所以说，要有一个这样完美的词嵌入空间是很难的，现在还没有。但利用深度学习，我们还是可以得到对于特定问题来说比较好的词嵌入空间的。在 Keras 使中，我们只需要让模型学习一个 Embedding 层的权重就可以得到对当前任务的词嵌入空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding</span><br><span class="line"></span><br><span class="line">embedding_layer = Embedding(<span class="number">1000</span>, <span class="number">64</span>)  <span class="comment"># Embedding(可能的token个数, 嵌入的维度)</span></span><br></pre></td></tr></table></figure><p>Embedding 层其实就相当于是一个字典，它将一个表示特定单词的整数索引映射到一个词向量。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gheu1p4zqdj316i046aau.jpg" alt="Embedding 层"></p><p>Embedding 层的输入是形状为 <code>(samples, sequence_length)</code> 的二维整数张量。这个输入张量中的一个元素是一个代表一个文本序列的整数序列，应该保持输入的所有序列长度相同，较短的序列应该用 0 填充，较长的序列应该被截断。</p><p>Embedding 层的输出是形状为 <code>(samples, sequence_length, embedding_dimensionality)</code> 的三维浮点数张量。这个输出就可以用 RNN 或者 Conv1D 去处理做其他事情了。</p><p>Embedding 层一开始也是被随机初始化的，在训练过程中，会利用反向传播来逐渐调节词向量、改变空间结构，一步步接近我们之前提到的那种理想的状态。</p><p>实例：用 Embedding 层处理 IMDB 电影评论情感预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 IMDB 数据，准备用于 Embedding 层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line">max_features = <span class="number">10000</span>    <span class="comment"># 作为特征的单词个数</span></span><br><span class="line">maxlen = <span class="number">20</span>    <span class="comment"># 在 maxlen 个特征单词后截断文本</span></span><br><span class="line"></span><br><span class="line">(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_features)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数列表转换成形状为 (samples, maxlen) 的二维整数张量</span></span><br><span class="line">x_train = preprocessing.sequence.pad_sequences(x_train, maxlen=maxlen)</span><br><span class="line">x_test = preprocessing.sequence.pad_sequences(x_test, maxlen=maxlen)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 IMDB 数据上使用 Embedding 层和分类器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding, Flatten, Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(<span class="number">10000</span>, <span class="number">8</span>, input_length=maxlen))  <span class="comment"># (samples, maxlen, 8)</span></span><br><span class="line">model.add(Flatten())  <span class="comment"># (samles, maxlen*8)</span></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))  <span class="comment"># top classifier</span></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train, y_train, </span><br><span class="line">                    epochs=<span class="number">10</span>, </span><br><span class="line">                    batch_size=<span class="number">32</span>, </span><br><span class="line">                    validation_split=<span class="number">0.2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_2 (Embedding)      (None, 20, 8)             80000     _________________________________________________________________flatten_1 (Flatten)          (None, 160)               0         _________________________________________________________________dense_1 (Dense)              (None, 1)                 161       =================================================================Total params: 80,161Trainable params: 80,161Non-trainable params: 0_________________________________________________________________Epoch 1/10625/625 [==============================] - 1s 1ms/step - loss: 0.6686 - acc: 0.6145 - val_loss: 0.6152 - val_acc: 0.6952Epoch 2/10625/625 [==============================] - 1s 929us/step - loss: 0.5370 - acc: 0.7525 - val_loss: 0.5214 - val_acc: 0.7318Epoch 3/10625/625 [==============================] - 1s 878us/step - loss: 0.4573 - acc: 0.7895 - val_loss: 0.4979 - val_acc: 0.7456Epoch 4/10625/625 [==============================] - 1s 889us/step - loss: 0.4182 - acc: 0.8116 - val_loss: 0.4937 - val_acc: 0.7512Epoch 5/10625/625 [==============================] - 1s 902us/step - loss: 0.3931 - acc: 0.8224 - val_loss: 0.4935 - val_acc: 0.7568Epoch 6/10625/625 [==============================] - 1s 931us/step - loss: 0.3721 - acc: 0.8360 - val_loss: 0.4969 - val_acc: 0.7582Epoch 7/10625/625 [==============================] - 1s 878us/step - loss: 0.3534 - acc: 0.8482 - val_loss: 0.5050 - val_acc: 0.7570Epoch 8/10625/625 [==============================] - 1s 873us/step - loss: 0.3356 - acc: 0.8579 - val_loss: 0.5103 - val_acc: 0.7556Epoch 9/10625/625 [==============================] - 1s 999us/step - loss: 0.3183 - acc: 0.8670 - val_loss: 0.5161 - val_acc: 0.7560Epoch 10/10625/625 [==============================] - 1s 886us/step - loss: 0.3017 - acc: 0.8766 - val_loss: 0.5260 - val_acc: 0.7508</code></pre><p>这里我们只把词嵌入序列展开之后用一个 Dense 层去完成分类，会导致模型对输入序列中的每个词单独处理，而不去考虑单词之间的关系和句子结构。这会导致模型认为「this movie is a bomb(这电影超烂)」和「this movie is the bomb(这电影超赞)」都是负面评价。要学习句子整体的话就要用到 RNN 或者 Conv1D 了，这些之后再介绍。</p><h4 id="使用预训练的词嵌入"><a href="#使用预训练的词嵌入" class="headerlink" title="使用预训练的词嵌入"></a>使用预训练的词嵌入</h4><p>和我们在做计算机视觉的时候使用预训练网络一样，在手头数据少的情况下，使用预训练的词嵌入，借用人家训练出来的可复用的模型里的通用特征。</p><p>通用的词嵌入通常是利用词频统计计算得出的，现在也有很多可供我们选用的了，比如 word2vec、GloVe 等等，具体的原理都比较复杂，我们先会用就行了。</p><p>我们会在下文的例子中尝试使用 GloVe。</p><h3 id="从原始文本到词嵌入"><a href="#从原始文本到词嵌入" class="headerlink" title="从原始文本到词嵌入"></a>从原始文本到词嵌入</h3><p>我们尝试从原始的 IMDB 数据（就是一大堆文本啦）开始，处理数据，做词嵌入。</p><h4 id="下载-IMDB-数据的原始文本"><a href="#下载-IMDB-数据的原始文本" class="headerlink" title="下载 IMDB 数据的原始文本"></a>下载 IMDB 数据的原始文本</h4><p>原始的 IMDB 数据集可以从 <a href="http://mng.bz/0tIo">http://mng.bz/0tIo</a> 下载（最后是跳转到从s3下的 <a href="http://s3.amazonaws.com/text-datasets/aclImdb.zip">http://s3.amazonaws.com/text-datasets/aclImdb.zip</a> ，不科学上网很慢哦）。</p><p>下载的数据集解压后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aclImdb</span><br><span class="line">├── test</span><br><span class="line">│   ├── neg</span><br><span class="line">│   └── pos</span><br><span class="line">└── train</span><br><span class="line">    ├── neg</span><br><span class="line">    └── pos</span><br></pre></td></tr></table></figure><p>在每个 neg/pos 目录下面就是一大堆 <code>.txt</code> 文件了，每个里面是一条评论。</p><p>下面，我们将 train 评论转换成字符串列表，一个字符串一条评论，并把对应的标签(neg/pos)写到 labels 列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理 IMDB 原始数据的标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">imdb_dir = <span class="string">&#x27;/Volumes/WD/Files/dataset/aclImdb&#x27;</span></span><br><span class="line">train_dir = os.path.join(imdb_dir, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line"></span><br><span class="line">texts = []</span><br><span class="line">labels = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> label_type <span class="keyword">in</span> [<span class="string">&#x27;neg&#x27;</span>, <span class="string">&#x27;pos&#x27;</span>]:</span><br><span class="line">    dir_name = os.path.join(train_dir, label_type)</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(dir_name):</span><br><span class="line">        <span class="keyword">if</span> fname.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dir_name, fname)) <span class="keyword">as</span> f:</span><br><span class="line">                texts.append(f.read())</span><br><span class="line">            labels.append(<span class="number">0</span> <span class="keyword">if</span> label_type == <span class="string">&#x27;neg&#x27;</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(labels[<span class="number">0</span>], texts[<span class="number">0</span>], sep=<span class="string">&#x27; --&gt; &#x27;</span>)</span><br><span class="line">print(labels[-<span class="number">1</span>], texts[-<span class="number">1</span>], sep=<span class="string">&#x27; --&gt; &#x27;</span>)</span><br><span class="line">print(<span class="built_in">len</span>(texts), <span class="built_in">len</span>(labels))</span><br></pre></td></tr></table></figure><pre><code>0 --&gt; Working with one of the best Shakespeare sources, this film manages to be creditable to it&#39;s source, whilst still appealing to a wider audience.&lt;br /&gt;&lt;br /&gt;Branagh steals the film from under Fishburne&#39;s nose, and there&#39;s a talented cast on good form.1 --&gt; Enchanted April is a tone poem, an impressionist painting, a masterpiece of conveying a message with few words. It has been one of my 10 favorite films since it came out. I continue to wait, albeit less patiently, for the film to come out in DVD format. Apparently, I am not alone.&lt;br /&gt;&lt;br /&gt;If parent company Amazon&#39;s listings are correct, there are many people who want this title in DVD format. Many people want to go to Italy with this cast and this script. Many people want to keep a permanent copy of this film in their libraries. The cast is spectacular, the cinematography and direction impeccable. The film is a definite keeper. Many have already asked. Please add our names to the list.25000 25000</code></pre><h4 id="对数据进行分词"><a href="#对数据进行分词" class="headerlink" title="对数据进行分词"></a>对数据进行分词</h4><p>现在来分词，顺便划分一下训练集和验证集。为了体验预训练词嵌入，我们再把训练集搞小一点，只留200条数据用来训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 IMDB 原始数据的文本进行分词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br><span class="line"></span><br><span class="line">maxlen = <span class="number">100</span>  <span class="comment"># 只看每条评论的前100个词</span></span><br><span class="line">training_samples = <span class="number">200</span></span><br><span class="line">validation_samples = <span class="number">10000</span></span><br><span class="line">max_words = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">tokenizer = Tokenizer(num_words=max_words)</span><br><span class="line">tokenizer.fit_on_texts(texts)</span><br><span class="line">sequences = tokenizer.texts_to_sequences(texts)</span><br><span class="line">word_index = tokenizer.word_index</span><br><span class="line">print(<span class="string">f&#x27;Found <span class="subst">&#123;<span class="built_in">len</span>(word_index)&#125;</span> unique tokens.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data = pad_sequences(sequences, maxlen=maxlen)</span><br><span class="line"></span><br><span class="line">labels = np.asarray(labels)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Shape of data tensor:&#x27;</span>, data.shape)</span><br><span class="line">print(<span class="string">&#x27;Shape of label tensor:&#x27;</span>, labels.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打乱数据</span></span><br><span class="line">indices = np.arange(labels.shape[<span class="number">0</span>])</span><br><span class="line">np.random.shuffle(indices)</span><br><span class="line">data = data[indices]</span><br><span class="line">labels = labels[indices]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练、验证集</span></span><br><span class="line">x_train = data[:training_samples]</span><br><span class="line">y_train = labels[:training_samples]</span><br><span class="line">x_val = data[training_samples: training_samples + validation_samples]</span><br><span class="line">y_val = labels[training_samples: training_samples + validation_samples]</span><br></pre></td></tr></table></figure><pre><code>Found 88582 unique tokens.Shape of data tensor: (25000, 100)Shape of label tensor: (25000,)</code></pre><h4 id="下载-GloVe-词嵌入"><a href="#下载-GloVe-词嵌入" class="headerlink" title="下载 GloVe 词嵌入"></a>下载 GloVe 词嵌入</h4><p>下载预训练好的 GloVe 词嵌入： <a href="http://nlp.stanford.edu/data/glove.6B.zip">http://nlp.stanford.edu/data/glove.6B.zip</a></p><p>写下来把它解压，里面用纯文本保存了训练好的 400000 个 tokens 的 100 维词嵌入向量。</p><h4 id="对嵌入进行预处理"><a href="#对嵌入进行预处理" class="headerlink" title="对嵌入进行预处理"></a>对嵌入进行预处理</h4><p>解析解压后的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glove_dir = <span class="string">&#x27;/Volumes/WD/Files/glove.6B&#x27;</span></span><br><span class="line"></span><br><span class="line">embeddings_index = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(glove_dir, <span class="string">&#x27;glove.6B.100d.txt&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        values = line.split()</span><br><span class="line">        word = values[<span class="number">0</span>]</span><br><span class="line">        coefs = np.asarray(values[<span class="number">1</span>:], dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">        embeddings_index[word] = coefs</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&#x27;Found <span class="subst">&#123;<span class="built_in">len</span>(embeddings_index)&#125;</span> word vectors.&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Found 400000 word vectors.</code></pre><p>然后，我们要构建一个可以加载进 Embedding 层的嵌入矩阵，其形状为 <code>(max_words, embedding_dim)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">embedding_dim = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">embedding_matrix = np.zeros((max_words, embedding_dim))</span><br><span class="line"><span class="keyword">for</span> word, i <span class="keyword">in</span> word_index.items():</span><br><span class="line">    <span class="keyword">if</span> i &lt; max_words:</span><br><span class="line">        embedding_vector = embeddings_index.get(word)  <span class="comment"># 有的就用 embeddings_index 里的词向量</span></span><br><span class="line">        <span class="keyword">if</span> embedding_vector <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:               <span class="comment"># 没有就用全零</span></span><br><span class="line">            embedding_matrix[i] = embedding_vector</span><br><span class="line">            </span><br><span class="line">print(embedding_matrix)</span><br></pre></td></tr></table></figure><pre><code>[[ 0.          0.          0.         ...  0.          0.   0.        ] [-0.038194   -0.24487001  0.72812003 ... -0.1459      0.82779998   0.27061999] [-0.071953    0.23127     0.023731   ... -0.71894997  0.86894   0.19539   ] ... [-0.44036001  0.31821999  0.10778    ... -1.29849994  0.11824   0.64845002] [ 0.          0.          0.         ...  0.          0.   0.        ] [-0.54539001 -0.31817999 -0.016281   ... -0.44865     0.067047   0.17975999]]</code></pre><h4 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding, Flatten, Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(max_words, embedding_dim, input_length=maxlen))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_2&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_3 (Embedding)      (None, 100, 100)          1000000   _________________________________________________________________flatten_2 (Flatten)          (None, 10000)             0         _________________________________________________________________dense_2 (Dense)              (None, 32)                320032    _________________________________________________________________dense_3 (Dense)              (None, 1)                 33        =================================================================Total params: 1,320,065Trainable params: 1,320,065Non-trainable params: 0_________________________________________________________________</code></pre><h4 id="把-GloVe-词嵌入加载进模型"><a href="#把-GloVe-词嵌入加载进模型" class="headerlink" title="把 GloVe 词嵌入加载进模型"></a>把 GloVe 词嵌入加载进模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.layers[<span class="number">0</span>].set_weights([embedding_matrix])</span><br><span class="line">model.layers[<span class="number">0</span>].trainable = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="训练与评估模型"><a href="#训练与评估模型" class="headerlink" title="训练与评估模型"></a>训练与评估模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">history = model.fit(x_train, y_train, </span><br><span class="line">                    epochs=<span class="number">10</span>, </span><br><span class="line">                    batch_size=<span class="number">32</span>, </span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line">model.save_weights(<span class="string">&#x27;pre_trained_glove_model.h5&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/107/7 [==============================] - 0s 64ms/step - loss: 1.3595 - acc: 0.5150 - val_loss: 0.6871 - val_acc: 0.5490Epoch 2/107/7 [==============================] - 0s 42ms/step - loss: 0.6846 - acc: 0.7950 - val_loss: 0.7569 - val_acc: 0.5217Epoch 3/107/7 [==============================] - 0s 42ms/step - loss: 0.3757 - acc: 0.8900 - val_loss: 0.8181 - val_acc: 0.5189Epoch 4/107/7 [==============================] - 0s 41ms/step - loss: 0.3464 - acc: 0.8800 - val_loss: 0.8497 - val_acc: 0.4971Epoch 5/107/7 [==============================] - 0s 41ms/step - loss: 0.2278 - acc: 0.9600 - val_loss: 0.8661 - val_acc: 0.5308Epoch 6/107/7 [==============================] - 0s 42ms/step - loss: 0.1328 - acc: 0.9950 - val_loss: 0.6977 - val_acc: 0.5895Epoch 7/107/7 [==============================] - 0s 42ms/step - loss: 0.1859 - acc: 0.9250 - val_loss: 0.6923 - val_acc: 0.5867Epoch 8/107/7 [==============================] - 0s 42ms/step - loss: 0.0950 - acc: 0.9950 - val_loss: 0.7609 - val_acc: 0.5609Epoch 9/107/7 [==============================] - 0s 50ms/step - loss: 0.0453 - acc: 1.0000 - val_loss: 0.7235 - val_acc: 0.5979Epoch 10/107/7 [==============================] - 0s 49ms/step - loss: 0.0398 - acc: 1.0000 - val_loss: 1.1416 - val_acc: 0.5063</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(acc))</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmvtdmhl3j30af07cmxf.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmvtbyf9tj30af07cglv.jpg" alt="png"></p><p>只用 200 个训练样本还是太难了，但用预训练词嵌入还是得到了不错的成果的。作为对比，看看如果不使用预训练，会是什么样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding, Flatten, Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(max_words, embedding_dim, input_length=maxlen))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">32</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用 GloVe 词嵌入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, </span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">history = model.fit(x_train, y_train, </span><br><span class="line">                    epochs=<span class="number">10</span>, </span><br><span class="line">                    batch_size=<span class="number">32</span>, </span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(acc))</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_3&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================embedding_4 (Embedding)      (None, 100, 100)          1000000   _________________________________________________________________flatten_3 (Flatten)          (None, 10000)             0         _________________________________________________________________dense_4 (Dense)              (None, 32)                320032    _________________________________________________________________dense_5 (Dense)              (None, 1)                 33        =================================================================Total params: 1,320,065Trainable params: 1,320,065Non-trainable params: 0_________________________________________________________________Epoch 1/107/7 [==============================] - 1s 72ms/step - loss: 0.6972 - acc: 0.4600 - val_loss: 0.6921 - val_acc: 0.5150Epoch 2/107/7 [==============================] - 0s 46ms/step - loss: 0.4991 - acc: 1.0000 - val_loss: 0.6901 - val_acc: 0.5347Epoch 3/107/7 [==============================] - 0s 46ms/step - loss: 0.2795 - acc: 1.0000 - val_loss: 0.6914 - val_acc: 0.5401Epoch 4/107/7 [==============================] - 0s 52ms/step - loss: 0.1171 - acc: 1.0000 - val_loss: 0.6977 - val_acc: 0.5389Epoch 5/107/7 [==============================] - 0s 45ms/step - loss: 0.0535 - acc: 1.0000 - val_loss: 0.7115 - val_acc: 0.5343Epoch 6/107/7 [==============================] - 0s 44ms/step - loss: 0.0271 - acc: 1.0000 - val_loss: 0.7133 - val_acc: 0.5348Epoch 7/107/7 [==============================] - 0s 44ms/step - loss: 0.0149 - acc: 1.0000 - val_loss: 0.7146 - val_acc: 0.5382Epoch 8/107/7 [==============================] - 0s 44ms/step - loss: 0.0087 - acc: 1.0000 - val_loss: 0.7192 - val_acc: 0.5410Epoch 9/107/7 [==============================] - 0s 44ms/step - loss: 0.0052 - acc: 1.0000 - val_loss: 0.7266 - val_acc: 0.5398Epoch 10/107/7 [==============================] - 0s 53ms/step - loss: 0.0032 - acc: 1.0000 - val_loss: 0.7378 - val_acc: 0.5380</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmvtd56u4j30af07c3yq.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghmvtcoi15j30af07cdg2.jpg" alt="png"></p><p>可以看到，在这个例子中，预训练词嵌入的性能要优于与任务一起学习的词嵌入。但如果有大量的可用数据，用一个 Embedding 层去与任务一起训练，通常比使用预训练词嵌入更加强大。</p><p>最后，再来看一下测试集上的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对测试集数据进行分词</span></span><br><span class="line"></span><br><span class="line">test_dir = os.path.join(imdb_dir, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">texts = []</span><br><span class="line">labels = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> label_type <span class="keyword">in</span> [<span class="string">&#x27;neg&#x27;</span>, <span class="string">&#x27;pos&#x27;</span>]:</span><br><span class="line">    dir_name = os.path.join(test_dir, label_type)</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> <span class="built_in">sorted</span>(os.listdir(dir_name)):</span><br><span class="line">        <span class="keyword">if</span> fname.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dir_name, fname)) <span class="keyword">as</span> f:</span><br><span class="line">                texts.append(f.read())</span><br><span class="line">            labels.append(<span class="number">0</span> <span class="keyword">if</span> label_type == <span class="string">&#x27;neg&#x27;</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sequences = tokenizer.texts_to_sequences(texts)</span><br><span class="line">x_test = pad_sequences(sequences, maxlen=maxlen)</span><br><span class="line">y_test = np.asarray(labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在测试集上评估模型</span></span><br><span class="line"></span><br><span class="line">model.load_weights(<span class="string">&#x27;pre_trained_glove_model.h5&#x27;</span>)</span><br><span class="line">model.evaluate(x_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>782/782 [==============================] - 1s 983us/step - loss: 1.1397 - acc: 0.5127[1.1397335529327393, 0.512719988822937]</code></pre><p>emmm，最后的进度是令人惊讶的 50%+ ！只用如此少的数据来训练还是难啊。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之计算机视觉</title>
      <link href="/2020/07/29/DeepLearningWithPython/Deep-Learning%20with-Python-ch5/"/>
      <url>/2020/07/29/DeepLearningWithPython/Deep-Learning%20with-Python-ch5/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python-for-computer-vision"><a href="#Deep-Learning-with-Python-for-computer-vision" class="headerlink" title="Deep Learning with Python for computer vision"></a>Deep Learning with Python for computer vision</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，你可以去 <a href="https://github.com/cdfmlr/Deep-Learning-with-Python-Notebooks">GitHub</a> 或 <a href="https://gitee.com/cdfmlr/Deep-Learning-with-Python-Notebooks">Gitee</a> 找到原始的 <code>.ipynb</code> 笔记本。</p><p>你可以去<a href="https://livebook.manning.com/book/deep-learning-with-python">这个网站在线阅读这本书的正版原文</a>(英文)。这本书的作者也给出了配套的 <a href="https://github.com/fchollet/deep-learning-with-python-notebooks">Jupyter notebooks</a>。</p><p>本文为 <strong>第5章  深度学习用于计算机视觉</strong> (Chapter 5. <em>Deep learning for computer vision</em>) 的笔记整合。</p><p>[TOC]</p><h2 id="卷积神经网络简介"><a href="#卷积神经网络简介" class="headerlink" title="卷积神经网络简介"></a>卷积神经网络简介</h2><blockquote><p>5.1 Introduction to convnets</p></blockquote><p>卷积神经网络处理计算机视觉问题很厉害啦。</p><p>首先看一个最简单的卷积神经网络处理 MNIST 完爆第二章里的全连接网络的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&quot;softmax&quot;</span>))</span><br></pre></td></tr></table></figure><p>这里我们用的 Conv2D 层要的 <code>input_shape</code> 是 <code>(image_height, image_width, image_channels)</code> 这种格式的。</p><p>Conv2D 和 MaxPooling2D 层的输出都是 3D 张量 <code>(height, width, channels)</code>， height 和 width 会逐层减小，channels 是由 Conv2D 的第一个参数控制的。</p><p>最后的三层里，我们是把最后一个 Conv2D 层的 <code>(3, 3, 64)</code> 的张量用一系列全连接层变成想要的结果向量：Flatten 层是用来把我们的 3D 张量展平(flatten，其实我想写成“压”、“降”之类的，这才是flatten的本意，但标准的中文翻译是展平)到 1D 的。 然后后面的两个 Dense 层就行我们在第二章做的那种，最后得到一个 10 路的分类。</p><p>最后，看一下模型结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_3 (Conv2D)            (None, 26, 26, 32)        320       _________________________________________________________________max_pooling2d_2 (MaxPooling2 (None, 13, 13, 32)        0         _________________________________________________________________conv2d_4 (Conv2D)            (None, 11, 11, 64)        18496     _________________________________________________________________max_pooling2d_3 (MaxPooling2 (None, 5, 5, 64)          0         _________________________________________________________________conv2d_5 (Conv2D)            (None, 3, 3, 64)          36928     _________________________________________________________________flatten_1 (Flatten)          (None, 576)               0         _________________________________________________________________dense_2 (Dense)              (None, 64)                36928     _________________________________________________________________dense_3 (Dense)              (None, 10)                650       =================================================================Total params: 93,322Trainable params: 93,322Non-trainable params: 0_________________________________________________________________</code></pre><p>好了，网络就建成这样了，还是很简单的，接下来就训练它了，大致和之前第二章里的是一样的（但注意reshape的形状不一样）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load the TensorBoard notebook extension</span></span><br><span class="line"><span class="comment"># TensorBoard 可以可视化训练过程</span></span><br><span class="line">%load_ext tensorboard</span><br><span class="line"><span class="comment"># Clear any logs from previous runs</span></span><br><span class="line">!rm -rf ./logs/ </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 MNIST 图像上训练卷积神经网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">train_images = train_images.reshape((<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">train_images = train_images.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">test_images = test_images.reshape((<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">test_images = test_images.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">train_labels = to_categorical(train_labels)</span><br><span class="line">test_labels = to_categorical(test_labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备 TensorBoard</span></span><br><span class="line">log_dir = <span class="string">&quot;logs/fit/&quot;</span> + datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>)</span><br><span class="line">tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&quot;categorical_crossentropy&quot;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">model.fit(train_images, train_labels, epochs=<span class="number">5</span>, batch_size=<span class="number">64</span>,</span><br><span class="line">          callbacks=[tensorboard_callback])</span><br></pre></td></tr></table></figure><pre><code>Train on 60000 samplesEpoch 1/560000/60000 [==============================] - 36s 599us/sample - loss: 0.0156 - accuracy: 0.9953Epoch 2/560000/60000 [==============================] - 33s 554us/sample - loss: 0.0127 - accuracy: 0.9960Epoch 3/560000/60000 [==============================] - 31s 524us/sample - loss: 0.0097 - accuracy: 0.9971Epoch 4/560000/60000 [==============================] - 32s 529us/sample - loss: 0.0092 - accuracy: 0.9974Epoch 5/560000/60000 [==============================] - 31s 523us/sample - loss: 0.0095 - accuracy: 0.9971&lt;tensorflow.python.keras.callbacks.History at 0x1441fa9d0&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%tensorboard --logdir logs/fit</span><br></pre></td></tr></table></figure><p>(这理会输出 tensorboard 显示的可视化模型训练情况)</p><iframe id="tensorboard-frame-f4ae12888a3a411e" width="100%" height="800" frameborder="0"></iframe><script>  (function() {    const frame = document.getElementById("tensorboard-frame-f4ae12888a3a411e");    const url = new URL("/", window.location);    url.port = 6006;    frame.src = url;  })();</script><p>来在测试集看一下结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=<span class="number">2</span>)</span><br><span class="line">print(test_loss, test_acc)</span><br></pre></td></tr></table></figure><pre><code>10000/1 - 1s - loss: 0.0172 - accuracy: 0.99260.03441549262946125 0.9926</code></pre><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>我们之前用的<em>密集连接层</em>是在整个输入特征空间（在 MNIST 中就是所有的像素）中学习全局模式的；而这里的卷积层是学习局部模式的。也就是说，Dense 是学整个图像的，而 Conv 是学图像的局部，比如在我们刚才写的代码里是学了 3x3 的窗口：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo1xjvr02j315g0o6n12.jpg" alt="卷积层学习局部模式"></p><p>这种卷积神经网络具有两个性质：</p><ul><li><p>卷积神经网络学到的模式是平移不变的(translation invariant)：卷积神经网络学习到某个模式之后，在其他地方又看到了这个一样的模式，它就会认出它已经学过这个了，不用再去学一次了。而对于 Dense 的网络，即使遇到有一样的局部部分依然要去重新学习一次。这个性质让卷积神经网络可以高效利用数据，它只需要更少的训练样本就可以学到泛化比较好的数据表示（一个个局部都记住了嘛，而不是靠整体去映射）。</p></li><li><p>卷积神经网络可以学到模式的空间层次结构(spatial hierarchies of patterns)：卷积神经网络在第一层学完了一个一个小的局部模式之后，下一层又可以用这些小局部拼出大一些的模式。然后这样多搞几层，卷积神经网络就可以学到越来越复杂、越来越抽象的视觉概念了，就是下面图片这个意思：</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo29tuqchj30zh0u0dn6.jpg" alt="卷积神经网络可以学到模式的空间层次结构"></p><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>我们刚才例子中用来表示图片的那种 3D 张量，包括两个空间轴 height、width 和一个深度轴 depth（也叫 channels 轴），对于 RGB 图片，深度轴的维度就是3，分别表示3种颜色嘛；而对于 MNIST 这种灰度图片，深度就是1，只用一个数去表示灰度值。在这种3D张量和在上面做的卷积运算的结果被称作 <em>feature map</em>（特征图）。</p><p>卷积运算会从输入特征图中提取出一个个小分块，并对所有这些分块施加一个相同的变换，得到输出特征图。输出特征图仍是一个 3D 张量：具有宽度和高度，其深度可能是任意值，深度的大小是该层的一个参数，深度轴里的每个 channel 都代表一个 filter (过滤器)。filter 会对输入数据的某一方面进行编码，比如，某个过滤器可以编码“输入中包含一张脸”这种概念。</p><p>在刚才的 MNIST 例子中，第一个卷积层接受尺寸为 <code>(28, 28, 1)</code> 的输入特征图，输出一个尺寸为 <code>(26, 26, 32)</code> 的特征图。这个输出中包含 32 个 filter，在每个深度轴中的 channel 都包含有 26x26 的值，叫做 filter 对输入的响应图(response map)，表示 filter 在输入中不同位置上的运算结果。这也就是特征图为什么叫特征图的原因了：深度轴的每个维度都是一个特征(或过滤器)，而 2D 张量 <code>output[:, :, n]</code> 是这个过滤器在输入上的响应的二维空间图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo5m7eb85j31jy0jgagx.jpg" alt="响应图的示意图"></p><h4 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h4><p>关于卷积，，emmm，复变没怎么听懂，我主要是看<a href="https://www.zhihu.com/question/22298352">「知乎: 如何通俗易懂地解释卷积?」</a>来理解的。这里我们主要用的是这种作用：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo6h1a5wfg30f30f4n2g.gif" alt="卷积"></p><p>Keras 的 Conv2D 层初始化写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conv2D(output_depth, (window_height, window_width))</span><br></pre></td></tr></table></figure><p>其中包含了卷积运算有两个核心参数：</p><ul><li>输出特征图的深度：在我们刚才的 MNIST 例子里用了 32 和 64；</li><li>从输入中提取的每个块（滑窗）的尺寸：一般是 3x3 或者 5x5；</li></ul><p>卷积运算会像滑动窗口一样的遍历所有可能的位置，把输入中每一小块的特征 <code>(window_height, window_width, input_depth)</code> 通过与一个称作卷积核(convolution kernel)的要学习的权重矩阵做点乘，变化得到一个向量 <code>(output_depth, )</code>。所有的这种结果向量拼在一起就得到了一个 3D 的最终输出 <code>(height, width, output_depth)</code>，其中的每个值就是输入对应过来的，比如取 3x3 的滑窗，则 <code>output[i, j, :]</code> 来自 <code>input[i-1:i+1, j-1:j+1, :]</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo6cg398tj30t40w8n2u.jpg" alt="卷积的工作原理"></p><p>关于卷积和 CNN 可以去看看这篇文章：<a href="https://mlnotebook.github.io/post/CNN1/">Convolutional Neural Networks - Basics, An Introduction to CNNs and Deep Learning</a></p><p>注意，因为边界效应(border effects)和使用了步幅(strides)，我们输出的宽度和高度可能与输入的宽度和高度不同。</p><h5 id="边界效应和填充"><a href="#边界效应和填充" class="headerlink" title="边界效应和填充"></a>边界效应和填充</h5><p>边界效应就是你在做滑窗之后得到的矩阵大小会缩小一圈（边界没了）。例如现输入一个 5x5 的图片，取 3x3 的小块只能取出 9 块来，因此输出的结果为 3x3 的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo9oanxxcj31h60rc76w.jpg" alt="边界效应"></p><p>之前我们做的 MNIST 也是类似的，一开始输入 28x28，第一层取 3x3 的，结果就是 26x26 了。</p><p>如果不希望这种减小发生，即希望保持输出的空间维度与输入的一致，则需要做填充(padding)。填充就是在输入的图片边界上加一些行和列，3x3 加1圈，5x5 要加2圈：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo9vytgefj31fa0kote4.jpg" alt="填充"></p><p>Keras 的 Conv2D 层里可以用 <code>padding</code> 参数来设置使用填充。<code>padding</code> 可以设为：</p><ul><li><code>&quot;valid&quot;</code>（默认值）：不做填充，只取“有效”的块。例如在 5×5 的输入特征图中，可以提取 3×3 图块的有效位置；</li><li><code>&quot;same&quot;</code>： 做填充，使输出和输入的 width、height 相等。</li></ul><h5 id="卷积步幅"><a href="#卷积步幅" class="headerlink" title="卷积步幅"></a>卷积步幅</h5><p>卷积的步幅就是一次滑窗移多少，之前我们一直做的都是步幅为1的。我们把步幅大于 1 的卷积叫做<strong>步进卷积</strong>(strided convolution)，比如下面这个是步幅为 2 的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggp4beuceuj31dw0pu76q.jpg" alt="步幅为 2 的步进卷积"></p><p>然而步进卷积在实际里面用的并不多😂，要做这种对特征图的下采样（downsampled）我们一般用最大池化。</p><blockquote><p>注：</p><p><strong>下采样</strong>：对于一个样值序列间隔几个样值取样一次，这样得到新序列就是原序列的下采样。</p><p>From <a href="https://baike.baidu.com/item/%E4%B8%8B%E9%87%87%E6%A0%B7">百度百科</a></p></blockquote><h3 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h3><p>与步进卷积类似，最大池化是用来对特征图进行下采样的。在一开始的 MNIST 例子中，我们用了 MaxPooling2D 层之后，特征图的尺寸就减半了。</p><p>最大池化是在一个窗口里，从输入特征图取出每个 channel 的最大值，然后输出出来。这个运算和卷积很类似，不过施加的函数是一个 max。</p><p>最大池化我们一般都是用 2x2 的窗口，步幅为 2，这样取可以将特征图下采样2倍。（卷积是一般取3x3窗口和步幅1）</p><p>如果不用最大池化，直接把一大堆卷积层堆起来，会有两个问题：</p><ul><li>特征图尺寸下降的慢，搞到后面参数太多了，会加重过拟合；</li><li>不利于空间层级结构的学习：一直一小点一小点的用卷积层去学，不利于看到更抽象的整体。</li></ul><p>除了最大池化，下采样的方式还有很多：比如步进卷积、平均池化之类的。但一般用最大池化效果比较好，我们要的是知道有没有某个特征嘛，如果用平均去就把这个特征“减淡”了，如果用步进卷积又可能把这个信息错过了。</p><p>总而言之，使用最大池化/其他下采样的原因，一是减少需要处理的特征图的元素个数，二是通过让一系列的卷积层观察到越来越大的窗口(看到的覆盖越来越多比例的原始输入)，从而学到空间层级结构。</p><h2 id="在小型数据集上从头训练一个卷积神经网络"><a href="#在小型数据集上从头训练一个卷积神经网络" class="headerlink" title="在小型数据集上从头训练一个卷积神经网络"></a>在小型数据集上从头训练一个卷积神经网络</h2><blockquote><p>5.2 Training a convnet from scratch on a small dataset</p></blockquote><p>我们搞计算机视觉的时候，经常要处理的问题就是在很小的数据集上训练一个图像分类的模型。emmm，这里的“很小”可以是几百到几万。</p><p>从这一节开始到后面几节，我们要搞的就是从头开始训练一个小型模型、使用预训练的网络做特征提取、对预训练的网络进行微调，这些步骤合起来就可以用于解决小型数据集的图像分类问题了。</p><p>我们这一节要做的是从头开始训练一个小型模型来分类猫狗的图片。不做正则化，先不管过拟合的问题。</p><h3 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h3><p>我们将使用 Dogs vs. Cats dataset 来训练模型，这个数据集里面是一大堆猫、狗的照片。这个数据集就不是 Keras 内置的了，我们可以从 Kaggle 下载：<a href="https://www.kaggle.com/c/dogs-vs-cats/data">https://www.kaggle.com/c/dogs-vs-cats/data</a></p><p>下载下来解压缩，，，（emmmm有点大我的 MBP 都装不下了，放移动硬盘上才解出来的😂，emmmm，又想起来该买个新固态了）。</p><p>然后来创建我们要用的数据集：训练集猫狗各1000个样本，验证集各500个，测试集各500个。编程来完成这个工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将图像复制到训练、验证和测试的目录</span></span><br><span class="line"><span class="keyword">import</span> os, shutil</span><br><span class="line"></span><br><span class="line">original_dataset_dir = <span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/dogs-vs-cats/train&#x27;</span>    <span class="comment"># 原始数据集</span></span><br><span class="line"></span><br><span class="line">base_dir = <span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/cats_and_dogs_small&#x27;</span>    <span class="comment"># 将要保存的较小数据集的位置</span></span><br><span class="line">os.mkdir(base_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创几个目录放划分后的训练、验证和测试集</span></span><br><span class="line">train_dir = os.path.join(base_dir, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">os.mkdir(train_dir)</span><br><span class="line">validation_dir = os.path.join(base_dir, <span class="string">&#x27;validation&#x27;</span>)</span><br><span class="line">os.mkdir(validation_dir)</span><br><span class="line">test_dir = os.path.join(base_dir, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">os.mkdir(test_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分开放猫狗</span></span><br><span class="line">train_cats_dir = os.path.join(train_dir, <span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line">os.mkdir(train_cats_dir)</span><br><span class="line">train_dogs_dir = os.path.join(train_dir, <span class="string">&#x27;dogs&#x27;</span>)</span><br><span class="line">os.mkdir(train_dogs_dir)</span><br><span class="line"></span><br><span class="line">validation_cats_dir = os.path.join(validation_dir, <span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line">os.mkdir(validation_cats_dir)</span><br><span class="line">validation_dogs_dir = os.path.join(validation_dir, <span class="string">&#x27;dogs&#x27;</span>)</span><br><span class="line">os.mkdir(validation_dogs_dir)</span><br><span class="line"></span><br><span class="line">test_cats_dir = os.path.join(test_dir, <span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line">os.mkdir(test_cats_dir)</span><br><span class="line">test_dogs_dir = os.path.join(test_dir, <span class="string">&#x27;dogs&#x27;</span>)</span><br><span class="line">os.mkdir(test_dogs_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制猫的图片</span></span><br><span class="line">fnames = [<span class="string">f&#x27;cat.<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]    <span class="comment"># 这里用了 f-String，要求 Python &gt;= 3.6，老版本可以用 &#x27;cat.&#123;&#125;.jpg&#x27;.format(i)</span></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">    src = os.path.join(original_dataset_dir, fname)</span><br><span class="line">    dst = os.path.join(train_cats_dir, fname)</span><br><span class="line">    shutil.copyfile(src, dst)</span><br><span class="line">    </span><br><span class="line">fnames = [<span class="string">f&#x27;cat.<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">1500</span>)]</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">    src = os.path.join(original_dataset_dir, fname)</span><br><span class="line">    dst = os.path.join(validation_cats_dir, fname)</span><br><span class="line">    shutil.copyfile(src, dst)</span><br><span class="line">    </span><br><span class="line">fnames = [<span class="string">f&#x27;cat.<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1500</span>, <span class="number">2000</span>)]</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">    src = os.path.join(original_dataset_dir, fname)</span><br><span class="line">    dst = os.path.join(test_cats_dir, fname)</span><br><span class="line">    shutil.copyfile(src, dst)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 复制狗的图片</span></span><br><span class="line">fnames = [<span class="string">f&#x27;dog.<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">    src = os.path.join(original_dataset_dir, fname)</span><br><span class="line">    dst = os.path.join(train_dogs_dir, fname)</span><br><span class="line">    shutil.copyfile(src, dst)</span><br><span class="line">    </span><br><span class="line">fnames = [<span class="string">f&#x27;dog.<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">1500</span>)]</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">    src = os.path.join(original_dataset_dir, fname)</span><br><span class="line">    dst = os.path.join(validation_dogs_dir, fname)</span><br><span class="line">    shutil.copyfile(src, dst)</span><br><span class="line">    </span><br><span class="line">fnames = [<span class="string">f&#x27;dog.<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1500</span>, <span class="number">2000</span>)]</span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">    src = os.path.join(original_dataset_dir, fname)</span><br><span class="line">    dst = os.path.join(test_dogs_dir, fname)</span><br><span class="line">    shutil.copyfile(src, dst)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">print(<span class="string">&#x27;total training cat images:&#x27;</span>, <span class="built_in">len</span>(os.listdir(train_cats_dir)))</span><br><span class="line">print(<span class="string">&#x27;total validation cat images:&#x27;</span>, <span class="built_in">len</span>(os.listdir(validation_cats_dir)))</span><br><span class="line">print(<span class="string">&#x27;total test cat images:&#x27;</span>, <span class="built_in">len</span>(os.listdir(test_cats_dir)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;total training dog images:&#x27;</span>, <span class="built_in">len</span>(os.listdir(train_dogs_dir)))</span><br><span class="line">print(<span class="string">&#x27;total validation dog images:&#x27;</span>, <span class="built_in">len</span>(os.listdir(validation_dogs_dir)))</span><br><span class="line">print(<span class="string">&#x27;total test dog images:&#x27;</span>, <span class="built_in">len</span>(os.listdir(test_dogs_dir)))</span><br></pre></td></tr></table></figure><pre><code>total training cat images: 1000total validation cat images: 500total test cat images: 500total training dog images: 1000total validation dog images: 500total test dog images: 500</code></pre><h3 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h3><p>在几乎所有的卷积神经网络里，我们都是让特征图的深度逐渐增大，而尺寸逐渐减小。所以这次我们也是这样的。</p><p>我们现在的这个问题是个二分类，所以最后一层用一个1单元的 sigmoid 激活的 Dense：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将猫狗分类的小型卷积神经网络实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>)))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br></pre></td></tr></table></figure><p>看一下网络的结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_4&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_16 (Conv2D)           (None, 148, 148, 32)      896       _________________________________________________________________max_pooling2d_16 (MaxPooling (None, 74, 74, 32)        0         _________________________________________________________________conv2d_17 (Conv2D)           (None, 72, 72, 64)        18496     _________________________________________________________________max_pooling2d_17 (MaxPooling (None, 36, 36, 64)        0         _________________________________________________________________conv2d_18 (Conv2D)           (None, 34, 34, 128)       73856     _________________________________________________________________max_pooling2d_18 (MaxPooling (None, 17, 17, 128)       0         _________________________________________________________________conv2d_19 (Conv2D)           (None, 15, 15, 128)       147584    _________________________________________________________________max_pooling2d_19 (MaxPooling (None, 7, 7, 128)         0         _________________________________________________________________flatten_4 (Flatten)          (None, 6272)              0         _________________________________________________________________dense_8 (Dense)              (None, 512)               3211776   _________________________________________________________________dense_9 (Dense)              (None, 1)                 513       =================================================================Total params: 3,453,121Trainable params: 3,453,121Non-trainable params: 0_________________________________________________________________</code></pre><p>然后就要编译这个网络了，做二分类嘛，所以损失函数用 binary crossentropy（二元交叉熵），优化器还是用 RMSprop (我们之前都是写 <code>optimizer=&#39;rmsprop&#39;</code>，这次要传点参数，所以用 <code>optimizers.RMSprop</code> 实例)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=optimizers.RMSprop(lr=<span class="number">1e-4</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>我们要把那些图片搞成浮点数张量才能喂给神经网络。步骤如下：</p><ol><li>读取图片文件</li><li>把 JPEG 文件内容解码成 RGB 像素网格</li><li>转化成浮点数张量</li><li>把像素的值从 <code>[0, 255]</code> 缩放到 <code>[0, 1]</code></li></ol><p>Keras 提供了一些工具可以自动完成这些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 ImageDataGenerator 从目录中读取图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line">train_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">train_generator = train_datagen.flow_from_directory(</span><br><span class="line">    train_dir,</span><br><span class="line">    target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">    batch_size=<span class="number">20</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;binary&#x27;</span>)    <span class="comment"># 用二分类的标签</span></span><br><span class="line"></span><br><span class="line">validation_generator = test_datagen.flow_from_directory(</span><br><span class="line">    validation_dir,</span><br><span class="line">    target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">    batch_size=<span class="number">20</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Found 2000 images belonging to 2 classes.Found 1000 images belonging to 2 classes.</code></pre><p>这个搞出来的 train_generator 和 validation_generator 就是 Python 的那种 Generator，惰性计算的那种。这个生成器一次 yield 出来一个 batch，所以把它叫做“batch generator”，迭代出一个来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data_batch, labels_batch <span class="keyword">in</span> train_generator:</span><br><span class="line">    print(<span class="string">&#x27;data batch shape:&#x27;</span>, data_batch.shape)</span><br><span class="line">    print(<span class="string">&#x27;labels batch shape:&#x27;</span>, labels_batch.shape)</span><br><span class="line">    print(<span class="string">&#x27;labels_batch:&#x27;</span>, labels_batch)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>data batch shape: (20, 150, 150, 3)labels batch shape: (20,)labels_batch: [1. 1. 1. 1. 1. 1. 1. 1. 1. 0. 1. 1. 1. 1. 0. 0. 1. 1. 0. 1.]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 batch 生成器拟合模型</span></span><br><span class="line">history = model.fit_generator(</span><br><span class="line">    train_generator,</span><br><span class="line">    steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">    epochs=<span class="number">30</span>,</span><br><span class="line">    validation_data=validation_generator,</span><br><span class="line">    validation_steps=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/30100/100 [==============================] - 97s 967ms/step - loss: 0.6901 - acc: 0.5450 - val_loss: 0.6785 - val_acc: 0.5270Epoch 2/30100/100 [==============================] - 86s 865ms/step - loss: 0.6661 - acc: 0.5875 - val_loss: 0.6525 - val_acc: 0.6060......Epoch 29/30100/100 [==============================] - 160s 2s/step - loss: 0.0533 - acc: 0.9860 - val_loss: 0.9298 - val_acc: 0.7310Epoch 30/30100/100 [==============================] - 162s 2s/step - loss: 0.0460 - acc: 0.9885 - val_loss: 1.0609 - val_acc: 0.7150</code></pre><p>这里因为是从 generator 读取 batch 来 fit，所以把我们平时用的 fit 改成了 <code>fit_generator</code>。里面传训练数据生成器、一个轮次要从 train_generator 里 yield 出来的次数(steps_per_epoch)、轮次、验证集生成器、一个轮次要从 validation_generator 里 yield 出来的次数(validation_steps)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steps_per_epoch &#x3D; 训练集数据总数 &#x2F; 构建generator时指定的batch_size</span><br></pre></td></tr></table></figure><p>validation_steps 和 steps_per_epoch 类似，只是是对验证集的。</p><p>用下面这行代码把训练好的模型保存下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model.save(<span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/cats_and_dogs_small_1.h5&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后把训练过程画出图来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制训练过程中的损失曲线和精度曲线</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(acc) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;sr-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;sr-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zaz7caj30af07ct8s.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zd7wcrj30af07cwek.jpg" alt="png"></p><p>不出所料，过拟合了，从差不多第5轮就开始过了。</p><p>接下来，我们要用 data augmentation (数据增强) 来降低过拟合。</p><h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h3><p>data augmentation (数据增强) 是用深度学习处理图像一般都会用到的一个方法。</p><p>过拟合是由于训练的数据太少导致的（只要样本足够多，模型就能看遍几乎所以可能，从而几乎不会犯错）。数据增强是一种以现有的样本为基础生成更多的训练数据的一种方法，这个方法利用多种能够生成可信图像的随机变换来增加。</p><p>在 Keras 中，我们用 ImageDataGenerator 的时候设几个参数就可以完成数据增强了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">datagen = ImageDataGenerator(</span><br><span class="line">      rotation_range=<span class="number">40</span>,      <span class="comment"># 随机旋转图片的范围，0~180</span></span><br><span class="line">      width_shift_range=<span class="number">0.2</span>,  <span class="comment"># 随机水平移动的比例</span></span><br><span class="line">      height_shift_range=<span class="number">0.2</span>, <span class="comment"># 随机竖直移动的比例</span></span><br><span class="line">      shear_range=<span class="number">0.2</span>,        <span class="comment"># 随机错切变换(shearing transformations)的角度</span></span><br><span class="line">      zoom_range=<span class="number">0.2</span>,         <span class="comment"># 随机缩放的范围</span></span><br><span class="line">      horizontal_flip=<span class="literal">True</span>,   <span class="comment"># 是否做随机水平反转</span></span><br><span class="line">      fill_mode=<span class="string">&#x27;nearest&#x27;</span>)    <span class="comment"># 填充新创建像素的方法</span></span><br></pre></td></tr></table></figure><p>找张图片增强了试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"></span><br><span class="line">fnames = [os.path.join(train_cats_dir, fname) <span class="keyword">for</span> </span><br><span class="line">          fname <span class="keyword">in</span> os.listdir(train_cats_dir)]</span><br><span class="line"></span><br><span class="line">img_path = fnames[<span class="number">3</span>]</span><br><span class="line">img = image.load_img(img_path, target_size=(<span class="number">150</span>, <span class="number">150</span>))    <span class="comment"># 读取图片</span></span><br><span class="line"></span><br><span class="line">x = image.img_to_array(img)    <span class="comment"># shape (150, 150, 3)</span></span><br><span class="line">x = x.reshape((<span class="number">1</span>,) + x.shape)  <span class="comment"># shape (1, 150, 150, 3)</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> datagen.flow(x, batch_size=<span class="number">1</span>):</span><br><span class="line">    plt.figure(i)</span><br><span class="line">    imgplot = plt.imshow(image.array_to_img(batch[<span class="number">0</span>]))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zfrydzj307907075h.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zk2m49j3079070myh.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zhn5dcj3079070aba.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zrkbkej30790703zv.jpg" alt="png"></p><p>注意数据增强并没有带来新的信息，只是把原本就有的信息 remix 一下。所以在数据特别少的情况下，光用数据增强不足以消除过拟合，所以我们还需要在 Dense 层之前用上 Dropout。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含 dropout 的新卷积神经网络</span></span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>)))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line"></span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))    <span class="comment"># 👈 新增的 Dropout</span></span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, </span><br><span class="line">              optimizer=optimizers.RMSprop(lr=<span class="number">1e-4</span>), </span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用数据增强生成器来训练卷积神经网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据生成器</span></span><br><span class="line">train_datagen = ImageDataGenerator(</span><br><span class="line">    rescale=<span class="number">1.</span>/<span class="number">255</span>,</span><br><span class="line">    rotation_range=<span class="number">40</span>,</span><br><span class="line">    width_shift_range=<span class="number">0.2</span>,</span><br><span class="line">    height_shift_range=<span class="number">0.2</span>,</span><br><span class="line">    shear_range=<span class="number">0.2</span>,</span><br><span class="line">    zoom_range=<span class="number">0.2</span>,</span><br><span class="line">    horizontal_flip=<span class="literal">True</span>,)</span><br><span class="line"></span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)    <span class="comment"># 测试集不增强哦</span></span><br><span class="line"></span><br><span class="line">train_generator = train_datagen.flow_from_directory(</span><br><span class="line">    train_dir,</span><br><span class="line">    target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">    batch_size=<span class="number">32</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">validation_generator = test_datagen.flow_from_directory(</span><br><span class="line">    validation_dir,</span><br><span class="line">    target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">    batch_size=<span class="number">32</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit_generator(</span><br><span class="line">    train_generator,</span><br><span class="line">    steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">    epochs=<span class="number">100</span>,</span><br><span class="line">    validation_data=validation_generator,</span><br><span class="line">    validation_steps=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model.save(<span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/cats_and_dogs_small_2.h5&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Found 2000 images belonging to 2 classes.Found 1000 images belonging to 2 classes.Epoch 1/100100/100 [==============================] - 142s 1s/step - loss: 0.6909 - acc: 0.5265 - val_loss: 0.6799 - val_acc: 0.5127Epoch 2/100100/100 [==============================] - 123s 1s/step - loss: 0.6817 - acc: 0.5474 - val_loss: 0.6561 - val_acc: 0.6320......100/100 [==============================] - 131s 1s/step - loss: 0.3225 - acc: 0.8612 - val_loss: 0.4465 - val_acc: 0.7976Epoch 99/100100/100 [==============================] - 134s 1s/step - loss: 0.3391 - acc: 0.8501 - val_loss: 0.5455 - val_acc: 0.7836Epoch 100/100100/100 [==============================] - 130s 1s/step - loss: 0.3140 - acc: 0.8624 - val_loss: 0.4295 - val_acc: 0.8274</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制训练过程中的损失曲线和精度曲线</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(acc) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;r-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;r-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zupxk2j30al07cjro.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh85zwpa4hj30al07c0t2.jpg" alt="png"></p><p>👌用了 Data Augmentation 和 Dropout 之后，过拟合就好多了，精度也有所提升。</p><p>接下来，我们还会用一些技术来进一步优化模型。</p><h2 id="使用预训练的卷积神经网络"><a href="#使用预训练的卷积神经网络" class="headerlink" title="使用预训练的卷积神经网络"></a>使用预训练的卷积神经网络</h2><blockquote><p>5.3 Using a pretrained convnet</p></blockquote><p>对于小型图像数据集，我们常用的一种高效的方法是利用预训练网络（pretrained network）来构建深度学习模型。预训练网络是之前在大型数据集上训练好的网络（通常是在大型图片分类任务上训练好的）。如果预训练集用的数据足够多，模型足够泛化，那么预训练网络学到的空间层次结构就可以有效地作为通用模型来反应现实的视觉世界，因此就可用于各种不同的计算机视觉问题，哪怕新的问题和原始任务完全扯不上关系。</p><p>例如，我们可以用一个在 ImageNet (这个数据集有140万张图像，1000个不同的类别，主要是动物和各种日常用品)完成预训练的网络来处理猫狗分类的问题。我们将使用的是 VGG16 这个架构。</p><p>使用预训练网络有两种方法：<em>特征提取</em>(feature extraction)和<em>微调模型</em>(fine-tuning)。</p><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>特征提取是使用之前的网络学到的表示来从新样本中提取出需要的特征，输入一个新的分类器，从头开始训练。</p><p>在前面的卷积神经网络例子中，我们知道，我们用来图片分类的模型可以分成两部分：</p><ul><li>卷积基（convolutional base）：前面的卷积、池化层；</li><li>分类器（classifier）：后面的密连接层；</li></ul><p>所以对于卷积神经网络，<strong>特征提取</strong>就是取出之前训练好的网络的卷积基，把新的数据输入进去跑，然后拿其输出去训练一个新的分类器：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggvimux4ttj314l0u0jv4.jpg" alt="保持卷积基不变，改变分类器"></p><p>注意，只复用卷积基，而不复用分类器。卷积基是用来提取特征的，这个可以相同；但由于每个问题的分类不同，理应使用不同的分类器；并且有的问题中特征的位置是有用的，而我们把特征图转到 Dense 层的时候这些位置特征就丢失了，所以并不是所有问题都是用 Dense 去简单的完成分类的，所以不应该无脑套用分类器。</p><p>在预训练网络中，能提取的特征表示的通用程度取决于于其深度。越少的层越通用（比如，图片的颜色、边缘、纹理之类的），越多的层就会包含越多的抽象信息（比如，有一个猫的眼睛啊之类的）。所以如果预训练网络处理的原始问题和我们当前要处理的问题差距太大，就只因该使用比较少的前几层，而不要用整个卷积基。</p><p>现在，来做实践了，我们要用在 ImageNet 上预训练的 VGG16 模型来处理猫狗分类的问题，我们将保持卷积基不变，改变分类器。</p><p>VGG16 模型是 Keras 有内置的，直接用就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> VGG16</span><br><span class="line"></span><br><span class="line">conv_base = VGG16(weights=<span class="string">&#x27;imagenet&#x27;</span>,        <span class="comment"># 指定模型初始化的权重检查点</span></span><br><span class="line">                  include_top=<span class="literal">False</span>,         <span class="comment"># 是否包含最后的密集连接层分类器</span></span><br><span class="line">                  input_shape=(<span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>)) <span class="comment"># 输入的形状，不传的话能处理任意形状的输入</span></span><br></pre></td></tr></table></figure><p>模型是要从这里下载的：<a href="https://github.com/fchollet/deep-learning-models/releases">https://github.com/fchollet/deep-learning-models/releases</a></p><p>如果让他自己下比较慢的话，可以考虑手动下载安装。参考 vgg16 的源码: <code>/usr/local/lib/python3.7/site-packages/keras_applications/vgg16.py</code>，发现它是调用一个 get_file 来获取模型的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weights_path = keras_utils.get_file(</span><br><span class="line">    <span class="string">&#x27;vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5&#x27;</span>,</span><br><span class="line">    WEIGHTS_PATH_NO_TOP,</span><br><span class="line">    cache_subdir=<span class="string">&#x27;models&#x27;</span>,</span><br><span class="line">    file_hash=<span class="string">&#x27;6d6bbae143d832006294945121d1f1fc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里看到他是从一个子目录 <code>models</code> 里读取模型的，还有这个 <code>keras_utils.get_file</code> 就是 <code>/usr/local/lib/python3.7/site-packages/tensorflow_core/python/keras/utils/data_utils.py</code> 第 150 行左右的 get_file 函数，文档注释里写了，东西默认是放到 <code>~/.keras</code> 这个目录的。</p><p>总之，就是把模型下载下来放到 <code>~/.keras/models</code> 里就好了。</p><p>还有注意加不加top(最后的分类器)，下载的模型大小差距还是很大的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggw35kvawgj30t407uta8.jpg" alt="不同配置的VGG16预训练模型的大小"></p><p>总之，最后完了会得到一个 conv_base 模型，这个模型还是很容易理解的，用到的都是我们之前已经学过的东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv_base.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;vgg16&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================input_1 (InputLayer)         [(None, 150, 150, 3)]     0         _________________________________________________________________block1_conv1 (Conv2D)        (None, 150, 150, 64)      1792      _________________________________________________________________block1_conv2 (Conv2D)        (None, 150, 150, 64)      36928     _________________________________________________________________block1_pool (MaxPooling2D)   (None, 75, 75, 64)        0         _________________________________________________________________block2_conv1 (Conv2D)        (None, 75, 75, 128)       73856     _________________________________________________________________block2_conv2 (Conv2D)        (None, 75, 75, 128)       147584    _________________________________________________________________block2_pool (MaxPooling2D)   (None, 37, 37, 128)       0         _________________________________________________________________block3_conv1 (Conv2D)        (None, 37, 37, 256)       295168    _________________________________________________________________block3_conv2 (Conv2D)        (None, 37, 37, 256)       590080    _________________________________________________________________block3_conv3 (Conv2D)        (None, 37, 37, 256)       590080    _________________________________________________________________block3_pool (MaxPooling2D)   (None, 18, 18, 256)       0         _________________________________________________________________block4_conv1 (Conv2D)        (None, 18, 18, 512)       1180160   _________________________________________________________________block4_conv2 (Conv2D)        (None, 18, 18, 512)       2359808   _________________________________________________________________block4_conv3 (Conv2D)        (None, 18, 18, 512)       2359808   _________________________________________________________________block4_pool (MaxPooling2D)   (None, 9, 9, 512)         0         _________________________________________________________________block5_conv1 (Conv2D)        (None, 9, 9, 512)         2359808   _________________________________________________________________block5_conv2 (Conv2D)        (None, 9, 9, 512)         2359808   _________________________________________________________________block5_conv3 (Conv2D)        (None, 9, 9, 512)         2359808   _________________________________________________________________block5_pool (MaxPooling2D)   (None, 4, 4, 512)         0         =================================================================Total params: 14,714,688Trainable params: 14,714,688Non-trainable params: 0_________________________________________________________________</code></pre><p>注意，最前面的输入已经调成了我们希望的<code>(150, 150, 3)</code>，最后的输出是<code>(4, 4, 512)</code>，在后面我们要连上我们自己的分类器。有两种办法：</p><ol><li>在这个卷积基上跑我们现在的数据集，然后把结果放到个 Numpy 数组里面，保存到磁盘，然后以这个数组为输入，扔到个密连接的网络里面去训练。这种办法比较简单，也只需要计算一次消耗最大的卷积基部分。但是，这种办法不能使用数据增强。</li><li>拓展 conv_base，往它后面加 Dense 层，然后在输入数据上端到端运行整个网络，这样可以使用数据增强，但计算代价比较大。</li></ol><p>首先，我们做第一种。</p><h4 id="不数据增强的快速特征提取"><a href="#不数据增强的快速特征提取" class="headerlink" title="不数据增强的快速特征提取"></a>不数据增强的快速特征提取</h4><p>重述一般，这种方法保存我们的数据通过 conv_base 后的输出，然后将这些输出作为输入放到一个新模型里。</p><p>这里还是用 ImageDataGenerator 把图片、标签提取到 Numpy 数组。然后调用 conv_base 的 predict 方法来用预训练模型提取特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用预训练的卷积基提取特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line">base_dir = <span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/cats_and_dogs_small&#x27;</span></span><br><span class="line">train_dir = os.path.join(base_dir, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">validation_dir = os.path.join(base_dir, <span class="string">&#x27;validation&#x27;</span>)</span><br><span class="line">test_dir = os.path.join(base_dir, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">batch_size = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_features</span>(<span class="params">directory, sample_count</span>):</span></span><br><span class="line">    features = np.zeros(shape=(sample_count, <span class="number">4</span>, <span class="number">4</span>, <span class="number">512</span>))    <span class="comment"># 这个要符合之前 conv_base.summary() 最后一层的输出的形状</span></span><br><span class="line">    labels = np.zeros(shape=(sample_count))</span><br><span class="line">    generator = datagen.flow_from_directory(</span><br><span class="line">        directory,</span><br><span class="line">        target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inputs_batch, labels_batch <span class="keyword">in</span> generator:    <span class="comment"># 一批一批加数据</span></span><br><span class="line">        features_batch = conv_base.predict(inputs_batch)</span><br><span class="line">        features[i * batch_size : (i + <span class="number">1</span>) * batch_size] = features_batch</span><br><span class="line">        labels[i * batch_size : (i + <span class="number">1</span>) * batch_size] = labels_batch</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i * batch_size &gt;= sample_count:    <span class="comment"># generator 会生成无限的数据哦，break 要自己控制</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> features, labels</span><br><span class="line"></span><br><span class="line">train_features, train_labels = extract_features(train_dir, <span class="number">2000</span>)</span><br><span class="line">validation_features, validation_labels = extract_features(validation_dir, <span class="number">1000</span>)</span><br><span class="line">test_features, test_labels = extract_features(test_dir, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><pre><code>Found 2000 images belonging to 2 classes.Found 1000 images belonging to 2 classes.Found 1000 images belonging to 2 classes.</code></pre><p>之后我们是要接密连接层的分类器来着，所以这里先把张量压扁了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_features = np.reshape(train_features, (<span class="number">2000</span>, <span class="number">4</span> * <span class="number">4</span> * <span class="number">512</span>))</span><br><span class="line">validation_features = np.reshape(validation_features, (<span class="number">1000</span>, <span class="number">4</span> * <span class="number">4</span> * <span class="number">512</span>))</span><br><span class="line">test_features = np.reshape(test_features, (<span class="number">1000</span>, <span class="number">4</span> * <span class="number">4</span> * <span class="number">512</span>))</span><br></pre></td></tr></table></figure><p>然后就是做密连接的分类器了，还是用 dropout 正则化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_dim=<span class="number">4</span> * <span class="number">4</span> * <span class="number">512</span>))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=optimizers.RMSprop(lr=<span class="number">2e-5</span>),</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(train_features, train_labels,</span><br><span class="line">                    epochs=<span class="number">30</span>,</span><br><span class="line">                    batch_size=<span class="number">20</span>,</span><br><span class="line">                    validation_data=(validation_features, validation_labels))</span><br></pre></td></tr></table></figure><pre><code>Train on 2000 samples, validate on 1000 samplesEpoch 1/302000/2000 [==============================] - 3s 1ms/sample - loss: 0.5905 - acc: 0.6840 - val_loss: 0.4347 - val_acc: 0.8430Epoch 2/302000/2000 [==============================] - 1s 640us/sample - loss: 0.4339 - acc: 0.8060 - val_loss: 0.3566 - val_acc: 0.8620......Epoch 29/302000/2000 [==============================] - 1s 686us/sample - loss: 0.0928 - acc: 0.9755 - val_loss: 0.2390 - val_acc: 0.9010Epoch 30/302000/2000 [==============================] - 1s 687us/sample - loss: 0.0889 - acc: 0.9715 - val_loss: 0.2401 - val_acc: 0.9010</code></pre><p>看结果了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(acc) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh861ydynej30al07cwek.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh862078xaj30af07cglo.jpg" alt="png"></p><p>可以看到，效果还是很不错的接近 90% 的准确率。但问题也还是有，因为没有数据增强，过拟合还是严重的，基本从一开始就在过拟合了。对这种太小的图片数据集，没有数据增强，一般都是不太行的。</p><h4 id="带数据增强的特征提取"><a href="#带数据增强的特征提取" class="headerlink" title="带数据增强的特征提取"></a>带数据增强的特征提取</h4><p>第二种办法，拓展 conv_base，往它后面加 Dense 层，然后在输入数据上端到端运行整个网络。</p><p>这个办法计算代价非！常！高！，基本只能用 GPU 跑。没 GPU 就被用这个了。</p><p>在 Keras 里，我们可以像添加层一样把一个模型添加到 Sequential model 里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在卷积基的基础上添加密集连接分类器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(conv_base)</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br></pre></td></tr></table></figure><p>看一下模型的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================vgg16 (Model)                (None, 4, 4, 512)         14714688  _________________________________________________________________flatten (Flatten)            (None, 8192)              0         _________________________________________________________________dense_2 (Dense)              (None, 256)               2097408   _________________________________________________________________dense_3 (Dense)              (None, 1)                 257       =================================================================Total params: 16,812,353Trainable params: 16,812,353Non-trainable params: 0_________________________________________________________________</code></pre><p>注意，在用这种用预训练模型的方法时，一定要<strong>冻结卷积基</strong>，也就是告诉网络，在训练过程种不要去更新卷积基的参数！这个很重要，不这么做的话预训练好的模型就会被破坏，到头来相当于你是从头训练的，那样就失去用预训练的意义了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冻结卷积基</span></span><br><span class="line">conv_base.trainable = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这样做之后，训练模型时就只会去不断更新 Dense 层的权重了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================vgg16 (Model)                (None, 4, 4, 512)         14714688  _________________________________________________________________flatten (Flatten)            (None, 8192)              0         _________________________________________________________________dense_2 (Dense)              (None, 256)               2097408   _________________________________________________________________dense_3 (Dense)              (None, 1)                 257       =================================================================Total params: 16,812,353Trainable params: 2,097,665Non-trainable params: 14,714,688_________________________________________________________________</code></pre><p>接下来，就可以上数据增强，训练模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用冻结的卷积基端到端地训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line">train_datagen = ImageDataGenerator(</span><br><span class="line">    rescale=<span class="number">1.</span>/<span class="number">255</span>,</span><br><span class="line">    rotation_range=<span class="number">40</span>,</span><br><span class="line">    width_shift_range=<span class="number">0.2</span>,</span><br><span class="line">    height_shift_range=<span class="number">0.2</span>,</span><br><span class="line">    shear_range=<span class="number">0.2</span>,</span><br><span class="line">    zoom_range=<span class="number">0.2</span>,</span><br><span class="line">    horizontal_flip=<span class="literal">True</span>,</span><br><span class="line">    fill_mode=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)    <span class="comment"># 注意 test 不增强</span></span><br><span class="line"></span><br><span class="line">train_generator = train_datagen.flow_from_directory(</span><br><span class="line">    train_dir,</span><br><span class="line">    target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">    batch_size=<span class="number">20</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">validation_generator = test_datagen.flow_from_directory(</span><br><span class="line">    validation_dir,</span><br><span class="line">    target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">    batch_size=<span class="number">20</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=optimizers.RMSprop(lr=<span class="number">2e-5</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit_generator(</span><br><span class="line">    train_generator,</span><br><span class="line">    steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">    epochs=<span class="number">30</span>,</span><br><span class="line">    validation_data=validation_generator,</span><br><span class="line">    validation_steps=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>P.S. 这个在我的 CPU 上跑，一轮大概要15分钟，30轮，，我放弃了。我用 Kaggle 跑了这个，一轮才30秒😭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Found 2000 images belonging to 2 classes.</span><br><span class="line">Found 1000 images belonging to 2 classes.</span><br><span class="line">Epoch 1&#x2F;30</span><br><span class="line">100&#x2F;100 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 30s 300ms&#x2F;step - loss: 0.5984 - acc: 0.6855 - val_loss: 0.4592 - val_acc: 0.8250</span><br><span class="line">Epoch 2&#x2F;30</span><br><span class="line">100&#x2F;100 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 30s 302ms&#x2F;step - loss: 0.4854 - acc: 0.7815 - val_loss: 0.3660 - val_acc: 0.8710</span><br><span class="line">......</span><br><span class="line">Epoch 29&#x2F;30</span><br><span class="line">100&#x2F;100 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 30s 300ms&#x2F;step - loss: 0.2774 - acc: 0.8825 - val_loss: 0.2402 - val_acc: 0.9040</span><br><span class="line">Epoch 30&#x2F;30</span><br><span class="line">100&#x2F;100 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 30s 302ms&#x2F;step - loss: 0.2693 - acc: 0.8900 - val_loss: 0.2401 - val_acc: 0.9070</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5lk985mvj30m60vqtcp.jpg" alt="运行结果图"></p><h3 id="Fine-tuning-微调模型"><a href="#Fine-tuning-微调模型" class="headerlink" title="Fine-tuning 微调模型"></a>Fine-tuning 微调模型</h3><p>（我比较喜欢 Fine-tuning 这个词，“微调”反而没内味儿了。）</p><p>Fine-tuning 是补充特征提取，进一步优化模型的。Fine-tuning 做的是将卷积基顶部(靠后面的)的几层<strong>解冻</strong>，把解冻的几层和新增加的部分(全连接分类器)联合训练。这个方法稍微调整了预训练模型里面那些高级抽象的表示(也就是那些接近顶层的)，使之更适合我们手头的问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5nq823wfj30ik0t0tbf.jpg" alt="Fine-tuning 示意图，微调了 VGG16 的最后一个卷积块"></p><p>注意，必须先把最后的全连接分类器训练好，才能去 Fine-tune 卷积基顶部的 Conv 块，不然就会把预训练的成果完全破坏调。</p><p>所以，Fine-tuning 需要按照以下步骤：</p><ol><li>在已经训练好的网络(base network，基网络)上添加我们自己的网络(比如分类器);</li><li>冻结基网络;</li><li>训练自己添加的那一部分;</li><li>解冻基网络的部分层;</li><li>联合训练解冻的层和自己的那部分;</li></ol><p>前三步都和特征提取做的是一样的，所以我们从第四步开始。首先再看一下我们的 VGG16 卷积基：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv_base.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;vgg16&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================input_1 (InputLayer)         [(None, 150, 150, 3)]     0         _________________________________________________________________block1_conv1 (Conv2D)        (None, 150, 150, 64)      1792      _________________________________________________________________block1_conv2 (Conv2D)        (None, 150, 150, 64)      36928     _________________________________________________________________block1_pool (MaxPooling2D)   (None, 75, 75, 64)        0         _________________________________________________________________block2_conv1 (Conv2D)        (None, 75, 75, 128)       73856     _________________________________________________________________block2_conv2 (Conv2D)        (None, 75, 75, 128)       147584    _________________________________________________________________block2_pool (MaxPooling2D)   (None, 37, 37, 128)       0         _________________________________________________________________block3_conv1 (Conv2D)        (None, 37, 37, 256)       295168    _________________________________________________________________block3_conv2 (Conv2D)        (None, 37, 37, 256)       590080    _________________________________________________________________block3_conv3 (Conv2D)        (None, 37, 37, 256)       590080    _________________________________________________________________block3_pool (MaxPooling2D)   (None, 18, 18, 256)       0         _________________________________________________________________block4_conv1 (Conv2D)        (None, 18, 18, 512)       1180160   _________________________________________________________________block4_conv2 (Conv2D)        (None, 18, 18, 512)       2359808   _________________________________________________________________block4_conv3 (Conv2D)        (None, 18, 18, 512)       2359808   _________________________________________________________________block4_pool (MaxPooling2D)   (None, 9, 9, 512)         0         _________________________________________________________________block5_conv1 (Conv2D)        (None, 9, 9, 512)         2359808   _________________________________________________________________block5_conv2 (Conv2D)        (None, 9, 9, 512)         2359808   _________________________________________________________________block5_conv3 (Conv2D)        (None, 9, 9, 512)         2359808   _________________________________________________________________block5_pool (MaxPooling2D)   (None, 4, 4, 512)         0         =================================================================Total params: 14,714,688Trainable params: 0Non-trainable params: 14,714,688_________________________________________________________________</code></pre><p>我们将解冻 block5_conv1, block5_conv2 和 block5_conv3 来完成 Fine-turning：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冻结直到某一层的所有层</span></span><br><span class="line"></span><br><span class="line">conv_base.trainable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">set_trainable = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> conv_base.layers:</span><br><span class="line">    <span class="keyword">if</span> layer.name == <span class="string">&#x27;block5_conv1&#x27;</span>:</span><br><span class="line">        set_trainable = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> set_trainable:</span><br><span class="line">        layer.trainable = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        layer.trainable = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 微调模型</span></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=optimizers.RMSprop(lr=<span class="number">1e-5</span>),    <span class="comment"># 这里用的学习率(lr)很小，是希望让微调的三层表示变化范围不要太大</span></span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit_generator(</span><br><span class="line">    train_generator,</span><br><span class="line">    steps_per_epoch=<span class="number">100</span>,</span><br><span class="line">    epochs=<span class="number">100</span>,</span><br><span class="line">    validation_data=validation_generator,</span><br><span class="line">    validation_steps=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>这个也是在 Kaggle 跑的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6fkf1r4hj31jw0gaq87.jpg" alt="在 Kaggle 训练的最后几轮输出"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6flamoy7j30o60wkdl5.jpg" alt="训练历史图线"></p><p>我不知道为什么我做出来的和书上差距很大，我反复看了好过错都没发现有什么问题，即使我用作者给的 Notebook 来跑也是😂，不知道哪里出问题了。不管了？就这样吧。</p><p>最后，来看看在测试集上的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_generator = test_datagen.flow_from_directory(</span><br><span class="line">        test_dir,</span><br><span class="line">        target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">        batch_size=<span class="number">20</span>,</span><br><span class="line">        class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line">test_loss, test_acc = model.evaluate_generator(test_generator, steps=<span class="number">50</span>)</span><br><span class="line">print(<span class="string">&#x27;test acc:&#x27;</span>, test_acc)</span><br></pre></td></tr></table></figure><p>书上的结果准确率有 97% 了，，我，我的还不到 95%，害。</p><h2 id="卷积神经网络的可视化"><a href="#卷积神经网络的可视化" class="headerlink" title="卷积神经网络的可视化"></a>卷积神经网络的可视化</h2><blockquote><p>5.4 Visualizing what convnets learn</p></blockquote><p>我们常说深度学习是黑箱，我们很难从其学习的过程中提取出 human-readable 的表示。但是，做计算机视觉的卷积神经网络不是这样，卷积神经网络是能可视化的，我们看得懂的，因为卷积神经网络本来就是提取“视觉概念的表示”的嘛。</p><p>现在已经有很多种不同的方法可以从不同角度把卷积神经网络可视化，并合理解释其意义。下面介绍其中几种。</p><h3 id="可视化中间激活"><a href="#可视化中间激活" class="headerlink" title="可视化中间激活"></a>可视化中间激活</h3><p><strong>可视化中间激活</strong>（Visualizing intermediate activations），也就是可视化卷积神经网络的中间输出。这个可视化可以帮助我们理解一系列连续得多卷积层是如何变换处理输入数据的、以及每个过滤器的基本意义。</p><p>这个其实就是把卷积/池化层输出的 feature maps 显示出来看看（层的输出也可以叫做 activation，激活）。具体的做法就是把输出的各个 channel 都做成二维的图像显示出来看。</p><p>我们用一个之前生成的模型来作为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> load_model</span><br><span class="line"></span><br><span class="line">model = load_model(<span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/cats_and_dogs_small_2.h5&#x27;</span>)</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_5&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_20 (Conv2D)           (None, 148, 148, 32)      896       _________________________________________________________________max_pooling2d_20 (MaxPooling (None, 74, 74, 32)        0         _________________________________________________________________conv2d_21 (Conv2D)           (None, 72, 72, 64)        18496     _________________________________________________________________max_pooling2d_21 (MaxPooling (None, 36, 36, 64)        0         _________________________________________________________________conv2d_22 (Conv2D)           (None, 34, 34, 128)       73856     _________________________________________________________________max_pooling2d_22 (MaxPooling (None, 17, 17, 128)       0         _________________________________________________________________conv2d_23 (Conv2D)           (None, 15, 15, 128)       147584    _________________________________________________________________max_pooling2d_23 (MaxPooling (None, 7, 7, 128)         0         _________________________________________________________________flatten_5 (Flatten)          (None, 6272)              0         _________________________________________________________________dropout (Dropout)            (None, 6272)              0         _________________________________________________________________dense_10 (Dense)             (None, 512)               3211776   _________________________________________________________________dense_11 (Dense)             (None, 1)                 513       =================================================================Total params: 3,453,121Trainable params: 3,453,121Non-trainable params: 0_________________________________________________________________</code></pre><p>然后我们找一张训练的时候网络没见过的图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img_path = <span class="string">&#x27;/Volumes/WD/Files/dataset/dogs-vs-cats/cats_and_dogs_small/test/cats/cat.1750.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image    <span class="comment"># 把图片搞成 4D 张量</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = image.load_img(img_path, target_size=(<span class="number">150</span>, <span class="number">150</span>))</span><br><span class="line">img_tensor = image.img_to_array(img)</span><br><span class="line">img_tensor = np.expand_dims(img_tensor, axis=<span class="number">0</span>)</span><br><span class="line">img_tensor /= <span class="number">255.</span></span><br><span class="line"></span><br><span class="line">print(img_tensor.shape)</span><br></pre></td></tr></table></figure><pre><code>(1, 150, 150, 3)</code></pre><p>显示图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.imshow(img_tensor[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8669nh8uj3079070js1.jpg" alt="png"></p><p>要提取特征图，就要用一个输入张量和一个输出张量列表来实例化一个模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">layer_outputs = [layer.output <span class="keyword">for</span> layer <span class="keyword">in</span> model.layers[:<span class="number">8</span>]]    <span class="comment"># 提取前 8 层的输出</span></span><br><span class="line">activation_model = models.Model(inputs=model.<span class="built_in">input</span>, outputs=layer_outputs)</span><br></pre></td></tr></table></figure><p>当输入一张图像时，这个模型就会返回原始模型前 8 层的激活值。我们之前的模型都是给一个输入，返一个输出的，但其实一个模型是可以给任意个输入，返任意个输出的。</p><p>接下来在把刚才找的图片输入进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activations = activation_model.predict(img_tensor)</span><br><span class="line"><span class="comment"># 返回 8 个 Numpy 数组组成的列表，每层一个，里面放着激活</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first_layer_activation = activations[<span class="number">0</span>]</span><br><span class="line">print(first_layer_activation.shape)</span><br></pre></td></tr></table></figure><pre><code>(1, 148, 148, 32)</code></pre><p>这东西有 32 个 channel，我们随便打一个出来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将第 4 个 channel 可视化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.matshow(first_layer_activation[<span class="number">0</span>, :, :, <span class="number">4</span>], cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x13f7b3d10&gt;</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8676bpw7j307f076wex.jpg" alt="png"></p><p>这个每个 channel 是干嘛的基本是随机的，我这个就和书上不一样。</p><p>下面，来绘制整个网络中完整的、所有激活的可视化。我们将 8 个 feature maps，每个其中的所有 channels 画出来了，排到一张大图上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将每个中间激活的所有通道可视化</span></span><br><span class="line"></span><br><span class="line">layer_names = []</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.layers[:<span class="number">8</span>]:</span><br><span class="line">    layer_names.append(layer.name)</span><br><span class="line">    </span><br><span class="line">images_per_row = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> layer_name, layer_activation <span class="keyword">in</span> <span class="built_in">zip</span>(layer_names, activations):</span><br><span class="line">    <span class="comment"># 对于每个 layer_activation，其形状为 (1, size, size, n_features)</span></span><br><span class="line">    n_features = layer_activation.shape[-<span class="number">1</span>]    <span class="comment"># 特征图里特征(channel)的个数</span></span><br><span class="line">    </span><br><span class="line">    size = layer_activation.shape[<span class="number">1</span>]    <span class="comment"># 图的大小</span></span><br><span class="line">    </span><br><span class="line">    n_cols = n_features // images_per_row</span><br><span class="line">    display_grid = np.zeros((size * n_cols, images_per_row * size))    <span class="comment"># 分格</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n_cols):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(images_per_row):</span><br><span class="line">            channel_image = layer_activation[<span class="number">0</span>, :, :, col * images_per_row + row]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 把图片搞好看一点</span></span><br><span class="line">            channel_image -= channel_image.mean()</span><br><span class="line">            channel_image /= channel_image.std()</span><br><span class="line">            channel_image *= <span class="number">64</span></span><br><span class="line">            channel_image += <span class="number">128</span></span><br><span class="line">            channel_image = np.clip(channel_image, <span class="number">0</span>, <span class="number">255</span>).astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">            display_grid[col * size : (col + <span class="number">1</span>) * size,</span><br><span class="line">                         row * size : (row + <span class="number">1</span>) * size] = channel_image</span><br><span class="line"></span><br><span class="line">    scale = <span class="number">1.</span> / size</span><br><span class="line">    plt.figure(figsize=(scale * display_grid.shape[<span class="number">1</span>], </span><br><span class="line">                        scale * display_grid.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    plt.title(layer_name)</span><br><span class="line">    plt.grid(<span class="literal">False</span>)</span><br><span class="line">    plt.imshow(display_grid, aspect=<span class="string">&#x27;auto&#x27;</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>/usr/local/lib/python3.7/site-packages/ipykernel_launcher.py:24: RuntimeWarning: invalid value encountered in true_divide</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866jmct8j30q004c40i.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8674iooxj30q004cdhw.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866chv4nj30q007cdjl.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866c10xej30q007cgpf.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866ewppaj30q00dejxf.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8666s9lfj30q00den33.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866djarhj30q00dejul.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866go1kzj30pu0dewhm.jpg" alt="png"></p><p>可以看到，特征越来越抽象。同时，黑的也越来越多（稀疏度越来越大），那些都是输入图像中找不到这些过滤器所编码的模式，所以就空白了。</p><p>这里表现出来一个重要普遍特征：随着层数的加深，层所提取的特征变得越来越抽象。更高的层激活包含关于特定输入的信息越来越少，而关于目标的信息越来越多。</p><p>与人类和动物感知世界的方式类似：人类观察一个场景几秒钟后，可以记住其中有哪些抽象物体(比如自行车、树)，但记不住这些物体的具体外观。你的大脑会自动将视觉输入完全抽象化，即将其转换为更高层次的视觉概念，同时过滤掉不相关的视觉细节。</p><p>深度神经网络利用信息蒸馏管道 (information distillation pipeline)，将输入原始数据(本例中是 RGB 图像)，反复进行变换，将无关信息过滤掉(比如图像的具体外观)，并放大和细化有用的信息(比如图像的类别)，最终完成对信息的利用（比如判断出图片是猫还是狗）。</p><h3 id="可视化卷积神经网络的过滤器"><a href="#可视化卷积神经网络的过滤器" class="headerlink" title="可视化卷积神经网络的过滤器"></a>可视化卷积神经网络的过滤器</h3><p><strong>可视化卷积神经网络的过滤器</strong>（Visualizing convnets filters），帮助理解各个过滤器善于接受什么样的视觉模式(pattern，我觉得“模式”这个词并不能很好的诠释 pattern 的意思)或概念。</p><p>要观察卷积神经网络学到的过滤器，我们可以显示每个过滤器所响应的视觉模式。这个可以在输入空间上用 gradient ascent（梯度上升）来实现：</p><p>为了从空白输入图像开始，让某个过滤器的响应最大化，可以将梯度下降应用于卷积神经网络输入图像的值。得到的输入图像即为对过滤器具有最大响应的图像。</p><p>这个做起来很简单，构建一个损失函数，其目的是让某个卷积层的某个过滤器的值最大化。然后，使用随机梯度下降来调节输入图像的值，使之激活值最大化。</p><p>例如，在 ImageNet 上预训练的 VGG16 网络的 block3_conv1 层第 0 个过滤器激活的损失就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> VGG16</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line">model = VGG16(weights=<span class="string">&#x27;imagenet&#x27;</span>, include_top=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">layer_name = <span class="string">&#x27;block3_conv1&#x27;</span></span><br><span class="line">filter_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">layer_output = model.get_layer(layer_name).output</span><br><span class="line">loss = K.mean(layer_output[:, :, :, filter_index])</span><br><span class="line"></span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure><pre><code>Tensor(&quot;Mean_11:0&quot;, shape=(), dtype=float32)</code></pre><p>要做梯度下降嘛，所以要得到 loss 相对于模型输入的梯度。用 Keras 的 backend 的 gradients 函数来完成这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># See https://github.com/tensorflow/tensorflow/issues/33135</span></span><br><span class="line"></span><br><span class="line">grads = K.gradients(loss, model.<span class="built_in">input</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 这东西返回的是一个装着一系列张量的 list，在此处，list 长度为1，所以取 [0] 就是一个张量</span></span><br><span class="line">print(grads)</span><br></pre></td></tr></table></figure><pre><code>Tensor(&quot;gradients_1/block1_conv1_4/Conv2D_grad/Conv2DBackpropInput:0&quot;, shape=(None, None, None, 3), dtype=float32)</code></pre><p>这里可以用一个小技巧来让梯度下降过程平顺地进行：将梯度张量除以其 L2 范数(张量的平方的平均值的平方根)来标准化。这种操作可以使输入图像更新地大小始终保持在同一个范围里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grads /= (K.sqrt(K.mean(K.square(grads))) + <span class="number">1e-5</span>)    <span class="comment"># + 1e-5 防止除以0</span></span><br><span class="line">print(grads)</span><br></pre></td></tr></table></figure><pre><code>Tensor(&quot;truediv_1:0&quot;, shape=(None, None, None, 3), dtype=float32)</code></pre><p>现在需要接近的问题是，给定输入图像，计算出 loss 和 grads 的值。这个可以用 iterate 函来做：它将一个 Numpy 张量转换为两个 Numpy 张量组成的列表，这两个张量分别是损失值和梯度值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterate = K.function([model.<span class="built_in">input</span>], [loss, grads])</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">loss_value, grads_value = iterate([np.zeros((<span class="number">1</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>))])</span><br><span class="line">print(loss_value, grads_value)</span><br></pre></td></tr></table></figure><pre><code>0.0 [[[[0. 0. 0.]   [0. 0. 0.]   [0. 0. 0.]   ...   ...   [0. 0. 0.]   [0. 0. 0.]   [0. 0. 0.]]]]</code></pre><p>然后，就来写梯度下降了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过随机梯度下降让损失最大化</span></span><br><span class="line"></span><br><span class="line">input_img_data = np.random.random((<span class="number">1</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>)) * <span class="number">20</span> + <span class="number">128.</span>   <span class="comment"># 随便一个有燥点的灰度图</span></span><br><span class="line"></span><br><span class="line">plt.imshow(input_img_data[<span class="number">0</span>, :, :, :] / <span class="number">225.</span>)</span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">step = <span class="number">1.</span>    <span class="comment"># 梯度更新的步长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    loss_value, grads_value = iterate([input_img_data])</span><br><span class="line">    input_img_data += grads_value * step    <span class="comment"># 沿着让损失最大化的方向调节输入图像</span></span><br><span class="line">    </span><br><span class="line">plt.imshow(input_img_data[<span class="number">0</span>, :, :, :] / <span class="number">225.</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8673z1cwj30790700sy.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh86752ufkj307907074x.jpg" alt="png"></p><p>Emmm，刚才这个画图是我随便写的啦，所以爆了个 Warning，为了正规地画出图来,下面好好处理一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将张量转换为有效图像的 utility 函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deprocess_image</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="comment"># 标准化，均值为 0， 标准差为 0.1</span></span><br><span class="line">    x -= x.mean()</span><br><span class="line">    x /= (x.std() + <span class="number">1e-5</span>)</span><br><span class="line">    x *= <span class="number">0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 裁剪到 [0, 1]</span></span><br><span class="line">    x += <span class="number">0.5</span></span><br><span class="line">    x = np.clip(x, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将 x 转换为 RGB 数组</span></span><br><span class="line">    x *= <span class="number">255</span></span><br><span class="line">    x = np.clip(x, <span class="number">0</span>, <span class="number">255</span>).astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把上面那些东西全部拼起来就可以得到完整的生成过滤器可视化的函数了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成过滤器可视化的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># See https://github.com/tensorflow/tensorflow/issues/33135</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_pattern</span>(<span class="params">layer_name, filter_index, size=<span class="number">150</span></span>):</span></span><br><span class="line">    <span class="comment"># 构建一个损失函数，将 layer_name 层第 filter_index 个过滤器的激活最大化</span></span><br><span class="line">    layer_output = model.get_layer(layer_name).output</span><br><span class="line">    loss = K.mean(layer_output[:, :, :, filter_index])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算损失相对于输入图像的梯度，并将梯度标准化</span></span><br><span class="line">    grads = K.gradients(loss, model.<span class="built_in">input</span>)[<span class="number">0</span>]</span><br><span class="line">    grads /= (K.sqrt(K.mean(K.square(grads))) + <span class="number">1e-5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回给定输入图像的损失和梯度</span></span><br><span class="line">    iterate = K.function([model.<span class="built_in">input</span>], [loss, grads])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从带有噪声的灰度图开始，梯度上升 40 次</span></span><br><span class="line">    input_img_data = np.random.random((<span class="number">1</span>, size, size, <span class="number">3</span>)) * <span class="number">20</span> + <span class="number">128.</span></span><br><span class="line">    step = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        loss_value, grads_value = iterate([input_img_data])</span><br><span class="line">        input_img_data += grads_value * step</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    img = input_img_data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> deprocess_image(img)</span><br></pre></td></tr></table></figure><p>然后就可以用了，还是那刚才那个例子是一下|：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(generate_pattern(<span class="string">&#x27;block3_conv1&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x167d78950&gt;</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866foirwj3079070t9a.jpg" alt="png"></p><p>这个图就是 block3_conv1 层第 0 个过滤器的响应了。这种 pattern 叫做 polka-dot（波尔卡点图案）。</p><p>接下来我们把每一层的每个过滤器都可视化。为了快一点，我们只可视化每个卷积块的第一层的前64个过滤器（防止也没什么意义，就是看看，随便搞几个就行了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一层中所有过滤器响应模式组成的网格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_patterns_in_layer</span>(<span class="params">layer_name, size=<span class="number">64</span>, margin=<span class="number">5</span></span>):</span></span><br><span class="line">    results = np.zeros((<span class="number">8</span> * size + <span class="number">7</span> * margin, <span class="number">8</span> * size + <span class="number">7</span> * margin, <span class="number">3</span>), dtype=np.<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            filter_img = generate_pattern(layer_name, i + (j * <span class="number">8</span>), size=size)</span><br><span class="line">            </span><br><span class="line">            horizontal_start = i * size + i * margin</span><br><span class="line">            horizontal_end = horizontal_start + size</span><br><span class="line">            </span><br><span class="line">            vertical_start = j * size + j * margin</span><br><span class="line">            vertical_end = vertical_start + size</span><br><span class="line">            </span><br><span class="line">            results[horizontal_start: horizontal_end,</span><br><span class="line">                    vertical_start: vertical_end, :] = filter_img</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">layer_names = [<span class="string">&#x27;block1_conv1&#x27;</span>, <span class="string">&#x27;block2_conv1&#x27;</span>, <span class="string">&#x27;block3_conv1&#x27;</span>, <span class="string">&#x27;block4_conv1&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> layer_names:</span><br><span class="line">    img = generate_patterns_in_layer(layer)</span><br><span class="line">    plt.figure(figsize=(<span class="number">20</span>, <span class="number">20</span>))</span><br><span class="line">    plt.title(layer)</span><br><span class="line">    plt.imshow(img)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh86676843j30q00den33.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8668h3n8j30u00u44d3.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866aay9sj30u00u4du6.jpg" alt="png"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh866b9rihj30u00u4nbg.jpg" alt="png"></p><p>这些图里就表现了卷积神经网络的层如何观察图片中的信息的：卷积神经网络中每一层都学习一组过滤器，然后输入会被表示成过滤器的组合，这个其实类似于傅里叶变换的过程。随着层数的加深，卷积神经网络中的过滤器变得越来越复杂，越来越精细，所以就可以提取、“理解”根据抽象的信息了。</p><h3 id="可视化图像中类激活的热力图"><a href="#可视化图像中类激活的热力图" class="headerlink" title="可视化图像中类激活的热力图"></a>可视化图像中类激活的热力图</h3><p><strong>可视化图像中类激活的热力图</strong>（Visualizing heatmaps of class activation in an image），用来了解网络是靠哪部分图像来识别一个类的，也有助于知道物体在图片的哪个位置。</p><p>用来对输入图像生成类激活的热力图的一种技术叫 CAM (class activation map 类激活图)可视化。类激活热力图对任意输入的图像的每个位置进行计算，表示出每个位置对该类别的重要程度。比如我们的猫狗分类网络里，对一个猫的图片生成类激活热力图，可以得到这个图片的各个不同的部位有多像猫（对模型认为这是猫的图片起了过大的作用）。</p><p>具体来说，我们用 [Grad-CAM](<a href="https://arxiv.org/abs/">https://arxiv.org/abs/</a> 1610.02391.) 这个方法：给定一张输入图像，对于一个卷积层的输出特征图，用类别相对于通道的梯度对这个特征图中的每个通道进行加权。说人话就是用「每个通道对分类的重要程度」对「输入图像对不同通道的激活的强弱程度」的空间图进行加权，从而得到「输入图像对类别的激活强度」的空间图。（emmm，这种超长的句子看原文比较好😭：Intuitively, one way to understand this trick is that you’re weighting a spatial map of “how intensely the input image activates different channels” by “how important each channel is with regard to the class,” resulting in a spatial map of “how intensely the input image activates the class.”）</p><p>我们在 VGG16 模型来演示这个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载带有预训练权重的 VGG16 网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications.vgg16 <span class="keyword">import</span> VGG16</span><br><span class="line"></span><br><span class="line">model = VGG16(weights=<span class="string">&#x27;imagenet&#x27;</span>)    <span class="comment"># 注意这个是带有分类器的，比较大，下载稍慢（有500+MB）</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;vgg16&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================input_1 (InputLayer)         [(None, 224, 224, 3)]     0         _________________________________________________________________block1_conv1 (Conv2D)        (None, 224, 224, 64)      1792      _________________________________________________________________block1_conv2 (Conv2D)        (None, 224, 224, 64)      36928     _________________________________________________________________block1_pool (MaxPooling2D)   (None, 112, 112, 64)      0         _________________________________________________________________block2_conv1 (Conv2D)        (None, 112, 112, 128)     73856     _________________________________________________________________block2_conv2 (Conv2D)        (None, 112, 112, 128)     147584    _________________________________________________________________block2_pool (MaxPooling2D)   (None, 56, 56, 128)       0         _________________________________________________________________block3_conv1 (Conv2D)        (None, 56, 56, 256)       295168    _________________________________________________________________block3_conv2 (Conv2D)        (None, 56, 56, 256)       590080    _________________________________________________________________block3_conv3 (Conv2D)        (None, 56, 56, 256)       590080    _________________________________________________________________block3_pool (MaxPooling2D)   (None, 28, 28, 256)       0         _________________________________________________________________block4_conv1 (Conv2D)        (None, 28, 28, 512)       1180160   _________________________________________________________________block4_conv2 (Conv2D)        (None, 28, 28, 512)       2359808   _________________________________________________________________block4_conv3 (Conv2D)        (None, 28, 28, 512)       2359808   _________________________________________________________________block4_pool (MaxPooling2D)   (None, 14, 14, 512)       0         _________________________________________________________________block5_conv1 (Conv2D)        (None, 14, 14, 512)       2359808   _________________________________________________________________block5_conv2 (Conv2D)        (None, 14, 14, 512)       2359808   _________________________________________________________________block5_conv3 (Conv2D)        (None, 14, 14, 512)       2359808   _________________________________________________________________block5_pool (MaxPooling2D)   (None, 7, 7, 512)         0         _________________________________________________________________flatten (Flatten)            (None, 25088)             0         _________________________________________________________________fc1 (Dense)                  (None, 4096)              102764544 _________________________________________________________________fc2 (Dense)                  (None, 4096)              16781312  _________________________________________________________________predictions (Dense)          (None, 1000)              4097000   =================================================================Total params: 138,357,544Trainable params: 138,357,544Non-trainable params: 0_________________________________________________________________</code></pre><p>然后我们照一张用来测试的图片：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh83vzik31j30oz0goq7t.jpg" alt="creative_commons_elephant"></p><p>这是两只亚洲象🐘哦，把这个图片处理成 VGG16 模型需要的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications.vgg16 <span class="keyword">import</span> preprocess_input, decode_predictions</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;./creative_commons_elephant.jpg&#x27;</span></span><br><span class="line">img = image.load_img(img_path, target_size=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"></span><br><span class="line">img = image.load_img(img_path, target_size=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">x = image.img_to_array(img)</span><br><span class="line">x = np.expand_dims(x, axis=<span class="number">0</span>)</span><br><span class="line">x = preprocess_input(x)</span><br></pre></td></tr></table></figure><p>预测一下图片里的是啥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preds = model.predict(x)</span><br><span class="line">print(<span class="string">&#x27;Predicted:&#x27;</span>, decode_predictions(preds, top=<span class="number">3</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>Predicted: [(&#39;n02504458&#39;, &#39;African_elephant&#39;, 0.909421), (&#39;n01871265&#39;, &#39;tusker&#39;, 0.086182885), (&#39;n02504013&#39;, &#39;Indian_elephant&#39;, 0.0043545826)]</code></pre><p>有 90% 的把握是亚洲象，不错。接下来就要用 Grad-CAM 算法来显示图像中哪些部分最像非洲象了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># See https://github.com/tensorflow/tensorflow/issues/33135</span></span><br><span class="line"></span><br><span class="line">african_elephant_output = model.output[:, <span class="number">386</span>]    <span class="comment"># 这个是输出向量中代表“非洲象”的元素</span></span><br><span class="line"></span><br><span class="line">last_conv_layer = model.get_layer(<span class="string">&#x27;block5_conv3&#x27;</span>)   <span class="comment"># VGG16 最后一个卷积层的输出特征图</span></span><br><span class="line"></span><br><span class="line">grads = K.gradients(african_elephant_output, last_conv_layer.output)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">pooled_grads = K.mean(grads, axis=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>))    <span class="comment"># 特定特征图通道的梯度平均大小，形状为 (512,) </span></span><br><span class="line"></span><br><span class="line">iterate = K.function([model.<span class="built_in">input</span>], [pooled_grads, last_conv_layer.output[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">pooled_grads_value, conv_layer_output_value = iterate([x])    <span class="comment"># 对刚才的测试🐘图片计算出梯度和特征图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">512</span>):</span><br><span class="line">    <span class="comment"># 将特征图数组的每个 channel 乘以「这个 channel 对‘大象’类别的重要程度」</span></span><br><span class="line">    conv_layer_output_value[:, :, i] *= pooled_grads_value[i]</span><br><span class="line">    </span><br><span class="line">heatmap = np.mean(conv_layer_output_value, axis=-<span class="number">1</span>)  <span class="comment"># 处理后的特征图的逐通道平均值即为类激活的热力图</span></span><br></pre></td></tr></table></figure><p>把它画出来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">heatmap = np.maximum(heatmap, <span class="number">0</span>)</span><br><span class="line">heatmap /= np.<span class="built_in">max</span>(heatmap)</span><br><span class="line">plt.matshow(heatmap)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x13d935210&gt;</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh8669908hj3078076mx8.jpg" alt="png"></p><p>emmmm，看不懂啊，所以，我们用 OpenCV 把这个叠加到原图上去看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(img_path)    <span class="comment"># 加载原图</span></span><br><span class="line">heatmap = cv2.resize(heatmap, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))    <span class="comment"># 调整热力图大小，符合原图</span></span><br><span class="line">heatmap = np.uint8(<span class="number">255</span> * heatmap)    <span class="comment"># 转换为 RGB 格式</span></span><br><span class="line">heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)</span><br><span class="line">superimposed_img = heatmap * <span class="number">0.4</span> + img    <span class="comment"># 叠加</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./elephant_cam.jpg&#x27;</span>, superimposed_img)    <span class="comment"># 保存</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>得到的图像如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh84yvepspj30oz0go7a9.jpg" alt="叠加到原图的热力图"></p><p>可以看出，VGG16 网络其实只识别了那只小的象，注意，小象头部的激活强度很大，这可能就是网络找到的非洲象的独特之处。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions 实践：Hexo GitHub Pages 博客持续部署</title>
      <link href="/2020/07/26/blog/GitHub-Actions-Hexo-CI-CD/"/>
      <url>/2020/07/26/blog/GitHub-Actions-Hexo-CI-CD/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Actions-实践-Hexo-GitHub-Pages-博客持续部署"><a href="#GitHub-Actions-实践-Hexo-GitHub-Pages-博客持续部署" class="headerlink" title="GitHub Actions 实践: Hexo GitHub Pages 博客持续部署"></a>GitHub Actions 实践: Hexo GitHub Pages 博客持续部署</h1><p>我用 Hexo 来管理自己的文章、并部署到 Github Pags 已经有一段时间了。关于我构建这个博客系统的经过可以看这篇文章：《<a href="https://clownote.github.io/2019/08/15/blog/GitHub%E5%8A%A0Hexo%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">GitHub + Hexo =&gt; 个人博客</a>》。</p><p>在实际使用这个系统的过程中，很多时候，我都是有想法就打开 Typora 开始写，文章写完了就在开头手动补一个 YAML 配置，然后直接把 <code>.md</code> 文件扔到 <code>_post</code> 或者 <code>_draft</code> 里。然后用 Hexo CLI 生成、部署，然后把源文件用 Git 提交、推送到 GitHub 备份。这个过程基本如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim newArticle.md    <span class="comment"># 实际上我是用 Typora 的，这里编辑过程用 vim 代替</span></span><br><span class="line">$ mv newArticle.md ~/clownote/<span class="built_in">source</span>/_post    <span class="comment"># 我的博客系统放在 ~/clownote</span></span><br><span class="line">$ hexo g -d    <span class="comment"># 生成、部署到 GitHub Pages</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;add newArticle&quot;</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>hexo 生成、部署、git 提交，这个过程果然还是太冗长了。我在想用没有一种方法可以简化这个套路化的流程。对此，我首先的想法是写一个 shell 脚本来简化整套流程。这个脚本提供如下接口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clownote new newArticleTitle    <span class="comment"># 新建文章，自动打开 Typora 编辑</span></span><br><span class="line">$ clownote update    <span class="comment"># 生成、部署、源码 git 提交</span></span><br></pre></td></tr></table></figure><p>但感觉有点死板，而且我其实不太喜欢写 shell 脚本，那语法虽然很简洁、高效，但真的，，真的一言难尽。当然也可以用其他语言来写这东西，Python 就不错，不用编译、写个执行注释加上权限直接就能跑。但是，这样比较无趣嘛，我没有这么做。</p><p>现在是云时代了，CI/CD 这一套很流行了，玩这东西可能比写个烂脚本有意思多了，所以我选择用 CI/CD 这一套来完成任务。</p><h2 id="CI-CD-amp-CD"><a href="#CI-CD-amp-CD" class="headerlink" title="CI, CD &amp; CD"></a>CI, CD &amp; CD</h2><p>简单说一下 CI/CD —— CI, CD &amp; CD：Continuous Integration，Continuous Delivery，Continuous Deployment。翻译成中文：持续集成、持续交付和持续部署。</p><ul><li>持续集成CI：提交代码到主分支前，自动编译、自动测试验证，没通过就不能合并；</li><li>持续交付CD：在 CI 验证通过后，如果没有问题，可以继续手动部署到生产环境中；</li><li>持续部署CD：把部署到生产环境的过程自动化，不需要手工操作。</li></ul><blockquote><p>还不了解 CI/CD 是什么？移步红帽的这篇 《<a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">CI/CD是什么？如何理解持续集成、持续交付和持续部署</a>》，还有这篇《<a href="http://www.ttlsa.com/news/ci-cd-cd/">详解CI、CD &amp; CD</a>》，还是不懂，就看看 <a href="https://www.zhihu.com/question/23444990">知乎</a> 吧。</p></blockquote><h2 id="博客的持续部署"><a href="#博客的持续部署" class="headerlink" title="博客的持续部署"></a>博客的持续部署</h2><p>抛开定义，直观上，持续部署，顾名思义，就是持续不断地去部署，部署自动紧跟代码改变：你的提交了源码修改，部署上就自动更新了。对于我们的博客系统，也就是新建/修改/删除了文章，博客站点就自动更新、修改对应内容。从效果上来说，就是我们不用再去手动 <code>hexo g -d</code> 生成、部署了。</p><p>我们刚才提出的脚本就能达到这样的目的，但我觉得这样不太算持续部署，写脚本只是把一系列操作合并到一起让计算机逐步完成，本质并没有改变，你终究是自己做了全套的部署工作。但你细品，用持续部署就不一样了，它是先提交源码，然后它在云端就自动给你去生成(编译)、部署了，这个生成、部署的工作是不需要由你在本地完成的。</p><p>这些工作不由你来做靠谁做呢？由提供 CI/CD 服务的服务器自动来完成。其实 GitHub 就免费提供来这项服务，叫做 <a href="https://github.com/features/actions">GitHub Actions</a>。</p><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>GitHub Actions 可以自动在你的 GitHub 仓库发生事件时自动完成一些工作，比如在你推送提交(git push)到博客仓库时，自动给你部署上。详细的入门，推荐看看阮一峰老师的《<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a>》。当然，<a href="https://docs.github.com/en/actions">官方文档</a> 也是很好的学习资料。</p><p>这个东西用起来有点像 Docker，可以以别人做好的“镜像”（在 GitHub Actions 中称为 Actions）为基础去执行一些工作，当然你也可以构建“镜像”。其实，已经有很多人做过自动在 Github Pages 持续部署 Hexo 博客的 Actions 了，我们甚至可以直接用。你可以在 GitHub 网页顶部看到一个 <code>Marketplace</code>，点进去可以搜别人写好的 Actions。</p><blockquote><p>注：下文对 Workflow 的介绍：**Forked from <a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">ruanyifeng/GitHub Actions 入门教程</a>**，并参考官方文档做了一定的修改、补充。</p></blockquote><p>GitHub Actions 的配置文件叫做 Workflow，存放在代码仓库的 <code>.github/workflows</code> 目录。Workflow 文件是用 <a href="https://yaml.org/">YAML</a> 去写的，后缀名为 <code>.yml</code>。一个 repo 可以有多个 workflow 文件。GitHub 会发现 <code>.github/workflows</code> 目录里所有 <code>.yml</code> 文件，自动把他们识别为 Action，在出发其中指定的操作时就自动运行。下面介绍一些 Workflow 的基本写法：</p><p>（1）<code>name</code>：workflow 的名称。如果省略，则默认为当前 workflow 的文件名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">GitHub</span> <span class="string">Actions</span> <span class="string">Demo</span></span><br></pre></td></tr></table></figure><p>（2）<code>on</code>：指定触发 workflow 的事件。比如 push 时出发执行该 Action。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="comment"># 如果有多种可以写数组：</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br><span class="line"><span class="comment"># 还可以指定分支 on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;：</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span>    </span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>（3）<code>jobs</code>：表示要执行的一项或多项任务，workflow 的主体。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">my_first_job:</span>    <span class="comment"># job_id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">job</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  <span class="attr">greeting_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">This</span> <span class="string">job</span> <span class="string">needs</span> <span class="string">my_first_job</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">my_first_job</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">a</span> <span class="string">greeting</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">MY_VAR:</span> <span class="string">Hi</span> <span class="string">there!</span> <span class="string">My</span> <span class="string">name</span> <span class="string">is</span></span><br><span class="line">          <span class="attr">MY_NAME:</span> <span class="string">Mona</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">$MY_VAR</span> <span class="string">$MY_NAME.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hello</span> <span class="string">world</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/hello-world-javascript-action@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">who-to-greet:</span> <span class="string">&#x27;Mona the Octocat&#x27;</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>name</code> ：任务的说明。</li><li><code>needs</code> ：指定当前任务的依赖关系，即运行顺序。</li><li><code>runs-on</code> ：指定运行所需要的虚拟机环境。必填，可以用 ubuntu、windows、macOS，还有好多版本可选，详细的看<a href="https://docs.github.com/en/actions/reference/virtual-environments-for-github-hosted-runners">文档</a>。</li><li><code>steps</code>：<code>steps</code>字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下字段：<ul><li><code>jobs.&lt;job_id&gt;.steps.name</code>：步骤名称。</li><li><code>jobs.&lt;job_id&gt;.steps.id</code>：步骤的 step_id。</li><li><code>jobs.&lt;job_id&gt;.steps.run</code>：该步骤运行的命令或者 action。带 env 来设置环境变量。</li><li><code>jobs.&lt;job_id&gt;.steps.uses</code>：调用别人做好的 action。带 with 来指定运行参数。</li></ul></li></ul><p>接下来我们就开始实践，构建自动部署 GitHub Pages 的 GitHub Action。（GitHub 全家桶警告😨）</p><h2 id="使用-sma11black-hexo-action"><a href="#使用-sma11black-hexo-action" class="headerlink" title="使用 sma11black/hexo-action"></a>使用 sma11black/hexo-action</h2><p>我查看、尝试了多个关于 Hexo 的 Actions，最后觉得 <a href="https://github.com/marketplace/actions/hexo-action">sma11black/hexo-action</a> 提供了我需要的一切，代码写的也很好，文档也最为完备。所以就决定直接用它了，懒得自己写。</p><blockquote><p>插嘴：这个项目真的不错，最后还写了几个<a href="https://github.com/marketplace/actions/hexo-action#recommand-hexo-repository-settings">建议的 Hexo 博客设置</a>，这些建议确实不错。</p></blockquote><p>下面跟着<a href="https://github.com/marketplace/actions/hexo-action">文档</a>，使用这个 Action。</p><ol><li>设置 <code>Deploy keys</code> 和 <code>Secrets</code>。</li></ol><p>首先在本地生成一对 ssh-key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;your_username@example.com&quot;</span></span><br></pre></td></tr></table></figure><p><code>your_username@example.com</code> 要时你自己的、你之后要在 <em>Github Pages</em> 仓库里提交的 GitHub 用户邮箱。</p><p>注意：参考 Issue <a href="https://github.com/sma11black/hexo-action/issues/6">SSH Key doesnt work #6</a>，<strong>不要加 passphrase</strong>，让你填写、确认的时候直接回车。把生成文件保存到一个你能找到的地方（比如桌面，不要提交到 git 中，不要用默认位置）。</p><p>然后设置公钥：去你的 <em>Github Pages</em> 仓库，点 <code>Settings &gt; Deploy Keys</code>，新建一个，把刚从生成的 <code>xxx.pub</code> 里面的内容填进去。</p><p>最后设置密钥：去你的 hexo 博客源文件仓库，点 <code>Settings &gt; Secrets</code>，新建一个叫做 <code>DEPLOY_KEY</code> 的项，把刚才生成的另一个文件里的内容填进去。</p><ol start="2"><li>配置 workflows。</li></ol><p>去 hexo 博客源文件仓库，在 GitHub 上仓库页面点 Actions，新建一个：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh47brdrqgj319g0u07wh.jpg" alt="屏幕快照，新建一个 Action"></p><p>其实也可以在 <code>.github/workflows</code> 目录里创建一个  <code>.yml</code>  文件，开始编辑。是等效的。</p><p>然后，在 workflows 配置文件中写入下面代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">(Hexo</span> <span class="string">g</span> <span class="string">-d)</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">user_name:</span> <span class="string">your_username</span></span><br><span class="line">        <span class="attr">user_email:</span> <span class="string">your_username@example.com</span></span><br><span class="line">        <span class="attr">commit_msg:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>  <span class="comment"># (or delete this input setting to use hexo default settings)</span></span><br><span class="line">    <span class="comment"># Use the output from the `deploy` step(use for test action)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; steps.deploy.outputs.notify &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>注意把 user_name、user_email 换成你刚才创建 ssh-key 的那个。</p><p>把编辑好的配置提交上，就完成了！以后每次你 git push 到 GitHub，博客网站就自动更新了！</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ol><li><strong>Action 内部无法访问 GitHub</strong></li></ol><p>现在 git push 时，你可能发现 Github 发邮件告诉你运行失败了！打开看结果日志里会发现爆出了 这种错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: could not read Username for &#39;https:&#x2F;&#x2F;github.com&#39;: No such device or address</span><br></pre></td></tr></table></figure><p>首先确定之前的步骤正确无误，尤其是 user_email 配置和生成的 ssh-key 一致，且 publish key、private key 设置正确。</p><p>如果这些都确认正确无误，请参考<a href="https://github.com/sma11black/hexo-action/issues/5">sma11black/hexo-action Issue #5</a>，在你的 hexo 配置文件 <code>_config.yml</code> 中，看看能不能把 deploy repo 的 URL 从 <strong>HTTPS</strong> 的换成 <strong>SSH</strong> 的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span></span><br><span class="line">  <span class="comment"># 改之前是 https://github.com/...</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这个解决了我的问题。</p><ol start="2"><li><strong>博客发布时间错乱</strong></li></ol><p>之前提到过，我平时写文章都是直接打开 Typora 就写，比如现在：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh48f31zmjj315b0u0dwz.jpg" alt="本文写作过程中 typora 的屏幕快照"></p><p>你可以看到我是没保存的，写完之后我会手动在文章开头写 YAML 配置，然后扔到 <code>_post</code> 里：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">GitHub</span> <span class="string">Actions</span> <span class="string">实践:</span> <span class="string">Hexo</span> <span class="string">GitHub</span> <span class="string">Pages</span> <span class="string">博客持续部署</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">blog</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>其实更一般的，因为懒，我就写个 title😂（有时候甚至连 title 都忘记写）。但如果你用 <code>hexo new</code>、<code>hexo publish</code> 去新建、公开文章的话，hexo给你自动完成的配置里还会多一项 <code>date</code> 写上文章创建的时间。生成网页时，会根据这个 date 来确定文章日期；对于没写date标签的文章，它会自动把文章发布时间设置成你系统上文件创建的时间。</p><p>我以前都忽略了这个 date，这对于在本地生成是没问题的，因为本地文件系统中保存着文件创建的时间信息。但是一用上刚才写好的持续部署，我发现一大堆这种手动建立文件的文章发布时间全变成了最后一次自动部署的时间。比如我 7月24日 git push了，然后自动部署执行，一大堆文章的创建时间全变成了7月24日😱。</p><p>这个问题是由于，GitHub Actions 是在容器内跑的嘛，它运行时把源码从 GitHub 复制到容器内，所以文件的创建时间全部时运行的时间。然后生成、发布，这些没写 date 标签的文章就都变成了“新”写的。</p><p>为了解决这个问题，需要给所有以前没写 date 的文章补上这个配置。还是很容易的，只要找到这些没写 date 的文章，然后在系统中查看文件属性里的创建时间，补上就好：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4960r7kpj31po0qa458.jpg" alt="查看文件属性里的创建时间，在文件中补充date"></p><p>但这并不是个小工程呐，涉及的文章有数十篇，肯定不可能手动去做这个操作。所以，写程序来完成这个任务！做这件事的程序思路如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4ak19a40j30wz0u0tbm.jpg" alt="自动完成YAML信息补全的程序流程图"></p><p>我用 Python 实现了这个程序。</p><h3 id="文章YAML配置补全脚本"><a href="#文章YAML配置补全脚本" class="headerlink" title="文章YAML配置补全脚本"></a>文章YAML配置补全脚本</h3><p>因为配置是写成 YAML 的嘛，所以说，首先，我们需要找一个 Python 的 YAML 库，我可不想手写一份 YAML 解析、生成的代码。Emmm，我的电脑上有其他库依赖安装了一个 <a href="https://pyyaml.org/">PyYAML</a>，所以就直接用这个了。关于 YAML，我们主要只用两种功能：解析和生成，可以用如下代码完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml    <span class="comment"># 导入 PyYAML</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字符串读取 YAML 内容，解析成 Python 对象，正常情况返回一个 dict：</span></span><br><span class="line">yaml.safe_load(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 Python 对象（一般用个 dict）转化成 YAML 内容：</span></span><br><span class="line">content = yaml.dump(data, allow_unicode=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>然后我们就要来封装我们需要的从博客文件中读取、写入 YAML 配置的函数了：</p><p>首先是读取：从一篇文章中读取 YAML 配置，即在文章开头处两行 <code>---</code> 之间的符合 YAML 语法的配置信息。返回 <code>yaml.safe_load</code> 出来的 Python 对象、原文件中 YAML 配置的起始结束行号（从0开始计数，闭区间），以及一个代表文件中是否存在 YAML 配置的 bool：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_yaml</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> os.path.isfile(file_path), <span class="string">f&quot;Target file not exists: <span class="subst">&#123;file_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    is_yaml = <span class="literal">False</span></span><br><span class="line">    yaml_content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    yaml_line = []</span><br><span class="line">    lines_cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.strip() == <span class="string">&#x27;---&#x27;</span>:</span><br><span class="line">                yaml_line.append(lines_cnt)</span><br><span class="line">                <span class="keyword">if</span> is_yaml <span class="keyword">or</span> (lines_cnt &gt; <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                is_yaml = <span class="keyword">not</span> is_yaml</span><br><span class="line">            <span class="keyword">if</span> is_yaml:</span><br><span class="line">                yaml_content += line.replace(<span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">            lines_cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> yaml.safe_load(yaml_content), yaml_line, <span class="built_in">len</span>(yaml_line) == <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有是写入，在文件头部写入信息，如果文件特别大还是有点头疼的， 但好在博客文章不可能太长，可以暂不考虑文件太大的情况，只需把文章内容全部先读出来，然后在文件头部覆盖写入 YAML 配置，再把原内容写回去。我们需要写的是一个 <code>write_yaml</code>  函数向其参数 file_path 指定的文件开头写入 yaml_data 转化成的 YAML 配置信息，YAML 信息将被前后各一行 <code>---</code> 所包裹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_yaml</span>(<span class="params">file_path, yaml_data</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    yaml_text = yaml.dump(yaml_data, allow_unicode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    wrapper = <span class="string">&#x27;---\n&#x27;</span></span><br><span class="line">    yaml_wrapped = wrapper + yaml_text + wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_content = f.read()</span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line">        f.write(yaml_wrapped)</span><br><span class="line">        f.write(file_content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，我们刚才的 <code>write_yaml</code> 写入并没有删除原有的 YAML 信息，所以如果以前有的话就重复了。咱们刚才写的 <code>read_yaml</code> 返回了文件中是否有 YAML、YAML 配置的始末位置对吧，依靠这两个，我们就可以把原来存在的 YAML 删除了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_lines</span>(<span class="params">file_path, lines_range</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># 从 file_path 文件中删除 lines_range 指定的行(闭区间[start, end]，从0开始计数)</span></span><br><span class="line">    file_dir = os.path.dirname(file_path)</span><br><span class="line">    file_name = os.path.basename(file_path)</span><br><span class="line"></span><br><span class="line">    temp_file = os.path.join(file_dir, <span class="string">f&#x27;.<span class="subst">&#123;file_name&#125;</span>.tmp&#x27;</span>)</span><br><span class="line">    shutil.copy(file_path, temp_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(temp_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f_in:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">            f_out.writelines(line <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">                f_in) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(lines_range[<span class="number">0</span>], lines_range[<span class="number">1</span>]+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    os.remove(temp_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调用的地方，删除原有 YAML 配置：</span></span><br><span class="line">data, yaml_line, has_yaml = read_yaml(article)</span><br><span class="line"><span class="keyword">if</span> has_yaml:</span><br><span class="line">remove_lines(article, yaml_line)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Ok，YAML 的读写就做好了。接下来写生成 title、date 的函数，并和文件中读取的合并。 title 取文件名 <code>a.md</code> 中的 <code>a</code>，date 取文件创建时间（在 Mac 中，可以用 stat 的 birthtime 获取）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_creation_time</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> platform.platform().find(<span class="string">&#x27;Darwin&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> os.stat(file_path).st_birthtime</span><br><span class="line">    <span class="comment"># ctime: Linux 是 inode 的 change time；据说 Windows 是 creation time</span></span><br><span class="line">    <span class="keyword">return</span> os.path.getctime(file_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_base_conf</span>(<span class="params">file_path</span>) -&gt; dict:</span></span><br><span class="line">    title = os.path.basename(file_path)</span><br><span class="line">    title_list = title.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title_list) &gt; <span class="number">1</span>:</span><br><span class="line">        title = <span class="string">&#x27;&#x27;</span>.join(title_list[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    creation_time = get_creation_time(file_path)</span><br><span class="line">    date = datetime.datetime.fromtimestamp(creation_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;title&#x27;</span>: title, <span class="string">&#x27;date&#x27;</span>: date&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调用的地方，合并配置信息：</span></span><br><span class="line">conf = generate_base_conf(article)</span><br><span class="line">data, yaml_line, has_yaml = read_yaml(article)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">dict</span>):</span><br><span class="line">    conf.update(data)</span><br></pre></td></tr></table></figure><p>最后，我们写一个寻找所有博客文章文件的函数，然后遍历文章，完成处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md_files_gen</span>(<span class="params"><span class="built_in">dir</span>, file_filter=<span class="keyword">lambda</span> fp: <span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="comment"># 返回一个 generator，生成 dir 目录下所有使 file_filter 返回 True 的 .md 文件的路径</span></span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> filename.lower().endswith(<span class="string">&#x27;.md&#x27;</span>):</span><br><span class="line">                file_path = os.path.join(dirpath, filename)</span><br><span class="line">                <span class="keyword">if</span> file_filter(file_path):</span><br><span class="line">                    <span class="keyword">yield</span> file_path</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complete_yaml4blogs</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    blogs = md_files_gen(<span class="built_in">dir</span>)</span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> blogs:</span><br><span class="line">        print(article)</span><br><span class="line">        conf = generate_base_conf(article)</span><br><span class="line">        data, yaml_line, has_yaml = read_yaml(article)</span><br><span class="line">        <span class="keyword">if</span> has_yaml:</span><br><span class="line">            remove_lines(article, yaml_line)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">dict</span>):</span><br><span class="line">            conf.update(data)</span><br><span class="line">        write_yaml(article, conf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后调用 complete_yaml4blogs 就可以完成工作了：</span></span><br><span class="line">complete_yaml4blogs(<span class="string">&#x27;/Users/foo/hexo-blog/source&#x27;</span>)</span><br></pre></td></tr></table></figure><p>P.S. <code>md_files_gen</code> 的 <code>file_filter</code> 是为了方便日后拓展使用而做的，比如我们可以利用这个东西过滤，只处理最近一个月内的新文件。</p><p>完整的代码我放去一个 Gist 了：<a href="https://gist.github.com/cdfmlr/d5a40f670ab71512511a63bf94d8d424">cdfmlr/complete_yaml4blogs.py</a>。</p><script src="https://gist.github.com/cdfmlr/d5a40f670ab71512511a63bf94d8d424.js"></script><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>啧，这篇文章写的，，结构好像有点问题。本来是介绍用 GitHub Actions 的，却花了大量的篇幅介绍我怎么处理偷懒造成的 bug 😂。不管了，解决这个问题还是很有趣的，练习一下 Python 文件操作，还顺便学了个 PyYAML 库，也不亏吧。</p><hr><p>本文由 CDFMLR 原创，收录于个人博客 <a href="https://clownote.github.io./">https://clownote.github.io。</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之机器学习基础</title>
      <link href="/2020/07/10/DeepLearningWithPython/Deep-Learning%20with-Python-ch4/"/>
      <url>/2020/07/10/DeepLearningWithPython/Deep-Learning%20with-Python-ch4/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，当我完成所以文章后，会在 GitHub 发布我写的所有  Jupyter notebooks。</p><p>你可以在这个网址在线阅读这本书的正版原文(英文)：<a href="https://livebook.manning.com/book/deep-learning-with-python">https://livebook.manning.com/book/deep-learning-with-python</a></p><p>这本书的作者也给出了一套 Jupyter notebooks：<a href="https://github.com/fchollet/deep-learning-with-python-notebooks">https://github.com/fchollet/deep-learning-with-python-notebooks</a></p><hr><p>本文为 <strong>第4章 机器学习基础</strong> (Chapter 4. Fundamentals of machine learning) 的笔记整合。</p><p>本文目录：</p><p>[TOC]</p><h2 id="机器学习的四个分支"><a href="#机器学习的四个分支" class="headerlink" title="机器学习的四个分支"></a>机器学习的四个分支</h2><blockquote><p>4.1 Four branches of machine learning</p></blockquote><ol><li>监督学习</li><li>无监督学习</li><li>自监督学习</li><li>强化学习</li></ol><h2 id="机器学习模型评估"><a href="#机器学习模型评估" class="headerlink" title="机器学习模型评估"></a>机器学习模型评估</h2><blockquote><p>4.2 Evaluating machine-learning models</p></blockquote><h3 id="训练集、验证集和测试集"><a href="#训练集、验证集和测试集" class="headerlink" title="训练集、验证集和测试集"></a>训练集、验证集和测试集</h3><ul><li>训练集：用来学习参数（网络里各节点的权重）；</li><li>验证集：用来学习超参数（网络的权重，比如层数、层的大小这种）；</li><li>测试集：用来验证结果，要保证模型从未见过这些数据。</li></ul><p>测试集必须是单独分出来的，训练集、测试集中不能和测试集有重合。</p><p>最好的做法是，先把所有数据分成训练集和测试集。然后从训练集里分一部分出来做验证集。</p><p>以下是几种选择验证集的方法：</p><h4 id="简单留出验证"><a href="#简单留出验证" class="headerlink" title="简单留出验证"></a>简单留出验证</h4><blockquote><p>SIMPLE HOLD-OUT VALIDATION</p></blockquote><p>就是简单的从训练集里留出一部分来做验证集。</p><p>可用的数据多的时候才能用这个。不然数据少了，分出来的验证集就太小，不够一般，效果不好。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggkhlemz7cj31io0k0n02.jpg" alt="简单留出验证的示意图"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hold-out validation</span></span><br><span class="line"></span><br><span class="line">num_validation_samples = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">np.random.shuffle(data)    <span class="comment"># 洗牌，打乱数据</span></span><br><span class="line"></span><br><span class="line">validation_data = data[:num_validation_samples]    <span class="comment">#定义验证集</span></span><br><span class="line">data = data[num_validation_samples:]</span><br><span class="line"></span><br><span class="line">training_data = data[:]    <span class="comment"># 定义训练集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练集训练模型，在验证集评估</span></span><br><span class="line">model = get_model()</span><br><span class="line">model.train(training_data)</span><br><span class="line">validation_score = model.evaluate(validation_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后这里可以根据结果调整模型，</span></span><br><span class="line"><span class="comment">## 然后重新训练、评估，然后再次调整...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调整好超参数之后，用除了测试集的所有数据来训练最终模型</span></span><br><span class="line">model = get_model()</span><br><span class="line">model.train(np.concatenate([training_data, validation_data]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用测试集来评估最终模型</span></span><br><span class="line">test_score = model.evaluate(test_data)</span><br></pre></td></tr></table></figure><h4 id="K折验证"><a href="#K折验证" class="headerlink" title="K折验证"></a>K折验证</h4><blockquote><p>K-FOLD VALIDATION</p></blockquote><p>这个方法是把数据等分成 K 份。对每个部分 i，在剩下的 K-1 个部分里训练，在 i 上验证评估。最终验证的结果取 K 次的验证值的平均。</p><p>这种方法对不同的训练、验证集划分对结果影响比较大时会很有效（比如数据比较少的时候）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggki8sc8x0j31os0u0q90.jpg" alt="K折验证示意图"></p><p>emmm，我觉得这个图有点问题，应该除了那些灰色的是 Validation，白的应该都是 Training。（中文译本上就是这种）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># K-fold cross-validation</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">num_validation_samples = <span class="built_in">len</span>(data) // k</span><br><span class="line"></span><br><span class="line">np.random.shuffle(data)</span><br><span class="line"></span><br><span class="line">validation_scores = []</span><br><span class="line"><span class="keyword">for</span> fold <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    <span class="comment"># 选择验证集</span></span><br><span class="line">    validation_data = data[num_validation_samples * fold:</span><br><span class="line">                           num_validation_samples * (fold + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 用剩下的做训练集</span></span><br><span class="line">    training_data = data[:num_validation_samples * fold] + </span><br><span class="line">                    data[num_validation_samples * (fold + <span class="number">1</span>):]</span><br><span class="line">    </span><br><span class="line">    model = get_model()    <span class="comment"># 注意是用个全新的模型</span></span><br><span class="line">    </span><br><span class="line">    model.train(training_data)</span><br><span class="line">    </span><br><span class="line">    validation_score = model.evaluate(validation_data)</span><br><span class="line">    validation_scores.append(validation_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总的验证值是所有的平均</span></span><br><span class="line">validation_score = np.average(validation_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后根据结果做各种超参数调整啦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后在除了测试集的所有数据上训练</span></span><br><span class="line">model = get_model()</span><br><span class="line">model.train(data)</span><br><span class="line">test_score = model.evaluate(test_data)</span><br></pre></td></tr></table></figure><h4 id="带有打乱数据的重复K折验证"><a href="#带有打乱数据的重复K折验证" class="headerlink" title="带有打乱数据的重复K折验证"></a>带有打乱数据的重复K折验证</h4><blockquote><p>ITERATED K-FOLD VALIDATION WITH SHUFFLING</p></blockquote><p>就是重复跑 P 次 K折验证，每次开始前洗牌。</p><p>这个是数据比较少，又要求尽可能精确的时候用的。要跑 P*K 次，所以比较耗时。</p><p>书上没给这个的代码，就是在 K折 的基础上再加一层循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ITERATED K-FOLD VALIDATION WITH SHUFFLING</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">num_validation_samples = <span class="built_in">len</span>(data) // k</span><br><span class="line"></span><br><span class="line">total_validation_scores = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    </span><br><span class="line">    validation_scores = []</span><br><span class="line">    <span class="keyword">for</span> fold <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> K折验证的那堆代码</span></span><br><span class="line">    </span><br><span class="line">    validation_score = np.average(validation_scores)</span><br><span class="line">    total_validation_scores.append(validation_score)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 总的验证值是所有的平均</span></span><br><span class="line">validation_score = np.average(total_validation_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后根据结果做各种超参数调整啦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后在除了测试集的所有数据上训练</span></span><br><span class="line">model = get_model()</span><br><span class="line">model.train(data)</span><br><span class="line">test_score = model.evaluate(test_data)</span><br></pre></td></tr></table></figure><h3 id="划分时的注意事项"><a href="#划分时的注意事项" class="headerlink" title="划分时的注意事项"></a>划分时的注意事项</h3><ul><li><strong>数据代表性</strong>：训练集和测试集都要可以代表所有数据。比如做数字识别，不能训练集里只有 0～7，测试集里全是 8～9。做这种之前要把所有数据随机洗牌打乱，然后再分训练集和测试集。</li><li><strong>时间箭头</strong>：如果是那种做跟时间有关的预测（给过去的，预测未来的），开始之前<strong>不要打乱数据</strong>，要保持数据的时间顺序（打乱了会时间泄露，就是模型从“未来”学习了），并且测试集的数据要晚于训练集。</li><li><strong>数据冗余</strong>：如果数据有重复，随机打乱之后，同样的数据就可能同时出现在训练、验证、测试集里了。这种情况会影响结果，训练和验证集不能有交集。</li></ul><h2 id="数据预处理、特征工程和特征学习"><a href="#数据预处理、特征工程和特征学习" class="headerlink" title="数据预处理、特征工程和特征学习"></a>数据预处理、特征工程和特征学习</h2><blockquote><p>4.3 Data preprocessing, feature engineering, and feature learning</p></blockquote><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ol><li><p>VECTORIZATION 向量化：喂给神经网络的数据都要是浮点数的张量（有时候也可以是整数的），我们要把各种真实的数据，比如文本、图像全变成张量。</p></li><li><p>VALUE NORMALIZATION 值标准化：为了利于训练和结果，我们要让数据符合以下标准：</p><ul><li>取值小，一般就 0~1；</li><li>同质性，即所有特征的取值范围大致相等；</li></ul></li></ol><p>如果严格一点（但不是必须的），我们可以把数据里的特征分别处理成平均值为 0，标准差为 1 的。用 Numpy 搞这个很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 是二维的：(samples, features)</span></span><br><span class="line">x -= x.mean(axis=<span class="number">0</span>)</span><br><span class="line">x /= x.std(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>HANDLING MISSING VALUES 缺失值处理：一般来说，只要 0 不是有意义的值，就可以用 0 来代替缺失值。网络可以学会 0 是缺失的这种意思的。还有如果你的测试集是有缺失情况的，但训练集没有，就要手动加些人工数据去让网络学会缺失情况。</li></ol><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>特征工程(feature engineering)，就是在开始训练之前，手动对数据进行处理，得到一种易于机器学习模型从中学习的数据表示。</p><p>我们的机器学习模型一般不能从任意的真实数据里面高效地自动学习，所以我们需要特征工程。特征工程的本质就是用更简单的方式表达问题，从而使问题变得更容易解决。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggkzvwdlyaj30vc0u0jwu.jpg" alt="特征工程示意图"></p><p>特征工程在深度学习之前都至关重要，浅层的学习一般都没有足够的假设空间去自己学习出关键的特征。但现在我们用深度学习可以免去大多数的特征工程了，深度学习可以自己从数据里学出有用的特征来，但是利用特征工程，我们的深度学习过程可以更加优雅、高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clown0te(<span class="string">&quot;防盗文爬:)虫的追踪标签，读者不必在意&quot;</span>).by(CDFMLR)</span><br></pre></td></tr></table></figure><h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><blockquote><p>4.4 Overfitting and underfitting</p></blockquote><p>机器学习里面有一组问题：<strong>优化</strong>（optimization）和<strong>泛化</strong>（generalization）。</p><p>优化不足就是欠拟合，泛化无力即为过拟合。</p><p>欠拟合就要接着训练，深度学习网络总是可以优化到一定精度的，关键的问题是泛化。处理过拟合用正则化（regularization），以下是几种正则化的手段：</p><h3 id="增加训练数据"><a href="#增加训练数据" class="headerlink" title="增加训练数据"></a>增加训练数据</h3><p>增加训练集的数据，emmmmm，找更多的数据给它看呀，见多识广啊，这就泛化了。</p><h3 id="减小网络大小"><a href="#减小网络大小" class="headerlink" title="减小网络大小"></a>减小网络大小</h3><p>减小层数和层的单元数，即减小总的参数个数（叫做模型的容量，capacity），这样就可以缓解过拟合。</p><p>参数越多，记忆容量越大，就是会死记硬背啦，不利于泛化，题目稍变它心态就崩了。但如果参数太少，记忆容量小，它又学不会、记不住知识，会欠拟合（这知识它不进脑子呀）。</p><p>我们要在容量过大和过小之间找个平衡，但这个没有万能公式可以套。要自己多做些尝试，用验证集去评估不同的选择，最终选出最好的来。确定这个的一般方法是：从一个相对较小的值开始，逐步增加，直到对结果基本没有影响了。</p><h3 id="添加权重正则化"><a href="#添加权重正则化" class="headerlink" title="添加权重正则化"></a>添加权重正则化</h3><p>和奥卡姆剃刀原理一致，一个简单模型比一个复杂模型更不容易过拟合。这里说的简单模型是指一个参数取值的分布熵更小的模型。</p><p>因此，我们可以强制模型权重取较小的值，从而限制模型的复杂度，来降低过拟合。这种使权重值的分布更加规则(regular)的方法叫作权重正则化<br>(weight regularization)。具体的实现方法是在损失函数中添加与较大权重值相关的成本。</p><p>添加这个成本的方法主要有两种：</p><ul><li>L1 regularization：添加与权重系数的绝对值成正比的值（权重的 L1 范数，the L1 norm of the weights）；</li><li>L2 regularization：添加与权重系数的平方值成正比的值（权重的 L2 范数，the L2 norm of the weights），在神经网络中，L2 正则化也叫权重衰减(weight decay)。</li></ul><p>在 Keras 里，添加权重正则化可以通过在层里传一个权重正则化实例来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> regularizers</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, kernel_regularizer=regularizers.l2(<span class="number">0.001</span>), </span><br><span class="line">                       activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, kernel_regularizer=regularizers.l2(<span class="number">0.001</span>),</span><br><span class="line">                       activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>regularizers.l2(0.001)</code> 的意思是在损失函数中添加一项惩罚 <code>0.001 * weight_coefficient_value</code>。这个东西只在训练的时候被添加，在用测试集评估的时候不会生效，所以你看到的训练时的损失值要远大于测试时的。</p><p>这里也可以把 L2 换成用 L1：<code>regularizers.l1(0.001)</code>，或者 L1、L2 同时上：<code>regularizers.l1_l2(l1=0.001, l2=0.001)</code>。</p><h3 id="添加-dropout"><a href="#添加-dropout" class="headerlink" title="添加 dropout"></a>添加 dropout</h3><p>对于神经网络的正则化，Dropout 其实才是是最常用、有效的方法。</p><p>对某一层使用 dropout，就是在训练过程中随机舍弃一些层输出的特征(就是把值设为 0)。</p><p>比如：<code>[0.2, 0.5, 1.3, 0.8, 1.1]</code> -&gt; <code>[0, 0.5, 1.3, 0, 1.1]</code>，变成 0 的位置是随机的哦。</p><p>这里有一个 dropout rate，表示把多少比例的特征置为0，这个比例通常取 0.2~0.5。还有，在测试的时候不 dropout 啊，但测试时的输出要按照 dropout rate 来缩小，以平衡测试和训练时的结果。</p><p>也就是说，比如我们搞一个 dropout rate 为 0.5 的，即在训练的时候扔一半：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># training case</span></span><br><span class="line">layer_output *= np.random.randint(<span class="number">0</span>, high=<span class="number">2</span>, size=layer_output.shape)</span><br></pre></td></tr></table></figure><p>然后测试的时候，相应的缩小50%：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testing case</span></span><br><span class="line">layer_output *= <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>但通常，我们不是在测试的时候缩小；而是在训练的时候扩大，然后测试的时候就不用动了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># training case</span></span><br><span class="line">layer_output *= np.random.randint(<span class="number">0</span>, high=<span class="number">2</span>, size=layer_output.shape)</span><br><span class="line">layer_output /= <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggl4f43cguj31iy0dc77b.jpg" alt="训练时对激活矩阵使用 dropout，并在训练时成比例增大。测试时激活矩阵保持不变"></p><p>在 Keras 里，我们可以通过添加 Dropout 层来实现这个东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><p>例如，我们在我们 IMDB 的网络里面加上 Dropout：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="机器学习的通用工作流程"><a href="#机器学习的通用工作流程" class="headerlink" title="机器学习的通用工作流程"></a>机器学习的通用工作流程</h2><blockquote><p>4.5 The universal workflow of machine learning</p></blockquote><ol><li><p>定义问题，收集数据集：定义问题与要训练的数据。收集这些数据，有需要的话用标签来标注数据。</p></li><li><p>选择衡量成功的指标：选择衡量问题成功的指标。你要在验证数据上监控哪些指标?</p></li><li><p>确定评估方法：留出验证? K 折验证?你应该将哪一部分数据用于验证?</p></li><li><p>准备数据：预处理啦，特征工程啦。。</p></li><li><p>开发比基准(比如随机预测)更好的模型，即一个具有统计功效的模型。</p></li></ol><p>最后一层和损失的选择：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglyp8zx9jj31jc0iiq75.jpg" alt="最后一层和损失的选择"></p><ol start="7"><li><p>扩大规模，开发出过拟合的模型：加层、加单元、加轮次</p></li><li><p>调节超参数，模型正则化：基于模型在验证数据上的性能来进行模型正则化与调节超参数。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之神经网络入门</title>
      <link href="/2020/07/08/DeepLearningWithPython/Deep-Learning%20with-Python-ch3/"/>
      <url>/2020/07/08/DeepLearningWithPython/Deep-Learning%20with-Python-ch3/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，当我完成所以文章后，会在 GitHub 发布我写的所有  Jupyter notebooks。</p><p>你可以在这个网址在线阅读这本书的正版原文(英文)：<a href="https://livebook.manning.com/book/deep-learning-with-python">https://livebook.manning.com/book/deep-learning-with-python</a></p><p>这本书的作者也给出了一套 Jupyter notebooks：<a href="https://github.com/fchollet/deep-learning-with-python-notebooks">https://github.com/fchollet/deep-learning-with-python-notebooks</a></p><hr><p>本文为 <strong>第3章 神经网络入门</strong> (Chapter 3. Getting started with neural networks) 的笔记整合。</p><p>本文目录：</p><p>[TOC]</p><h2 id="电影评论分类-二分类问题"><a href="#电影评论分类-二分类问题" class="headerlink" title="电影评论分类:二分类问题"></a>电影评论分类:二分类问题</h2><p><a href="https://livebook.manning.com/book/deep-learning-with-python/chapter-3/101">原文链接</a></p><h3 id="IMDB-数据集"><a href="#IMDB-数据集" class="headerlink" title="IMDB 数据集"></a>IMDB 数据集</h3><p>IMDB 数据集里是 50,000 条电影评论。一半是训练集，一半是测试集。<br>数据里 50% 是积极评价，50% 是消极评价。</p><p>Keras 内置了做过预处理的 IMDB 数据集，把单词序列转化成了整数序列（一个数字对应字典里的词）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集</span></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = imdb.load_data(</span><br><span class="line">    num_words=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure><p><code>num_words=10000</code> 是只保留出现频率前 10000 的单词。</p><p>先来随便看一条评论，这是条好评：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">index_word = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> imdb.get_word_index().items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原一条评论看看</span></span><br><span class="line">text = <span class="string">&#x27; &#x27;</span>.join([index_word[i] <span class="keyword">for</span> i <span class="keyword">in</span> train_data[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;<span class="subst">&#123;train_labels[<span class="number">0</span>]&#125;</span>:&quot;</span>, text)</span><br></pre></td></tr></table></figure><pre><code>1: the as you with out themselves powerful lets loves their becomes reaching had journalist of lot from anyone to have after out atmosphere never more room and it so heart shows to years of every never going and help moments or of every chest visual movie except her was several of enough more with is now current film as you of mine potentially unfortunately of you than him that with out themselves her get for was camp of you movie sometimes movie that with scary but and to story wonderful that in seeing in character to of 70s musicians with heart had shadows they of here that with her serious to have does when from why what have critics they is you that isn&#39;t one will very to as itself with other and in of seen over landed for anyone of and br show&#39;s to whether from than out themselves history he name half some br of and odd was two most of mean for 1 any an boat she he should is thought frog but of script you not while history he heart to real at barrel but when from one bit then have two of script their with her nobody most that with wasn&#39;t to with armed acting watch an for with heartfelt film want an</code></pre><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>先看一下 train_data 现在的形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data.shape</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(25000,)</code></pre><p>我们要把它变成 <code>(samples, word_indices)</code> 的样子，大概是下面这种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[0, 0, ..., 1, ..., 0, ..., 1],</span><br><span class="line"> [0, 1, ..., 0, ..., 1, ..., 0],</span><br><span class="line"> ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>有这个词就是 1，没有就是 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_sequences</span>(<span class="params">sequences, dimension=<span class="number">10000</span></span>):</span></span><br><span class="line">    results = np.zeros((<span class="built_in">len</span>(sequences), dimension))</span><br><span class="line">    <span class="keyword">for</span> i, sequence <span class="keyword">in</span> <span class="built_in">enumerate</span>(sequences):</span><br><span class="line">        results[i, sequence] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">x_train = vectorize_sequences(train_data)</span><br><span class="line">x_test = vectorize_sequences(test_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_train</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([[0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.],       ...,       [0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.]])</code></pre><p>labels 也随便搞一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_labels</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([1, 0, 0, ..., 0, 1, 0])</code></pre><p>处理一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_train = np.asarray(train_labels).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">y_test = np.asarray(test_labels).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_train</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([1., 0., 0., ..., 0., 1., 0.], dtype=float32)</code></pre><p>现在这些数据就可以安全投喂我们一会儿建的神经网络了。</p><h3 id="建立网络"><a href="#建立网络" class="headerlink" title="建立网络"></a>建立网络</h3><p>对于这种输入是向量、标签是标量（甚至是 0 或 1）的问题：<br>使用 relu 激活的 Dense (全连接)堆起来的网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这种层的作用是 <code>output = relu(dot(W, input) + b)</code>。</p><p>16 是每层里隐藏单元(hidden unit)的个数。一个 hidden unit 就是在这层的表示空间里的一个维度。<br>W 的形状也是 <code>(input_dimension, 16)</code>，dot 出来就是个 16 维的向量，也就把数据投影到了 16 维的表示空间。</p><p>这个维度 (hidden unit 的数量) 可以看成对网络学习的自由度的控制。<br>维度越高，能学的东西越复杂，但计算消耗也越大，而且可能学到一些不重要的东西导致过拟合。</p><p>这里，我们将使用两层这种16个隐藏单元的层，<br>最后还有一个 sigmoid 激活的层来输出结果（在$[0, 1]$内的值），<br>这个结果表示预测有多可能这个数据的标签是1，即一条好评。</p><p>relu 是过滤掉负值（把输入的负值输出成0），sigmoid 是把值投到 <code>[0, 1]</code>：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8cohvw31j31hi0lu49o.jpg" alt="relu and sigmoid"></p><p>在 Keras 中实现这个网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h4><p>我们之前在 MNIST 里用过 relu 激活函数，所以<em>激活函数</em>到底是干嘛的？</p><p>一个没有激活函数的 Dense 层的作用只是一个线性变换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output &#x3D; dot(W, input) + b</span><br></pre></td></tr></table></figure><p>如果每一层都是这种线性变换，把多个这种层叠在一起，假设空间并不会变大，所以能学到的东西很有限。</p><p>而激活函数就是在 <code>dot(W, input) + b</code> 外面套的一个函数，比如 relu 激活是 <code>output = relu(dot(W, input) + b)</code>。<br>利用这种激活函数，可以拓展表示空间，也就可以让网络学习到更复杂的“知识”。</p><h3 id="编译模型"><a href="#编译模型" class="headerlink" title="编译模型"></a>编译模型</h3><p>编译模型时，我们还需要选择损失函数、优化器和指标。</p><p>对这种最后输出 0 或 1 的二元分类问题，损失函数可以使用 <code>binary_crossentropy</code>(从名字就可以看得出来很合适啦)。</p><p>这个 <em>crossentropy</em> 中文叫交叉熵，是信息论里的，是用来衡量概率分布直接的距离的。<br>所以输出概率的模型经常是用这种 crossentropy 做损失的。</p><p>至于优化器，和 MNIST 一样，我们用 <code>rmsprop</code> （书里还没写为什么），指标也还是准确度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><p>因为这几个optimizer、loss、metrics 都是常用的，所以 Keras 内置了，可以直接传字符串。<br>但也可以传类实例来定制一些参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> losses</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=optimizers.RMSprop(lr=<span class="number">0.001</span>),</span><br><span class="line">              loss=losses.binary_crossentropy,</span><br><span class="line">              metrics=[metrics.binary_accuracy])</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>为了在训练的过程中验证模型在它没见过的数据上精度如何，我们从原来的训练数据里分 10,000 个样本出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x_val = x_train[:<span class="number">10000</span>]</span><br><span class="line">partial_x_train = x_train[<span class="number">10000</span>:]</span><br><span class="line"></span><br><span class="line">y_val = y_train[:<span class="number">10000</span>]</span><br><span class="line">partial_y_train = y_train[<span class="number">10000</span>:]</span><br></pre></td></tr></table></figure><p>用一批 512 个样本的 mini-batches，跑 20 轮（所有x_train里的数据跑一遍算一轮），<br>并用刚分出来的 10,000 的样本做精度验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure><pre><code>Train on 15000 samples, validate on 10000 samplesEpoch 1/2015000/15000 [==============================] - 3s 205us/sample - loss: 0.5340 - acc: 0.7867 - val_loss: 0.4386 - val_acc: 0.8340.......Epoch 20/2015000/15000 [==============================] - 1s 74us/sample - loss: 0.0053 - acc: 0.9995 - val_loss: 0.7030 - val_acc: 0.8675</code></pre><p><code>fit</code> 阔以返回 history，里面保存了训练过程里每个 Epoch 的黑历史：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history_dict = history.history</span><br><span class="line">history_dict.keys()</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>dict_keys([&#39;loss&#39;, &#39;acc&#39;, &#39;val_loss&#39;, &#39;val_acc&#39;])</code></pre><p>我们可以把这些东西画图出来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画训练和验证的损失</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">history_dict = history.history</span><br><span class="line">loss_values = history_dict[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss_values = history_dict[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_values) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss_values, <span class="string">&#x27;ro-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss_values, <span class="string">&#x27;bs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjeapcizwj30at07qjri.jpg" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画训练和验证的准确度</span></span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line"></span><br><span class="line">acc = history_dict[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">val_acc = history_dict[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;ro-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;bs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjeasgbdsj30az07q3ym.jpg" alt="png"></p><p>我们可以看到，训练集上的精度倒是一直在增（损失一直减），<br>但在验证集上，到了后面损失反而大了，差不多第4轮左右就到最好的峰值了。</p><p>这就是过拟合了，其实从第二轮开始就开始过了。所以，我们其实跑个3、4轮就 ok 了。<br>要是再跑下去，咱的模型就只“精通”训练集，不认识其他没见过的数据了。</p><p>所以，我们重新训练一个模型（要从建立网络开始重写，不然fit是接着刚才已经进行过的这些），那去用测试集测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">             loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">             metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">result = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br></pre></td></tr></table></figure><pre><code>Train on 25000 samplesEpoch 1/425000/25000 [==============================] - 2s 69us/sample - loss: 0.4829 - accuracy: 0.8179Epoch 2/425000/25000 [==============================] - 1s 42us/sample - loss: 0.2827 - accuracy: 0.9054Epoch 3/425000/25000 [==============================] - 1s 42us/sample - loss: 0.2109 - accuracy: 0.9253Epoch 4/425000/25000 [==============================] - 1s 43us/sample - loss: 0.1750 - accuracy: 0.938025000/1 - 3s - loss: 0.2819 - accuracy: 0.8836</code></pre><p>把结果输出出来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>[0.2923990402317047, 0.8836]</code></pre><p>训练完成后，我们当然想实际试一下，对吧。所以我们预测一下测试集，把结果打出来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.predict(x_test)</span><br></pre></td></tr></table></figure><p>Output:</p><pre><code>array([[0.17157233],       [0.99989915],       [0.79564804],       ...,       [0.11750051],       [0.05890778],       [0.5040823 ]], dtype=float32)</code></pre><h3 id="进一步实验"><a href="#进一步实验" class="headerlink" title="进一步实验"></a>进一步实验</h3><ol><li>尝试只用一个层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line"><span class="comment"># model.add(layers.Dense(16, activation=&#x27;relu&#x27;, input_shape=(10000, )))</span></span><br><span class="line"><span class="comment"># model.add(layers.Dense(16, activation=&#x27;relu&#x27;))</span></span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">             loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">             metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">result = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>Train on 25000 samplesEpoch 1/425000/25000 [==============================] - 3s 116us/sample - loss: 0.5865 - accuracy: 0.7814Epoch 2/425000/25000 [==============================] - 1s 31us/sample - loss: 0.4669 - accuracy: 0.8608Epoch 3/425000/25000 [==============================] - 1s 32us/sample - loss: 0.3991 - accuracy: 0.8790Epoch 4/425000/25000 [==============================] - 1s 33us/sample - loss: 0.3538 - accuracy: 0.892025000/1 - 3s - loss: 0.3794 - accuracy: 0.8732[0.3726908649635315, 0.8732]</code></pre><p>…这问题比较简单，一个层效果都这么好，但比之前正经的差远了</p><ol start="2"><li>多搞几个层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">             loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">             metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">result = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>Train on 25000 samplesEpoch 1/425000/25000 [==============================] - 3s 123us/sample - loss: 0.5285 - accuracy: 0.7614Epoch 2/425000/25000 [==============================] - 1s 45us/sample - loss: 0.2683 - accuracy: 0.9072s - loss:Epoch 3/425000/25000 [==============================] - 1s 45us/sample - loss: 0.1949 - accuracy: 0.9297Epoch 4/425000/25000 [==============================] - 1s 47us/sample - loss: 0.1625 - accuracy: 0.942225000/1 - 2s - loss: 0.3130 - accuracy: 0.8806[0.30894253887176515, 0.88056]</code></pre><p>好一点，但也还不如正经的版本</p><ol start="3"><li>多几个隐藏层的单元</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">1024</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">             loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">             metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">result = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>Train on 25000 samplesEpoch 1/425000/25000 [==============================] - 15s 593us/sample - loss: 0.5297 - accuracy: 0.7964Epoch 2/425000/25000 [==============================] - 12s 490us/sample - loss: 0.2233 - accuracy: 0.9109Epoch 3/425000/25000 [==============================] - 12s 489us/sample - loss: 0.1148 - accuracy: 0.9593Epoch 4/425000/25000 [==============================] - 12s 494us/sample - loss: 0.0578 - accuracy: 0.983525000/1 - 9s - loss: 0.3693 - accuracy: 0.8812[0.4772889766550064, 0.8812]</code></pre><p>不是远多越好呀。</p><ol start="4"><li>用 mse 损失</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">             loss=<span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">             metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">result = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>Train on 25000 samplesEpoch 1/425000/25000 [==============================] - 3s 119us/sample - loss: 0.1472 - accuracy: 0.8188Epoch 2/425000/25000 [==============================] - 1s 46us/sample - loss: 0.0755 - accuracy: 0.9121Epoch 3/425000/25000 [==============================] - 1s 50us/sample - loss: 0.0577 - accuracy: 0.9319Epoch 4/425000/25000 [==============================] - 1s 47us/sample - loss: 0.0474 - accuracy: 0.944225000/1 - 3s - loss: 0.0914 - accuracy: 0.8828[0.08648386991858482, 0.88276]</code></pre><ol start="5"><li>用 tanh 激活</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(<span class="number">10000</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;tanh&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">             loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">             metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">4</span>, batch_size=<span class="number">512</span>)</span><br><span class="line">result = model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>Train on 25000 samplesEpoch 1/425000/25000 [==============================] - 4s 149us/sample - loss: 0.4237 - accuracy: 0.8241Epoch 2/425000/25000 [==============================] - 1s 46us/sample - loss: 0.2310 - accuracy: 0.9163Epoch 3/425000/25000 [==============================] - 1s 46us/sample - loss: 0.1779 - accuracy: 0.9329Epoch 4/425000/25000 [==============================] - 1s 49us/sample - loss: 0.1499 - accuracy: 0.945825000/1 - 3s - loss: 0.3738 - accuracy: 0.8772[0.3238203083658218, 0.87716]</code></pre><p>所以，这些实验就是说，之前我们书上用的模型是合理的，你改来改去都不如他那个😂。</p><h2 id="新闻分类-多分类问题"><a href="#新闻分类-多分类问题" class="headerlink" title="新闻分类: 多分类问题"></a>新闻分类: 多分类问题</h2><p><a href="https://livebook.manning.com/book/deep-learning-with-python/chapter-3/192">原文链接</a></p><p>刚才我们电影评论问题不是把向量输入分成两类嘛，这节我们要把东西分成多类，即做“多分类（multi-class classification）”。</p><p>我们要把来自路透社的新闻分到 46 个话题种类里，这里要求一条新闻只能属于一个类，所以具体来说，我们要做的是一个“单标签多分类（single-label, multiclass classification）”问题。</p><h3 id="路透社数据集"><a href="#路透社数据集" class="headerlink" title="路透社数据集"></a>路透社数据集</h3><p>the Reuters dataset，路透社在 1986 年（比我老多了😂）发布的数据集，里面有 46 类新闻，训练集里每类至少 10 条数据。</p><p>这个玩具数据集和 IMDB、MNIST 一样，也在  Keras 里内置了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> reuters</span><br><span class="line"></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = reuters.load_data(</span><br><span class="line">    num_words=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure><pre><code>Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/reuters.npz2113536/2110848 [==============================] - 6s 3us/step</code></pre><p>这个数据集里面的数据和之前的 IMDB 一样，把单词翻译成了数字，然后我们只截取出现频率最高的10000个词。</p><p>咱们这个训练集里有 8K+ 条数据，测试集 2K+：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">len</span>(train_data), <span class="built_in">len</span>(test_data))</span><br></pre></td></tr></table></figure><pre><code>8982 2246</code></pre><p>咱们还是像搞 IMDB 时那样，把数据还原会文本看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_news</span>(<span class="params">data</span>):</span></span><br><span class="line">    reverse_word_index = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> reuters.get_word_index().items()&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([reverse_word_index.get(i - <span class="number">3</span>, <span class="string">&#x27;?&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> data])</span><br><span class="line">    <span class="comment"># i - 3 是因为 0、1、2 为保留词 “padding”(填充)、“start of sequence”(序列开始)、“unknown”(未知词)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text = decode_news(train_data[<span class="number">0</span>])</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure><pre><code>? ? ? said as a result of its december acquisition of space co it expects earnings per share in 1987 of 1 15 to 1 30 dlrs per share up from 70 cts in 1986 the company said pretax net should rise to nine to 10 mln dlrs from six mln dlrs in 1986 and rental operation revenues to 19 to 22 mln dlrs from 12 5 mln dlrs it said cash flow per share this year should be 2 50 to three dlrs reuter 3</code></pre><p>标签是 0~45 的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_labels[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>Output:</p><pre><code>3</code></pre><h3 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h3><p>首先，还是把数据位向量化，直接套用我们搞 IMDB 时写的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_sequences</span>(<span class="params">sequences, dimension=<span class="number">10000</span></span>):</span></span><br><span class="line">    results = np.zeros((<span class="built_in">len</span>(sequences), dimension))</span><br><span class="line">    <span class="keyword">for</span> i, sequence <span class="keyword">in</span> <span class="built_in">enumerate</span>(sequences):</span><br><span class="line">        results[i, sequence] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_train = vectorize_sequences(train_data)</span><br><span class="line">x_test = vectorize_sequences(test_data)</span><br></pre></td></tr></table></figure><p>然后就是这种效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(x_train)</span><br></pre></td></tr></table></figure><pre><code>array([[0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.],       ...,       [0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.],       [0., 1., 1., ..., 0., 0., 0.]])</code></pre><p>然后要处理标签。我们可以把标签处理成整数张量，也可以用 <code>One-hot</code> 编码<br>对于分类这种问题，我们常用 one-hot 编码（也叫<em>分类编码</em>，categorical encoding）。</p><p>对于我们当前的问题，使用 one-hot 编码，即用除了标签索引位置为 1 其余位置全为 0 的向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_one_hot</span>(<span class="params">labels, dimension=<span class="number">46</span></span>):</span></span><br><span class="line">    results = np.zeros((<span class="built_in">len</span>(labels), dimension))</span><br><span class="line">    <span class="keyword">for</span> i, label <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):</span><br><span class="line">        results[i, label] = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_hot_train_labels = to_one_hot(train_labels)</span><br><span class="line">one_hot_test_labels = to_one_hot(test_labels)</span><br></pre></td></tr></table></figure><p>其实，，，Keras 里自带了一个可以干这个事情的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="comment"># 书上是 from keras.utils.np_utils import to_categorical 但，，，时代变了，而且咱这用的是 tensorflow.keras，所以稍微有点区别</span></span><br><span class="line"></span><br><span class="line">one_hot_train_labels = to_categorical(train_labels)</span><br><span class="line">one_hot_test_labels = to_categorical(test_labels)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(one_hot_train_labels)</span><br></pre></td></tr></table></figure><pre><code>array([[0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       ...,       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.]], dtype=float32)</code></pre><h3 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h3><p>这个问题和之前的电影评论分类问题还是差不多的，只是最后的解的可能从 2 -&gt; 46，解空间大了太多了。</p><p>对于我们用的 Dense 层堆叠，每层都是接收上一层输出的信息作为输入。<br>所以，如果某一层丢失了一些信息，那么这些信息就再也不能被后面的层找回来了。<br>如果丢失的信息对分类没用，那这种丢失是好的、我们期望发生的；<br>但如果这些丢失的信息是对最后分类起作用的，那这种丢失就制约网络的结果了。<br>也就是说，这可能造成一种“信息瓶颈”。这种瓶颈在每一层都可能发生。</p><p>之前的电影评论分类最后只要 2 个结果，所以我们把层里的单元是用了 16 个，<br>即让机器在一个 16 维空间里学习，以及足够大了，不太会有“信息瓶颈“。</p><p>而我们现在的问题，解空间是 46 维的。<br>直接照搬之前的代码，让它在 16 维空间里学习，肯定有瓶颈！</p><p>解决瓶颈的办法很简单，直接增加层里的单元就好。这里我们是 16 -&gt; 64:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure><p>在最后一层，我们的输出是 46 维的，对应 46 种分类，<br>而这一层的激活函数是 softmax，和我们在训练 MNIST 时用的一样。</p><p>用 softmax 可以让网络输出在 46 种分类上的概率分布，即一个 46 维的向量，<br>其中第 i 个元素代表输入属于第 i 种分类的可能性，<br>并且这 46 个元素的总和为 <code>1</code>。</p><h3 id="编译模型-1"><a href="#编译模型-1" class="headerlink" title="编译模型"></a>编译模型</h3><p>编译模型，又要确定损失函数、优化器和优化的目标了。</p><ul><li>损失函数，分类问题嘛，还是用“分类交叉熵” categorical_crossentropy。</li><li>优化器，其实对很多问题我们都是用 rmsprop</li><li>目标还是一个，预测的精度 accuracy</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h3><p>我们还是要搞一个验证集来在训练过程中评估模型的。从训练集里分个 1K 条数据出来就好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x_val = x_train[:<span class="number">1000</span>]</span><br><span class="line">partial_x_train = x_train[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line">y_val = one_hot_train_labels[:<span class="number">1000</span>]</span><br><span class="line">partial_y_train = one_hot_train_labels[<span class="number">1000</span>:]</span><br></pre></td></tr></table></figure><h3 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h3><p>好了，准备工作完成，又可以看到最迷人的训练过程了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">512</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/207982/7982 [==============================] - 3s 372us/sample - loss: 2.6180 - accuracy: 0.5150 - val_loss: 1.7517 - val_accuracy: 0.6290......Epoch 20/207982/7982 [==============================] - 1s 91us/sample - loss: 0.1134 - accuracy: 0.9578 - val_loss: 1.0900 - val_accuracy: 0.8040</code></pre><p>🆗挺快的，照例，还是画图看看训练过程。</p><ol><li>训练过程中的损失</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjed34amjj30at07qdfx.jpg" alt="png"></p><ol start="2"><li>训练过程中的精度</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.clf()</span><br><span class="line"></span><br><span class="line">acc = history.history[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_accuracy&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, acc, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_acc, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjed4tgtzj30at07qglp.jpg" alt="png"></p><p>Emmmm，说，第9轮 epochs 的时候开始过拟合了（你看validation的曲线抖在第9轮了一下）。<br>所以只要跑 9 轮就够了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">9</span>,</span><br><span class="line">          batch_size=<span class="number">512</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/97982/7982 [==============================] - 1s 153us/sample - loss: 2.5943 - accuracy: 0.5515 - val_loss: 1.7017 - val_accuracy: 0.6410......Epoch 9/97982/7982 [==============================] - 1s 84us/sample - loss: 0.2793 - accuracy: 0.9402 - val_loss: 0.8758 - val_accuracy: 0.8170&lt;tensorflow.python.keras.callbacks.History at 0x16eb5d6d0&gt;</code></pre><p>然后，用测试集测试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results = model.evaluate(x_test, one_hot_test_labels, verbose=<span class="number">2</span>)</span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure><pre><code>2246/1 - 0s - loss: 1.7611 - accuracy: 0.7912[0.983459981976082, 0.7911843]</code></pre><p>精度差不多 80%，其实还是不错的了，比随机瞎划线去分好多了。</p><p>如果随机划线去分类的话，对二元分类问题精度是 50 %，而对这 46 元的分类精度只要不到 19% 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">test_labels_copy = copy.copy(test_labels)</span><br><span class="line">np.random.shuffle(test_labels_copy)</span><br><span class="line">hits_array = np.array(test_labels) == np.array(test_labels_copy)</span><br><span class="line"><span class="built_in">float</span>(np.<span class="built_in">sum</span>(hits_array)) / <span class="built_in">len</span>(test_labels)</span><br></pre></td></tr></table></figure><pre><code>0.18432769367764915</code></pre><p>调用 model 实例的 predict 方法，可以得到对输入在 46 个分类上的概率分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predictions = model.predict(x_test)</span><br><span class="line">print(predictions)</span><br></pre></td></tr></table></figure><pre><code>array([[4.7181980e-05, 2.0765587e-05, 8.6653872e-06, ..., 3.1266565e-05,        8.2046267e-07, 6.0611728e-06],       [5.9005950e-04, 1.3404934e-02, 1.2290048e-03, ..., 4.2919168e-05,        5.7422225e-05, 4.0201416e-05],       [8.5751421e-04, 9.2367262e-01, 1.5855590e-03, ..., 4.8341672e-04,        4.5594123e-05, 2.6183401e-05],       ...,       [8.5679676e-05, 2.0081598e-04, 4.1808224e-05, ..., 7.6962686e-05,        6.5783697e-06, 2.9889508e-05],       [1.7291466e-03, 2.5600385e-02, 1.8182390e-03, ..., 1.4499390e-03,        4.8478998e-04, 8.5257640e-04],       [2.5776261e-04, 8.6797208e-01, 3.9900807e-03, ..., 2.6547859e-04,        6.5820634e-05, 6.8603881e-06]], dtype=float32)</code></pre><p>predictions 分别代表 46 个分类的可能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predictions[<span class="number">0</span>].shape</span><br></pre></td></tr></table></figure><pre><code>(46,)</code></pre><p>他们的总和为 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">sum</span>(predictions[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>0.99999994</code></pre><p> 其中最大的，即我们认为这条新闻属于这个分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argmax(predictions[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><h3 id="处理标签和损失的另一种方法"><a href="#处理标签和损失的另一种方法" class="headerlink" title="处理标签和损失的另一种方法"></a>处理标签和损失的另一种方法</h3><p>前面提到了标签可以使用 one-hot 编码，或者直接把标签处理成整数张量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_train = np.array(train_labels)</span><br><span class="line">y_test = np.array(test_labels)</span><br></pre></td></tr></table></figure><p>用这种的话，损失函数也要跟着改，改成 sparse_categorical_crossentropy，<br>这个和 categorical_crossentropy 在数学上是一样的，只是接口不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="中间层维度足够大的重要性"><a href="#中间层维度足够大的重要性" class="headerlink" title="中间层维度足够大的重要性"></a>中间层维度足够大的重要性</h3><p>之前讨论了关于“信息瓶颈”的事，然后我们就说对这个 46 维结果的网络，中间层的维度要足够大！</p><p>现在咱试试如果不够大（导致信息瓶颈）会怎么样，咱搞夸张一点，从 64 减到 4：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">4</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">20</span>,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/207982/7982 [==============================] - 2s 288us/sample - loss: 2.8097 - accuracy: 0.4721 - val_loss: 2.0554 - val_accuracy: 0.5430.......Epoch 20/207982/7982 [==============================] - 1s 121us/sample - loss: 0.6443 - accuracy: 0.8069 - val_loss: 1.8962 - val_accuracy: 0.6800&lt;tensorflow.python.keras.callbacks.History at 0x16f628b50&gt;</code></pre><p>看看这，这训练出来比之前 64 维的差的不是一点半点哈，差距相当明显了。</p><p>发生这种效果的下降就是因为你给他学习的空间维度太低了，他把好多对分类有用的信息抛弃了。</p><p>那是不是越大越好？我们再试试把中间层加大一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">20</span>,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/207982/7982 [==============================] - 2s 273us/sample - loss: 1.5523 - accuracy: 0.6310 - val_loss: 1.1903 - val_accuracy: 0.7060......Epoch 20/207982/7982 [==============================] - 2s 296us/sample - loss: 0.0697 - accuracy: 0.9605 - val_loss: 3.5296 - val_accuracy: 0.7850&lt;tensorflow.python.keras.callbacks.History at 0x1707fcf90&gt;</code></pre><p>可以看到训练用的时间长了一点，电脑更暖手了一点，但效果却没有多大的提升。<br>这是由于第一层输入到中间层的只有 64 维嘛，中间层再大，也被第一层的瓶颈制约了。</p><p>在试试把第一层也加大！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">20</span>,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/207982/7982 [==============================] - 5s 662us/sample - loss: 1.3423 - accuracy: 0.6913 - val_loss: 0.9565 - val_accuracy: 0.7920......Epoch 20/207982/7982 [==============================] - 5s 583us/sample - loss: 0.0648 - accuracy: 0.9597 - val_loss: 2.9887 - val_accuracy: 0.8030&lt;tensorflow.python.keras.callbacks.History at 0x176fbbd90&gt;</code></pre><p>（稍微小一点，本来是用 4096 的，但太大了，咱乞丐版 mbp 跑的贼慢，跑完要20多分钟，我懒得等）</p><p>这个多浪费了好多时间，而且他很快就<del>过泥河</del>过拟合了，过得还过得很严重，画个图看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">loss = _.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = _.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjefsh6f1j30at07qwel.jpg" alt="png"></p><p>所以，太大了也不好。还是要有个度！</p><h3 id="尝试使用更少-更多的层"><a href="#尝试使用更少-更多的层" class="headerlink" title="尝试使用更少/更多的层"></a>尝试使用更少/更多的层</h3><ol><li>更少的层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">20</span>,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/207982/7982 [==============================] - 1s 132us/sample - loss: 2.4611 - accuracy: 0.6001 - val_loss: 1.8556 - val_accuracy: 0.6440......Epoch 20/207982/7982 [==============================] - 1s 85us/sample - loss: 0.1485 - accuracy: 0.9570 - val_loss: 1.2116 - val_accuracy: 0.7960</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjeg0o13pj30at07qaa5.jpg" alt="png"></p><p>快呀！结果稍微差了一点点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clown0te(<span class="string">&quot;防盗文爬:)虫的追踪标签，读者不必在意&quot;</span>).by(CDFMLR)</span><br></pre></td></tr></table></figure><ol start="2"><li>更多的层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">10000</span>,)))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">46</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">          partial_y_train,</span><br><span class="line">          epochs=<span class="number">20</span>,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;bo-&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;rs-&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>Train on 7982 samples, validate on 1000 samplesEpoch 1/207982/7982 [==============================] - 2s 188us/sample - loss: 1.8340 - accuracy: 0.5829 - val_loss: 1.3336 - val_accuracy: 0.6910......Epoch 20/207982/7982 [==============================] - 1s 115us/sample - loss: 0.0891 - accuracy: 0.9600 - val_loss: 1.7227 - val_accuracy: 0.7900</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjem9vu9zj30b007qmxh.jpg" alt="png"></p><p>所以，这个也不是越多越好呀！</p><h2 id="预测房价-回归问题"><a href="#预测房价-回归问题" class="headerlink" title="预测房价: 回归问题"></a>预测房价: 回归问题</h2><p><a href="https://livebook.manning.com/book/deep-learning-with-python/chapter-3/271">原文链接</a></p><p>前面两个例子，我们都是在做分类问题（预测离散的标签）。这次看一个回归问题（预测连续的数值）。</p><h3 id="波士顿房间数据集"><a href="#波士顿房间数据集" class="headerlink" title="波士顿房间数据集"></a>波士顿房间数据集</h3><p>我们用 Boston Housing Price dataset 这个数据集来预测 70 年代中期的波士顿郊区房价。数据集里有当时那个地方的一些数据，比如犯罪律、税率什么的。</p><p>这个数据集比起我们前两个分类的数据集，数据相当少，只有 506 个，404 个在训练集，102 非个在测试集。数据里每种特征（feature）的输入数据数量级也不尽相同。</p><p>我们先把数据导进来看看（这个数据集也是 Keras 自带有的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> boston_housing</span><br><span class="line"></span><br><span class="line">(train_data, train_targets), (test_data, test_targets) = boston_housing.load_data()</span><br><span class="line"></span><br><span class="line">print(train_data.shape, test_data.shape)</span><br></pre></td></tr></table></figure><pre><code>(404, 13) (102, 13)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><pre><code>array([[1.23247e+00, 0.00000e+00, 8.14000e+00, 0.00000e+00, 5.38000e-01,        6.14200e+00, 9.17000e+01, 3.97690e+00, 4.00000e+00, 3.07000e+02,        2.10000e+01, 3.96900e+02, 1.87200e+01],       [2.17700e-02, 8.25000e+01, 2.03000e+00, 0.00000e+00, 4.15000e-01,        7.61000e+00, 1.57000e+01, 6.27000e+00, 2.00000e+00, 3.48000e+02,        1.47000e+01, 3.95380e+02, 3.11000e+00],       [4.89822e+00, 0.00000e+00, 1.81000e+01, 0.00000e+00, 6.31000e-01,        4.97000e+00, 1.00000e+02, 1.33250e+00, 2.40000e+01, 6.66000e+02,        2.02000e+01, 3.75520e+02, 3.26000e+00]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_targets[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><pre><code>array([15.2, 42.3, 50. ])</code></pre><p>targets 里的数据单位是 <em>千美元</em>， 这个时候的房价还比较便宜：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(train_targets), <span class="built_in">sum</span>(train_targets)/<span class="built_in">len</span>(train_targets), <span class="built_in">max</span>(train_targets)</span><br></pre></td></tr></table></figure><pre><code>(5.0, 22.395049504950496, 50.0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">range</span>(<span class="built_in">len</span>(train_targets))</span><br><span class="line">y = train_targets</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;House Prices&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;train_targets&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;prices&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggje0e4s1qj30aq07r3yo.jpg" alt="png"></p><h3 id="数据准备-2"><a href="#数据准备-2" class="headerlink" title="数据准备"></a>数据准备</h3><p>我们喂给神经网络的数据值的范围不应该差距太大，虽然神经网络是可以处理差距大的数据的，但总归不太好。<br>对于这种差距大的数据，我们一般都会对每个特征做标准化（feature-wise normalization）。</p><p>具体的操作是对每个特征（输入数据矩阵的一列）减去该列的均值，再除以其标准差。<br>这样做完之后，数据会变成以 0 为中心的，有一个标准差的（标准差为 1 ）。</p><p>用 Numpy 可以很容易的做这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mean = train_data.mean(axis=<span class="number">0</span>)</span><br><span class="line">std = train_data.std(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_data -= mean</span><br><span class="line">train_data /= std</span><br><span class="line"></span><br><span class="line">test_data -= mean</span><br><span class="line">test_data /= std</span><br></pre></td></tr></table></figure><p>注意哈，对测试集的处理用的是训练集的均值和标准差。</p><p>处理完数据就可以构建网络、训练了（标签不用处理，比分类方便）</p><h3 id="构建网络-1"><a href="#构建网络-1" class="headerlink" title="构建网络"></a>构建网络</h3><p>数据越少，越容易过拟合，要减缓过拟合，可以使用比较小的网络。</p><p>比如，在这个问题中，我们使用一个只有两个隐藏层的网络，每个 64 单元：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>():</span></span><br><span class="line">    model = models.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&quot;relu&quot;</span>, input_shape=(train_data.shape[<span class="number">1</span>], )))</span><br><span class="line">    model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;rmsprop&quot;</span>, loss=<span class="string">&quot;mse&quot;</span>, metrics=[<span class="string">&quot;mae&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>网络的最后一层只有一个单元，并且没有激活函数（所以是个线性的层）。这种层是我们做连续单值回归问题的最后一步的标配。</p><p>如果加了激活函数，输出的值就会有范围限制，比如 sigmoid 会把值限制到 <code>[0, 1]</code>。没有激活函数，这个线性的层输出的值就没有限制了。</p><p>我们在编译模型时，使用的损失函数是 <code>mse</code> （mean squared error，均方误差）。这个函数返回预测和真实目标值的差的平方。回归问题多用这个损失。</p><p>然后我们还用了以前没用过的训练指标 —— <code>mae</code>（mean absolute error，平均绝对误差），这个东西是预测和真实目标的差的绝对值。</p><h3 id="拟合验证-——-K-fold-验证"><a href="#拟合验证-——-K-fold-验证" class="headerlink" title="拟合验证 —— K-fold 验证"></a>拟合验证 —— K-fold 验证</h3><p>我们之前一直在做 —— 为了对网络进行评估，来调节网络参数(比如训练的轮数)，我们将数据划分为训练集和验证集。这一次，我们也需要这么做。<br>但有一点麻烦是，我们这次的数据太少了，所以分出来的验证集就很小（可能才有100条数据）。这种情况下，验证集选择的数据不同，可能对验证的结果有很大影响（即验证集的划分方式不同可能造成验证结果的方差很大），这种情况会影响我们对模型的验证。</p><p>在这种尴尬的境地，最佳实践是使用 <em>K-fold</em> 交叉验证（K折交叉验证）。</p><p>用 K-fold 验证，我们把数据分成 K 个部分（一般 k = 4 or 5），然后实例化 K 个独立的模型，每个用 K-1 份数据去训练，然后用剩余的一份去验证，最终模型的验证分数使用 K 个部分的平均值。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gert24t4p8j317u0mstci.jpg" alt="K-fold 验证示意图"></p><p>K-fold 验证的代码实现：</p><p>稍微改一下书上的例子，我们加一点用 TensorBoard 来可视化训练过程的代码。首先在 Jupyter Lab 笔记本里加载 tensorboard：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load the TensorBoard notebook extension</span></span><br><span class="line"><span class="comment"># TensorBoard 可以可视化训练过程</span></span><br><span class="line">%load_ext tensorboard</span><br><span class="line"><span class="comment"># Clear any logs from previous runs</span></span><br><span class="line">!rm -rf ./logs/ </span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>The tensorboard extension is already loaded. To reload it, use:  %reload_ext tensorboard</code></pre><p>然后开始写主要的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">num_val_samples = <span class="built_in">len</span>(train_data) // k</span><br><span class="line">num_epochs = <span class="number">100</span></span><br><span class="line">all_scores = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备 TensorBoard</span></span><br><span class="line">log_dir = <span class="string">&quot;logs/fit/&quot;</span> + datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>)</span><br><span class="line">tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    print(<span class="string">f&#x27;processing fold #<span class="subst">&#123;i&#125;</span> (<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;k&#125;</span>)&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备验证数据</span></span><br><span class="line">    val_data = train_data[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">    val_targets = train_targets[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备训练数据</span></span><br><span class="line">    partial_train_data = np.concatenate(</span><br><span class="line">        [train_data[: i * num_val_samples],</span><br><span class="line">         train_data[(i+<span class="number">1</span>) * num_val_samples :]],</span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line">    partial_train_targets = np.concatenate(</span><br><span class="line">        [train_targets[: i * num_val_samples], </span><br><span class="line">         train_targets[(i+<span class="number">1</span>) *  num_val_samples :]], </span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#构建、训练模型</span></span><br><span class="line">    model = build_model()</span><br><span class="line">    model.fit(partial_train_data, partial_train_targets, </span><br><span class="line">              epochs=num_epochs, batch_size=<span class="number">1</span>, verbose=<span class="number">0</span>,</span><br><span class="line">              callbacks=[tensorboard_callback])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 有验证集评估模型</span></span><br><span class="line">    val_mse, val_mae = model.evaluate(val_data, val_targets, verbose=<span class="number">0</span>)</span><br><span class="line">    all_scores.append(val_mae)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.mean(all_scores)</span><br></pre></td></tr></table></figure><pre><code>processing fold #0 (1/4)processing fold #1 (2/4)processing fold #2 (3/4)processing fold #3 (4/4)2.4046657</code></pre><p>用下面这个命令可以在 Jupyter Lab 笔记本里显示 tensorboard：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%tensorboard --logdir logs/fit</span><br></pre></td></tr></table></figure><p>它大概是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggje37vwedj31fw0u0dmn.jpg" alt="tensorboard的截图"></p><p>这个东西也可以直接在你的浏览器里直接打开 <code>http://localhost:6006</code> 得到。</p><p>刚才那个只是玩一下哈，现在我们改一下，迭代 500 轮（没独显的mbp跑这个好慢啊啊啊），把训练的结果记下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">4</span></span><br><span class="line">num_val_samples = <span class="built_in">len</span>(train_data) // k</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">500</span></span><br><span class="line">all_mae_histories = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    print(<span class="string">f&#x27;processing fold #<span class="subst">&#123;i&#125;</span> (<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;k&#125;</span>)&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备验证数据</span></span><br><span class="line">    val_data = train_data[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">    val_targets = train_targets[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备训练数据</span></span><br><span class="line">    partial_train_data = np.concatenate(</span><br><span class="line">        [train_data[: i * num_val_samples],</span><br><span class="line">         train_data[(i+<span class="number">1</span>) * num_val_samples :]],</span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line">    partial_train_targets = np.concatenate(</span><br><span class="line">        [train_targets[: i * num_val_samples], </span><br><span class="line">         train_targets[(i+<span class="number">1</span>) *  num_val_samples :]], </span><br><span class="line">        axis=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#构建、训练模型</span></span><br><span class="line">    model = build_model()</span><br><span class="line">    history = model.fit(partial_train_data, partial_train_targets,</span><br><span class="line">                        validation_data=(val_data, val_targets),</span><br><span class="line">                        epochs=num_epochs, batch_size=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    mae_history = history.history[<span class="string">&#x27;val_mae&#x27;</span>]</span><br><span class="line">    all_mae_histories.append(mae_history)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Done.&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>processing fold #0 (1/4)processing fold #1 (2/4)processing fold #2 (3/4)processing fold #3 (4/4)Done.</code></pre><p>画图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">average_mae_history = [</span><br><span class="line">    np.mean([x[i] <span class="keyword">for</span> x <span class="keyword">in</span> all_mae_histories]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(average_mae_history) + <span class="number">1</span>), average_mae_history)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Validation MAE&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggje0zqitmj30b007eq35.jpg" alt="png"></p><p>这个图太密了，看不清，所以要处理一下：</p><ul><li>去掉前十组数据，这端明显和其他的数量差距比较大；</li><li>把每个点都换成前面数据点的指数移动平均值（an exponential moving average of the previous points），把曲线变平滑；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smooth_curve</span>(<span class="params">points, factor=<span class="number">0.9</span></span>):</span></span><br><span class="line">  smoothed_points = []</span><br><span class="line">  <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    <span class="keyword">if</span> smoothed_points:</span><br><span class="line">      previous = smoothed_points[-<span class="number">1</span>]</span><br><span class="line">      smoothed_points.append(previous * factor + point * (<span class="number">1</span> - factor))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      smoothed_points.append(point)</span><br><span class="line">  <span class="keyword">return</span> smoothed_points</span><br><span class="line"></span><br><span class="line">smooth_mae_history = smooth_curve(average_mae_history[<span class="number">10</span>:])</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(smooth_mae_history) + <span class="number">1</span>), smooth_mae_history)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Validation MAE&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggje11t08ij30b007egls.jpg" alt="png"></p><p>从这个图看，差不多过了 80 个 epochs 后就过拟合了。</p><p>在尝试了这些之后，我们找出最佳的参数（轮数啦，网络的层数啦，这些都可以试试），然后用最佳的参数在所有数据上训练，来得出最终的生产模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练最终模型</span></span><br><span class="line"></span><br><span class="line">model = build_model()</span><br><span class="line">model.fit(train_data, train_targets, </span><br><span class="line">          epochs=<span class="number">80</span>, batch_size=<span class="number">16</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后评估一下</span></span><br><span class="line">test_mse_score, test_mae_score = model.evaluate(test_data, test_targets, verbose=<span class="number">0</span>)</span><br><span class="line">print(test_mse_score, test_mae_score)</span><br></pre></td></tr></table></figure><pre><code>17.43332971311083 2.6102107</code></pre><p>这个 test_mae_score 的值说明，我们训练出来的模型的预测和实际大概差了 2k+ 美元。。。😭</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI基础——构建列表和导航</title>
      <link href="/2020/06/24/SwiftUI/SwiftUI_Essentials_2_Building_List_and_navigation/"/>
      <url>/2020/06/24/SwiftUI/SwiftUI_Essentials_2_Building_List_and_navigation/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift-UI-基础"><a href="#Swift-UI-基础" class="headerlink" title="Swift UI 基础"></a>Swift UI 基础</h1><p>今天是 WWDC20 的第二天了，所以继续来学习 Apple 的 app 开发。😜</p><blockquote><p>翻译自 SwiftUI 的官方教程：<a href="https://developer.apple.com/tutorials/swiftui/tutorials">Learn to Make Apps with SwiftUI</a></p><p>这篇文章是 Apple 给的 SwiftUI 官方教程的一部分，我自己阅读学习的时候顺便翻译的。</p></blockquote><h2 id="构建列表和导航"><a href="#构建列表和导航" class="headerlink" title="构建列表和导航"></a>构建列表和导航</h2><blockquote><p>原文链接：<a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation">https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation</a></p></blockquote><p>在我们已经完成了基本的地标细节视图后，现在，我们需要提供给用户一种方式，来查看完整的地标列表，并可以查看每一个地标的细节。</p><p>我们将构建可以展示任意地标信息的视图，还有动态生成一个滚动列表，用户可以点击列表里的项目来查看对应地标的细节信息。为了微调用户界面，我们将使用 Xcode 的画布在不同的设备尺寸下渲染多个预览。</p><p>载项目文件，跟着下面的步骤开始构建工程吧：</p><blockquote><p>预计时间：35分钟</p><p>项目文件：<a href="https://docs-assets.developer.apple.com/published/f021500afcdf6c3930549f1ffeb65e7e/110/BuildingListsAndNavigation.zip">https://docs-assets.developer.apple.com/published/f021500afcdf6c3930549f1ffeb65e7e/110/BuildingListsAndNavigation.zip</a> </p></blockquote><h3 id="§-1-认识样本数据-Sample-Data"><a href="#§-1-认识样本数据-Sample-Data" class="headerlink" title="§ 1 认识样本数据(Sample Data)"></a>§ 1 认识样本数据(Sample Data)</h3><blockquote><p>原文链接：<a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#Get-to-Know-the-Sample-Data">https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#Get-to-Know-the-Sample-Data</a></p></blockquote><p>在之前的教程中，我们把信息用硬编码(hard-coded)写死到了我们的自定义视图中。现在，我们将要学习如何让视图显示我们传进去的指定信息。</p><p>首先，下载打开起步项目文件，然后自己熟悉一下样本数据吧。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg33qnycraj30pa0dkq3j.jpg" alt="一张图显示了如何从JSON数据中提取各种地标的细节"></p><p><strong>Step 1.</strong> 在项目导航（Project navigator）中选择 <strong>Models</strong> &gt; <code>Landmark.swift</code>。</p><p><code>Landmark.swift</code> declares a <code>Landmark</code>structure that stores all of the landmark information the app needs to display, and imports an array of landmark data from <code>landmarkData.json</code>.</p><p><code>Landmark.swift</code> 声明了一个 <code>Landmark</code> 结构体，用来储存我们的 app 需要显示的所有地标信息（这些信息是从 <code>landmarkData.json</code> 读取出来的）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Landmark.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Landmark</span>: <span class="title">Hashable</span>, <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> imageName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> coordinates: <span class="type">Coordinates</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> park: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> category: <span class="type">Category</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> locationCoordinate: <span class="type">CLLocationCoordinate2D</span> &#123;</span><br><span class="line">        <span class="type">CLLocationCoordinate2D</span>(</span><br><span class="line">            latitude: coordinates.latitude,</span><br><span class="line">            longitude: coordinates.longitude)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Category</span>: <span class="title">String</span>, <span class="title">CaseIterable</span>, <span class="title">Codable</span>, <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> featured <span class="operator">=</span> <span class="string">&quot;Featured&quot;</span></span><br><span class="line">        <span class="keyword">case</span> lakes <span class="operator">=</span> <span class="string">&quot;Lakes&quot;</span></span><br><span class="line">        <span class="keyword">case</span> rivers <span class="operator">=</span> <span class="string">&quot;Rivers&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Landmark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="type">ImageStore</span>.shared.image(name: imageName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coordinates</span>: <span class="title">Hashable</span>, <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Step 2.</strong> 在项目导航中，选择 <strong>Resources</strong> &gt; <code>landmarkData.json</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Turtle Rock&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;Featured&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Twentynine Palms&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;California&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1001</span>,</span><br><span class="line">        <span class="attr">&quot;park&quot;</span>: <span class="string">&quot;Joshua Tree National Park&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;coordinates&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;longitude&quot;</span>: <span class="number">-116.166868</span>,</span><br><span class="line">            <span class="attr">&quot;latitude&quot;</span>: <span class="number">34.011286</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;imageName&quot;</span>: <span class="string">&quot;turtlerock&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Silver Salmon Creek&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;Lakes&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Port Alsworth&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;Alaska&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1002</span>,</span><br><span class="line">        <span class="attr">&quot;park&quot;</span>: <span class="string">&quot;Lake Clark National Park and Preserve&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;coordinates&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;longitude&quot;</span>: <span class="number">-152.665167</span>,</span><br><span class="line">            <span class="attr">&quot;latitude&quot;</span>: <span class="number">59.980167</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;imageName&quot;</span>: <span class="string">&quot;silversalmoncreek&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在接下来的步骤中，我们都将使用这个样本数据文件。</p><p><strong>Step 3.</strong> 注意，在 <a href="https://clownote.github.io/2020/06/23/SwiftUI/SwiftUI_Essentials_Creating_and_Combining_Views/">创建并组合视图</a> 里我们写的 ContentView 现在重命名成了 <code>LandmarkDetail</code>。</p><p>在接下来的教程中，我们还有构建更多的其他视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LandmarkDetail.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkDetail</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">MapView</span>()</span><br><span class="line">                .edgesIgnoringSafeArea(.top)</span><br><span class="line">                .frame(height: <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">CircleImage</span>()</span><br><span class="line">                .offset(y: <span class="operator">-</span><span class="number">130</span>)</span><br><span class="line">                .padding(.bottom, <span class="operator">-</span><span class="number">130</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Turtle Rock&quot;</span>)</span><br><span class="line">                    .font(.title)</span><br><span class="line"></span><br><span class="line">                <span class="type">HStack</span>(alignment: .top) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Joshua Tree National Park&quot;</span>)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;California&quot;</span>)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkDetail_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LandmarkDetail</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预览效果是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg35gcegikj30vj0u013u.jpg" alt="Xcode预览的截图，地图视图对准了显示器的顶部"></p><h3 id="§-2-创建行视图-Row-View"><a href="#§-2-创建行视图-Row-View" class="headerlink" title="§ 2 创建行视图(Row View)"></a>§ 2 创建行视图(Row View)</h3><p>在本教程中，我们将构建的第一个视图是一个用于显示每个地标详细信息的行。这个行视图将它所显示的地标的信息存储在一个属性中，因此一个这种视图是可以显示任何地标的。之后，我们将把多个这种行组合成一个地标列表。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg360dch7nj30md0bo74z.jpg" alt="一张图描述了你将为本教程构建的行是如何构建的。该行由左边的图像、从JSON文件中提取数据以了解地标细节的文本视图和右边的间隔符组成。"></p><p><strong>Step 1.</strong> 创建一个新的 SwiftUI View，文件命名为 <code>LandmarkRow.swift</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg361wqte4j30tg0xcwld.jpg" alt="Xcode的截图，显示文件创建对话框。"></p><p><strong>Step 2.</strong> 如果预览没有显示，则通过  <strong>Editor &gt; Canvas</strong> 打开画布，然后点 <strong>Resume</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg37cr5otnj30tg0xcmxq.jpg" alt="一张图片显示了Xcode中欢迎来到SwiftUI屏幕"></p><p><strong>Step 3.</strong> 给 <code>LandmarkRow</code> 添加一个 landmark 储存属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LandmarkRow.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkRow</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> landmark: <span class="type">Landmark</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkRow_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LandmarkRow</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你添加 landmark 属性时，预览会停止工作，因为LandmarkRow类型在初始化时需要一个 Landmark 实例。</p><p>为了修复预览，我们要修改一下预览提供器（PreviewProvider）。</p><p><strong>Step 4.</strong> 在 LandmarkRow_Previews 的 previews 静态属性中，给 LandmarkRow 的初始化器中添加 landmark 参数，指定 landmarkData 数组的第一个元素。</p><p>现在，预览就可以工作了，显示出了文本 “Hello World”。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg37q6jzywj31940n6whf.jpg" alt="代码和预览截图，预览显示出了Hello World"></p><p>修复了这个问题之后，就可以开始构建行的视图了。</p><p><strong>Step 5.</strong> 把现有的文本视图嵌入到一个 HStack 里。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg37sj9i5aj318m0podiy.jpg" alt="代码和预览截图，代码把现有的文本视图嵌入到一个 HStack 里，预览不变"></p><p><strong>Step 6.</strong> 把文本视图的内容改成 <code>landmark</code> 属性的 <code>name</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg37zyjvbzj31920oy0vt.jpg" alt="代码和预览截图，文本视图的内容改成了landmark属性的name，预览显示文本Turtle Rock"></p><p><strong>Step 7.</strong> 通过在文本视图前添加图像，在文本视图后添加间隔符来完成行。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg38568glgj319g0tstd3.jpg" alt="代码和预览截图，在文本视图前添加图像，在文本视图后添加间隔"></p><hr><p>这一节里我们完成的主要代码是<code>LandmarkRow.swift</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkRow</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> landmark: <span class="type">Landmark</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            landmark.image</span><br><span class="line">                .resizable()</span><br><span class="line">                .frame(width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">            <span class="type">Text</span>(landmark.name)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkRow_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LandmarkRow</span>(landmark: landmarkData[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在 Playground 里完成这个，但稍微有点麻烦。</p><p>新建一个 Playground，打开左侧的 Navigater，展开可以看到 Resources 文件夹，把 Apple 给的那个项目文件中的 Resources 里面的东西（一个 json文件，还有一堆图片文件）</p><h3 id="§-3-自定义行预览"><a href="#§-3-自定义行预览" class="headerlink" title="§ 3 自定义行预览"></a>§ 3 自定义行预览</h3><p>Xcode 的画布可以自动识别并显示当前编辑器中实现了 PreviewProvider 协议的任何类型。预览提供器（preview provider）会返回一个或多个视图，并带有配置大小和设备的选项。</p><p>你可以自定义从预览提供器返回的内容，以准确地呈现对工作最有帮助的预览。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3h6nrl7oj30nt0kgmyz.jpg" alt="两台iPhone设备并排的图片。左边的iPhone在靠近显示屏中间的四行周围有一个高亮。左边的四行高亮处有一个箭头，这些箭头在右边iPhone的列表视图中得到了复制。"></p><p><strong>Step 1.</strong> 在LandmarkRow_Previews中，把 landmark 参数改为 landmarkData 数组中的第二个元素。</p><p>修改完代码，预览会立即改变，显示第二个样本地标，而不再是第一个。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3hqssaaaj317f0u0gpw.jpg" alt="代码和预览的截图"></p><p><strong>Step 2.</strong> 使用 <code>previewLayout(_:)</code> 修饰器来把预览设置成近似一个行的尺寸大小。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3idkm3npj318o0u0q7l.jpg" alt="代码和预览的截图"></p><p>我们可以使用一个 Group 来从一个 preview provider 返回多个预览。</p><p><strong>Step 3.</strong> 将现在 previews 返回的 LandmarkRow 包裹在一个 Group 中，并将第一行再次添加回来。</p><p>Group 是对视图内容进行分组的容器。Xcode 在画布中以单独的预览来呈现 Group 的子视图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3nomqyhzj313a0u00z2.jpg" alt="代码和预览的截图"></p><p><strong>Step 4.</strong> 为了简化代码，将 <code> previewLayout(_:)</code> 的调用移到组的子声明的外面。</p><p>视图的孩子 (Children) 会继承视图的上下文设置，例如预览配置。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3o6fyo1vj313m0u0ag3.jpg" alt="代码和预览的截图"></p><p>我们在预览提供器(PreviewProvider)中写的代码只会改变画布(canvas)中显示的预览内容，不会影响视图本身。</p><h3 id="§-4-创建地标列表（the-List-of-Landmarks）"><a href="#§-4-创建地标列表（the-List-of-Landmarks）" class="headerlink" title="§ 4 创建地标列表（the List of Landmarks）"></a>§ 4 创建地标列表（the List of Landmarks）</h3><p>使用 SwiftUI 的 <code>List</code> 类型，可以显示一个平台特定(platform-specific)的视图列表。列表中的元素可以是静态的，比如到目前为止你创建的那种 stack 的子视图，也可以是动态生成的。我们甚至可以在 List 里混合静态和动态生成的视图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3ogifginj30m905kdgp.jpg" alt="两行地标的截图，左边有图片，地标名称，每排右侧边缘有导航箭头。"></p><p><strong>Step 1.</strong> 创建一个新的 SwiftUI View，命名为 <code>LandmarkList.swift</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3oovkeetj30tg0xcdmp.jpg" alt="Xcode的截图，显示新SwiftUI视图正被添加到项目中。"></p><p><strong>Step 2.</strong> 用一个 List 替换默认的 Text 视图，并提供 LandmarkRow 实例，将前两个地标作为列表的子节点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg3or740ejj318w0nkgpr.jpg" alt="代码和预览的截图"></p><p>预览显示两个 LandmarkRow 以适合 iOS 的列表样式呈现出来了。</p>]]></content>
      
      
      <categories>
          
          <category> Learn to Make Apps with SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI基础——创建并组合视图</title>
      <link href="/2020/06/23/SwiftUI/SwiftUI_Essentials_1_Creating_and_Combining_Views/"/>
      <url>/2020/06/23/SwiftUI/SwiftUI_Essentials_1_Creating_and_Combining_Views/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift-UI-基础"><a href="#Swift-UI-基础" class="headerlink" title="Swift UI 基础"></a>Swift UI 基础</h1><p>今天开 2020 年的 WWDC 了，所以来学习一下 Apple 的 app 开发吧。😜</p><blockquote><p>翻译自：Learn to Make Apps with SwiftUI</p><p>英文原文：<a href="https://developer.apple.com/tutorials/swiftui/tutorials">https://developer.apple.com/tutorials/swiftui/tutorials</a></p><p>这篇文章是 Apple 给的 SwiftUI 官方教程的一部分，我自己阅读学习的时候顺便翻译的。</p></blockquote><h2 id="创建并组合视图"><a href="#创建并组合视图" class="headerlink" title="创建并组合视图"></a>创建并组合视图</h2><blockquote><p>原文链接：<a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">https://developer.apple.com/tutorials/swiftui/creating-and-combining-views</a></p></blockquote><p>这个教程教你构建一个 iOS app —— <em>Landmarks</em>。这个 App 是用来发现、分享你喜欢的地点的。我们会从构建一个显示地标(Landmarks) 详情的 View 开始。</p><p>要布局这个地标详情的 View，我们用 <em>stacks</em> 来组合、堆放[^1] 图片和文本视图组件。我们还要用引入 MapKit 组件来提供地图视图。在你修改视图的时候，Xcode 会给你及时的反馈，让你看到改变的代码。</p><p>下载项目文件，跟着下面的步骤开始构建工程吧：</p><blockquote><p>预计用时：40 分钟</p><p>下载项目文件：<a href="https://docs-assets.developer.apple.com/published/b90bcabe8b9615e22850aaf17f3e7dfd/110/CreatingAndCombiningViews.zip">https://docs-assets.developer.apple.com/published/b90bcabe8b9615e22850aaf17f3e7dfd/110/CreatingAndCombiningViews.zip</a></p><p>Xcode 11：<a href="https://itunes.apple.com/us/app/xcode/id497799835?mt=12">https://itunes.apple.com/us/app/xcode/id497799835?mt=12</a></p></blockquote><p>[^1]: combine and layer，我的理解是 combine 在同一水平面组合，layer 做垂直方向上堆放</p><h3 id="§-1-创建新项目和探索画布"><a href="#§-1-创建新项目和探索画布" class="headerlink" title="§ 1 创建新项目和探索画布"></a>§ 1 创建新项目和探索画布</h3><blockquote><p>原文链接：<a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas</a></p></blockquote><p>在 Xcode 创建一个使用 SwiftUI 的新项目。在里面探索画布、预览和 SwiftUI 的模版代码。</p><p>要在 Xcode 里预览视图，并与之交互，需要 macOS Catalina 10.15。[^2]</p><p><strong>Step 1.</strong> 打开 Xcode，然后在 Xcode 的启动页面点击 <strong>Create a new Xcode project</strong>，或者选择 <strong>File &gt; New &gt; Project</strong>。[^3] <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geow8syirjj30tg0xcwg2.jpg" alt="一张屏幕截图，Welcome to Xcode页面的，当你打开Xcode的时候会显示。当你打开Xcode时，有三个选项可供选择。开始使用一个playground，创建一个新的Xcode项目，和克隆一个现有的项目。第二个选项--创建一个新的Xcode项目--被突出显示。"></p><p><strong>Step 2.</strong> 在模版选择窗口里选择 <strong>iOS</strong> 平台、<strong>Single View App</strong> 模版，然后点击 <strong>Next</strong>。<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geox1ilcygj30tg0xcjtr.jpg" alt="Xcode中的模板选择表的截图。在最上面一行中，iOS被选为平台。在应用部分，选择了单视图App作为模板；在工作表右下角的下一步按钮上方有一个高亮显示。"></p><p><strong>Step 3.</strong> 在 Product Name 处输入“Landmarks”，user interface 选择 <strong>SwiftUI</strong>，点击 <strong>Next</strong>。然后选择一个位置在你的 Mac 上保存这个项目。<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geox5hibhcj30u00xzwhi.jpg" alt="Xcode中的模板选择表截图。在最上面一行中，iOS被选为平台。在应用部分，选择了单视图App作为模板；在工作表右下角的下一步按钮上方有一个高亮显示。"></p><p><strong>Step 4.</strong> 在项目导航栏(Project navigator)里选择<code>ContentView.swift</code>。默认情况下，SwiftUI 声明了两个结构体，第一个遵循了 View 协议，是用来描述视图的内容和布局的；第二个结构体声明了对这个视图的预览。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2aqcod8mj30zr0u0gop.jpg" alt="代码以及来预览的屏幕截图，预览是iPhone上显示的效果，文字&quot;Hello World！&quot;位于预览的中间。"></p><p><strong>Step 5.</strong> 在画布(canvas)里点击 **Resume ** 来显示预览。</p><p>Tips：如果画布没有显示，你可以选择<strong>Editor &gt; Editor and Canvas</strong>，来打卡它。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepcq2cqr7j30tg0xc3zm.jpg" alt="A screenshot of the Preview window, with a Refresh button in its upper-right corner."></p><p><strong>Step 6.</strong> 在 body 属性里，把 <code>“Hello World”</code> 改成对你自己打招呼的话。</p><p>在你改变视图体(a view’s <code>body</code> property)的时候，预览及时地反映出了你的改变。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2atforcrj30zc0u0tbt.jpg" alt="代码以及来预览的屏幕截图，预览是iPhone上显示的效果，文字&quot;Hello SwiftUI！&quot;位于预览的中间。"></p><p>完成这一节后，我们的主要代码看上去是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello SwiftUI!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【译注】：由于本人使用 MacOS Mojave 10.14，所以无法使用预览的功能。这还是相当痛苦的，没有预览几乎难以进行 UI 设计了，所以我采取的代替方案是在 Playground 中写 SwiftUI。实现的步骤如下：</p><p>新建一个 Playground，选择 iOS 平台，Blank 模版。打开 Playground 后，把里面的代码替换如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HelloWoldView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.setLiveView(<span class="type">HelloWoldView</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行 Playground 至第 10 行（鼠标移到第十行的行标处，数字变成表示运行的箭头▶️，点击这个箭头），即可看到预览：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepdi7wg5vj31e00u01fv.jpg" alt="一张 Playground 的截图，左边写了前文里的 Hello World 程序代码，右边显示出了预览——一个空白的页面中间显示有文本 Hello World"></p><p>这样勉强可以进行 SwiftUI 的开发，只是无法如在 Catalina 的 Xcode 项目里那样和画布交互。</p><p>[^2]: 本人使用 MacOS Mojave 10.14，所以无法使用预览的功能，我采取的代替方案是在 Playground 中写 SwiftUI：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepd5aetotj31e00u0nkd.jpg" alt="一个 Playground 的截图，图中写了一段显示 Hello SwiftUI 文本的程序，右边显示出了预览"><br>[^3]: 分享一个让我很感动的细节，Apple 的文档里，居然对这样的一张截图写了如此详细的 alt 说明：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geowgmdd4nj31aa0u0tyk.jpg" alt="Apple文档的截图，显示了 apple 对网页上的一张图片写了特别详细的 alt 说明"> 扪心自问，我从来不认真写 alt，总认为这东西又看不见写它干嘛！看到了 Apple 的做法，不禁思索，万一正在阅读你的文章的人因为网络、计算机、甚至是视觉问题无法看到这张图片，我们难道没有义务为这样的特殊人群写一段图片说明嘛？尤其是对有视觉障碍的人士！以后我会尽可能认真写 alt！第一步就是——这篇文章翻译里包括这些 alt！</p><h3 id="§-2-定制文本视图-Text-View"><a href="#§-2-定制文本视图-Text-View" class="headerlink" title="§ 2 定制文本视图(Text View)"></a>§ 2 定制文本视图(Text View)</h3><blockquote><p>原文链接: <a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#customize-the-text-view">https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#customize-the-text-view</a></p></blockquote><p>通过修改代码，你可以定制视图的显示效果。当然，你也可以用检视器(inspector)来发现你可以做些什么，并帮助你完成代码。</p><p>在构建 <em>Landmarks</em> app 的过程中，你可以随意使用任何编辑器：代码编辑器(source editor)，画布(canvas)，检视器(inspectors)。无论你使用了那种方式来编辑，代码总会自动保持更新。</p><p><video data-v-f6e12e74="" autoplay="autoplay" muted="muted" playsinline=""><!----><source src="https://docs-assets.developer.apple.com/published/62bc5b3021f9628ad1536bdab67f5781/110/customize-text-view.mp4"></video></p><p>接下来，我们将使用监视器来定制文本视图。</p><p><strong>Step 1.</strong> 在预览中，按住 command 点击我们写了问候的文本，会出现一个结构编辑弹出框(popover)。在这个弹出框里，选择 <strong>Inspect</strong>。</p><p>这个弹出框里还有其他的你可以定制的属性，不同的视图可能有不同的属性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2443doj0j30tg0xcgr0.jpg" alt="结构编辑弹出框的截图"></p><p><strong>Step 2.</strong> 在检视器中，把文本(Text)改成 “Turtle Rock” —— 你的 app 中要展现的第一个地标。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg249uwx45j30tg0xcwmm.jpg" alt="在检视器中，把文本(Text)改成 “Turtle Rock”的截图"></p><p><strong>Step 3.</strong> 把字体修改成 <strong>Title</strong> (标题)。</p><p>这个操作是让文本使用系统字体，这种字体可以跟随用户当前的偏好设置。</p><p>【译注】也可以使用代码完成这个更改: <code>Text(&quot;Turtle Rock&quot;).font(.title)</code>。哈哈，这种写法就很 Swift，具体这是什么意思下面的原文有写。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg248kgh47j30tg0xck13.jpg" alt="在检视器中，修改字体的截图"></p><p>要用 SwiftUI 定制视图，我们可以调用称作修饰器(<em>modifiers</em>)的方法。修饰器会包装一个 View 来更改其显示效果或其他属性。每个修饰器都会返回一个新的 View，所以我们常链式调用多个修饰器以叠加效果。</p><p><strong>Step 4.</strong> 手动修改代码，添加一个修饰器：<code>foregroundColor(.green)</code>，这是用来把文本颜色改成绿色的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2946pjduj317s0pigp3.jpg" alt="修改后的代码和来自Xcode预览的截图，它显示一个在iPhone上的效果预览，绿色的文字，Turtle Rock，在显示器的中间。"></p><p>代码才是我们的视图效果的依据，当你用检视器来修改或移除修饰器时，Xcode 都会立刻在代码里做出相应的修改。</p><p><strong>Step 5.</strong> 现在，我们在代码里按住 Command 点击 <code>Text</code> 的声明，从弹出框里选择 <strong>Inspect</strong>，这样也可以打开监视器。在 <strong>Color</strong> 菜单里，把颜色设置成 <strong>Inherited</strong>，这样文本的颜色就复原了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg25eor1eqj30tg0xcqfu.jpg" alt="来自Xcode的结构化编辑器菜单截图，通过Command-点击文本视图的声明打开。"></p><p><strong>Step 6.</strong> 注意，完成刚才那一步之后， Xcode 自动帮我们把代码做了相应的修改，即去掉了修饰器 <code>foregroundColor(.green)</code>：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg27bz7r5sj317o0ougod.jpg" alt="原文里的代码和预览的截图"></p><hr><p>完成这一节后，我们的主要代码看上去是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Turtle Rock&quot;</span>)</span><br><span class="line">            .font(.title)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="§-3-用-Stacks-组合视图"><a href="#§-3-用-Stacks-组合视图" class="headerlink" title="§ 3 用 Stacks 组合视图"></a>§ 3 用 Stacks 组合视图</h3><blockquote><p>原文链接: <a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#Combine-Views-Using-Stacks">https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#Combine-Views-Using-Stacks</a></p></blockquote><p>在上一节我们完成了一个标题。现在，我们将再添加一些文本视图来描述地标的详细信息，比如所处的公园名称和所在的州。</p><p>在使用 SwiftUI 创建 View 时，我们在视图的 <code>body</code> 属性里描述其内容、布局、行为。但是，body 属性只会返回<strong>一个</strong>视图。所以，我们要把多个视图放到 stack 里来让它们在水平、竖直、前后方向上组合在一起。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg280wmdfij30f408ct8p.jpg" alt="一个VStack的示意图，在视图的上半部分显示了Turtle Rock的标题左对齐。下面是一个被高光包围的HStack。HStack包含三个视图。左边的视图显示文本&quot;Joshua Tree National Park&quot;。中间的视图是一个隔板Spacer。右边的视图显示文字 &quot;California&quot;"></p><p>在这一节里，我们我们将用一个竖直方向的 stack 来把标题放在一个包含了地标细节的水平 stack 的上方。</p><p>（emmm，我一直不太会翻译这种比较长的英文句子，可能是我语文学的不好吧，我不知道怎么解耦这种有嵌套结构的句子）</p><p>我们 Xcode 的结构编辑(structured editing)提供把一个 view 嵌入一个容器视图、打开检视器和其他许多有用的操作。</p><p><strong>Step 1.</strong> 按住 Command 点击文本视图的初始化器(构造函数啦)，会显示出结构编辑弹出框，在里面选择 <strong>Embed in VStack</strong>（嵌入VStack）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg28iuv3hrj30tg0xcajy.jpg" alt="当你Command点击文本初始化器时显示的弹出式菜单的截图。在菜单中，&quot;嵌入VStack &quot;选项被高亮显示。"></p><p>接下来，我们将通过从库里拖一个 Text 放到 Stack 里增加一个文本视图。</p><p><strong>Step 2.</strong> 点击位于 Xcode 窗口右上方的加号（+）打开库。从里面拖一个 Text 出来放到我们的“Turtle Rock”文本视图代码的后面。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2919jfa8j30tg0xc4bd.jpg" alt="画布和预览的截图，以及库窗口，显示了Turtle Rock下方的新文本视图。"></p><p><strong>Step 3.</strong> 把新的文本视图的内容替换为“<strong>Joshua Tree National Park</strong>”。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg296yvagmj317g0q4whx.jpg" alt="代码和预览截图，预览中显示了Turtle Rock下方的新文本视图。"></p><p>接下来我们还会定制刚刚添加的那个表示<em>位置</em>的文本视图，以匹配所需的布局。</p><p><strong>Step 4.</strong> 设置位置文本的字体为 subheadline（副标题）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Joshua Tree National Park&quot;</span>)</span><br><span class="line">.font(.subheadline)</span><br></pre></td></tr></table></figure><p><strong>Step 5.</strong> 编辑 VStack 的初始化器来指定视图前缘对齐（align the views by their leading edges，就是把左边对齐了，Android 里的 <code>gravity=&quot;start&quot;</code> 这种意思吧）。</p><p>默认情况下，stack 会沿其轴线把内容中心对齐，并且只提供适合内容的空间。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg29moovfzj317s0ou0w9.jpg" alt="代码和预览的截图，预览是显示的是iPhone上的效果，Turtle Rock和Joshua Tree National Park文本在显示屏的中间左对齐。"></p><p>接下来，我们要在表示位置的文本右边增加一个文本，表示其所在的州。</p><p><strong>Step 6.</strong> 在画布中，按住 Command 点击 <strong>Joshua Tree National Park</strong>，选择 <strong>Embed in HStack</strong>（嵌入HStack）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg29rui2mhj30tg0xcwnl.jpg" alt="弹出窗口的截图，菜单中高亮显示Embed in HStack。"></p><p><strong>Step 7.</strong> 在位置后面新建一个文本视图，把内容改成州名，把字体设置为 subheadline。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg29wvmdrrj30zf0u0td7.jpg" alt="代码和预览的截图"></p><p><strong>Step 8.</strong>  为了让我们的布局占满整个设备的屏幕宽度，我们在包含公园和州名的 HStack 里添加一个 <strong>Spacer</strong> 来把两个文本视图分开。</p><p><code>Spacer</code> 用来“撑大”容器布局，使其占满整个水平或竖直方向的父视图（its parent view）空间，而不再只是恰好包含内容。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2ahwhhvwj30zm0u0433.jpg" alt="代码和预览的截图"></p><p><strong>Step 9.</strong> 最后，使用 <code>padding()</code> 修饰方法给地标的名称和细节增加一点空间。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2alkmh6oj30zn0u0791.jpg" alt="代码和预览的截图"></p><hr><p>完成这一节后，我们的主要代码看上去是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Turtle Rock&quot;</span>)</span><br><span class="line">                .font(.title)</span><br><span class="line">            <span class="type">HStack</span>&#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Joshua Tree National Park&quot;</span>)</span><br><span class="line">                    .font(.subheadline)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;California&quot;</span>)</span><br><span class="line">                    .font(.subheadline)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="§-4-创建自定义图片视图-Custom-Image-View"><a href="#§-4-创建自定义图片视图-Custom-Image-View" class="headerlink" title="§ 4 创建自定义图片视图(Custom Image View)"></a>§ 4 创建自定义图片视图(Custom Image View)</h3><p>现在，咱们的地标名称、位置都已经安排好了。下一步，我们打算加一张地标的图片。</p><p>我们将创建一个新的自定义视图，而不是直接在现在的文件里继续写更多的代码了。这个自定义视图将包含有遮罩、边框和投影。</p><p><video data-v-f6e12e74="" autoplay="autoplay" muted="muted" playsinline=""><!----><source src="https://docs-assets.developer.apple.com/published/dd83089688f823328fbd9cb9a26238c5/110/custom-image-view.mp4"></video></p><p>首先，我们要先添加图片到项目的资产目录( asset catalog)。</p><p><strong>Step 1.</strong> 把 <code>turtlerock.png</code> （在Apple给的项目文件里的 Resources 文件夹里有）把它拖到 资产目录 编辑器里，Xcode 会为这个新图片创建一个图片集。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2bi3sx88j30tg0xc76h.jpg" alt="资产目录的截图，图片放在1倍槽中。"></p><p>【译注】那个图片就是下面这张👇</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2blu752tj306y06y0us.jpg" alt="turtlerock"></p><p>接下来，我们要创建一个新的 SwiftUI View 来写我们的自定义图片视图。</p><p><strong>Step 2.</strong> 选择 <strong>File &gt; New &gt; File</strong>，打开模版选择器，在 <strong>User Interface</strong> 中，选择 <strong>SwiftUI View</strong>，然后点 <strong>Next</strong>，把文件名取成 <code>CircleImage.swift</code>，然后点 <strong>Create</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2gd8yh7lj30tg0q1424.jpg" alt="新文件类型选择器的截图，高亮显示SwiftUI View和下一步按钮。"></p><p>现在，我们就准备好插入图片，然后修改显示效果来达到我们的预期目标了。</p><p><strong>Step 3.</strong> 用我们刚才准备好的图片来替换新建的文件里的文本视图，用 <code>Image(_:)</code> 来显示一张图片。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2gj64fgfj30zi0u0am7.jpg" alt="使用Image显示图片的代码和预览截图"></p><p>【译注】在 Playground 里写 <code>Image(&quot;turtlerock&quot;)</code> 要不成，要用 <code>Image(uiImage: UIImage(named: &quot;turtlerock.jpg&quot;)!)</code></p><p><strong>Step 4.</strong> 添加一个 <code>clipShape(Circle())</code> 调用来把图片裁剪为圆形。</p><p><code>Circle</code> 类型是一个形状，你可以把它当遮罩(mask)用，也可以把它作为一个圆形的视图（有圆形的笔触或者圆形填充的）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2hfamef6j317w0psaki.jpg" alt="把Image显示图片变成圆形的代码和预览效果截图"></p><p><strong>Step 5.</strong> 再创建一个新的灰色笔触的圆，然后把它作为 <code>overlay</code> 加到我们之前的 Image 上，这样可以作出一个边框效果。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2hodymblj317u0pqtj5.jpg" alt="代码和预览效果截图，加了灰色的圆形边框"></p><p><strong>Step 6.</strong> 接下来，添加一个半径为 10 点的阴影。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2hrhhj7tj317c0q2n8b.jpg" alt="代码和预览效果截图，加了阴影"></p><p><strong>Step 7.</strong> 把边框颜色改成白色。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2hta2gs3j31960p8wq2.jpg" alt="代码和预览效果截图，把边框颜色改成了白色"></p><p>现在，我们的自定义图片视图就完成了。</p><hr><p>完成这一节后，我们的主要代码看上去是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CircleImage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// Playground 里换成：Image(uiImage: UIImage(named: &quot;turtlerock.jpg&quot;)!)</span></span><br><span class="line">        <span class="type">Image</span>(<span class="string">&quot;turtlerock&quot;</span>)</span><br><span class="line">            .clipShape(<span class="type">Circle</span>())</span><br><span class="line">            .overlay(</span><br><span class="line">                <span class="type">Circle</span>().stroke(<span class="type">Color</span>.white, lineWidth: <span class="number">4</span>))</span><br><span class="line">            .shadow(radius: <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="§-5-同时使用-SwiftUI-和-UIKit"><a href="#§-5-同时使用-SwiftUI-和-UIKit" class="headerlink" title="§ 5 同时使用 SwiftUI 和 UIKit"></a>§ 5 同时使用 SwiftUI 和 UIKit</h3><p>现在，咱打算做一个地图视图了。我们可以用一个来自 <code>MapKit</code> 的 <code>MKMapView</code> 类来提供一个地图视图。</p><p>要在 SwiftUI 中使用 <code>UIView</code> 的子类，我们要把它用一个实现了 <code>UIViewRepresentable</code> 协议的 SwiftUI 视图包裹起来。SwiftUI 也对 WatchKit 和 AppKit 的视图提供了相似的协议。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2i5762mvj30oy0bcwha.jpg" alt="MapKit视图截图，约书亚树国家公园上有一个标记。"></p><p>首先，我们要自定义一个视图来包装 MKMapView。</p><p><strong>Step 1.</strong> 选择 <strong>File &gt; New &gt; File</strong>，打开模版选择器，在 <strong>User Interface</strong> 中，选择 <strong>SwiftUI View</strong>，然后点 <strong>Next</strong>，把文件名取成 <code>MapView.swift</code>，然后点 <strong>Create</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2itovm2cj30tg0q1427.jpg" alt="新建文件类型选择器的截图，高亮显示SwiftUI View和下一步按钮。"></p><p><strong>Step 2.</strong> 添加一个 import 语句来导入 <code>MapKit</code>，然后让 <code>MapView</code> 遵循 <code>UIViewRepresentable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">MapView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别介意 Xcode 提示的错误，我们将在接下来几步里解决这些问题。</p><p>接下来我们要完成 <code>UIViewRepresentable</code> 要求两个实现：</p><ul><li><code>makeUIView(context:)</code>：这个方法用来创建 MKMapView；</li><li><code>updateUIView(_:context:)</code>：这个方法用来设定视图，并对任意改变作出响应。</li></ul><p><strong>Step 3.</strong> 把新建的视图里的 body 属性的代码替换成定义一个 <code>makeUIView(context:)</code> 方法，这个方法用来创建并返回一个新的 <code>KMapView</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">MKMapView</span> &#123;</span><br><span class="line">        <span class="type">MKMapView</span>(frame: .zero)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Step 4.</strong> 在 MapView 里添加一个 <code>updateUIView(_:context:)</code> 方法来设置我们的地图把要显示的位置放到中心位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="keyword">_</span> uiView: MKMapView, context: Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> coordinate <span class="operator">=</span> <span class="type">CLLocationCoordinate2D</span>(</span><br><span class="line">        latitude: <span class="number">34.011286</span>, longitude: <span class="operator">-</span><span class="number">116.166868</span>)</span><br><span class="line">    <span class="keyword">let</span> span <span class="operator">=</span> <span class="type">MKCoordinateSpan</span>(latitudeDelta: <span class="number">2.0</span>, longitudeDelta: <span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">let</span> region <span class="operator">=</span> <span class="type">MKCoordinateRegion</span>(center: coordinate, span: span)</span><br><span class="line">    uiView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在静态模式（static mode）下预览只会渲染 SwiftUI 视图，而我们的地图是个 UIView 的子类，所以我们需要把预览调到 live 模式（live preview）才能看见地图。</p><p><strong>Step 5.</strong> 点击 <strong>Live Preview</strong> 按钮来把预览调至 live 模式。然后，你可能还需要点击 <strong>Try Again</strong> 或者 <strong>Resume</strong> 按钮才能显示出预期的效果。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2kfi6wy2j30tg0xc48n.jpg" alt="Xcode画布的截图，选择了Live Preview按钮。"></p><p>现在，我们将看见一张显示着 Joshua Tree National Park 的地图——这就是我们的地标 Turtle Rock 的家。</p><hr><p>这一节里，我们完成的主要代码看上去是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">MKMapView</span> &#123;</span><br><span class="line">        <span class="type">MKMapView</span>(frame: .zero)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="keyword">_</span> uiView: MKMapView, context: Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> coordinate <span class="operator">=</span> <span class="type">CLLocationCoordinate2D</span>(</span><br><span class="line">            latitude: <span class="number">34.011286</span>, longitude: <span class="operator">-</span><span class="number">116.166868</span>)</span><br><span class="line">        <span class="keyword">let</span> span <span class="operator">=</span> <span class="type">MKCoordinateSpan</span>(latitudeDelta: <span class="number">2.0</span>, longitudeDelta: <span class="number">2.0</span>)</span><br><span class="line">        <span class="keyword">let</span> region <span class="operator">=</span> <span class="type">MKCoordinateRegion</span>(center: coordinate, span: span)</span><br><span class="line">        uiView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="§-6-组成-Detail-视图"><a href="#§-6-组成-Detail-视图" class="headerlink" title="§ 6 组成 Detail 视图"></a>§ 6 组成 Detail 视图</h3><p>现在，我们已经构建完了我们需要的一切——地标的名字和位置、一张圆形的图片以及其所在位置的地图。</p><p>现在，我们要把这些我们写好的自定义视图组合在一起，来完成一个地标的 Detail 视图的最终设计了！我们要用到的还是已经开始熟悉的那些工具。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2kw18daoj30lq0lkqbl.jpg" alt="合成视图的图像，上面是地图视图，下面是公园名称，中间是圆形图像视图。"></p><p><strong>Step 1.</strong> 在项目导航（Project navigator）中，选择打开 <code>ContentView.swift</code> 文件。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2kzfv52qj31020u0792.jpg" alt="ContentView.swift文件内的代码和预览截图"></p><p><strong>Step 2.</strong> 把之前那个包含三个 Text 的 VStack 用另一个新的 VStack 包裹起来。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2l1en0s5j312c0u0afy.jpg" alt="代码和预览效果的截图，在之前的 VStack外面套了一个新的VStack，预览效果不变"></p><p><strong>Step 3.</strong> 把我们自定义的 MapView 放到 stack 的顶部，并用 <code>frame(width:height:)</code> 来调整其大小。</p><p>当你只指定了 height（高度）属性时，视图会自动把宽度设置成符合内容的。在这里，MapView 会拓展开充满整个可用空间。</p><p><strong>Step 4.</strong> 点击 <strong>Live Preview</strong> 按钮来查看在组合视图中渲染出来的地图。</p><p>在显示  Live Preview 的同时，你也还可以继续编辑视图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2lg3l7hpj30zd0u0q5e.jpg" alt="代码和预览效果的截图，添加了MapView"></p><p><strong>Step 5.</strong> 在 stack 里添加一个 CircleImage。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2lh5tko1j30yp0u0tn8.jpg" alt="代码和预览效果的截图，添加了 CircleImage"></p><p><strong>Step 6.</strong> 我们要把图片视图移到地图视图的上层：给它竖直偏移(offset) -130 点，底部内补(padding) -130 点。</p><p>这个调整通过把图片向上移，来提供给文本更多空间。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2lsxro6ej310t0u07ie.jpg" alt="代码和预览效果的截图，移动了圆形图片"></p><p><strong>Step 7.</strong>  在最外层的 VStack 的底部增加一个 spacer，把我们的那些内容推到屏幕顶部。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg2lw903stj30za0u016z.jpg" alt="代码和预览效果的截图，增加来一个 spacer，内容全在屏幕顶部来了"></p><p><strong>Step 8.</strong> 最后一步，为了能让我们的地图拓展到屏幕顶部边缘（说直白点就是伸到刘海里😂），给地图视图加一个 <code>edgesIgnoringSafeArea(.top)</code> 修饰。</p><hr><p>这一节里，我们完成的主要代码看上去是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">MapView</span>()</span><br><span class="line">                .edgesIgnoringSafeArea(.top)</span><br><span class="line">                .frame(height: <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">CircleImage</span>()</span><br><span class="line">                .offset(y: <span class="operator">-</span><span class="number">130</span>)</span><br><span class="line">                .padding(.bottom, <span class="operator">-</span><span class="number">130</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Turtle Rock&quot;</span>)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                <span class="type">HStack</span>(alignment: .top) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Joshua Tree National Park&quot;</span>)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;California&quot;</span>)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learn to Make Apps with SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 课程表 I、II、III</title>
      <link href="/2020/05/13/School/Leetcode-course-tab-I-II-III/"/>
      <url>/2020/05/13/School/Leetcode-course-tab-I-II-III/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-课程表-I、II、III"><a href="#Leetcode-课程表-I、II、III" class="headerlink" title="Leetcode 课程表 I、II、III"></a>Leetcode 课程表 I、II、III</h1><p>这篇文章介绍 Leetcode 的课程表 I、II、III 三道题目的解法。</p><p>[TOC]</p><p>本文由 CDFMLR 原创，收录于个人主页 <a href="https://clownote.github.io./">https://clownote.github.io。</a></p><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是 邻接矩阵 。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li><li><code>1 &lt;= numCourses &lt;= 10^5</code></li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/course-schedule">https://leetcode-cn.com/problems/course-schedule</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>这个东西要可以学就是要图里没有环。有环就“循环依赖”，没法学了。所以解法就是深度优先去搜索有没有环，有就不行，没有就行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    adj := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adj[p[<span class="number">1</span>]] = <span class="built_in">append</span>(adj[p[<span class="number">1</span>]], p[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> hasCycle(i, adj, <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(node <span class="keyword">int</span>, adj [][]<span class="keyword">int</span>, visited []<span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    visited[node] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> adj[node] &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[a] || hasCycle(a, adj, visited) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[node] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepo6jel4dj30qe05ymxv.jpg" alt="执行通过的截图，图片上显示执行用时44ms在所有 Go 提交中击败了14.12%的用户，内存消耗6.7MB在所有 Go 提交中击败了100%的用户"></p><h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。</p><p><strong>提示</strong>:</p><ol><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过 BFS 完成。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/course-schedule-ii">https://leetcode-cn.com/problems/course-schedule-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>这个题就是做拓扑排序，但拓扑排序只能用于 DAG (有向无环图) ！所以我们直接把上面那个题目的 hasCycle 抄过来判断是否有环，有环就返回一个空序列就好了，没环就拿去拓扑排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    adj := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adj[p[<span class="number">1</span>]] = <span class="built_in">append</span>(adj[p[<span class="number">1</span>]], p[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited :=  <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> hasCycle(i, adj, <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)) &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfsForTopoSort(i, adj, visited, &amp;ret)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ret) &lt; numCourses &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(node <span class="keyword">int</span>, adj [][]<span class="keyword">int</span>, visited []<span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    visited[node] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> adj[node] &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[a] || hasCycle(a, adj, visited) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[node] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsForTopoSort</span><span class="params">(node <span class="keyword">int</span>, adj [][]<span class="keyword">int</span>, visited []<span class="keyword">bool</span>, ret *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !visited[node] &#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, a := <span class="keyword">range</span> adj[node] &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[a] &#123;</span><br><span class="line">                dfsForTopoSort(a, adj, visited, ret)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        *ret = <span class="built_in">append</span>(*ret, node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> left, right := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; left &lt; right; left, right = left+<span class="number">1</span>, right<span class="number">-1</span> &#123;</span><br><span class="line">        a[left], a[right] = a[right], a[left]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个很好理解，也可以通过，但判断环 + 拓扑排序跑了两遍嘛，最后还做了一个切片翻转，所以比较慢。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geproy8i5cj30o805maar.jpg" alt="Leetcode 执行结果截图，执行用时 40 ms, 在所有 Go 提交中击败了11.81%的用户; 内存消耗 6.8 MB, 在所有 Go 提交中击败了100.00%的用户"></p><h2 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。</p><p>给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">这里一共有 4 门课程, 但是你最多可以修 3 门:</span><br><span class="line">首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。</span><br><span class="line">第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。</span><br><span class="line">第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。</span><br><span class="line">第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。</span><br></pre></td></tr></table></figure><p>提示:</p><ol><li>整数 1 &lt;= d, t, n &lt;= 10,000 。</li><li>你不能同时修两门课程。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/course-schedule-iii">https://leetcode-cn.com/problems/course-schedule-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="贪心优先队列"><a href="#贪心优先队列" class="headerlink" title="贪心优先队列"></a>贪心优先队列</h3><p>哇，这个题的贪心策略还是很6⃣️的，思路写起来比较麻烦，<a href="https://leetcode-cn.com/problems/course-schedule-iii/solution/ke-cheng-biao-iii-by-leetcode/">官方题解</a> 写的很好了，直接照着它那个，其实基本的代码很简单的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sort(&amp;courses)</span><br><span class="line"></span><br><span class="line">queue := PriorityQueue&#123;&#125;</span><br><span class="line">time := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line"><span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">queue.Push(c[<span class="number">0</span>])</span><br><span class="line">time += c[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !queue.IsEmpty() &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">time += c[<span class="number">0</span>] - queue.Poll()</span><br><span class="line">queue.Push(c[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue.Size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是，这里面需要 sort 和 PriorityQueue。Python、Java、甚至 C++ 写这个都还是比较方便的，直接用标准库里的实现。但 Golang，，，标准库的这两个东西有点诡异，用起来没那么方便。</p><p>所以，我们先试试自己实现<strong>排序</strong>和<strong>优先队列</strong>，练习一下，也当是追忆以前写 C 时那种啥都自己写的时光。</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>优先队列一般我们使用堆去实现，但这里为了方便，我们直接维护一个切片，每次插入元素的时候排个序也就“优先队列”了。</p><p>我们先写一个快速排序，让 courses 的排序和优先队列都基于这个快排。</p><p>由于 courses 是 <code>[][]int</code>，优先队列是 <code>[]int</code>，我们写一种通用的——对 <code>[]interface&#123;&#125;</code> 的快排，这个代码还是很传统的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">q := partition(pA, p, r, le)</span><br><span class="line">quick_sort(pA, p, q<span class="number">-1</span>, le)</span><br><span class="line">quick_sort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">A := (*pA)</span><br><span class="line"></span><br><span class="line">q := p</span><br><span class="line"><span class="keyword">for</span> u := p; u &lt; r; u++ &#123;</span><br><span class="line"><span class="keyword">if</span> le(A[u], A[r]) &#123;</span><br><span class="line">A[q], A[u] = A[u], A[q]</span><br><span class="line">q++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A[q], A[r] = A[r], A[q]</span><br><span class="line"><span class="keyword">return</span> q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把它封装一层，分别提供<code>[][]int</code>、<code>[]int</code> 的排序接口，其实这两个代码基本是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_sint</span><span class="params">(pA *([]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">(*pA)[i] = v.(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_ssint</span><span class="params">(pA *([][]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">(*pA)[i] = v.([]<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好了排序，再看优先队列，实现基本的入、出、顶、大小、空判断就好：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">push</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">q.data = <span class="built_in">append</span>(q.data, element)</span><br><span class="line">quick_sort_sint(&amp;q.data, <span class="number">0</span>, <span class="built_in">len</span>(q.data)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.(<span class="keyword">int</span>) &lt;= a.(<span class="keyword">int</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">poll</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">r := q.data[<span class="number">0</span>]</span><br><span class="line">q.data = q.data[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合到一起，就有解了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">quick_sort_ssint(&amp;courses, <span class="number">0</span>, <span class="built_in">len</span>(courses)<span class="number">-1</span>,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.([]<span class="keyword">int</span>)[<span class="number">1</span>] &lt;= b.([]<span class="keyword">int</span>)[<span class="number">1</span>]</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">queue := PriorityQueue&#123;&#125;</span><br><span class="line">time := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line"><span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">queue.push(c[<span class="number">0</span>])</span><br><span class="line">time += c[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !queue.isEmpty() &amp;&amp; queue.top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">time += c[<span class="number">0</span>] - queue.poll()</span><br><span class="line">queue.push(c[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue.size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 优先队列 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">push</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">q.data = <span class="built_in">append</span>(q.data, element)</span><br><span class="line">quick_sort_sint(&amp;q.data, <span class="number">0</span>, <span class="built_in">len</span>(q.data)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.(<span class="keyword">int</span>) &lt;= a.(<span class="keyword">int</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">poll</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">r := q.data[<span class="number">0</span>]</span><br><span class="line">q.data = q.data[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 把对 []int 的快排转化为对 []interface&#123;&#125; 的快排  **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_sint</span><span class="params">(pA *([]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">(*pA)[i] = v.(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 把对 [][]int 的快排转化为对 []interface&#123;&#125; 的快排  **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_ssint</span><span class="params">(pA *([][]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">(*pA)[i] = v.([]<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对 []interface&#123;&#125; 的快排  **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">q := partition(pA, p, r, le)</span><br><span class="line">quick_sort(pA, p, q<span class="number">-1</span>, le)</span><br><span class="line">quick_sort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">A := (*pA)</span><br><span class="line"></span><br><span class="line">q := p</span><br><span class="line"><span class="keyword">for</span> u := p; u &lt; r; u++ &#123;</span><br><span class="line"><span class="keyword">if</span> le(A[u], A[r]) &#123;</span><br><span class="line">A[q], A[u] = A[u], A[q]</span><br><span class="line">q++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A[q], A[r] = A[r], A[q]</span><br><span class="line"><span class="keyword">return</span> q</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个版本算法是正确的，但提交运行会超时！</p><p><code>clown0te（防&#123;盗[文()爬]虫&#125;的追踪标签，读者不必在意）</code></p><h4 id="插入排序-归并排序"><a href="#插入排序-归并排序" class="headerlink" title="插入排序 + 归并排序"></a>插入排序 + 归并排序</h4><p>我们的程序里大量的排序，这个也是最主要的时间消耗，而刚才简单粗暴的全用了快排，这肯定不是最好的，考虑在这方面优化一下：</p><ol><li><code>PriorityQueue.Push</code> 数据基本有序，对基本有序的数据用快排肯定慢（所以我们有时候用快排要先把数据打乱），我们把这里改成对基本有序的数据最快的——插入排序。</li><li><code>courses</code> 的排序，既然不需要重复使用快排我们就可以把之前的 <code>interface&#123;&#125;</code> 封装去掉，直接实现一个对 <code>[][]int</code> 的排序（我还把快排改成了归并排序，只是为了好玩）</li></ol><p>先写最简单的插入排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSortReverse</span><span class="params">(pA *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">A := *pA</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">key := A[i]</span><br><span class="line">j := i - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; A[j] &lt; key &#123;</span><br><span class="line">A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">A[j+<span class="number">1</span>] = key</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，归并排序，这个代码也不是很难：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> INF = []<span class="keyword">int</span>&#123;<span class="number">99999999</span>, <span class="number">99999999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(pA *[][]<span class="keyword">int</span>, p, q, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="comment">// n1 := q - p + 1</span></span><br><span class="line"><span class="comment">// n2 := r - q</span></span><br><span class="line"><span class="comment">// b, c := make([][]int, n1+1), make([][]int, n2+1)</span></span><br><span class="line">A := *pA</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[p: q+<span class="number">1</span>]...)</span><br><span class="line">c := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[q+<span class="number">1</span>: r+<span class="number">1</span>]...)</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">append</span>(b, INF)</span><br><span class="line">c = <span class="built_in">append</span>(c, INF)</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := p; k &lt;= r; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> le(b[i], c[j]) &#123;</span><br><span class="line">A[k] = b[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">A[k] = c[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(pA *[][]<span class="keyword">int</span>, p <span class="keyword">int</span>, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">q := (p + r) / <span class="number">2</span></span><br><span class="line">mergeSort(pA, p, q, le)</span><br><span class="line">mergeSort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">merge(pA, p, q, r, le)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码写的时候要注意一点，b 和 c 这里，不能直接这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">append</span>(A[p: q+<span class="number">1</span>], INF)</span><br><span class="line">c := <span class="built_in">append</span>(A[q+<span class="number">1</span>: r+<span class="number">1</span>], INF)</span><br></pre></td></tr></table></figure><p>原因是，<strong>切片和底层数组</strong>。你构建 b 的时候往里面 append 了一个 INF，实际上是底层数组的<code>A[q+1]</code> 位置变成了 INF，所以再构建 c 的时候，切片 <code>A[q+1: r+1]</code> 的值就成了 <code>[INF, ...]</code>，然后归并就爆炸了💥。</p><p>把代码合一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">mergeSort(&amp;courses, <span class="number">0</span>, <span class="built_in">len</span>(courses)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span> <span class="params">(a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>] &lt;= b[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">queue := PriorityQueue&#123;&#125;</span><br><span class="line">time := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line"><span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">queue.Push(c[<span class="number">0</span>])</span><br><span class="line">time += c[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !queue.IsEmpty() &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">time += c[<span class="number">0</span>] - queue.Poll()</span><br><span class="line">queue.Push(c[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue.Size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 优先队列 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Push</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">q.data = <span class="built_in">append</span>(q.data, element)</span><br><span class="line">insertSortReverse(&amp;q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Poll</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">r := q.data[<span class="number">0</span>]</span><br><span class="line">q.data = q.data[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  对 []int 的插入排序**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSortReverse</span><span class="params">(pA *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">A := *pA</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">key := A[i]</span><br><span class="line">j := i - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; A[j] &lt; key &#123;</span><br><span class="line">A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">A[j+<span class="number">1</span>] = key</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对 [][]int 的归并排序 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> INF = []<span class="keyword">int</span>&#123;<span class="number">99999999</span>, <span class="number">99999999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(pA *[][]<span class="keyword">int</span>, p, q, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="comment">// n1 := q - p + 1</span></span><br><span class="line"><span class="comment">// n2 := r - q</span></span><br><span class="line"><span class="comment">// b, c := make([][]int, n1+1), make([][]int, n2+1)</span></span><br><span class="line">A := *pA</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[p: q+<span class="number">1</span>]...)</span><br><span class="line">c := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[q+<span class="number">1</span>: r+<span class="number">1</span>]...)</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">append</span>(b, INF)</span><br><span class="line">c = <span class="built_in">append</span>(c, INF)</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := p; k &lt;= r; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> le(b[i], c[j]) &#123;</span><br><span class="line">A[k] = b[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">A[k] = c[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(pA *[][]<span class="keyword">int</span>, p <span class="keyword">int</span>, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">q := (p + r) / <span class="number">2</span></span><br><span class="line">mergeSort(pA, p, q, le)</span><br><span class="line">mergeSort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">merge(pA, p, q, r, le)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一个版本就可以通过了：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geq2tnkgy4j30p605yjs3.jpg" alt="Leetcode 执行结果截图，执行用时 580 ms, 在所有 Go 提交中击败了50.00%的用户;内存消耗 8.1 MB, 在所有 Go 提交中击败了100.00%的用户"></p><h4 id="标准库-sort-heap"><a href="#标准库-sort-heap" class="headerlink" title="标准库 sort + heap"></a>标准库 sort + heap</h4><p>Go 的标准库还是很强大的，但是标准库的设计相当的 Golang，才从其他语言转过来用着真的很不习惯（比如 math 包里连 Max 都没有），不过多用用这些东西、多看看它们的源码（Go 标准库的好多源码写的挺有意思的），对理解 Go 的思想很有帮助。</p><p>我们用到的两个东西，排序和优先队列，Go 标准库里其实都有可用的：</p><ul><li>排序：<code>sort</code> 包</li><li>优先队列：<code>container/heap</code> 包，Go 没有直接的优先队列，但我们可以用堆来快速实现一个。</li></ul><p>首先看排序：</p><blockquote><p><strong>Package sort</strong></p><p>Package sort provides primitives for sorting slices and user-defined collections.</p></blockquote><p><code>sort</code> 包里已经封装好了很多我们常用的排序情况，比如，对整数切片 <code>[]int</code> 的排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// unsorted</span></span><br><span class="line">sort.Ints(s)</span><br><span class="line">fmt.Println(s)<span class="comment">// [1 2 3 4 5 6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种用起来很方便，但我们现在要排一个 <code>[][]int</code> 这就不太常规了。对这种非常规东西的排序，go 提供的方式和其他语言有一些区别。</p><p>大多数语言，对这种非常规东西的排序，我们是把一个可迭代对象传进去，然后给他一个函数，告诉它比较的结果。例如，这是 C++ STL 的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myvector</span> <span class="params">(myints, myints+<span class="number">8</span>)</span></span>;<span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line">    <span class="comment">// using function as comp</span></span><br><span class="line"><span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction);<span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言里也有这种用法，它提供了一个<code>sort.Slice</code> 对任意切片进行排序，比如这是一个文档里的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Name &lt; people[j].Name &#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;By name:&quot;</span>, people) <span class="comment">// By name: [&#123;Alice 55&#125; &#123;Bob 75&#125; &#123;Gopher 7&#125; &#123;Vera 24&#125;]</span></span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;By age:&quot;</span>, people) <span class="comment">// By age: [&#123;Gopher 7&#125; &#123;Vera 24&#125; &#123;Alice 55&#125; &#123;Bob 75&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里对 <code>[][]int</code> 排序的需求可以解决了，but we do need one more thing.</p><p>Go 还提供了一种更加 Go 风格的排序：<code>sort.Sort</code>。</p><blockquote><p><code>func Sort(data Interface)</code></p><p>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</p></blockquote><p>这玩意儿是传一个 <code>sort.Interface</code> 的实现进来，这真的很 Golang！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>长度、大小、交换的方法都由你来定。其实一般用起来还是很简单的，Len、Swap基本就这样，一般要改的只有 Less（只改Less，其实也差不多就是 sort.Slice，但内部实现还是有所区别的）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByAge implements sort.Interface for []Person based on</span></span><br><span class="line"><span class="comment">// the Age field.</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []Person&#123;</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;John&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Michael&quot;</span>, <span class="number">17</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Jenny&quot;</span>, <span class="number">26</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(people)</span><br><span class="line"></span><br><span class="line">sort.Sort(ByAge(people))</span><br><span class="line">fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>排序的问题解决了，再看优先队列：</p><blockquote><p>Package container/heap</p><p>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</p><p>The minimum element in the tree is the root, at index 0.</p><p>A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.</p></blockquote><p>优先队列可以用堆来实现，实现一个堆要实现 heap.Interface，你可以看到，这个接口是“继承”了 sort.Interface 的，这也是为什么我们刚才要介绍它的原因：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体要怎么做，其实 Go 的文档里给出了些优先队列的例子了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates a priority queue built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line"><span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line"><span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">pq[i].index = i</span><br><span class="line">pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*pq)</span><br><span class="line">item := x.(*Item)</span><br><span class="line">item.index = n</span><br><span class="line">*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *pq</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">item := old[n<span class="number">-1</span>]</span><br><span class="line">old[n<span class="number">-1</span>] = <span class="literal">nil</span>  <span class="comment">// avoid memory leak</span></span><br><span class="line">item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">*pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">item.value = value</span><br><span class="line">item.priority = priority</span><br><span class="line">heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Some items and their priorities.</span></span><br><span class="line">items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line"><span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">pq[i] = &amp;Item&#123;</span><br><span class="line">value:    value,</span><br><span class="line">priority: priority,</span><br><span class="line">index:    i,</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">item := &amp;Item&#123;</span><br><span class="line">value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">priority: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">heap.Push(&amp;pq, item)</span><br><span class="line">pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line"><span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>真正用起来没有这么难，它这个是比较一般的情况了。我们这里需要的只是一个简单的基于 <code>[]int</code> 的堆，可以简化很多的。</p><p>用库就比较简单，直接写全部的代码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sort.Slice(courses, <span class="function"><span class="keyword">func</span> <span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> courses[i][<span class="number">1</span>] &lt; courses[j][<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">queue := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">time := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line"><span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">time += c[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.Len() != <span class="number">0</span> &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">time += c[<span class="number">0</span>] - heap.Pop(queue).(<span class="keyword">int</span>)</span><br><span class="line">heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> queue.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Swap</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">q[a], q[b] = q[b], q[a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Less</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q[a] &gt; q[b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">v := (*q)[q.Len()<span class="number">-1</span>]</span><br><span class="line">*q = (*q)[: q.Len()<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 scheduleCourse 里调用 PriorityQueue 时要注意，我们使用的必须是 <code>heap.Push</code> 和 <code>heap.Pop</code>，不能去调用自己写的那个 <code>queue.Push/Pop</code>，heap.Push、Pop 才能保证堆的正确性。</p><p>这个可以通过，执行用时 152 ms（击败87.5%），内存消耗：7.3 MB。还有人写的比这快？</p><p>我看了一下 sort.Slice 源码，它用了些反射（reflectlite）😂，所以比 sort.Sort 慢（sort.Sort没有反射），那些写的更快的人都是用  sort.Sort ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> coursesSoted SS4Sort = courses</span><br><span class="line">sort.Sort(coursesSoted)</span><br><span class="line"></span><br><span class="line">queue := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">time := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> coursesSoted &#123;</span><br><span class="line"><span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">time += c[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.Len() != <span class="number">0</span> &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">time += c[<span class="number">0</span>] - heap.Pop(queue).(<span class="keyword">int</span>)</span><br><span class="line">heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> queue.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对 [][]int 排序的接口 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SS4Sort [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SS4Sort)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SS4Sort)</span> <span class="title">Swap</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[a], s[b] = s[b], s[a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SS4Sort)</span> <span class="title">Less</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> s[a][<span class="number">1</span>] &lt; s[b][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 优先队列 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Swap</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">q[a], q[b] = q[b], q[a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Less</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q[a] &gt; q[b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">v := (*q)[q.Len()<span class="number">-1</span>]</span><br><span class="line">*q = (*q)[: q.Len()<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqkex0ey2j30oa05oaar.jpg" alt="Leetcode 执行结果截图，执行用时 136 ms, 在所有 Go 提交中击败了100.00%的用户; 内存消耗 7.3 MB, 在所有 Go 提交中击败了100.00%的用户"></p><p>哎，，Go 还是写结构化比较强的东西好用。这种库里大量的接口需要自己写实现，在工程里倒是挺好用，但拿来解这种小问题写起来就各种不方便了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之初窥神经网络</title>
      <link href="/2020/05/12/DeepLearningWithPython/Deep-Learning%20with-Python-ch2/"/>
      <url>/2020/05/12/DeepLearningWithPython/Deep-Learning%20with-Python-ch2/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-with-Python"><a href="#Deep-Learning-with-Python" class="headerlink" title="Deep Learning with Python"></a>Deep Learning with Python</h1><p>这篇文章是我学习《Deep Learning with Python》(第二版，François Chollet 著) 时写的系列笔记之一。文章的内容是从  Jupyter notebooks 转成 Markdown 的，当我完成所以文章后，会在 GitHub 发布我写的所有  Jupyter notebooks。</p><p>你可以在这个网址在线阅读这本书的正版原文(英文)：<a href="https://livebook.manning.com/book/deep-learning-with-python">https://livebook.manning.com/book/deep-learning-with-python</a></p><p>这本书的作者也给出了一套 Jupyter notebooks：<a href="https://github.com/fchollet/deep-learning-with-python-notebooks">https://github.com/fchollet/deep-learning-with-python-notebooks</a></p><hr><p>本文为 <strong>第2章 开始之前：神经网络背后的数学</strong> (Chapter 2. Before we begin: the mathematical building blocks of neural networks) 的笔记整合。</p><p>本文目录：</p><p>[TOC]</p><h2 id="初窥神经网络"><a href="#初窥神经网络" class="headerlink" title="初窥神经网络"></a>初窥神经网络</h2><p>学编程语言从 “Hello World” 开始，学 Deep learning 从 <code>MINST</code> 开始。</p><p>MNIST 用来训练手写数字识别， 它包含 28x28 的灰度手写图片，以及每张图片对应的标签(0~9的值)。</p><h3 id="导入MNIST数据集"><a href="#导入MNIST数据集" class="headerlink" title="导入MNIST数据集"></a>导入MNIST数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loading the MNIST dataset in Keras</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br></pre></td></tr></table></figure><p>看一下训练集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(train_images.shape)</span><br><span class="line">print(train_labels.shape)</span><br><span class="line">train_labels</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(60000, 28, 28)(60000,)array([5, 0, 4, ..., 5, 6, 8], dtype=uint8)</code></pre><p>这是测试集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(test_images.shape)</span><br><span class="line">print(test_labels.shape)</span><br><span class="line">test_labels</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(10000, 28, 28)(10000,)array([7, 2, 1, ..., 4, 5, 6], dtype=uint8)</code></pre><h3 id="网络构建"><a href="#网络构建" class="headerlink" title="网络构建"></a>网络构建</h3><p>我们来构建一个用来学习 MNIST 集的神经网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line">network = models.Sequential()</span><br><span class="line">network.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">28</span> * <span class="number">28</span>, )))</span><br><span class="line">network.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure><p>神经网络是一个个「层」组成的。<br>一个「层」就像是一个“蒸馏过滤器”，它会“过滤”处理输入的数据，从里面“精炼”出需要的信息，然后传到下一层。</p><p>这样一系列的「层」组合起来，像流水线一样对数据进行处理。<br>层层扬弃，让被处理的数据，或者说“数据的表示”对我们最终希望的结果越来越“有用”。</p><p>我们刚才这段代码构建的网络包含两个「Dense 层」，这么叫是因为它们是密集连接（densely connected）或者说是 <em>全连接</em> 的。</p><p>数据到了最后一层（第二层），是一个 <strong>10路</strong> 的 softmax 层。<br>这个层输出的是一个数组，包含 10 个概率值（它们的和为1），这个输出「表示」的信息就对我们预测图片对应的数字相当有用了。<br>事实上这输出中的每一个概率值就分别代表输入图片属于10个数字（0～9）中的一个的概率！</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>接下来，我们要 <em>编译</em> 这个网络，这个步骤需要给3个参数：</p><ul><li>损失函数：评价你这网络表现的好不好的函数</li><li>优化器：怎么更新（优化）你这个网络</li><li>训练和测试过程中需要监控的指标，比如这个例子里，我们只关心一个指标 —— 预测的精度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">network.<span class="built_in">compile</span>(loss=<span class="string">&quot;categorical_crossentropy&quot;</span>,</span><br><span class="line">                optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">                metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="图形处理"><a href="#图形处理" class="headerlink" title="图形处理"></a>图形处理</h4><p>我们还需要处理一下图形数据，把它变成我们的网络认识的样子。</p><p>MNIST 数据集里的图片是 28x28 的，每个值是属于 [0, 255] 的 uint8。<br>而我们的神经网络想要的是 28x28 的在 [0, 1] 中的 float32。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_images = train_images.reshape((<span class="number">60000</span>, <span class="number">28</span> * <span class="number">28</span>))</span><br><span class="line">train_images = train_images.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">test_images = test_images.reshape((<span class="number">10000</span>, <span class="number">28</span> * <span class="number">28</span>))</span><br><span class="line">test_images = test_images.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255</span></span><br></pre></td></tr></table></figure><h4 id="标签处理"><a href="#标签处理" class="headerlink" title="标签处理"></a>标签处理</h4><p>同样，标签也是需要处理一下的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">train_labels = to_categorical(train_labels)</span><br><span class="line">test_labels = to_categorical(test_labels)</span><br></pre></td></tr></table></figure><h3 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.fit(train_images, train_labels, epochs=<span class="number">5</span>, batch_size=<span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>Train on 60000 samplesEpoch 1/560000/60000 [==============================] - 3s 49us/sample - loss: 0.2549 - accuracy: 0.9254Epoch 2/560000/60000 [==============================] - 2s 38us/sample - loss: 0.1025 - accuracy: 0.9693Epoch 3/560000/60000 [==============================] - 2s 35us/sample - loss: 0.0676 - accuracy: 0.9800Epoch 4/560000/60000 [==============================] - 2s 37us/sample - loss: 0.0491 - accuracy: 0.9848Epoch 5/560000/60000 [==============================] - 2s 42us/sample - loss: 0.0369 - accuracy: 0.9888&lt;tensorflow.python.keras.callbacks.History at 0x13a7892d0&gt;</code></pre><p>可以看到，训练很快，一会儿就对训练集有 98%+ 的精度了。</p><p>再用测试集去试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_loss, test_acc = network.evaluate(test_images, test_labels, verbose=<span class="number">2</span>)    <span class="comment"># verbose=2 to avoid a looooong progress bar that fills the screen with &#x27;=&#x27;. https://github.com/tensorflow/tensorflow/issues/32286</span></span><br><span class="line">print(<span class="string">&#x27;test_acc:&#x27;</span>, test_acc)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>10000/1 - 0s - loss: 0.0362 - accuracy: 0.9789test_acc: 0.9789</code></pre><p>我们训练好的网络在测试集下的表现并没有之前在训练集中那么好，这是「过拟合」的锅。</p><h2 id="神经网络的数据表示"><a href="#神经网络的数据表示" class="headerlink" title="神经网络的数据表示"></a>神经网络的数据表示</h2><p>Tensor，张量，任意维的数组（我的意思是编程的那种数组）。矩阵是二维的张量。</p><p>我们常把「张量的维度」说成「轴」。</p><h3 id="认识张量"><a href="#认识张量" class="headerlink" title="认识张量"></a>认识张量</h3><h4 id="标量-0D-Tensors"><a href="#标量-0D-Tensors" class="headerlink" title="标量 (0D Tensors)"></a>标量 (0D Tensors)</h4><p>Scalars，标量是 0 维的张量（0个轴），包含一个数。</p><p>标量在 numpy 中可以用 float32 或 float64 表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="number">12</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array(12)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.ndim    <span class="comment"># 轴数（维数）</span></span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>1</code></pre><h4 id="向量-1D-Tensors"><a href="#向量-1D-Tensors" class="headerlink" title="向量 (1D Tensors)"></a>向量 (1D Tensors)</h4><p>Vectors，向量是 1 维张量（有1个轴），包含一列标量（就是搞个array装标量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([1, 2, 3, 4, 5])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.ndim</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>1</code></pre><p>我们把这样有5个元素的向量叫做“5维向量”。<br>但注意<strong>5D向量</strong>可不是<strong>5D张量</strong>！</p><ul><li>5D向量：只有1个轴，在这个轴上有5个维度。</li><li>5D张量：有5个轴，在每个轴上可以有任意维度。</li></ul><p>这个就很迷，这“维度”有的时候是指轴数，有的时候是指轴上的元素个数。</p><p>所以，我们最好换种说法，用「阶」来表示轴数，说 <strong>5阶张量</strong>。</p><h4 id="矩阵-2D-Tensors"><a href="#矩阵-2D-Tensors" class="headerlink" title="矩阵 (2D Tensors)"></a>矩阵 (2D Tensors)</h4><p>Matrices，矩阵是 2 阶张量（2个轴，就是我们说的「行」和「列」），包含一列向量（就是搞个array装向量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">5</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">6</span>, <span class="number">79</span>, <span class="number">3</span>, <span class="number">35</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">80</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">2</span>]])</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([[ 5, 78,  2, 34,  0],       [ 6, 79,  3, 35,  1],       [ 7, 80,  4, 36,  2]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.ndim</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>2</code></pre><h4 id="高阶张量"><a href="#高阶张量" class="headerlink" title="高阶张量"></a>高阶张量</h4><p>你搞个装矩阵的 array 就得到了3阶张量。</p><p>再搞个装3阶张量的 array 就得到了4阶张量，依次类推，就有高阶张量了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[[<span class="number">5</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">0</span>],</span><br><span class="line">               [<span class="number">6</span>, <span class="number">79</span>, <span class="number">3</span>, <span class="number">35</span>, <span class="number">1</span>],</span><br><span class="line">               [<span class="number">7</span>, <span class="number">80</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">2</span>]],</span><br><span class="line">              [[<span class="number">5</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">0</span>],</span><br><span class="line">               [<span class="number">6</span>, <span class="number">79</span>, <span class="number">3</span>, <span class="number">35</span>, <span class="number">1</span>],</span><br><span class="line">               [<span class="number">7</span>, <span class="number">80</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">2</span>]],</span><br><span class="line">              [[<span class="number">5</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">0</span>],</span><br><span class="line">               [<span class="number">6</span>, <span class="number">79</span>, <span class="number">3</span>, <span class="number">35</span>, <span class="number">1</span>],</span><br><span class="line">               [<span class="number">7</span>, <span class="number">80</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">2</span>]]])</span><br><span class="line">x.ndim</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>3</code></pre><p>深度学习里，我们一般就用0～4阶的张量。</p><h3 id="张量的三要素"><a href="#张量的三要素" class="headerlink" title="张量的三要素"></a>张量的三要素</h3><ul><li>阶数（轴的个数）：3，5，…</li><li>形状（各轴维数）：(2, 1, 3)，(6, 5, 5, 3, 6)，…</li><li>数据类型：float32，uint8，…</li></ul><p>我们来看看 MNIST 里的张量数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">print(train_images.ndim)</span><br><span class="line">print(train_images.shape)</span><br><span class="line">print(train_images.dtype)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>3(60000, 28, 28)uint8</code></pre><p>所以 train_images 是个8位无符号整数的3阶张量。</p><p>打印个里面的图片看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digit = train_images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;image:&quot;</span>)</span><br><span class="line">plt.imshow(digit, cmap=plt.cm.binary)</span><br><span class="line">plt.show()</span><br><span class="line">print(<span class="string">&quot;label: &quot;</span>, train_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepeqfrnx9j3073070747.jpg" alt="一张图片，显示了一个位于图像中央的数字5"></p><pre><code>label:  5</code></pre><h3 id="Numpy张量操作"><a href="#Numpy张量操作" class="headerlink" title="Numpy张量操作"></a>Numpy张量操作</h3><h4 id="张量切片："><a href="#张量切片：" class="headerlink" title="张量切片："></a>张量切片：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_slice = train_images[<span class="number">10</span>:<span class="number">100</span>]</span><br><span class="line">print(my_slice.shape)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(90, 28, 28)</code></pre><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_slice = train_images[<span class="number">10</span>:<span class="number">100</span>, :, :]</span><br><span class="line">print(my_slice.shape)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(90, 28, 28)</code></pre><p>也等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_slice = train_images[<span class="number">10</span>:<span class="number">100</span>, <span class="number">0</span>:<span class="number">28</span>, <span class="number">0</span>:<span class="number">28</span>]</span><br><span class="line">print(my_slice.shape)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(90, 28, 28)</code></pre><p>选出 <strong>右下角</strong> 14x14 的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_slice = train_images[:, <span class="number">14</span>:, <span class="number">14</span>:]</span><br><span class="line">plt.imshow(my_slice[<span class="number">0</span>], cmap=plt.cm.binary)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepeimx6pwj3073070a9v.jpg" alt="一张图片，在左上角有数字5的一部分"></p><p>选出 中心处 14x14 的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_slice = train_images[:, <span class="number">7</span>:-<span class="number">7</span>, <span class="number">7</span>:-<span class="number">7</span>]</span><br><span class="line">plt.imshow(my_slice[<span class="number">0</span>], cmap=plt.cm.binary)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepeiqkaq6j3073070jr7.jpg" alt="一张图片，显示了一个数字5，占满了整个图片"></p><h4 id="数据批量"><a href="#数据批量" class="headerlink" title="数据批量"></a>数据批量</h4><p>深度学习的数据里，一般第一个轴（index=0）叫做「样本轴」（或者说「样本维度」）。</p><p>深度学习里，我们一般不会一次性处理整个数据集，我们一批一批地处理。</p><p>在 MNIST 中，我们的一个批量是 128 个数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一批</span></span><br><span class="line">batch = train_images[:<span class="number">128</span>]</span><br><span class="line"><span class="comment"># 第二批</span></span><br><span class="line">batch = train_images[<span class="number">128</span>:<span class="number">256</span>]</span><br><span class="line"><span class="comment"># 第n批</span></span><br><span class="line">n = <span class="number">12</span></span><br><span class="line">batch = train_images[<span class="number">128</span> * n : <span class="number">128</span> * (n+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>所以，在使用 batch 的时候，我们也把第一个轴叫做「批量轴」。</p><h3 id="常见数据张量表示"><a href="#常见数据张量表示" class="headerlink" title="常见数据张量表示"></a>常见数据张量表示</h3><table><thead><tr><th align="center">数据</th><th align="center">张量维数</th><th align="left">形状</th></tr></thead><tbody><tr><td align="center">向量数据</td><td align="center">2D</td><td align="left">(samples,features)</td></tr><tr><td align="center">时间序列</td><td align="center">3D</td><td align="left">(samples, timesteps, features)</td></tr><tr><td align="center">图像</td><td align="center">4D</td><td align="left">(samples, height, width, channels) 或 (samples, channels, height, width)</td></tr><tr><td align="center">视频</td><td align="center">5D</td><td align="left">(samples, frames, height, width, channels) 或 (samples, frames, channels, height, width)</td></tr></tbody></table><h2 id="神经网络的“齿轮”-张量运算"><a href="#神经网络的“齿轮”-张量运算" class="headerlink" title="神经网络的“齿轮”: 张量运算"></a>神经网络的“齿轮”: 张量运算</h2><p>在我们的第一个神经网络例子中(MNIST)，我们的每一层其实都是对输入数据做了类似如下的运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output &#x3D; relu(dot(W, input) + b)</span><br></pre></td></tr></table></figure><p>input 是输入，<br>W 和 b 是层的属性，<br>output 是输出。</p><p>这些东西之间做了 relu、dot、add 运算，<br>接下来我们会解释这些运算。</p><h3 id="逐元素操作-Element-wise"><a href="#逐元素操作-Element-wise" class="headerlink" title="逐元素操作(Element-wise)"></a>逐元素操作(Element-wise)</h3><p>Element-wise 的操作，就是分别对张量中的每一个元素作用。<br>比如，我们实现一个简单的 <code>relu</code> （<code>relu(x) = max(x, 0)</code>）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_relu</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(x.shape) == <span class="number">2</span>    <span class="comment"># x is a 2D Numpy tensor.</span></span><br><span class="line">    x = x.copy()    <span class="comment"># Avoid overwriting the input tensor.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">1</span>]):</span><br><span class="line">            x[i, j] = <span class="built_in">max</span>(x[i, j], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>加法也是逐元素操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># assert x and y are 2D Numpy tensors and have the same shape.</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(x.shape) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> x.shape == y.shape</span><br><span class="line">    </span><br><span class="line">    x = x.copy()    <span class="comment"># Avoid overwriting the input tensor.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">1</span>]):</span><br><span class="line">            x[i, j] += y[i, j]</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>在 Numpy 里，这些都写好了。 具体的运算是交给 C 或 Fortran 写的 BLAS 进行的，速度很高。</p><p>你可以这样查看有没有装 BLAS：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.show_config()</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>blas_mkl_info:  NOT AVAILABLEblis_info:  NOT AVAILABLEopenblas_info:    libraries = [&#39;openblas&#39;, &#39;openblas&#39;]    library_dirs = [&#39;/usr/local/lib&#39;]    language = c    define_macros = [(&#39;HAVE_CBLAS&#39;, None)]blas_opt_info:    libraries = [&#39;openblas&#39;, &#39;openblas&#39;]    library_dirs = [&#39;/usr/local/lib&#39;]    language = c    define_macros = [(&#39;HAVE_CBLAS&#39;, None)]lapack_mkl_info:  NOT AVAILABLEopenblas_lapack_info:    libraries = [&#39;openblas&#39;, &#39;openblas&#39;]    library_dirs = [&#39;/usr/local/lib&#39;]    language = c    define_macros = [(&#39;HAVE_CBLAS&#39;, None)]lapack_opt_info:    libraries = [&#39;openblas&#39;, &#39;openblas&#39;]    library_dirs = [&#39;/usr/local/lib&#39;]    language = c    define_macros = [(&#39;HAVE_CBLAS&#39;, None)]</code></pre><p>下面是如何使用 numpy 的逐元素 relu、add：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>],</span><br><span class="line">              [<span class="number">3</span>, -<span class="number">1</span>, <span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], </span><br><span class="line">              [-<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>], </span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">c = a + b    <span class="comment"># Element-wise addition</span></span><br><span class="line">d = np.maximum(c, <span class="number">0</span>)    <span class="comment"># Element-wise relu</span></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>[[ 7  9 11] [-3 -1 -2] [ 4 -1  8]][[ 7  9 11] [ 0  0  0] [ 4  0  8]]</code></pre><h3 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h3><p>当进行逐元素运算时，如果两个张量的形状不同，在可行的情况下，较小的张量会「广播」成和较大的张量一样的形状。</p><p>具体来说，可以通过广播，对形状为 <code>(a, b, ..., n, n+1, ..., m)</code> 和 <code>(n, n+1, ..., m)</code> 的两个张量进行逐元素运算。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.random((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">10</span>))    <span class="comment"># x is a random tensor with shape (64, 3, 32, 10).</span></span><br><span class="line">y = np.random.random((<span class="number">32</span>, <span class="number">10</span>))    <span class="comment"># y is a random tensor with shape (32, 10).</span></span><br><span class="line">z = np.maximum(x, y)    <span class="comment"># The output z has shape (64, 3, 32, 10) like x.</span></span><br></pre></td></tr></table></figure><p>广播的操作如下：</p><ol><li>小张量增加轴（广播轴），加到和大的一样（ndim）</li><li>小张量的元素在新轴上重复，加到和大的一样（shape）</li></ol><p>E.g. </p><pre><code>x: (32, 10), y: (10,)Step 1: add an empty first axis to y: Y -&gt; (1, 10)Step 2: repeat y 32 times alongside this new axis: Y -&gt; (32, 10)</code></pre><p>在完成后，有 <code>Y[i, :] == y for i in range(0, 32)</code></p><p>当然，在实际的实现里，我们不这样去复制，这样太浪费空间了，<br>我们是直接在算法里实现这个“复制的”。<br>比如，我们实现一个简单的向量和矩阵相加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_add_matrix_and_vector</span>(<span class="params">m, v</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(m.shape) == <span class="number">2</span>    <span class="comment"># m is a 2D Numpy tensor.</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(v.shape) == <span class="number">1</span>    <span class="comment"># v is a Numpy vector.</span></span><br><span class="line">    <span class="keyword">assert</span> m.shape[<span class="number">1</span>] == v.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    m = m.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m.shape[<span class="number">1</span>]):</span><br><span class="line">            m[i, j] += v[j]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">naive_add_matrix_and_vector(np.array([[<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]), </span><br><span class="line">                            np.array([<span class="number">1</span>, -<span class="number">1</span>, <span class="number">100</span>]))</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([[  2,   1, 103],       [  5,   4, 106],       [  8,   7, 109]])</code></pre><h3 id="张量点积-dot"><a href="#张量点积-dot" class="headerlink" title="张量点积(dot)"></a>张量点积(dot)</h3><p>张量点积，或者叫张量乘积，在 numpy 里用 <code>dot(x, y)</code> 完成。</p><p>点积的操作可以从如下的简单程序中看出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向量点积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_vector_dot</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(x.shape) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(y.shape) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> x.shape[<span class="number">0</span>] == y.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    z = <span class="number">0.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        z += x[i] * y[i]</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵与向量点积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_matrix_vector_dot</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    z = np.zeros(x.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        z[i] = naive_vector_dot(x[i, :], y)</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵点积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_matrix_dot</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(x.shape) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(y.shape) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> x.shape[<span class="number">1</span>] == y.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    z = np.zeros((x.shape[<span class="number">0</span>], y.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y.shape[<span class="number">1</span>]):</span><br><span class="line">            row_x = x[i, :]</span><br><span class="line">            column_y = y[:, j]</span><br><span class="line">            z[i, j] = naive_vector_dot(row_x, column_y)</span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>],</span><br><span class="line">              [<span class="number">3</span>, -<span class="number">1</span>, <span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], </span><br><span class="line">              [-<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>], </span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line">naive_matrix_dot(a, b)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([[  5.,   1.,  22.],       [-13., -13., -18.],       [ 24.,  24.,  39.]])</code></pre><p>对于高维的张量点积，其实也是一样的。<br>例如，(这说的是shape哈)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a, b, c, d) . (d,) -&gt; (a, b, c)</span><br><span class="line">(a, b, c, d) . (d, e) -&gt; (a, b, c, e)</span><br></pre></td></tr></table></figure><h3 id="张量变形-reshaping"><a href="#张量变形-reshaping" class="headerlink" title="张量变形(reshaping)"></a>张量变形(reshaping)</h3><p>这个操作，简言之就是，，，还是那些元素，只是排列的方式变了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">              [<span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">              [<span class="number">4.</span>, <span class="number">5.</span>]])</span><br><span class="line">print(x.shape)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(3, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.reshape((<span class="number">6</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([[0.],       [1.],       [2.],       [3.],       [4.],       [5.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.reshape((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>array([[0., 1., 2.],       [3., 4., 5.]])</code></pre><p>「转置」(transposition) 是一种特殊的矩阵变形，<br>转置就是行列互换。</p><p>原来的 <code>x[i, :]</code>，转置后就成了 <code>x[:, i]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.zeros((<span class="number">300</span>, <span class="number">20</span>))</span><br><span class="line">y = np.transpose(x)</span><br><span class="line">print(y.shape)</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>(20, 300)</code></pre><h2 id="神经网络的“引擎”-基于梯度的优化"><a href="#神经网络的“引擎”-基于梯度的优化" class="headerlink" title="神经网络的“引擎”: 基于梯度的优化"></a>神经网络的“引擎”: 基于梯度的优化</h2><p>再看一次我们的第一个神经网络例子中(MNIST)，每一层对输入数据做的运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output &#x3D; relu(dot(W, input) + b)</span><br></pre></td></tr></table></figure><p>这个式子里：W 和 b 是层的属性（权重，或着说可训练参数）。<br>具体来说，</p><ul><li><code>W</code> 是 kernel 属性；</li><li><code>b</code> 是 bias 属性。</li></ul><p>这些「权重」就是神经网络从数据中学习到的东西。</p><p>一开始，这些权重被随机初始化成一些较小的值。然后从这次随机的输出开始，反馈调节，逐步改善。</p><p>这个改善的过程是在「训练循环」中完成的，只有必要，这个循环可以一直进行下去：</p><ol><li>抽取一批训练数据 x 以及对应的 y</li><li>向前传播，得到 x 经过网络算出来的预测 y_pred</li><li>通过 y_pred 与 y，计算出损失</li><li>通过某种方式调整参数，减小损失</li></ol><p>前三步都比较简单，第4步更新参数比较复杂，一种比较有效、可行的办法就是利用可微性，通过计算梯度，向梯度的反方向移动参数。</p><h3 id="导数-derivative"><a href="#导数-derivative" class="headerlink" title="导数(derivative)"></a>导数(derivative)</h3><p>这一节解释了导数的定义。</p><p>(直接去看书吧。)</p><p>知道了导数，那要更新 x 来最小化一个函数 <code>f(x)</code>，其实只需将 x 向导数的反方向移动。</p><h3 id="梯度-gradient"><a href="#梯度-gradient" class="headerlink" title="梯度(gradient)"></a>梯度(gradient)</h3><p>「梯度」是张量运算的导数。或者说「梯度」是「导数」在多元函数上的推广。<br>某点的梯度代表的是该点的曲率。</p><p>考虑:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_pred &#x3D; dot(W, x)</span><br><span class="line">loss_value &#x3D; loss(y_pred, y)</span><br></pre></td></tr></table></figure><p>若固定 x 和 y，则 loss_value 将是一个 W 的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss_value &#x3D; f(W)</span><br></pre></td></tr></table></figure><p>设当前点为 <code>W0</code>，<br>则 f 在 W0 的导数(梯度)记为 <code>gradient(f)(W0)</code>，<br>这个梯度值与 W 同型。<br>其中每个元素 <code>gradient(f) (W0)[i, j]</code> 代表改变 <code>W0[i, j]</code> 时，f 的变化方向及大小。</p><p>所以，要改变 W 的值来实现 <code>min f</code>，就可以向梯度的反方向（即<strong>梯度下降</strong>的方向）移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W1 &#x3D; W0 - step * gradient(f)(W0)</span><br></pre></td></tr></table></figure><h3 id="随机梯度下降-Stochastic-gradient-descent"><a href="#随机梯度下降-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降(Stochastic gradient descent)"></a>随机梯度下降(Stochastic gradient descent)</h3><p>理论上，给定一个可微函数，其最小值一定在导数为0的点中取到。所以我们只有求出所有导数为0的点，比较其函数值，就可以得到最小值。</p><p>这个方法放到神经网络中，就需要解一个关于 <code>W</code> 的方程 <code>gradient(f)(W) = 0</code>，这是个 N 元方程（N=神经网络中参数个数），而实际上N一般不会少于1k，这使得解这个方程变得几乎不可行。</p><p>所以面对这个问题，我们利用上面介绍的4步法，其中第四步使用梯度下降，逐步往梯度的反方向更新参数，一小步一小步地朝减小损失的方向前进：</p><ol><li>抽取一批训练数据 x 以及对应的 y</li><li>向前传播，得到 x 经过网络算出来的预测 y_pred</li><li>通过 y_pred 与 y，计算出损失</li><li>通过某种方式调整参数，减小损失<ol><li>向后传播，计算损失函数关于网络参数的梯度</li><li>朝梯度的反方向稍微移动参数即可减小损失（W -= step * gradient）</li></ol></li></ol><p>这个方法叫做「小批量随机梯度下降」（mini-batch stochastic gradient descent，mini-batch SGD）。<br>随机一词是指我们在第1步抽取数据是随机抽取的。</p><p>有一些变种的 SGD 不只看当前梯度就更新值了，它们还要看上一次的权重更新。这些变体被称作「优化方法(optimization method)」或者「优化器(optimizer)」。在很多这些变体中，都会使用一个叫「动量(momentum)」的概念。</p><p>「动量」主要处理 SGD 中的两个问题：收敛速度和局部极小点。<br>用动量可以避免在 learning rate 比较小时收敛到局部最优解，而不是向全局最优解继续前进。</p><p>这里的动量就是来自物理的那个动量概念。我们可以想象，一个小球在损失曲面上往下(梯度下降的方向)滚，如果有足够的动量，它就可以“冲过”局部最小值，不被困在那里。<br>在这个例子中，小球的运动不但被当前位置的坡度（当前的加速度）决定，还受当前的速度（这取决于之前的加速度）的影响。</p><p>这个思想放到神经网络中，也就是，一次权重值的更新，不但看当前的梯度，还要看上一次权重更新：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># naive implementation of Optimization with momentum</span></span><br><span class="line">past_velocity = <span class="number">0.</span></span><br><span class="line">momentum = <span class="number">0.1</span>    <span class="comment"># Constant momentum factor</span></span><br><span class="line"><span class="keyword">while</span> loss &gt; <span class="number">0.01</span>:    <span class="comment"># Optimization loop</span></span><br><span class="line">    w, loss, gradient = get_current_parameters()</span><br><span class="line">    velocity = past_velocity * momentum + learning_rate * gradient</span><br><span class="line">    w = w + momentum * velocity - learning_rate * gradient</span><br><span class="line">    past_velocity = velocity</span><br><span class="line">    update_parameter(w)</span><br></pre></td></tr></table></figure><h3 id="反向传播算法：链式求导"><a href="#反向传播算法：链式求导" class="headerlink" title="反向传播算法：链式求导"></a>反向传播算法：链式求导</h3><p>神经网络是一大堆张量操作链式和在一起的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(W1, W2, W3) &#x3D; a(W1, b(W2, c(W3)))    # 其中 W1, W2, W3 是权重</span><br></pre></td></tr></table></figure><p>微积分里有个「链式法则(chain rule)」可以给这种复合函数求导：<code>f(g(x)) = f&#39;(g(x)) * g&#39;(x)</code></p><p>把这个链式法则用到神经网络就搞出了一个叫「反向传播(Backpropagation)」的算法，<br>这个算法也叫「反式微分(reverse-mode differentiation)」。</p><p>反向传播从最终算出的损失出发，从神经网络的最顶层反向作用至最底层，用这个链式法则算出每层里每个参数对于损失的贡献大小。</p><p>现在的 TensorFlow 之类的框架，都有种叫「符号微分(symbolic differentiation)」的能力。<br>这使得这些框架可以自动求出给定神经网络里操作的梯度函数，然后我们就不用手动实现反向传播了（虽然有意思，但写起来真的烦），直接从梯度函数取值就行了。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Deep Learning with Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用 pip 安装自己写的包</title>
      <link href="/2020/05/07/blog/pip-install-yourselfs-packages/"/>
      <url>/2020/05/07/blog/pip-install-yourselfs-packages/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用-pip-安装自己写的包"><a href="#如何用-pip-安装自己写的包" class="headerlink" title="如何用 pip 安装自己写的包"></a>如何用 pip 安装自己写的包</h1><p>昨天突发奇想，想让自己写的包也可以像我们常用的 numpy、flask、tensorflow 那样直接一个 <code>pip install XXX</code> 命令就安装上。</p><p>要实现这个，首先，我们需要了解 pip 和 Pypi。</p><p>（如果你懂一点点英语，请直接看这篇文档：<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#packaging-and-distributing-projects">Packaging and distributing projects</a>）</p><p>（如果你用 Windows，我不保证你可以顺利完成所有操作，自求多福 [告辞]）</p><h2 id="Pypi"><a href="#Pypi" class="headerlink" title="Pypi"></a>Pypi</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejog1c7xdj31e00u0kdb.jpg" alt="pypi"></p><blockquote><p>The Python Package Index (PyPI) is a repository of software for the Python programming language.</p></blockquote><p>这是 <a href="https://pypi.org/">Pypi</a> 的官网上对自己的描述，大概翻译一下：</p><blockquote><p>Python Package Index (PyPI) 是 Python 编程语言的软件库。</p></blockquote><p>其实，我们平时使用 pip 时，就是在 Pypi 里拉取这些包的，例如：</p><ul><li><a href="https://pypi.org/project/numpy/">numpy</a>: pip install numpy</li><li><a href="https://pypi.org/project/tensorflow/">tensorflow</a>: pip install tensorflow</li></ul><p>如何用 pip 安装包可以参考：<a href="https://packaging.python.org/tutorials/installing-packages/">文档 - Installing Packages</a>，这不是本文的重点。</p><p>我们接下来参考 <a href="https://packaging.python.org/tutorials/packaging-projects/">文档 - Packaging Python Projects</a>，讨论如何打包、发布自己的项目，然后用 pip 安装自己写的包。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>大家都知道（不然这篇文章还不适合现在的你，不用看了），我们写一个 Python 项目时，最基本的目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packaging_tutorial&#x2F;</span><br><span class="line">  example_pkg&#x2F;</span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure><p>当我们要开源或者以其他形式发布一个项目时，比如放到 Github 之前，还会加一些测试、LICENSE、README，目录就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">packaging_tutorial&#x2F;</span><br><span class="line">  example_pkg&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">  tests&#x2F;</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure><p>现在我们要打包发布这个项目，还需要再加一个 <code>setup.py</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">packaging_tutorial&#x2F;</span><br><span class="line">  example_pkg&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">  tests&#x2F;</span><br><span class="line">  setup.py</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure><h2 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h2><p><code> setup.py</code> 描述了你的项目，告诉别人你项目的名称、版本、描述、依赖……类似于写 node.js 同学的 <code>package.json </code>。</p><p>说的官方一点就是：setup.py 是 setuptools 的构建脚本。它告诉 setuptools 关于你的软件包（如名称和版本）以及要包含哪些代码文件。</p><p>一个基本的 setup.py 长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;packaging_tutorial&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;0.0.1&#x27;</span>,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    url=<span class="string">&#x27;https://github.com/pypa/sampleproject&#x27;</span>,</span><br><span class="line">    license=<span class="string">&#x27;MIT&#x27;</span>,</span><br><span class="line">    author=<span class="string">&#x27;Example Author&#x27;</span>,</span><br><span class="line">    author_email=<span class="string">&#x27;author@example.com&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;A small example package&#x27;</span>,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">&quot;text/markdown&quot;</span>,</span><br><span class="line">    install_requires=[<span class="string">&#x27;numpy&#x27;</span>],</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">&quot;Programming Language :: Python :: 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;License :: OSI Approved :: MIT License&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Operating System :: OS Independent&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    python_requires=<span class="string">&#x27;&gt;=3.6&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实基本看名字就知道是些什么了，我们只说明几个特别的：</p><ul><li><code>packages</code>，这里可以写一个list，比如 <code>packages=[&#39;example_pkg1&#39;, &#39;example_pkg2&#39;, ...]</code>，即你的目录里的 Python 包（带<code>__init__.py</code>的那种目录），也可以如官网建议的直接让 setuptools 给你去找。</li></ul><ul><li><code>long_description</code>，我们从 README.md 里直接读取的 markdown 文档，所以把<code>long_description_content_type</code> 对于设置了 markdown。</li></ul><ul><li><code>install_requires</code>，是你这个项目依赖的包，可以让 pip 安装你的包的时候检查依赖，如果依赖没有安装或版本不对，就把正确的依赖也一起装上。注意，这里的依赖必须是 pypi 里有的(即你可以用 pip install xxx 安装的)。要了解更多请看：<a href="https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files">install_requires vs requirements files</a></li></ul><ul><li><code>classifiers</code>，就是给你的项目贴些标签，方便别人检索啦，可选的在这个目录里：<a href="https://pypi.org/classifiers/">https://pypi.org/classifiers/</a></li></ul><p>setup.py 里还可以指定很多其他东西的，具体看文档：<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#setup-args">https://packaging.python.org/guides/distributing-packages-using-setuptools/#setup-args</a></p><hr><p>写完 setup.py 其实我们就可以在自己的电脑上 pip 安装这个包了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> packaging_tutorial</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 install .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import example_pkg    <span class="comment"># 注意这里import的不是setup里的name，而是packages列表里的包名</span></span></span><br></pre></td></tr></table></figure><p>如果本地安装没问题（我没遇到问题，不清楚有没有坑），接下来，我们把包就要上传到 Pypi 了。</p><h2 id="注册-Pypi-账号"><a href="#注册-Pypi-账号" class="headerlink" title="注册 Pypi 账号"></a>注册 Pypi 账号</h2><p>和 GitHub 一样哈，你得先注册一个号才能上传到 Pypi。</p><p>直接点这个链接注册：<a href="https://pypi.org/account/register/">https://pypi.org/account/register/</a>。</p><p>注册好之后，生成一个 token：<a href="https://pypi.org/manage/account/#api-tokens%E3%80%82%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E6%98%AF%E8%A6%81%E4%B8%8A%E4%BC%A0%E6%96%B0%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E8%A6%81%E9%99%90%E5%88%B6">https://pypi.org/manage/account/#api-tokens。由于我们是要上传新项目，所以不要限制</a> scope 到特定的项目。</p><p>⚠️<strong>注意：token 生成出来以后不要马上关掉页面，不然就没了！！！把 token 复制粘贴保存到个本地的文件里(你要手抄我不反对，一百多位，别抄错就行 [狗头])。</strong></p><p>然后，创建一个纯文本文件 <code>$HOME/.pypirc</code> （Windows 咋搞自行解决，我不用Windows），在里面写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pypi]</span><br><span class="line">username &#x3D; __token__</span><br><span class="line">password &#x3D; &lt;换成你刚刚复制下来的 token, 包括 &#96;pypi-&#96; 前缀&gt;</span><br></pre></td></tr></table></figure><p>注意，<strong>不要把username改成你的用户名</strong>，就是写 <code>username = __token__</code>，固定der！因为我们是要用 token 嘛，所以用户是 <code>__token__</code>。<code>password = token</code> 把 token 换成你的 token，注意不要换行，也不要加其他乱七八糟的空白字符（如果你要Windows的记事本，请小心BOM）。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pypi]</span><br><span class="line">username &#x3D; __token__</span><br><span class="line">password &#x3D; pypi-BCqRT66666666kLTI1NjQzZGUJXsgElwaS576OnvGVIshizhegedeshisabiJzaW9uIjogMXC05ZzcIWlOs2lyTZCOCCCCU1NwACvbnL9IsWyPMiOiAidXiJBBBcmcicN0AAAYgCB82jrAI9RDJl5BJfK2333333</span><br></pre></td></tr></table></figure><h2 id="打包、上传"><a href="#打包、上传" class="headerlink" title="打包、上传"></a>打包、上传</h2><p>打包很简单：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> packaging_tutorial</span><br><span class="line">$ python setup.py sdist</span><br><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── packaging_tutorial.egg-info</span><br><span class="line">│   ├── PKG-INFO</span><br><span class="line">│   ├── SOURCES.txt</span><br><span class="line">│   ├── dependency_links.txt</span><br><span class="line">│   ├── requires.txt</span><br><span class="line">│   └── top_level.txt</span><br><span class="line">├── dist</span><br><span class="line">│   └── packaging_tutorial-0.0.1.tar.gz</span><br><span class="line">├── setup.py</span><br><span class="line">└── example_pkg</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── src.py</span><br></pre></td></tr></table></figure><p>你会看见出来些 <code>packaging_tutorial.egg-info</code>、<code>dist</code> 啦。如果你没兴趣，就不用管它们，把他们看成“编译”出来的二进制文件就好。这些也不用加版本管理里，你随时可以生成的。</p><p>然后就是上传了，这一步需要我们先安装一个 twine：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install twine</span><br></pre></td></tr></table></figure><p>好了之后，用 twine 就可以把包上传到 pypi 了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ twine upload dist/*</span><br></pre></td></tr></table></figure><p>当然，你可以只上传某个特定版本： <code>twine upload dist/packaging_tutorial-0.0.1.tar.gz</code>。</p><p>如果失败，请检查你的网络，确保你可以上 <a href="https://pypi.org/">pypi官网</a> (搞这些最好科学上网，不然我不知道能不能成)；还有检查你的 <code>$HOME/.pypirc</code>，token 有没有写错。</p><p>上传完它就会输出一个 URL：<code>https://pypi.org/project/&lt;sampleproject&gt;</code>，打开就可以在 pypi 里看到你的项目了！</p><h2 id="用-Pip-安装自己写的包"><a href="#用-Pip-安装自己写的包" class="headerlink" title="用 Pip 安装自己写的包"></a>用 Pip 安装自己写的包</h2><p>最后，换台计算机（我们自己的电脑上已经安装过了嘛，痛失贞洁了，不好玩了）。</p><p>在另一台机器上（安装了 python、pip的）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install packaging_tutorial</span><br></pre></td></tr></table></figure><p>你可以看到下载、依赖处理、安装的过程。好了之后你就可以用自己写的包了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import example_pkg</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章只是对整个流程简要的记录和介绍，官方的这篇文章写了更完整的介绍：<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#packaging-and-distributing-projects">Packaging and distributing projects</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 236. 二叉树的最近公共祖先</title>
      <link href="/2020/04/28/School/leetcode_P236_lowest-common-ancestor-of-a-binary-tree/"/>
      <url>/2020/04/28/School/leetcode_P236_lowest-common-ancestor-of-a-binary-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-236-二叉树的最近公共祖先"><a href="#leetcode-236-二叉树的最近公共祖先" class="headerlink" title="leetcode 236. 二叉树的最近公共祖先"></a>leetcode <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9c56ruw6j305k05aa9z.jpg" alt="img"> </p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><p>。。。这个题，以前肯定刷过，记不得是哪个 OJ 的了。最简洁的方法应该是递归回溯，但不想写了。直接拿暴力法 ac 了，再改成并发玩玩吧。。。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>首先，实现一个辅助函数 <code>rewalk(root, node *TreeNode) []*TreeNode</code> ：遍历树，找到从某节点到根节点到一条路径，即找到这个节点的所有祖先节点。</p><p>通过这个 rewalk 函数，获得 p、q 的所有祖先节点，然后从里面找距离 p、q 最近的公共祖先节点返回即可。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for TreeNode.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *ListNode</span></span><br><span class="line"><span class="comment"> *     Right *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    rp := rewalk(root, p)</span><br><span class="line">    rq := rewalk(root, q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> rp &#123;</span><br><span class="line">        <span class="keyword">for</span> _, qq := <span class="keyword">range</span> rq &#123;</span><br><span class="line">            <span class="keyword">if</span> pp == qq &#123;</span><br><span class="line">                <span class="keyword">return</span> pp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rewalk</span><span class="params">(root, node *TreeNode)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []*TreeNode&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == node || root.Right == node &#123;</span><br><span class="line">        <span class="keyword">return</span> []*TreeNode&#123;node, root&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r := rewalk(root.Left, node); <span class="built_in">len</span>(r) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(r, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r := rewalk(root.Right, node); <span class="built_in">len</span>(r) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(r, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []*TreeNode&#123;node&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge99q4zyelj31cn0u04qp.jpg" alt="image-20200428102347236"></p><p>Swift:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var left: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public var right: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.left = nil</span></span><br><span class="line"><span class="comment"> *         self.right = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(<span class="keyword">_</span> root: TreeNode?, <span class="keyword">_</span> p: TreeNode?, <span class="keyword">_</span> q: TreeNode?)</span></span> -&gt; <span class="type">TreeNode</span>? &#123;</span><br><span class="line">        <span class="keyword">for</span> pp <span class="keyword">in</span> rewalk(root, p) &#123;</span><br><span class="line">            <span class="keyword">for</span> qq <span class="keyword">in</span> rewalk(root, q) &#123;</span><br><span class="line">                <span class="keyword">if</span> pp<span class="operator">?</span>.val <span class="operator">==</span> qq<span class="operator">?</span>.val &#123;</span><br><span class="line">                    <span class="keyword">return</span> pp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">rewalk</span><span class="params">(<span class="keyword">_</span> root: TreeNode?, <span class="keyword">_</span> node: TreeNode?)</span></span> -&gt; [<span class="type">TreeNode</span>?] &#123;</span><br><span class="line">        <span class="keyword">if</span> root <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">TreeNode</span>?]()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root<span class="operator">?</span>.left<span class="operator">?</span>.val <span class="operator">==</span> node<span class="operator">?</span>.val <span class="operator">||</span> root<span class="operator">?</span>.right<span class="operator">?</span>.val <span class="operator">==</span> node<span class="operator">?</span>.val &#123;</span><br><span class="line">            <span class="keyword">return</span> [node, root]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> rl <span class="operator">=</span> rewalk(root<span class="operator">?</span>.left, node)</span><br><span class="line">        <span class="keyword">if</span> rl.count <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">            rl.append(root)</span><br><span class="line">            <span class="keyword">return</span> rl</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> rr <span class="operator">=</span> rewalk(root<span class="operator">?</span>.right, node)</span><br><span class="line">        <span class="keyword">if</span> rr.count <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">            rr.append(root)</span><br><span class="line">            <span class="keyword">return</span> rr</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [node]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9a8pvmnnj31cn0u01kx.jpg" alt="image-20200428104142149"></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在前几天写的 <a href="https://clownote.github.io/2020/04/21/School/Leetcode_P100_same-tree/">从「Leetcode 100. 相同的树」出发讨论为什么用「并发」</a> 一文里，我讨论过，有的时候用并发并不是为了跑的快，只是让解决问题的思路变得更清晰、操作更加“原子化”、避免时间不同步造成的额外储存使用。这里也是一样的，我们可以把刚才的暴力法改成用 goroutine 和 channel，Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    cp := <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line">    cq := <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> rewalk(root, p, cp)</span><br><span class="line">    <span class="keyword">go</span> rewalk(root, q, cq)</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>(<span class="keyword">chan</span> *TreeNode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ap := []*TreeNode&#123;&#125;</span><br><span class="line">        aq := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> p := &lt;- cp:</span><br><span class="line">                <span class="keyword">for</span> _, q := <span class="keyword">range</span> aq &#123;</span><br><span class="line">                    <span class="keyword">if</span> p == q &#123;</span><br><span class="line">                        ans &lt;- p</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ap = <span class="built_in">append</span>(ap, p)</span><br><span class="line">            <span class="keyword">case</span> q := &lt;- cq:</span><br><span class="line">                <span class="keyword">for</span> _, p := <span class="keyword">range</span> ap &#123;</span><br><span class="line">                    <span class="keyword">if</span> q == p &#123;</span><br><span class="line">                        ans &lt;- q</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                aq = <span class="built_in">append</span>(aq, q)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rewalk</span><span class="params">(root, node *TreeNode, ch <span class="keyword">chan</span> *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == node || root.Right == node &#123;</span><br><span class="line">        ch &lt;- node</span><br><span class="line">        ch &lt;- root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r := rewalk(root.Left, node, ch); r &#123;</span><br><span class="line">        ch &lt;- root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r := rewalk(root.Right, node, ch); r &#123;</span><br><span class="line">        ch &lt;- root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- node</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9bp875ekj31cn0u01kx.jpg" alt="image-20200428113206480"></p><p>通过调整超时（就是在 select 里加一个 <code>case &lt;- time.After(...*time.Microsecond)</code>），我去卡了 leetcode 的测试用例出来看，他的数据规模都比较小，给的树都不大，所以这个用并发优势体现不出来。但如果你的树炒鸡大，这个用并发的算法肯定是会有一定优势的。比如如果给的 p、q 距离树根都有 10,000,000 个祖先节点，暴力法要全部跑一边、存下来、再嵌套for  10,000,000 个  10,000,000 个的去遍历，而如果它们的最近公共祖先只距离 1000 个节点，那并发只要跑 1000 个就结束了、检查的遍历也是在 1000 * 1000 里的，这要快得多、省得多了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 104. 二叉树的最大深度</title>
      <link href="/2020/04/28/School/Leetcode_P104_maximum-depth-of-binary-tree/"/>
      <url>/2020/04/28/School/Leetcode_P104_maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-104-二叉树的最大深度"><a href="#Leetcode-104-二叉树的最大深度" class="headerlink" title="Leetcode 104. 二叉树的最大深度"></a>Leetcode <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>求深度，深度优先去跑一遍就出来了。Golang 实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := maxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    rightDepth := maxDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth &gt; rightDepth &#123;</span><br><span class="line">        <span class="keyword">return</span> leftDepth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rightDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge96uvbw9fj31co0u01kx.jpg" alt="image-20200428084432376"></p><p>Swift:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var left: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public var right: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.left = nil</span></span><br><span class="line"><span class="comment"> *         self.right = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root<span class="operator">?</span>.left), maxDepth(root<span class="operator">?</span>.right)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge96tea5w1j31ih0u0qss.jpg" alt="image-20200428084300289"></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>把递归改成栈，DFS也能出来，基本是一样的。Golang 实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    depth := <span class="number">1</span></span><br><span class="line">    root.Val = <span class="number">1</span></span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[: <span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node.Val &gt; depth &#123;</span><br><span class="line">            depth = node.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Left.Val = node.Val + <span class="number">1</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Right.Val = node.Val + <span class="number">1</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge972t6548j31co0u01kx.jpg" alt="屏幕快照 2020-04-28 08.51.08"></p><p>虽然不地道，但代码基本不变，改几个符号就可以放到 Swift 里跑了:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> depth <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        root<span class="operator">?</span>.val <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> stack: [<span class="type">TreeNode</span>] <span class="operator">=</span> [root<span class="operator">!</span>, ]</span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>stack.isEmpty &#123;</span><br><span class="line">            <span class="keyword">let</span> node <span class="operator">=</span> stack.popLast()<span class="operator">!</span></span><br><span class="line">            <span class="keyword">if</span> node.val <span class="operator">&gt;</span> depth &#123;</span><br><span class="line">                depth <span class="operator">=</span> node.val</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                node.left<span class="operator">?</span>.val <span class="operator">=</span> node.val <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                stack.append(node.left<span class="operator">!</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                node.right<span class="operator">?</span>.val <span class="operator">=</span> node.val <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                stack.append(node.right<span class="operator">!</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge984g3z1qj31co0u01kx.jpg" alt="image-20200428092824475"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 101. 对称二叉树</title>
      <link href="/2020/04/21/School/Leetcode_P101_symmetric-tree/"/>
      <url>/2020/04/21/School/Leetcode_P101_symmetric-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-101-对称二叉树"><a href="#Leetcode-101-对称二叉树" class="headerlink" title="Leetcode 101. 对称二叉树"></a>Leetcode <a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，检查它是否是镜像对称的。 </p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>把左子树以<strong>先左后右</strong>的顺序遍历，把 val 用线性结构存下来；把右子树以<strong>先右后左</strong>的顺序遍历，把 val 用线性结构存下来。然后，比较两个结果，相等则说明对称。大概就这个思路，你细品。</p><p>涉及到空值处理的代码我喜欢用 Swift 实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var left: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public var right: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.left = nil</span></span><br><span class="line"><span class="comment"> *         self.right = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(<span class="keyword">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> leftSubTreeVals <span class="operator">=</span> [root<span class="operator">?</span>.val]</span><br><span class="line">        leftFirstWalk(root<span class="operator">?</span>.left, <span class="operator">&amp;</span>leftSubTreeVals)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> rightSubTreeVals <span class="operator">=</span> [root<span class="operator">?</span>.val]</span><br><span class="line">        rightFirstWalk(root<span class="operator">?</span>.right, <span class="operator">&amp;</span>rightSubTreeVals)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftSubTreeVals <span class="operator">==</span> rightSubTreeVals</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">leftFirstWalk</span><span class="params">(<span class="keyword">_</span> root: TreeNode?,<span class="keyword">_</span> vals: <span class="keyword">inout</span> [Int?])</span></span> &#123;</span><br><span class="line">        vals.append(root<span class="operator">?</span>.val)</span><br><span class="line">        <span class="keyword">if</span> root <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        leftFirstWalk(root<span class="operator">?</span>.left, <span class="operator">&amp;</span>vals)</span><br><span class="line">        leftFirstWalk(root<span class="operator">?</span>.right, <span class="operator">&amp;</span>vals)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">rightFirstWalk</span><span class="params">(<span class="keyword">_</span> root: TreeNode?,<span class="keyword">_</span> vals: <span class="keyword">inout</span> [Int?])</span></span> &#123;</span><br><span class="line">        vals.append(root<span class="operator">?</span>.val)</span><br><span class="line">        <span class="keyword">if</span> root <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rightFirstWalk(root<span class="operator">?</span>.right, <span class="operator">&amp;</span>vals)</span><br><span class="line">        rightFirstWalk(root<span class="operator">?</span>.left, <span class="operator">&amp;</span>vals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1gffgsjwj31c60u01kx.jpg" alt="屏幕快照 2020-04-21 16.11.00"></p><p>（一开始rightFirstWalk是直接复制粘贴leftFirstWalk过来的，里面的 left 忘改成 right 了😂，所以报了个WA）</p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>和往常一样，我们递归的设计从考虑一个最简单的情形开始。考虑两棵只有一个节点的树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1      n2</span><br></pre></td></tr></table></figure><p>它们是对称的当且仅当 <code>n1 == n2</code>。</p><p>如果这两个节点有且只有一层孩子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   n1          n2</span><br><span class="line">  &#x2F; \         &#x2F; \</span><br><span class="line">l1   r1     l2   r2</span><br></pre></td></tr></table></figure><p>这时，两棵数对称的充要条件变成了：<code>n1 == n2</code> 且 <code>l1 == r2</code> 且 <code>r1 == r2</code>。</p><p>注意到 <code>l1 == r2</code> 等价于两棵只有一个节点的树 <code>l1</code> 和 <code>r2</code> 对称。</p><p>这给了我们一个启示，如果这两个节点有子树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   n1          n2</span><br><span class="line">  &#x2F; \         &#x2F; \</span><br><span class="line">l1   r1     l2   r2</span><br></pre></td></tr></table></figure><p>这时，两棵数对称的充要条件就是：<code>n1 == n2</code> 且 <code>l1 与 r2 对称</code> 且 <code>r1 与 r2 对称</code>。</p><p> Swift 实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(<span class="keyword">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> symmetric(root<span class="operator">?</span>.left, root<span class="operator">?</span>.right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">symmetric</span><span class="params">(<span class="keyword">_</span> left: TreeNode?, <span class="keyword">_</span> right: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> right <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left<span class="operator">?</span>.val <span class="operator">!=</span> right<span class="operator">?</span>.val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> symmetric(left<span class="operator">?</span>.left, right<span class="operator">?</span>.right) <span class="operator">&amp;&amp;</span> symmetric(left<span class="operator">?</span>.right, right<span class="operator">?</span>.left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1hly9ljrj31c60u01kx.jpg" alt="image-20200421165205677"></p><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(<span class="keyword">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s <span class="operator">=</span> [root, root]</span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>s.isEmpty &#123;</span><br><span class="line">            <span class="keyword">let</span> t1 <span class="operator">=</span> s.popLast()</span><br><span class="line">            <span class="keyword">let</span> t2 <span class="operator">=</span> s.popLast()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1<span class="operator">??</span>.val <span class="operator">!=</span> t2<span class="operator">??</span>.val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> t1<span class="operator">??</span>.val <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> t2<span class="operator">??</span>.val <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                s.insert(contentsOf: [t1<span class="operator">??</span>.left, t2<span class="operator">??</span>.right], at: <span class="number">0</span>)</span><br><span class="line">                s.insert(contentsOf: [t1<span class="operator">??</span>.right, t2<span class="operator">??</span>.left], at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1iqz5yxhj31c60u01kx.jpg" alt="image-20200421173132163"></p><hr><h2 id="（蒟蒻的抱怨）"><a href="#（蒟蒻的抱怨）" class="headerlink" title="（蒟蒻的抱怨）"></a>（蒟蒻的抱怨）</h2><p>啪！</p><p>嘣！</p><p>蒟蒻把键盘一砸，就夺门而出。</p><p>“蒟蒻出门了！”，不知谁喊了这么一嗓子，家家户户便都急着开窗，太太们顾不得整理饰物就伸出头来围观蒟蒻的蓬头垢面。</p><p>先生们、孩子们、没有抢到窗口宝地的年轻小姐们，开始推攘着、嬉笑着挤出门来，平时能够两个人并排走的门，这时看来狭窄得可笑。走在后面的、脾气暴躁的老人好不容易挪到街上，发昏的视线马上被前面一排排高举着孩子的小伙子们皱起的后衣遮住了，只看得他们满目怒火。</p><p>八尺宽的街道一瞬间变得水泄不通，低着头的蒟蒻如平时那般忽视着身周的邻居们——他所到之处，人群也不知是怎么消退的，自然就让出了一个刚够蒟蒻前进的身位。他一路骂骂咧咧：“这 Leetcode 有毒，写了三个差不多的算法，一个比一个慢！早知道随便写他一个就溜了，浪费这么多时间也不见个效果，我图个啥了。。。”</p><p>这时，一个孩子。。。</p><p>（啊，终于下课了，吃饭去了。。。不写了👋）</p><hr><p>By <a href="https://clownote.github.io/">CDFMLR</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从「Leetcode 100. 相同的树」出发讨论为什么用「并发」</title>
      <link href="/2020/04/21/School/Leetcode_P100_same-tree/"/>
      <url>/2020/04/21/School/Leetcode_P100_same-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="从「Leetcode-100-相同的树」出发讨论为什么用「并发」"><a href="#从「Leetcode-100-相同的树」出发讨论为什么用「并发」" class="headerlink" title="从「Leetcode 100. 相同的树」出发讨论为什么用「并发」"></a>从「Leetcode <a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a>」出发讨论为什么用「并发」</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>树嘛，最方便的解决方案就是递归。</p><p> 同时 Walk 两棵树，对于某一步有这么几种情况：</p><ul><li>两个节点都走到 nil 了，说明之前都相等，这里也相等，返回 true;</li><li>两个节点一个到了 nil，另一个不是，说明不相等，返回 false;</li><li>两个节点都不为 nil，但其 Val 不等，说明不相等，返回 false;</li><li>两个节点都不为 nil，且 Val 相等，分别下一层递归左右子树，若左右子树都相等则返回 true.</li></ul><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nil</span> || q == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> p.Val != q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge172qhlqij31c60u01kx.jpg" alt="image-20200421104735760"></p><p>Golang 在处理这种涉及 nil 值判断的问题的时候都显得稍微繁琐了一点，用 Swift 可以写出更简洁的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var left: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public var right: TreeNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.left = nil</span></span><br><span class="line"><span class="comment"> *         self.right = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(<span class="keyword">_</span> p: TreeNode?, <span class="keyword">_</span> q: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> q <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> p<span class="operator">?</span>.val <span class="operator">!=</span> q<span class="operator">?</span>.val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p<span class="operator">?</span>.left, q<span class="operator">?</span>.left) <span class="operator">&amp;&amp;</span> isSameTree(p<span class="operator">?</span>.right, q<span class="operator">?</span>.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge18xo0znij31c60u01kx.jpg" alt="屏幕快照 2020-04-21 11.48.10"></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>把递归改成用一个 <del>栈</del> 队列就可以在迭代里完成这个功能了，Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    s := [][<span class="number">2</span>]*TreeNode&#123;[<span class="number">2</span>]*TreeNode&#123;p, q&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p, q, s = s[<span class="number">0</span>][<span class="number">0</span>], s[<span class="number">0</span>][<span class="number">1</span>], s[<span class="number">1</span>:]; !<span class="function"><span class="keyword">func</span> <span class="params">(pn, qn *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">case</span> p.Val != q.Val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(p, q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            s = <span class="built_in">append</span>(s, [<span class="number">2</span>]*TreeNode&#123;p.Left, q.Left&#125;, [<span class="number">2</span>]*TreeNode&#123;p.Right, q.Right&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不喜欢这个算法，所以我故意把代码写的很恶心，但它可以运行通过，而且不慢：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1e4ks0hqj31c60u01kx.jpg" alt="image-20200421145136574"></p><p>利用 Swift 的 <strong>Optionals</strong> 和 <strong>Closures</strong>，可以在很大程度上简化刚才的 golang 代码，这个代码就看得懂了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(<span class="keyword">_</span> p: TreeNode?, <span class="keyword">_</span> q: TreeNode?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s <span class="operator">=</span> [[p, q], ]</span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>s.isEmpty &#123;</span><br><span class="line">            <span class="keyword">let</span> pn <span class="operator">=</span> s[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">let</span> qn <span class="operator">=</span> s[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            s.remove(at: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>&#123; <span class="variable">$0</span><span class="operator">?</span>.val <span class="operator">==</span> <span class="variable">$1</span><span class="operator">?</span>.val &#125;(pn, qn) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pn <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                s.append([pn<span class="operator">?</span>.left, qn<span class="operator">?</span>.left])</span><br><span class="line">                s.append([pn<span class="operator">?</span>.right, qn<span class="operator">?</span>.right])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1f4q9thqj31c60u01kx.jpg" alt="image-20200421152621048"></p><h2 id="进一步探究：相同的二叉查找树"><a href="#进一步探究：相同的二叉查找树" class="headerlink" title="进一步探究：相同的二叉查找树"></a>进一步探究：相同的二叉查找树</h2><p>在 <em>A Tour of Go</em> 的「并发」章节里有这么一个叫 <a href="https://tour.golang.org/concurrency/7">Exercise: Equivalent Binary Trees</a> 的练习题，和我们的「 Leetcode 100. 相同的树」都是判断树是否相同的，但题目有所区别。</p><p><em>A Tour of Go</em> 里的题目大概如下：</p><blockquote><p>不同二叉树的叶节点上可以保存相同的值序列。例如，以下两个二叉树都保存了序列 <code>1，1，2，3，5，8，13</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2umnsl25j30dn0513yh.jpg" alt="img"></p><p>在大多数语言中，检查两个二叉树是否保存了相同序列的函数都相当复杂。 我们将使用 Go 的并发和信道来编写一个简单的解法。</p></blockquote><p>这个题是让判断两个<strong>二叉查找树</strong>（不仅是二叉树！）里保存的序列是否相同。</p><p>我先贴一下这道题的二叉搜索树实现（为了测试，我把树大小调的比较大）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2011 The Go Authors.  All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tree <span class="comment">// import &quot;golang.org/x/tour/tree&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Tree is a binary tree with integer values.</span></span><br><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">Left  *Tree</span><br><span class="line">Value <span class="keyword">int</span></span><br><span class="line">Right *Tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns a new, random binary tree holding the values k, 2k, ..., 10k.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(k <span class="keyword">int</span>)</span> *<span class="title">Tree</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t *Tree</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> rand.Perm(<span class="number">10000000</span>) &#123;</span><br><span class="line">t = insert(t, (<span class="number">1</span>+v)*k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(t *Tree, v <span class="keyword">int</span>)</span> *<span class="title">Tree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Tree&#123;<span class="literal">nil</span>, v, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v &lt; t.Value &#123;</span><br><span class="line">t.Left = insert(t.Left, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Right = insert(t.Right, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;()&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">s := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">s += t.Left.String() + <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">s += fmt.Sprint(t.Value)</span><br><span class="line"><span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">s += <span class="string">&quot; &quot;</span> + t.Right.String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + s + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要解决这个问题，我们可以跑个中序遍历，把值存下来，即把二叉搜索树里的数据放到排好序的顺序结构中，再比较两个顺序结构是否等价。比如对于题目中这两棵树，我们分别把他们化为顺序结构，刚好两个结果都是 <code>[1，1，2，3，5，8，13]</code>，所以，两棵树是等价的。代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noConcurrency.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;./tree&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TreeHeight <span class="keyword">int</span> = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">Walk(t.Left, ch)</span><br><span class="line">*ch = <span class="built_in">append</span>(*ch, t.Value)</span><br><span class="line">Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">Walk(t1, &amp;c1)</span><br><span class="line">Walk(t2, &amp;c2)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; TreeHeight; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> c1[i] != c2[i] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testSame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSame</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">1</span>)))</span><br><span class="line">fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现依赖额外的数据储存，内存消耗很大：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2vh6wvlvj311a0padom.jpg" alt="屏幕快照 2020-04-22 21.33.05"></p><p>所以，还有更好的实现吗？是的！我一开始介绍了，这个题目是出现在「并发」章节里的！乍一看，你可能觉得这个题用并发，好像就是可以把两个化为顺序结构的递归放两个线程里，单独跑，可以快一些吗？这好像也快不了多少。。</p><p>其实，之所以用并发，不是为了快，是为了省内存！利用 Go 程与信道，我们可以相当方便的实现一个<strong>不用额外顺序结构</strong>的实现。</p><p>这个实现的思路是，开两个 goroutine 里分别跑 Walk，中序那里不是 append 切片，而是把值传到信道里。再开另一个 goroutine 阻塞，等两个 Walk goroutine 的信道都有值了，就判断这两个值是否相等，不等就直接返回了；相等的话继续阻塞，判断下一组传过来的值，直到遍历完树。如果遍历完了，每一组值都相等，就说明两棵树是相等的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrency.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;./tree&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TreeHeight <span class="keyword">int</span> = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">Walk(t.Left, ch)</span><br><span class="line">ch &lt;- t.Value</span><br><span class="line">Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">ans := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Walk(t1, c1)</span><br><span class="line"><span class="keyword">go</span> Walk(t2, c2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; TreeHeight; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> &lt;-c1 != &lt;-c2 &#123;</span><br><span class="line">ans &lt;- <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &lt;-ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testSame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSame</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">1</span>)))</span><br><span class="line">fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然时间上区别不大（所以我没贴出来），但这个版本的代码里，我们把 <code>noConcurrency.go</code> 里的两个空间复杂度 $O(n)$ 切片改成了 $O(1)$ 的信道！所以内存消耗相当显著得下降了：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2vi16zg2j311a0pa7cz.jpg" alt="屏幕快照 2020-04-22 21.35.47"></p><h2 id="启示：关于并发的思考"><a href="#启示：关于并发的思考" class="headerlink" title="启示：关于并发的思考"></a>启示：关于并发的思考</h2><p>在过去还没有学习并发技术的很长的一段时间里，我都认为并发这些东西就是为了快！直到我学 Python 的时候学了一点点并发，才了解到并发在我们的通信、服务这方面有多重要。不过这个时候，我依然认为本源是并发可以跑得快！它跑得快所以单位时间内能处理的服务增多了。。。</p><p>学习了 Go 之后，回头想想这些想法，就感觉有点片面了。</p><p>诚然，在如今的多核/超线程处理器下，并发、并行的确能带来性能的提升。但这些手段在单核单线程的处理器上跑得并不快，还不如单线程呢。甚至有的时候，即使是在多线程处理器下并发跑得也不快，就比如我刚才写的两个版本判断相同的二叉查找树的代码，它们耗时几乎是一样的。即便如此，我们还是在用并发——不是为了效率，而是把问题拆分成小的模块，单独去处理一个一个的小模块。模块与模块之间相对独立，只在必要的时机传递必要的、最小化的信息（而且最好是单向点对点的传递，一个发，一个收）。</p><p>模块间的通信是这种系统的精髓。</p><p>我们一开始写的 <code>noConcurrency.go</code> 里两个 Walk 模块独自运行（虽然这里两个模块不是并发的，但不影响讨论，你可以看作是并发，给Walk调用前面加个go就好了），它们之间没有任何通讯把它们联系起来。这导致了两个模块必须各自把整颗树跑完，返两个超大的切片回来，再逐位判断两个切片里的值是否相等。要注意，这两个超大的切片里每一个值我们都只有了一次啊，但是用之前它在那里占用内存，用之后它还在那里消耗资源。一大堆($O(n)$)这样的「当前没有正在被使用的值」导致了大量的浪费。</p><p>我们不希望这样的浪费，即希望尽量减少这种「当前没有正在被使用的值」。那要怎么办？尽量减少就减到零嘛，那这任务就完成不了了。零个不行，就考虑 $O(1)$ 个。我们很自然就想到了两个 Walk 分别把自己遍历到的值放到变量 <code>c1</code>、<code>c2</code> 里，然后及时地比较 <code>c1</code>、<code>c2</code> ，比较完就扔，然后两个 Walk 又可以往里面放值了，然后再次比较。这种想法即可以完成任务，又把消耗降到了 $O(1)$。</p><p>我们来试着这种想法，用传统的代码，需要同时遍历两颗树：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DuplicateWalk</span><span class="params">(t1 *tree.Tree, t2 *tree.Tree)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t1 != <span class="literal">nil</span> &amp;&amp; t2 != <span class="literal">nil</span> &#123;</span><br><span class="line">Walk(t1.Left, t2.Left)</span><br><span class="line">        <span class="keyword">if</span> t1.Value != t2.Value &#123;</span><br><span class="line">            <span class="comment">// not Equivalent</span></span><br><span class="line">        &#125;</span><br><span class="line">Walk(t1.Right, t2.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现这很不优雅！明明是两棵不同的树的遍历，现在都连到一起了！在这个问题里因为遍历二叉树这种任务很简单，所以这种写法勉强可以接受，但如果你面对的不是树的遍历而是一个超复杂的工作、也不止是两个同时，而是上千个任务，这种写法就会复杂的不可接受，乃至无法实现了。</p><p>既要同时发生（<code>Walk(t1, t2)</code>），又要同时停止进行比较（<code>if t1.Value != t2.Value &#123;...&#125;</code>），还要不恶心地把两棵树的遍历写在一起，这就是「并发」可以干的事了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> Walk(t1, c1)</span><br><span class="line"><span class="keyword">go</span> Walk(t2, c2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; TreeHeight; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> &lt;-c1 != &lt;-c2 &#123;</span><br><span class="line">            ans &lt;- <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>树的递归还是一颗树一颗树分开的（这很好，一个模块就只应该做一个事），而且这次它们同时运行。同时运行就可以进行通信！它们分别靠两个信道把遍历到的值传出来，然后另一个 goroutine （模块）就等着这两个信道都有值的时候把值取出来比较一波。这样在并发下靠信道来通信，单向，点对点，一个发、一个收，在优雅地完成任务的同时，又把消耗降到了最低。所以说模块间的通信是并发系统的精髓。</p><p>当然，并发还有另一种好处：在这种模块化的系统中，只有模块设计的适当小，分离得足够充分，模块间的通信控制得足够准确，如果其中一个模块出了问题，除了与之通信的有限个模块随之挂起外，其他的模块都还是好的。这种小规模的局部问题是可以处理的，不容易造成全盘连锁崩溃。这在服务端程序里尤为重要。</p><p>（我困了写不下去了，就这样吧，有机会再改改、再补充）</p><hr><p>By CDFMLR.</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 78. 子集</title>
      <link href="/2020/04/14/School/Leetcode_P78_subsets/"/>
      <url>/2020/04/14/School/Leetcode_P78_subsets/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-78-子集"><a href="#Leetcode-78-子集" class="headerlink" title="Leetcode 78. 子集"></a>Leetcode <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets">https://leetcode-cn.com/problems/subsets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>其实嘛，取子集这件事情，对每一个元素就两种状态，取和不取，共有 $2^{len(nums)}$种可能。这可以直接用一个二进制 bit （boolean）位向量表示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">幂集 = [</span><br><span class="line">    [],</span><br><span class="line">    [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 表示不取</span></span><br><span class="line"><span class="comment"># 1 表示取</span></span><br><span class="line">对应取的状态 = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，所有对应取的状态合在一起，其实就是遍历了 <code>len(nums)</code> 位的二进制位向量所有可能的取值。如果用整数表示二进制位向量，即遍历 <code>[0, 1 &lt;&lt; len(nums) - 1]</code> 。这样实现起来很简单了，跑一个循环就行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个遍历里，把二进制位向量映射到原数组的索引，就能取出一个子集了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j, ii := <span class="number">0</span>, i; j &lt; <span class="built_in">len</span>(nums); j, ii = j+<span class="number">1</span>, ii&gt;&gt;<span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个 for 其实就是每次从低位端 pop 一个位出来，这个位对应一个索引嘛</span></span><br><span class="line">    <span class="comment">// pop 出的是 1 就取这个索引处的元素进子集</span></span><br><span class="line">    <span class="keyword">if</span> ii &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, nums[j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合在一起，就有了完整的 Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    subs := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        s := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j, ii := <span class="number">0</span>, i; j &lt; <span class="built_in">len</span>(nums); j, ii = j+<span class="number">1</span>, ii&gt;&gt;<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ii &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">                s = <span class="built_in">append</span>(s, nums[j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subs = <span class="built_in">append</span>(subs, s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊，我写不清这个，，，我觉得二进制、位运算这种东西相当自然，就像我们算 1 + 1 很自然就得到了 2，用二进制位向量是一种很自然的事，它就该这么用，所有反倒难以解释了😂</p><p>也许这不是一个很好的思路，但从结果上来看，这个算法还是比较快的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdt1clsxr0j31c60u0not.jpg" alt="屏幕快照 2020-04-14 08.50.13"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 136. 只出现一次的数字</title>
      <link href="/2020/04/08/School/Leetcode_P136_single-number/"/>
      <url>/2020/04/08/School/Leetcode_P136_single-number/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-136-只出现一次的数字"><a href="#Leetcode-136-只出现一次的数字" class="headerlink" title="Leetcode 136. 只出现一次的数字"></a>Leetcode <a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>这道题最简单的方法，哈希表暴力存一下出现次数就好了。由于题目保证最多有出现两次，所以用个bool去存出现次数就行了，Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    memo := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        memo[v] = !memo[v]</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> memo &#123;</span><br><span class="line">        <span class="keyword">if</span> v &#123;</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>按位异或（C风格写做 <code>^</code>）有很多有趣的性质，这道题可以用其中的一两个：</p><ol><li><code>x ^ x = 0</code></li><li><code>0 ^ x = x</code></li></ol><p>其实这两个性质还是很显然的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  100110</span><br><span class="line">^ 100110</span><br><span class="line">--------</span><br><span class="line">  000000</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  000000</span><br><span class="line">^ 100110</span><br><span class="line">--------</span><br><span class="line">  100110</span><br></pre></td></tr></table></figure><p>这两个性质合在一起就有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ^ a ^ b ^ b ^ ... ^ z &#x3D; z</span><br><span class="line">&#x2F;&#x2F; 省略的那里也是一对一对的，只有z是单独一个</span><br></pre></td></tr></table></figure><p>这道题就解决了。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        x ^= v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdmdhgx8xwj317x0u04qd.jpg" alt="image-20200408150554908"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 3. 无重复字符的最长子串</title>
      <link href="/2020/04/07/School/Leetcode_P3_longest-substring-without-repeating-characters/"/>
      <url>/2020/04/07/School/Leetcode_P3_longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode 3. 无重复字符的最长子串"></a>Leetcode <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>​     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="可能是滑窗的解法"><a href="#可能是滑窗的解法" class="headerlink" title="可能是滑窗的解法"></a>可能是滑窗的解法</h2><p>（这道题我去年写的了，大概看了一下，还可以，就不重新写 了）</p><p>其实就是像人一样去找，这个算法还是很直接暴力的，C语言实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pmhead = s;</span><br><span class="line">    <span class="keyword">char</span> *pmtail = s;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = *s;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (c = s[i++], c != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        j = pmtail - pmhead;</span><br><span class="line">        pc = <span class="built_in">memchr</span>(pmhead, c, j);</span><br><span class="line">        <span class="keyword">if</span> (pc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; max) &#123;</span><br><span class="line">                max = j;</span><br><span class="line">            &#125;</span><br><span class="line">            pmhead = pc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pmtail++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pmtail - pmhead &gt; max) &#123;</span><br><span class="line">        max = pmtail - pmhead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdkvuf8tzaj31l10u0dkk.jpg" alt="image-20200407080959808"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 14. 最长公共前缀</title>
      <link href="/2020/03/31/School/Leetcode_P14_longest-common-prefix/"/>
      <url>/2020/03/31/School/Leetcode_P14_longest-common-prefix/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-14-最长公共前缀"><a href="#Leetcode-14-最长公共前缀" class="headerlink" title="Leetcode 14. 最长公共前缀"></a>Leetcode <a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>说明:</p><p>所有输入只包含小写字母 a-z 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="暴力遍历法"><a href="#暴力遍历法" class="headerlink" title="暴力遍历法"></a>暴力遍历法</h2><p>这个方法的思路是这样：</p><p>例如，处理题例 <code>strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code>:</p><p>第一轮：</p><ol><li>从 <code>strs[0]</code> 即<del>第0个</del>第一个元素 <code>&quot;flower&quot;</code> 取出第一个字符 <code>&quot;f&quot;</code></li><li>遍历 <code>strs</code>，若有元素没有前缀 <code>&quot;f&quot;</code>，则最长公共前缀为 <code>&quot;&quot;</code></li></ol><p>第二轮：</p><ol><li>从 <code>strs[0]</code> 即<del>第0个</del>第一个元素 <code>&quot;flower&quot;</code> 取出前两个字符 <code>&quot;fl&quot;</code></li><li>遍历 <code>strs</code>，若有元素没有前缀 <code>&quot;fl&quot;</code>，则最长公共前缀为 <code>&quot;f&quot;</code></li></ol><p>第三轮：</p><ol><li>从 <code>strs[0]</code> 即<del>第0个</del>第一个元素 <code>&quot;flower&quot;</code> 再取出前三个字符，得到 <code>&quot;flo&quot;</code></li><li>遍历 <code>strs</code>，若有元素没有前缀 <code>&quot;flo&quot;</code>，则最长公共前缀为 <code>&quot;fl&quot;</code></li></ol><p>……</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(strs[<span class="number">0</span>]); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> !strings.HasPrefix(strs[j], strs[<span class="number">0</span>][:i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdct2u0iynj31930u04pt.jpg" alt="屏幕快照 2020-03-31 08.28.51"></p><p>感觉还有好多种暴力遍历的方法，随便怎么都出得来，但好像效率都差不多？大概是 $O(\sum_{i=0}^{len(strs)}len(strs[i]))$？</p><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>我想用分治来写这个，感觉会比较有意思。</p><p>其实就是一个递归，用二分法“分”问题，分到最后基础情况就是只剩一个元素直接返回；然后“合”就是求二分左右递归各自返回来的两个串的最长公共前缀：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdcuvnmzffj31sz0u0gqr.jpg" alt="image-20200331093206511"></p><p>（我疯了，居然用 XMind 画这个。。。）</p><p>代码实现，Golang：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partLongestCommonPrefix(strs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partLongestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m := <span class="built_in">len</span>(strs) / <span class="number">2</span></span><br><span class="line">        l := partLongestCommonPrefix(strs[: m])</span><br><span class="line">        r := partLongestCommonPrefix(strs[m :])</span><br><span class="line">        <span class="keyword">return</span> fuzzbuzz(l, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fuzzbuzz 是一个函数，用来返回两个字符串的最长公共前缀</span></span><br><span class="line"><span class="comment"> * 用这个函数来举反例，以此呼吁大家认真命名、取有意义的名字！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fuzzbuzz</span><span class="params">(foo, bar <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fuzz := <span class="built_in">len</span>(foo)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(bar) &lt; fuzz &#123;</span><br><span class="line">        fuzz = <span class="built_in">len</span>(bar)</span><br><span class="line">    &#125;</span><br><span class="line">    buzz := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; buzz &lt; fuzz; buzz++ &#123;</span><br><span class="line">        <span class="keyword">if</span> foo[buzz] != bar[buzz] &#123;</span><br><span class="line">            <span class="keyword">return</span> foo[: buzz]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo[: buzz]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个时间复杂度和刚才那个暴力法差不多，而空间占用还更多了：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdcuauj2g2j31930u01kx.jpg" alt="image-20200331091205895"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础手册P2 基本数据类型基本类型</title>
      <link href="/2020/03/28/python_booklet/Python%E5%9F%BA%E7%A1%80%E6%89%8B%E5%86%8CP2%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/03/28/python_booklet/Python%E5%9F%BA%E7%A1%80%E6%89%8B%E5%86%8CP2%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-基本数据类型"><a href="#Python-基本数据类型" class="headerlink" title="Python 基本数据类型"></a>Python 基本数据类型</h1><p>。。。</p><p>今天没有想要写在开头的废话，，，好烦，要不破例直接开始吧。</p><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Python 是一门<strong>动态语言</strong>，这意味着 Python 变量本身的类型是不固定的。<br>在 Python 中使用变量前<strong>不用声明</strong>（不用写类似 <code>int a;</code> 的语句），<strong>在首次使用前为其赋初始值</strong>就行（直接用 <code>a = 0</code>）。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>实际上，在 Python 语法中并<strong>没有定义常量</strong>。</p><p>但是 <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> 定义了常量的命名规范为<strong>大写字母和下划线</strong>组成。在实际应用中，这种“常量”首次赋值后，<strong>无法阻止其他代码对其进行修改或删除</strong>。</p><p>要使用真正的常量，可以自己实现一个，例如：<a href="https://code.activestate.com/recipes/65207-constants-in-python/">constants-in-python</a>。</p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>Python 中使用 <code>None</code> 来代表空值。<br><code>None</code> 在交互式命令行中不会显示，但可以用 <code>print()</code> 打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Python 中有布尔值 <code>True</code> 和 <code>False</code>。</p><h3 id="真值问题"><a href="#真值问题" class="headerlink" title="真值问题"></a>真值问题</h3><p>代表 ‘假’ 的值有：<code>False</code>，<code>None</code>，<code>0</code>，<code>&#39;&#39;</code>，<code>[]</code>，<code>&#123;&#125;</code>，…；<br>其余值为真。</p><h3 id="布尔值的相关的运算"><a href="#布尔值的相关的运算" class="headerlink" title="布尔值的相关的运算"></a>布尔值的相关的运算</h3><table><thead><tr><th>逻辑运算符</th><th>相当于C中的</th></tr></thead><tbody><tr><td><code>and</code></td><td><code>&amp;&amp;</code></td></tr><tr><td><code>or</code></td><td>`</td></tr><tr><td><code>not</code></td><td><code>!</code></td></tr></tbody></table><p>⚠️【注意 <code>and</code> 的优先级高于 <code>or</code>。</p><table><thead><tr><th>比较运算符</th></tr></thead><tbody><tr><td><code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>!=</code></td></tr></tbody></table><p>使用比较运算符得到的结果是布尔值（<code>True</code> 或 <code>False</code>）。</p><p><strong>使用逻辑运算符得到的结果未必是布尔值</strong>：</p><p>具体的运算情况可以参考下面这段程序生成的表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **注意，是第一列的值 and|or 第一行的值！**</span></span><br><span class="line">li = [<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;or&#x27;</span>]</span><br><span class="line">ls = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;&quot;abc&quot;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> opt <span class="keyword">in</span> li:</span><br><span class="line">    <span class="comment"># head</span></span><br><span class="line">    print(<span class="string">&#x27;&lt;%s&gt;&#x27;</span> % opt, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> ls:</span><br><span class="line">        print(j, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">        <span class="comment"># col</span></span><br><span class="line">        print(i, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ls:</span><br><span class="line">            <span class="comment"># row</span></span><br><span class="line">            print(</span><br><span class="line">                    <span class="built_in">eval</span>(<span class="string">&#x27;%s %s %s&#x27;</span> % (i, opt, j)),</span><br><span class="line">                    end=<span class="string">&#x27;\t&#x27;</span></span><br><span class="line">                    )</span><br><span class="line">        print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># end</span></span><br><span class="line">    print(<span class="string">&#x27;\n-------\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从中可以看到，<br><code>and</code> 的规则是：</p><blockquote><p>前后两者 <strong>皆为真</strong> ，返回 <strong>后</strong> 者；<br>前后两者 <strong>有一假</strong> ，返回 <strong>假</strong> 者；<br>前后两者 <strong>皆为假</strong> ，返回 <strong>前</strong> 者；</p></blockquote><p><code>or</code> 的规则是：</p><blockquote><p>前后两者 <strong>皆为真</strong> ，返回 <strong>前</strong> 者；<br>前后两者 <strong>有一真</strong> ，返回 <strong>真</strong> 者；<br>前后两者 <strong>皆为假</strong> ，返回 <strong>后</strong> 者；</p></blockquote><p>此外，<br><code>not</code> 的规则是：</p><blockquote><p>若对象为 <strong>真</strong> ，返回 <code>False</code><br>若对象为 <strong>假</strong> ，返回 <code>True</code></p></blockquote><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="int-float"><a href="#int-float" class="headerlink" title="int, float"></a>int, float</h3><p>Python 中内置有 <a href="https://docs.python.org/3/library/functions.html#int">int</a> 和 <a href="https://docs.python.org/3/library/functions.html#float">float</a> 两类数字。</p><table><thead><tr><th>数字</th><th>含义</th><th>表示范围</th><th>精度</th></tr></thead><tbody><tr><td>int</td><td>整数</td><td>大小没有限制</td><td>始终是准确的</td></tr><tr><td>float</td><td>（基于二进制的）浮点数</td><td>有一定大小限制，超出后表示为inf</td><td>和C一样，不准确</td></tr></tbody></table><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>Python 还内置了对 <a href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)">复数</a> 的支持，使用后缀 <code>j</code> 或 <code>J</code> 表示虚数部分（例如，<code>3+5j</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">3</span> + <span class="number">1j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">3</span> - <span class="number">1j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * b</span><br><span class="line">(<span class="number">10</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>关于这部分详见<a href="https://docs.python.org/3/library/stdtypes.html#typesnumeric">官方文档</a>。</p><h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><p>在标准库中，python 还有对 <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal">精确小数 Decimal（基于十进制的浮点数）</a>和 <a href="https://docs.python.org/3/library/fractions.html#fractions.Fraction">分数  Fraction</a> 等其他数字类型的支持。</p><h4 id="Decimal-（小数）"><a href="#Decimal-（小数）" class="headerlink" title="Decimal （小数）"></a>Decimal （小数）</h4><p>在 Python 的标准库中，<code>decimal</code> 库提供了 <em>基于十进制的浮点数</em> <strong>Decimal</strong> 类型，这种数字类型修复了 float 的不准确问题，可以用 <strong>Decimal</strong> 实现更加精准的数学计算(但也不是绝对的准确，仍存在误差)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> - <span class="number">0.3</span>   <span class="comment"># float</span></span><br><span class="line"><span class="number">5.551115123125783e-17</span>       <span class="comment"># 这个结果是不精确的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) - Decimal(<span class="number">0.3</span>)   <span class="comment"># decimal</span></span><br><span class="line">Decimal(<span class="string">&#x27;2.775557561565156540423631668E-17&#x27;</span>)    <span class="comment"># 较为精确</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcontext().prec = <span class="number">12</span>    <span class="comment"># 限制 Decimal 的小数位数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) - Decimal(<span class="number">0.3</span>)</span><br><span class="line">Decimal(<span class="string">&#x27;1.11022302463E-17&#x27;</span>)</span><br></pre></td></tr></table></figure><p>正如上例，要使用 <code>Decimal</code> 类型，</p><ul><li><p>首先要 <code>import decimal</code>；</p></li><li><p>然后用 <code>decimal.Decimal(Num)</code>来获取一个 Decimal 实例，这里的 Num 可以是如下几种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">&#x27;3.14&#x27;</span>)     <span class="comment"># 内容是 float 的字符串</span></span><br><span class="line">Decimal(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal((<span class="number">0</span>, (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>), -<span class="number">2</span>))  <span class="comment"># tuple (sign, digit_tuple, exponent)，得到的值是 (-1) * sign * digit_tuple 代表数字 * 10 ^ exponent</span></span><br><span class="line">Decimal(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">314</span>)        <span class="comment"># int，float 都可以</span></span><br><span class="line">Decimal(<span class="string">&#x27;314&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(Decimal(<span class="number">314</span>))  <span class="comment"># 另一个 decimal 实例</span></span><br><span class="line">Decimal(<span class="string">&#x27;314&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">&#x27;  3.14  \\n&#x27;</span>)    <span class="comment"># 前后可以有空白字符</span></span><br><span class="line">Decimal(<span class="string">&#x27;3.14&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>decimal.getcontext().prec 代表有效位数，</p><ul><li>通过 <code>print(decimal.getcontext().prec)</code> 来查看当前值，默认是28位</li><li>通过 <code>decimal.getcontext().prec = Places</code> 来设置有效位数，这个精度的取值是 <code>[1, MAX_PREC]</code> ，MAX_PREC取值在64位机器上是 <code>999999999999999999</code>，32位为 <code>425000000</code>（这是因为这个值要可以转化为C的整型，详见<a href="https://github.com/python/cpython/blob/3.7/Lib/_pydecimal.py">Python版的源码</a>）！</li></ul></li><li><p>加减乘除运算入常</p></li></ul><h4 id="Fraction-（分数）"><a href="#Fraction-（分数）" class="headerlink" title="Fraction （分数）"></a>Fraction （分数）</h4><p>在 <code>fractions</code> 库中，定义了 <code>Fraction</code> 类型，用以表达分数，加减乘除运算入常。</p><p>使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.5</span>)    <span class="comment"># 传入 float，会自动算出分数表示</span></span><br><span class="line">Fraction(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1</span>, <span class="number">3</span>)   <span class="comment"># 传入 分子，分母</span></span><br><span class="line">Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">2</span>, <span class="number">6</span>)   <span class="comment"># 默认会有理化</span></span><br><span class="line">Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">2</span>, <span class="number">6</span>, _normalize=<span class="literal">False</span>)    <span class="comment"># 指定不有理化</span></span><br><span class="line">Fraction(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(Fraction(<span class="number">1</span>/<span class="number">11</span>))    <span class="comment"># 另一个 Fraction 实例，Decimal 实例也可以</span></span><br><span class="line">Fraction(<span class="number">3275345183542179</span>, <span class="number">36028797018963968</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">&#x27; 22/7 &#x27;</span>)    <span class="comment"># 使用代表分数的字符串，注意 numerator/denominator，中间不可有空格，前后可有空白字符</span></span><br><span class="line">Fraction(<span class="number">22</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>Python 中，字符串可以用单引号 (<code>&#39;...&#39;</code>) 或双引号 (<code>&quot;...&quot;</code>) 标识单行内的字符串，<br>还可以使用连续三个单/双引号(<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>)表示与格式化的多行字符。</p><p>Python没有单独的字符类型；一个字符就是一个简单的长度为1的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">&#x27;1\</span></span><br><span class="line"><span class="string">... 2\</span></span><br><span class="line"><span class="string">... 3\</span></span><br><span class="line"><span class="string">... a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st</span><br><span class="line"><span class="string">&#x27;123a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">&#x27;&#x27;&#x27;1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>3</span></span><br><span class="line"><span class="string"><span class="meta">... </span>a</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st</span><br><span class="line"><span class="string">&#x27;1\n2\n3\na\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>⚠️【注意】单引号可以包含双引号，<code>&#39;asd&quot;123&quot;fgh&#39;</code> 是允许的，同样 <code>&#39;&#39;&#39;</code> 中也可以包含 <code>&quot;&quot;&quot;</code>。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>首先，附上几种字符编码的比较：<br>| 编码 | 长度 | ‘A’ | ‘中’ |<br>| – | – | – | – |<br>| ASCII | 1 Byte | <strong>01000001</strong> | (无此字符) |<br>| Unicode | 通常是2 Byte | <em>00000000</em> <strong>01000001</strong> (ASCII前补零) | 01001110 00101101 |<br>| UTF-8 | 可变（1~6 Byte）| <strong>01000001</strong> （UTF-8包含着ASCII）| 11100100 10111000 10101101 |</p><p>Python3.x 默认用 Unicode 编码字符串。</p><p>编码 &lt;=&gt; 字符 的函数：</p><ul><li><code>ord()</code>：获取字符的整数表示；</li><li><code>chr()</code>：把编码转换成对应的字符；</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">66</span>)</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">20014</span>)</span><br><span class="line"><span class="string">&#x27;丮&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>Python 的字符串类型是 <code>str</code>。</p><blockquote><p><code>str</code> 在内存中以 Unicode 表示，一个字符对应若干字节。</p></blockquote><p>在写入二级缓存（本地-&gt;硬盘 | 远程-&gt;网络）时，<code>str</code>将变为<code>bytes</code>。</p><blockquote><p><code>bytes</code> 以字节为单位。</p></blockquote><p>Python 用带 <code>b</code> 前缀的单/双引号表示 <code>bytes</code>。</p><table><thead><tr><th>str</th><th>bytes</th></tr></thead><tbody><tr><td><code>&#39;ABC&#39;</code></td><td><code>b&#39;ABC&#39;</code></td></tr></tbody></table><hr><p>str &lt;=&gt; bytes:</p><ul><li>encode(): str –&gt; bytes</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)    <span class="comment"># 超出范围了，报错</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>decode(): bytes –&gt; str</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;abc&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)    <span class="comment"># 超出范围了，报错</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe4 in position 0: ordinal not in range(128)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 若 bytes 中包含无法解码的字节，decode() 会报错；</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 可以在调用 decode() 时传入 `errors=&#x27;ignore&#x27;` ，以忽略错误字节。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87asd&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;asd&#x27;</span></span><br></pre></td></tr></table></figure><p>⚠️【注意】为避免乱码问题，<strong>应始终使用 <code>utf-8</code> 编码对 <code>str</code> 和 <code>bytes</code> 进行转换。</strong></p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>Python 字符串中可以使用转义字符，可以参考下表：</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\</code>(在行尾时)</td><td>续行符</td></tr><tr><td><code>\\</code></td><td>反斜杠符号</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\a</code></td><td>响铃</td></tr><tr><td><code>\b</code></td><td>退格(Backspace)</td></tr><tr><td><code>\e</code></td><td>转义</td></tr><tr><td><code>\000</code></td><td>空</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\v</code></td><td>纵向制表符</td></tr><tr><td><code>\t</code></td><td>横向制表符</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\xxx</code></td><td>八进制数，例如：<code>&#39;\100&#39;</code> 代表 <code>&#39;@&#39;</code></td></tr><tr><td><code>\oyy</code></td><td>八进制数，yy代表的字符，例如：<code>&#39;\o12&#39;</code> 代表换行</td></tr><tr><td><code>\xyy</code></td><td>十六进制数，yy代表的字符，例如：<code>&#39;\x0a&#39;</code> 代表换行</td></tr><tr><td><code>\uxxxx</code></td><td>十六进制数，xxxx代表的字符，例如：<code>&#39;\u4e2d\u6587&#39;</code> 代表 <code>&#39;中文&#39;</code></td></tr><tr><td><code>\other</code></td><td>其它的字符以普通格式输出，例如：<code>&#39;\sds&#39;</code> 代表 <code>&#39;\\sds&#39;</code></td></tr></tbody></table><p>若要取消转义，可以给字符串 <code>r</code> 前缀：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;C:\some\name&#x27;</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r&#x27;C:\some\name&#x27;</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure><h3 id="基本字符串操作"><a href="#基本字符串操作" class="headerlink" title="基本字符串操作"></a>基本字符串操作</h3><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>Python 内置的 <code>len()</code> 函数可以获取多种类型的对象长度，包括字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(word)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 这个方法等效于：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.__len__()</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><ul><li>相邻的两个字符串文本自动连接在一起。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Py&#x27;</span> <span class="string">&#x27;thon&#x27;</span></span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 这个功能可以用来写长字符串：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">&#x27;Put several strings within parentheses &#x27;</span></span><br><span class="line">            <span class="string">&#x27;to have them joined together.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;Put several strings within parentheses to have them joined together.&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>字符串的 <code>+</code> 与 <code>*</code></li></ul><p>字符串可以由 + 操作符连接(粘到一起)，可以由 * 表示重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times &#x27;un&#x27;, followed by &#x27;ium&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">&#x27;un&#x27;</span> + <span class="string">&#x27;ium&#x27;</span></span><br><span class="line"><span class="string">&#x27;unununium&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>字符串的插值主要有 4 种方式：</p><ol><li>字符串连接</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;a is &quot;</span> + <span class="built_in">str</span>(a) + <span class="string">&quot;:)&quot;</span> </span><br><span class="line"><span class="string">&#x27;a is 123:)&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>%</code> 元组插值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">66.77</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a = %s, b = %s, c = %s&#x27;</span> % (a, b, c)</span><br><span class="line"><span class="string">&#x27;a = 123, b = 66.77, c = hello&#x27;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>字符串的 <code>format</code> 方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a = &#123;arg_a&#125;, b = &#123;arg_b&#125;, c = &#123;arg_c&#125;&#x27;</span>.<span class="built_in">format</span>(arg_a=<span class="string">&quot;东方&quot;</span>, arg_b=<span class="number">123</span>, arg_c=<span class="number">333.44</span>+<span class="number">8j</span>)</span><br><span class="line"><span class="string">&#x27;a = 东方, b = 123, c = (333.44+8j)&#x27;</span></span><br></pre></td></tr></table></figure><p>或者也可以匿名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Another way: &#123;0&#125;, &#123;2&#125;, &#123;1&#125;, &#123;3&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&quot;zero&quot;</span>, <span class="number">2</span>, <span class="number">1.0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;Another way: zero, 1.0, 2, 3&#x27;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>f-string</code></li></ol><p>Python 3.6 引入了 <code>f-string</code>，让插值更加优雅：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">456.789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> + <span class="subst">&#123;b&#125;</span> = <span class="subst">&#123;a+b&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;123 + 456.789 = 579.789&#x27;</span></span><br></pre></td></tr></table></figure><p>更多关于 <code>f-string</code> 的说明，可以参考 <a href="https://realpython.com/python-f-strings/">realpython的这篇文章</a>，或者查看 <code>f-string</code> 的来源：<a href="https://www.python.org/dev/peps/pep-0498/">PEP 498 – Literal String Interpolation</a>。</p><h4 id="字符串切分"><a href="#字符串切分" class="headerlink" title="字符串切分"></a>字符串切分</h4><p>用字符串的 split 方法可以以指定字符串为分割切分字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a b   c&#x27;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;he-*-ll-*-o--&#x27;</span>.split(<span class="string">&#x27;-*-&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;he&#x27;</span>, <span class="string">&#x27;ll&#x27;</span>, <span class="string">&#x27;o--&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>用字符串的 replace 方法可以替换字符串的一部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;he-*-ll-*-o--&#x27;</span>.replace(<span class="string">&#x27;-*-&#x27;</span>, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;he...ll...o--&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串索引及切片"><a href="#字符串索引及切片" class="headerlink" title="字符串索引及切片"></a>字符串索引及切片</h4><ul><li><strong>索引</strong></li></ul><table><thead><tr><th>字符</th><th>P</th><th>y</th><th>t</th><th>h</th><th>o</th><th>n</th></tr></thead><tbody><tr><td>正向索引</td><td>0（-0）</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>反向索引</td><td>-6</td><td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">&#x27;o&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>切片</strong></li></ul><p>索引用于获得单个字符，切片 让你获得一个子字符串。</p><p>切片的规则是：<code>str[起始:末尾:间隔]</code><br>    * 起始：开始的索引（取），缺省为0<br>    * 末尾：结束的索引(不取)，缺省时，取到字符串最后一个字符（取得到）<br>    * 间隔：每取一个之后间隔几个（&gt;0），缺省为1，为负值时倒着取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 几个常用模式：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">1</span>:-<span class="number">1</span>]    <span class="comment"># 去掉首位字符（可以用来去括号、引号）</span></span><br><span class="line"><span class="string">&#x27;ytho&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[::-<span class="number">1</span>]    <span class="comment"># 字符串反向</span></span><br><span class="line"><span class="string">&#x27;nohtyP&#x27;</span></span><br></pre></td></tr></table></figure><p>⚠️【注意】切片包含起始的字符，不包含末尾的字符。<br><code>s[:i] + s[i:] == s</code><br>⚠️【注意】字符串<strong>索引、切片</strong>都是<strong>只读</strong>的，不可以给字符串索引、切片赋值！</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>字符串的使用肯定绕不过正则表达式，python 内置了正则表达式模块—— <code>re</code> 。</p><p>我不在这里介绍正则表达式的写法，只是展示怎么用 Python 完成常见的正则表达式操作。正则本身有问题，请到 <a href="https://regexr.com./">https://regexr.com。</a></p><p><strong>匹配</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&#x27;abc(.*?)def&#x27;</span><span class="comment"># 正则里有大量&#x27;\&#x27;,用r字符串取消转义</span></span><br><span class="line">test = <span class="string">&#x27;abc123def&#x27;</span></span><br><span class="line"><span class="keyword">if</span> re.match(pattern, test):</span><br><span class="line">    print(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;failed&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>提取</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&#x27;abc(.*?)def(\d+)&#x27;</span></span><br><span class="line">test = <span class="string">&#x27;abc123def456&#x27;</span></span><br><span class="line">m = re.match(pattern, test)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">    print(m.groups())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;failed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>用 m.groups() 即可获取提取到的组：<code>(&#39;123&#39;, &#39;456&#39;)</code>。</p><p><strong>切分</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切分</span></span><br><span class="line">re.split(<span class="string">r&#x27;[\s\,\;]+&#x27;</span>, <span class="string">&#x27;a,b;; c  d&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>其实，在我心中，字符串也是种集合类型（你学过C语言就会有同感了，字符串不过是字符组成的 list 而已）。所以，刚才介绍字符串的很多操作，在接下来的 list 中也一样适用。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list：列表，写在 <code>[]</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l0 = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;l0&#125;</span>\n<span class="subst">&#123;l1&#125;</span>\n<span class="subst">&#123;l2&#125;</span>&#x27;</span>)</span><br><span class="line">[]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>索引&amp;切片</strong>：</p><ul><li>get：<code>lst[索引 || 切片]</code></li><li>set：<code>lst[索引 || 切片] = 值</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l[0] &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; l[0]</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure><p>索引&amp;切片 和字符串中介绍的相同，不了解可以这回去看。</p><p>我们来看 list 的基本操作：</p><p><strong>尾部添加</strong>：<code>lst.append(值)</code>, <code>lst.extend(iterable)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">999</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.extend([<span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;好&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.extend(&#123;<span class="string">&#x27;再&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;见&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">12</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="number">999</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;好&#x27;</span>, <span class="string">&#x27;再&#x27;</span>, <span class="string">&#x27;见&#x27;</span>]</span><br></pre></td></tr></table></figure><p>append 和 extend 一个是添加单个元素，一个是添加一系列元素。</p><p>利用切片，append 方法就等效于 <code>lst[len(lst):] = [值]</code>, 而 extend 即 <code>lst[len(lst):] = iterable</code>。</p><p><strong>插入</strong>：<code>lst.insert(索引, 值)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.insert(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.insert(<span class="built_in">len</span>(l), <span class="number">200</span>)       <span class="comment"># 等效于 l.append(200)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.insert(<span class="number">1</span>, <span class="number">300</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.insert(<span class="number">1</span>, <span class="number">400</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">100</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">200</span>]</span><br></pre></td></tr></table></figure><p><strong>删</strong>：<code>lst.remove(值)</code>, <code>lst.pop(索引)</code>, <code>clear()</code></p><p>remove 是删除 list 中存在的一个值，若不存在，会报 ValueError。</p><p>pop 是删除 list 中给定索引处的值，若索引越界，会报 IndexError。</p><p>clear 就是清空（删除）所有元素；也可以用 <code>del a[:]</code> 完成类似的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">100</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">200</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.remove(<span class="number">400</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.pop()<span class="comment"># pop 缺省参数则出最后一个，等效于 pop(-1) 或 pop(len(l)-1)</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">300</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.remove(<span class="string">&#x27;fool&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="built_in">list</span>.remove(x): x <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.pop(<span class="number">999</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: pop index out of <span class="built_in">range</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p><strong>其他操作</strong>：</p><ul><li><code>list.index(x[, start[, end]])</code>: 你给值，它返索引</li><li><code>list.count(x)</code>: 你给值，它告诉你有几个</li><li><code>list.sort(key=None, reverse=False)</code>: 一种比较快的原址排序</li><li><code>list.reverse()</code>: 列表反转，调个个（这个词好怪a，我的问题嘛？）</li><li><code>list.copy()</code>: 返一个自己的<em>浅拷贝</em>。</li></ul><p>关于 list ，可以写的东西实在太多了，都可以单独再写一篇，专门研究了。。。（以后再说吧，可能我会写吧，用了复习数据结构课。）</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple：元组，和 list 类似，只是常写在 <code>()</code> 中。</p><p>tuple 可以 get，<strong>不能set</strong>。也就是说，不能 append、不能 pop、不能索引赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">1</span>] = <span class="string">&quot;sdfdsf&quot;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.append(<span class="number">12</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;append&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.pop()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;pop&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">1</span>:]</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>注意，刚才我写了一句“tuple常写在<code>()</code>中”，何来此“常”，tuple 不就是写在圆括号里的嘛？如果你有此疑问，一定是没有好好读过文档。</p><p>给你个改过自新的机会：<a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</a>：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeo2dghg1j304j03mdfs.jpg" alt="RTFM"></p><p>文档里写了：</p><blockquote><p> A tuple consists of a number of values separated by commas.</p></blockquote><p>意思是说：“元组(tuple)是一系列用逗号分开的值！”，可没提用圆括号扩起来的呀，再看看这个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples 可以嵌套:</span></span><br><span class="line"><span class="meta">... </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples 不可变:</span></span><br><span class="line"><span class="meta">... </span>t[<span class="number">0</span>] = <span class="number">88888</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 但可以包含可变的元素:</span></span><br><span class="line"><span class="meta">... </span>v = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>可见，tuple 对 Python 中例如函数参数的一系列元素的打包传递相当有用！</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set</code> 是保证<strong>元素唯一</strong>的<strong>无序</strong>集合。</p><p>我们一般也就用它来消除重复，保证唯一。当然，你应该知道，<code>set</code> 就大概对应于数学里的「集合」，所以 <code>set</code> 可以算 <del>病娇茶部</del> 并、交、差、<del>补</del>（你可以想象，数学那种补是不能算的，但可以算「<a href="https://en.wikipedia.org/wiki/Symmetric_difference">对称差</a>」）。</p><p>创建一个 set 有两种写法：<code>set()</code> 函数和使用花括号 <code>&#123;ele1, ele2, ...&#125;</code>。但如果你要建空 set，只能用 <code>set()</code>，而不能用 <code>&#123;&#125;</code>！因为你应该知道，<code>&#123;&#125;</code> 建的是空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;</span></span><br><span class="line">&gt;&gt;&gt; s = set()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt;</span></span><br><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s2)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b    <span class="comment"># 并，类似于「逻辑或」：在a或在b或都在</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b    <span class="comment"># 交，类似于「逻辑与」：在a且在b</span></span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b    <span class="comment"># 差，类似于「逻辑差」：在a不在b</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b    <span class="comment"># 对称差，类似于「逻辑异或」：在a或在b，但不都在</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict：字典，键值对，底层实现是哈希表。字面值写作 <code>&#123;key1: value1, key2: value2, ...&#125;</code>。</p><p>既然 dict 都写成和 set 一样的 <code>&#123;&#125;</code> 了，那你看可以想象，dict 也可以保证唯一性 —— dict保证 key 的唯一。</p><p>key 可以是任何「不可变」的值，也就是说，数字、字符串、不包含可变元素的元组都可以作为 key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2.0001</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"><span class="number">2.0001</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;guido&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="number">4098</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> tel[<span class="string">&#x27;sape&#x27;</span>]<span class="comment"># 删除元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;irv&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;irv&#x27;</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(tel)<span class="comment"># 取键</span></span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(tel)</span><br><span class="line">[<span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> tel<span class="comment"># 键在不在字典里</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>用 <code>dict()</code> 函数可以有更多初始化字典的技巧，我随便从文档抄两个，你细品：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;sape&#x27;</span>, <span class="number">4139</span>), (<span class="string">&#x27;guido&#x27;</span>, <span class="number">4127</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><p>推导式（comprehensions）是用来创建集合类型实例的。</p><p>比如，你想建一个“1到10的平方组成的list”，你如何来写代码？</p><p>当然，数据量不大，我们肯定可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>但如果是1～100，1～100000呢？你想用循环对吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line"><span class="meta">... </span>    a.append(i**<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span></span><br></pre></td></tr></table></figure><p>但这样不够简洁！</p><p>“1到10的平方组成的list”，说起来就一句话，代码也应该简简单单一行就完成！「推导式」就是干这个的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>推导式的一般形式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[表达式 任意个<span class="keyword">for</span>或<span class="keyword">if</span>句]</span><br></pre></td></tr></table></figure><p>这个例子可以给你个比较好的印象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y, x*y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">12</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 相当于：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>            combs.append((x, y, x*y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><p>其实准确的说，我们刚才写的这些都是「列表推导式」。我们还有「set推导式」甚至是「dict推导式」。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><p>你可能还想写这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x107988bd0</span>&gt;</span><br></pre></td></tr></table></figure><p>哈哈，有点不一样了，这次它给你返了个 generator——生成器，这就不是推导式了，这里不做介绍，后面我们再讨论这东西。</p><p>最后，再看两个很有意思的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[(j, i, j*i) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">或</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(j, i, j*i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>)]</span><br><span class="line">[[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)], [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)], [(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>)], [(<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">12</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">16</span>)], [(<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">5</span>, <span class="number">15</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">20</span>), (<span class="number">5</span>, <span class="number">5</span>, <span class="number">25</span>)], [(<span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">18</span>), (<span class="number">4</span>, <span class="number">6</span>, <span class="number">24</span>), (<span class="number">5</span>, <span class="number">6</span>, <span class="number">30</span>), (<span class="number">6</span>, <span class="number">6</span>, <span class="number">36</span>)], [(<span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">7</span>, <span class="number">14</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">21</span>), (<span class="number">4</span>, <span class="number">7</span>, <span class="number">28</span>), (<span class="number">5</span>, <span class="number">7</span>, <span class="number">35</span>), (<span class="number">6</span>, <span class="number">7</span>, <span class="number">42</span>), (<span class="number">7</span>, <span class="number">7</span>, <span class="number">49</span>)], [(<span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>), (<span class="number">2</span>, <span class="number">8</span>, <span class="number">16</span>), (<span class="number">3</span>, <span class="number">8</span>, <span class="number">24</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">32</span>), (<span class="number">5</span>, <span class="number">8</span>, <span class="number">40</span>), (<span class="number">6</span>, <span class="number">8</span>, <span class="number">48</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">56</span>), (<span class="number">8</span>, <span class="number">8</span>, <span class="number">64</span>)], [(<span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">9</span>, <span class="number">18</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>), (<span class="number">4</span>, <span class="number">9</span>, <span class="number">36</span>), (<span class="number">5</span>, <span class="number">9</span>, <span class="number">45</span>), (<span class="number">6</span>, <span class="number">9</span>, <span class="number">54</span>), (<span class="number">7</span>, <span class="number">9</span>, <span class="number">63</span>), (<span class="number">8</span>, <span class="number">9</span>, <span class="number">72</span>), (<span class="number">9</span>, <span class="number">9</span>, <span class="number">81</span>)]]</span><br></pre></td></tr></table></figure><p>乘法表，这两种写法效果是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>没错！矩阵转置，利用推导式中只用一行代码就可以实现。</p><hr><p>未完待续…</p><p>（最近这两天都在补作业呀、补作业呀、补作业呀…不补作业的时候还要打游戏…忙得很。而且最近练习双拼，中文打字速度直线下降，所以这篇写了好久。现在作业大概补完了，双拼也已有了小成（大概？），以后应该会快一些了。）</p><p>Next: 【Python流程控制】</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 239. 滑动窗口最大值</title>
      <link href="/2020/03/26/School/Leetcode_P239_sliding-window-maximum/"/>
      <url>/2020/03/26/School/Leetcode_P239_sliding-window-maximum/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-239-滑动窗口最大值"><a href="#Leetcode-239-滑动窗口最大值" class="headerlink" title="Leetcode 239. 滑动窗口最大值"></a>Leetcode <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <em>nums</em>，有一个大小为 <em>k</em> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <em>k</em> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>进阶：</strong></p><p>你能在线性时间复杂度内解决此题吗？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="双向队列法"><a href="#双向队列法" class="headerlink" title="双向队列法"></a>双向队列法</h2><p>我们可以维护一个一个<strong>双向队列</strong>，在里面维护存在于<strong>当前窗口中的</strong>逐步最大值索引 ，每一步右端压入当前索引、清除比当前小的值的索引。从 k 处开始，每次取左端值即当前滑窗的最大值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; k || k &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> e <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    swMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    swMax[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> e = <span class="built_in">len</span>(memo); e &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[memo[e<span class="number">-1</span>]]; e-- &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        memo = memo[:e]</span><br><span class="line">        memo = <span class="built_in">append</span>(memo, i)</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; swMax[<span class="number">0</span>] &#123;</span><br><span class="line">            swMax[<span class="number">0</span>] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(memo)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// leaving</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(memo) != <span class="number">0</span> &amp;&amp; memo[<span class="number">0</span>] == i - k &#123;</span><br><span class="line">            memo = memo[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// entering</span></span><br><span class="line">        <span class="keyword">for</span> e = <span class="built_in">len</span>(memo); e &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[memo[e<span class="number">-1</span>]]; e-- &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        memo = memo[:e]</span><br><span class="line">        memo = <span class="built_in">append</span>(memo, i)</span><br><span class="line">        <span class="comment">// ans</span></span><br><span class="line">        swMax = <span class="built_in">append</span>(swMax, nums[memo[<span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> swMax</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 641. 设计循环双端队列</title>
      <link href="/2020/03/26/School/Leetcode_P641_design-circular-deque/"/>
      <url>/2020/03/26/School/Leetcode_P641_design-circular-deque/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-641-设计循环双端队列"><a href="#Leetcode-641-设计循环双端队列" class="headerlink" title="Leetcode 641. 设计循环双端队列"></a>Leetcode <a href="https://leetcode-cn.com/problems/design-circular-deque/">641. 设计循环双端队列</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p><ul><li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li><li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li><li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li><li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li><li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li><li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li><li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li><li>isEmpty()：检查双端队列是否为空。</li><li>isFull()：检查双端队列是否满了。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3</span><br><span class="line">circularDeque.insertLast(1);        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertLast(2);        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(3);        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);        &#x2F;&#x2F; 已经满了，返回 false</span><br><span class="line">circularDeque.getRear();  &#x2F;&#x2F; 返回 2</span><br><span class="line">circularDeque.isFull();        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.deleteLast();        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.getFront();&#x2F;&#x2F; 返回 4</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p>经典的数据结构就不解释了，大家都懂，直接上代码，Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">int</span></span><br><span class="line">Next *Node</span><br><span class="line">Priv *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyCircularDeque <span class="keyword">struct</span> &#123;</span><br><span class="line">Front  *Node</span><br><span class="line">Last   *Node</span><br><span class="line">length <span class="keyword">int</span></span><br><span class="line">maxLen <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">MyCircularDeque</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> MyCircularDeque&#123;</span><br><span class="line">length: <span class="number">0</span>,</span><br><span class="line">maxLen: k,</span><br><span class="line">Front:  <span class="literal">nil</span>,</span><br><span class="line">Last:   <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">InsertFront</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == this.maxLen &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line">this.Last = &amp;Node&#123;</span><br><span class="line">Data: value,</span><br><span class="line">&#125;</span><br><span class="line">this.Front = this.Last</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.Front.Priv = &amp;Node&#123;</span><br><span class="line">Data: value,</span><br><span class="line">Next: this.Front,</span><br><span class="line">&#125;</span><br><span class="line">this.Front = this.Front.Priv</span><br><span class="line">&#125;</span><br><span class="line">this.length++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the Last of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">InsertLast</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == this.maxLen &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line">this.Front = &amp;Node&#123;</span><br><span class="line">Data: value,</span><br><span class="line">&#125;</span><br><span class="line">this.Last = this.Front</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.Last.Next = &amp;Node&#123;</span><br><span class="line">Data: value,</span><br><span class="line">Priv: this.Last,</span><br><span class="line">&#125;</span><br><span class="line">this.Last = this.Last.Next</span><br><span class="line">&#125;</span><br><span class="line">this.length++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">DeleteFront</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.Front = this.Front.Next</span><br><span class="line"><span class="keyword">if</span> this.Front != <span class="literal">nil</span> &#123;</span><br><span class="line">this.Front.Priv = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">this.length--</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the Last of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">DeleteLast</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.Last = this.Last.Priv</span><br><span class="line"><span class="keyword">if</span> this.Last != <span class="literal">nil</span> &#123;</span><br><span class="line">this.Last.Next = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">this.length--</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">GetFront</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.Front.Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">GetLast</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.Last.Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias of GetLast for the foolish leetcode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">GetRear</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.length == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.Last.Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (this.length == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (this.length == this.maxLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(k);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.InsertFront(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.InsertLast(value);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.DeleteFront();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.DeleteLast();</span></span><br><span class="line"><span class="comment"> * param_5 := obj.GetFront();</span></span><br><span class="line"><span class="comment"> * param_6 := obj.GetLast();</span></span><br><span class="line"><span class="comment"> * param_7 := obj.IsEmpty();</span></span><br><span class="line"><span class="comment"> * param_8 := obj.IsFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>吐槽一下Leetcode，给你的模版里是个 <code>GetLast</code>，你写好了，运行的时候就会爆出个错说你的 MyCircularDeque 里方法 <code>GetRear</code> 缺失，要把 GetLast 的代码抄一遍写个 GetRear 才行！</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd730nmy30j31930u01kx.jpg" alt="image-20200326094017120"></p><p>用链表做算法题肯定时间空间结果都不好，但有意思嘛，写个切片去套快是快了、空间用的也小。</p><h2 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h2><p>参考 <a href="https://blog.csdn.net/JoshuaTsui/article/details/105102674">JoshuaTsui《LeetCode 设计循环双端队列》</a>，Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCircularDeque <span class="keyword">struct</span> &#123;</span><br><span class="line">data   []<span class="keyword">int</span></span><br><span class="line">pFront <span class="keyword">int</span></span><br><span class="line">pAfterLast  <span class="keyword">int</span></span><br><span class="line">maxLen <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">MyCircularDeque</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> MyCircularDeque&#123;</span><br><span class="line">maxLen: k+<span class="number">1</span>,</span><br><span class="line">pFront: <span class="number">0</span>,</span><br><span class="line">pAfterLast: <span class="number">0</span>,</span><br><span class="line">data: <span class="built_in">make</span>([]<span class="keyword">int</span>, k+<span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">InsertFront</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsFull() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.pFront = (this.pFront - <span class="number">1</span> + this.maxLen) % this.maxLen<span class="comment">// notice to promise &gt;= 0</span></span><br><span class="line">this.data[this.pFront] = value</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the Last of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">InsertLast</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsFull() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.data[this.pAfterLast] = value</span><br><span class="line">    this.pAfterLast = (this.pAfterLast + <span class="number">1</span>) % this.maxLen</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">DeleteFront</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.pFront = (this.pFront + <span class="number">1</span>) % this.maxLen</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the Last of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">DeleteLast</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.pAfterLast = (this.pAfterLast - <span class="number">1</span> + this.maxLen) % this.maxLen</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">GetFront</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.data[this.pFront]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">GetLast</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.data[(this.pAfterLast - <span class="number">1</span> + this.maxLen) % this.maxLen]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias of GetLast for the foolish leetcode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">GetRear</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.data[(this.pAfterLast - <span class="number">1</span> + this.maxLen) % this.maxLen]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (this.pFront == this.pAfterLast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (this.pAfterLast + <span class="number">1</span>) % this.maxLen == this.pFront</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd76ckm54wj31930u01kx.jpg" alt="image-20200326113533190"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2020/03/25/Algorithm/greedy_algorithm/"/>
      <url>/2020/03/25/Algorithm/greedy_algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote><p>这是篇很老的博客了，是我刚学贪心的时候写的笔记。今天无意间翻到，就分享一下。</p><p>内容没写多少，主要是看例子，这几个题都比较经典，都是当时我参考大佬的博客自己研究了写的（都是运行了测试过的，但时间长了，我不保证都对）。</p></blockquote><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>贪心选择是采用从顶向下（问题拆分）、以迭代的方法做出相继选择（循环处理拆分出的部分），每做一次贪心选择就将所求问题简化为一个规模更小的子问题（找出这个部分的贪心最优解）。</p><p>贪心算法追求的不是问题整体上的最优解，只是迭代找到各部分贪心较优解（最关注的那一项），并将循环结果作为较为满意的解（贪心算法的每一次操作都对结果产生直接影响）。</p><p>找到最优解要穷举所有可能，因此会消耗大量时间。而贪心算法常以每一个迭代的情况为基础做最优选择，而不考虑整体情况（贪心算法不需要回溯），因此可以快速找到较优解。</p><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><ul><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fat = 问题</span><br><span class="line">sub = 拆分(fat)</span><br><span class="line"><span class="keyword">for</span> a_part <span class="keyword">in</span> sub:</span><br><span class="line">    res.append(贪心最优解(a_part))</span><br><span class="line">    </span><br><span class="line">print(<span class="string">&quot;问题的较优解&quot;</span>, res)</span><br></pre></td></tr></table></figure><h3 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h3><ol><li>背包问题</li></ol><p><em>有一个背包，背包容量是M=150kg。有几个物品，。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</em></p><pre><code>（1）物品**不可以**分割成任意大小</code></pre><p>这里以物体的价值与质量比作为标准，每次迭代都找比值较优的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coding : c++ 11</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEIGHT_OF_BAG 150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> id;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">double</span> value;</span><br><span class="line"><span class="keyword">double</span> value_pre_weight;</span><br><span class="line"><span class="keyword">bool</span> chosen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node arr[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> weights[MAX] = &#123;<span class="number">35</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> values[MAX]  = &#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">/*拆分问题*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123;</span><br><span class="line">arr[i].id = i;</span><br><span class="line">arr[i].weight = weights[i];</span><br><span class="line">arr[i].value = values[i];</span><br><span class="line">arr[i].value_pre_weight = values[i]/weights[i];</span><br><span class="line">arr[i].chosen = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*寻求部分贪心最优解*/</span></span><br><span class="line"><span class="keyword">double</span> total_weight = <span class="number">0</span>, total_value = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; chosen_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (total_weight &lt; WEIGHT_OF_BAG) &#123;</span><br><span class="line"><span class="keyword">double</span> greatest = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i].chosen == <span class="literal">false</span> &amp;&amp; total_weight + arr[i].weight &lt;= <span class="number">150</span> &amp;&amp; arr[i].value_pre_weight &gt;= greatest) &#123;</span><br><span class="line">greatest = arr[i].value_pre_weight;</span><br><span class="line">choice = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[choice].chosen = <span class="literal">true</span>;</span><br><span class="line">chosen_list.push_back(arr[choice]);</span><br><span class="line">total_weight += arr[choice].weight;</span><br><span class="line">total_value += arr[choice].value;</span><br><span class="line">greatest = arr[choice].value_pre_weight;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/*将结果循环作为问题的较优解*/</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chosen:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : chosen_list)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\tThe &quot;</span> &lt;&lt; <span class="keyword">int</span>(item.id) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Total weight:\t&quot;</span> &lt;&lt; total_weight</span><br><span class="line">&lt;&lt; <span class="string">&quot;\nTotal value:\t&quot;</span> &lt;&lt; total_value</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   (2)物品<strong>可以</strong>分割成任意大小<br>   这里以物体质量为标准<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bag</span><span class="params">(<span class="keyword">double</span> m, <span class="keyword">double</span> *v, <span class="keyword">double</span> *w, <span class="keyword">double</span> *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> maxWeight = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">double</span> wts[] = &#123; <span class="number">10</span>,  <span class="number">30</span>,  <span class="number">20</span>,  <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> vls[] = &#123;<span class="number">200</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> res[N] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 记录装物品的比例</span></span><br><span class="line"></span><br><span class="line">bag(maxWeight, vls, wts, res);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--[%d]: %lf\n&quot;</span>, i, res[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寻找贪心最优解*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bag</span><span class="params">(<span class="keyword">double</span> m, <span class="keyword">double</span> *v, <span class="keyword">double</span> *w, <span class="keyword">double</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (m - w[i] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">x[i] = <span class="number">1.0</span>;</span><br><span class="line">m -= w[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; N)</span><br><span class="line">x[i] = m/w[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>2. 换零钱问题<br>假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chosen</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> Count[N] = &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Value[N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Chosen&gt; got;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> c = min(money/Value[i], Count[i]);</span><br><span class="line">money = money - c * Value[i];</span><br><span class="line">num += c;</span><br><span class="line"></span><br><span class="line">Chosen temp;</span><br><span class="line">temp.value = Value[i];</span><br><span class="line">temp.count = c;</span><br><span class="line">got.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (money &gt; <span class="number">0</span>)</span><br><span class="line">num = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> money;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter money: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = solve(money);</span><br><span class="line"><span class="keyword">if</span> (res != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n共&quot;</span>&lt;&lt; res &lt;&lt; <span class="string">&quot; 张。&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : got)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d个%2d元\t&quot;</span>, i.count, i.value);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCan&#x27;t solve!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>活动安排<br>有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd68gim7rwj30x808w0z0.jpg" alt="屏幕快照 2020-03-25 16.02.45"></p><p>贪心策略应该是每次选取结束时间最早的活动。直观上也很好理解，按这种方法选择相容活动为未安排活动留下尽可能多的时间。这也是把各项活动按照结束时间单调递增排序的原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Action</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line">&#125; act[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Action a, struct Action b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (act[j].start &gt;= act[i].end) &#123;</span><br><span class="line">i = j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t%2d : From %2d To %2d\n&quot;</span>, i, act[i].start, act[i].end);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;几组测试数据: &quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 共几个活动: &quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;活动&quot;</span> &lt;&lt; i &lt;&lt;<span class="string">&quot;的始末：&quot;</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;act[i].start, &amp;act[i].end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">act[<span class="number">0</span>].start = act[<span class="number">0</span>].end = <span class="number">-1</span>;</span><br><span class="line">sort(act + <span class="number">1</span>, act + N + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">int</span> res = greedy();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;共可安排：&quot;</span>&lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>机器安排<br>n个作业组成的作业集，可由m台相同机器加工处理。要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。作业不能拆分成更小的子作业；每个作业均可在任何一台机器上加工处理。</li></ol><p>首先将n个作业从大到小排序，然后依此顺序将作业分配给空闲的处理机。也就是说从剩下的作业中，选择需要处理时间最长的，然后依次选择处理时间次长的，直到所有的作业全部处理完毕，或者机器不能再处理其他作业为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Work = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>, n=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Work&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;machines: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Works: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Work&gt; <span class="title">mch</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">Work temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d].length: &quot;</span>, i);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">arr.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-----\n&quot;</span>;</span><br><span class="line">sort(arr.begin(), arr.end(), [](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;<span class="comment">// Check each machine</span></span><br><span class="line"><span class="keyword">if</span> (mch[j] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Use (%d) to process [length_%d];\n&quot;</span>, j, arr[i]);</span><br><span class="line">mch[j] = arr[i];</span><br><span class="line">i++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : mch)</span><br><span class="line">p--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P20 有效的括号</title>
      <link href="/2020/03/24/School/Leetcode_P20_valid-parentheses/"/>
      <url>/2020/03/24/School/Leetcode_P20_valid-parentheses/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-20-有效的括号"><a href="#Leetcode-20-有效的括号" class="headerlink" title="Leetcode 20. 有效的括号"></a>Leetcode <a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>括号不匹配的情况很多，但匹配的情况就3种：<code>()</code>，<code>[]</code>，<code>&#123;&#125;</code>。</p><p>以前刚学算法的时候看过一个大佬写的暴力解法，他把不匹配的情况的情况穷举出来了！他那个跑的飞快，但巨复杂。</p><p>我脑子没那么好，写不出他那个来。所以我选择老老实实用栈。我的思路很直接，遇到前括号就入栈，遇到后括号就出栈。如果每一步都匹配，且最后栈为空，就匹配成功。这个思路和人去判断是一致的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        match = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> match.values():</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                front = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> match.get(i) != front:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">len</span>(stack) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4p1lylnsj31r90u0dk8.jpg" alt="image-20200324080539922"></p><p>其实这代码是我以前刚学的时候写的了，所以很慢。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础手册P1 启动、注释和运算符</title>
      <link href="/2020/03/23/python_booklet/Python%E5%9F%BA%E7%A1%80%E6%89%8B%E5%86%8CP1%20%E5%90%AF%E5%8A%A8%E3%80%81%E6%B3%A8%E9%87%8A%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/03/23/python_booklet/Python%E5%9F%BA%E7%A1%80%E6%89%8B%E5%86%8CP1%20%E5%90%AF%E5%8A%A8%E3%80%81%E6%B3%A8%E9%87%8A%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础手册P1-启动、注释和运算符"><a href="#Python基础手册P1-启动、注释和运算符" class="headerlink" title="Python基础手册P1 启动、注释和运算符"></a>Python基础手册P1 启动、注释和运算符</h1><p>[TOC]</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>我很长时间之前就打算写一个系列的文章，以一个非初学者的视角讨论 Python 基础。</p><p>从入门到进阶的初学者指南很多，有的写的也相当出色，比如我自己入门学习的廖雪峰老师的Python教程。说实话，要在这些入门教程中再添一笔，不是件容易的事，我也无心研究编程入门教学。</p><p>我希望的是，整理一下 Python 基础，并少量对照源码，通过自己的研究写一些东西，在这个过程中夯实基础，提升技能。</p><p>这个系列暂定名为《Python基础手册》。这更像是一本给自己的 Python 操作手册，一本 My version 的 Python Cookbook。</p><p>看看基础，写写实例，读读源码，再作成笔记，希望助更多学习 Python 的朋友一臂之力。</p><hr><p>既然不是面向初学者，那就需要读者有一定的基础。比如，在阅读本文前，您应该懂得命令行的使用，如果这方面的知识您有所欠缺，我推荐学习 Zed A. Shaw 的《命令行快速入门》（您可以在 <a href="https://learnpythonthehardway.org/book/appendixa.html">Zed A. Shaw 的网站</a> 上阅读这一内容）。</p><p>（你大可不看。我尝试过很多办法力荐身边的朋友（那些惯用Windows的朋友）使用命令行，但都基本无效。我现在不想再做这件事了，既然有人可以忍受不会使用命令行而带来的不便，那我也不好说什么。毕竟，我会使用命令行，用的不好，但足够应付我遇到的问题，而你不会命令行，麻烦的不是我。在享受命令行的强大的同时，冷眼嘲讽那些看着视窗，对于“从特定文件中提取特定的字段来批量重命名数百个文件”这样的简单入门级命令行任务无从下手、只好开始百度“一键批量重命名神器.exe下载”的典型***也是一件令人愉悦的事）</p><p>哈哈，言重了，其实 Python 也可以相当优雅的完成这个任务，有机会的话，我会在以后的文章中介绍如何用 Python 解决这些琐事。但这需要我们现在先来看一看 Python 到底怎么用👇👇👇</p><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>你知道 Python 是解释型语言啦，所以有一个叫 Python 解释器的东西啦。我们写的 Python 代码就是通过解释器运行起来的。</p><p>废话不多说，来看这解释器的用法：</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li><code>$ python</code>: 进入交互式环境。</li><li><code>$ python -</code>: 脚本名指定为 ‘-‘ （表示标准输入），与<code>$ python</code>等效。</li><li><code>$ python -c command [arg] ...</code>: 在命令行执行 Python 语句，类似于 shell 中的 -c 选项。用’单引号’包裹command，其中写python语句，类似于awk。</li><li><code>$ python -m module [arg] ...</code>: 有一些 Python 模块也可以当作脚本使用。这类似在命令行中键入完整的路径名执行模块源文件一样。</li><li><code>$ python filename</code>: 执行python源文件。</li><li><code>$ python -i filename</code>: 执行python源文件，然后不退出，留在python交互式命令行。</li></ul><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li>输入一个文件结束符（Unix 系统是 <code>Control-D</code>，Windows 系统是 <code>Control-Z</code>）让解释器以 0 状态码退出。</li><li>输入 <code>quit()</code> 命令退出解释器。</li><li>输入 <code>exit()</code> 命令退出解释器。</li></ul><h3 id="命令行参数传递"><a href="#命令行参数传递" class="headerlink" title="命令行参数传递"></a>命令行参数传递</h3><p>调用解释器时，脚本名和附加参数传入一个名为 <code>sys.argv</code> 的字符串列表，这类似于C语言main函数的 <code>char *argv[]</code>。</p><p>取用 <code>sys.argv</code> 前要 <code>import sys</code>。</p><p>关于 argv 的行为，我们借用C/C++的 switch-case 语句的形式来讨论：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (输入命令) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;$ python&quot;</span>: </span><br><span class="line">        <span class="comment">// sys.argv 有一个元素：sys.argv[0] 此时为空字符串</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;$ python -&quot;</span>:</span><br><span class="line">        <span class="comment">// sys.argv[0] 被设定为 &#x27;-&#x27;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;$ python -c command [arg] ...&quot;</span>:</span><br><span class="line">        <span class="comment">// sys.argv[0] 被设定为 &#x27;-c&#x27;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;$ python -m module [arg] ...&quot;</span>:</span><br><span class="line">        <span class="comment">// sys.argv[0] 被设定为指定模块的全名</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">注意C/C++的这个语句switch后面括号内的“表达式”必须是整数类型！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>⚠️【注意】：<code>-c</code> 指令 或者 <code>-m</code> 模块 之后的参数不会被 Python 解释器的选项处理机制所截获，而是留在 <code>sys.argv</code> 中，供脚本命令操作。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -i -c &#39;import sys&#39; 1 2 3</span><br><span class="line">&gt;&gt;&gt; sys.argv</span><br><span class="line">[&#39;-c&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span><br></pre></td></tr></table></figure><h3 id="指定源程序编码"><a href="#指定源程序编码" class="headerlink" title="指定源程序编码"></a>指定源程序编码</h3><p>默认情况下，Python 源文件是 UTF-8 编码。<br>在 <code>#!</code> 行（首行）后插入至少一行特殊的注释行来定义源文件的编码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: encoding -*-</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/codecs.html#module-codecs">可用的 encoding 列表</a></p><p>⚠️【注意】如果使用 Microsoft Windows 自带的 记事本（‘Notepad’）进行 python 源码的编辑，注意使用 <code>utf-8 without BOM</code> 编码！</p><h2 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h2><p>没有人会否认注释的重要性。在开始讨论其他语法之前，我们有必要看一看注释怎么写。</p><p>Python 中的注释以 <code>#</code> 字符起始，直至实际的行尾(physical line, 表示实际的换行而非编辑器的自动换行)。<br>注释可以从行首开始，也可以在空白或代码之后，但是不出现在字符串中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个注释</span></span><br></pre></td></tr></table></figure><p>写文档注释的时候，我们常借用多行字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;函数func是用来干什么的</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    详细行为描述...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    a: 参数a是什么</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    返回值是什么</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;类的总结</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    详细行为描述...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        a: 属性a的说明</span></span><br><span class="line"><span class="string">        b: 属性b的说明</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>【注】关于文档注释，我们会在本系列后面的【Python代码风格】一文中详细介绍。</p><h2 id="Python基本运算符"><a href="#Python基本运算符" class="headerlink" title="Python基本运算符"></a>Python基本运算符</h2><p>计算机，如其名，是计算的好手！既然编程语言是人类和计算机沟通的语言，那这些语言就应该可以方便简介地让计算机算起来——从加减乘除开始。Python 的加减乘除运算我们都很熟悉，基本就是我们在小学数学中看到的那些写法：</p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>+</code> ，<code>-</code> ，<code>*</code></td><td>用于 加、减、乘 运算</td></tr><tr><td><code>/</code></td><td>除运算，返回一个浮点数</td></tr><tr><td><code>//</code></td><td>除运输，返回结果取整(<a href="https://zh.wikipedia.org/wiki/%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0">floor, 向下取整</a>)后的整数</td></tr><tr><td><code>%</code></td><td>取余运算</td></tr><tr><td><code>**</code></td><td>乘方运算</td></tr><tr><td><code>()</code></td><td>用于分组</td></tr><tr><td><code>=</code></td><td>用于给变量赋值</td></tr><tr><td><code>==</code></td><td>用于判断值是否相等</td></tr></tbody></table><p>⚠️【几点注意】：</p><ul><li>变量在使用前必须 “定义”(赋值)，否则会出错。</li><li>交互模式中，最近一个表达式的值赋给变量 <code>_</code>。</li><li>浮点数有完整的支持；整数和浮点数的混合计算中，整数会被转换为浮点数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;c&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_ + <span class="number">3</span>    <span class="comment"># (3) + 3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = _ * <span class="number">2</span>    <span class="comment"># c = (6) * 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">0.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + d</span><br><span class="line"><span class="number">1.3</span></span><br></pre></td></tr></table></figure><p>对于整数类型，你还可以像 C 一样，做位运算：</p><table><thead><tr><th>运算</th><th>说明</th></tr></thead><tbody><tr><td>`x</td><td>y`</td></tr><tr><td><code>x &amp; y</code></td><td>x、y 按位取逻辑与</td></tr><tr><td><code>x ^ y</code></td><td>x、y 按位取异或</td></tr><tr><td><code>x &lt;&lt; n</code></td><td>x 左移 n 位</td></tr><tr><td><code>x &gt;&gt; n</code></td><td>x 右移 n 位</td></tr><tr><td><code>~x</code></td><td>x 按位取逻辑非</td></tr></tbody></table><hr><p>未完待续…</p><p>Next: 【Python基本数据类型】</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学了那么久，那么多库到底怎么用？好哥们儿默默从收藏夹里掏出这篇保姆级教程</title>
      <link href="/2020/03/22/blog/Python-how2-use-packages/"/>
      <url>/2020/03/22/blog/Python-how2-use-packages/</url>
      
        <content type="html"><![CDATA[<h1 id="Python学了那么久，那么多库到底怎么用？好哥们儿默默从收藏夹里掏出这篇保姆级教程"><a href="#Python学了那么久，那么多库到底怎么用？好哥们儿默默从收藏夹里掏出这篇保姆级教程" class="headerlink" title="Python学了那么久，那么多库到底怎么用？好哥们儿默默从收藏夹里掏出这篇保姆级教程"></a>Python学了那么久，那么多库到底怎么用？好哥们儿默默从收藏夹里掏出这篇保姆级教程</h1><p>本文又名《一篇写给 Python 初学者的用包指南》。</p><blockquote><p>一位不愿意透露姓名的网友曾经说过：“做软件就像搞建筑。其中导包用库抄代码就像做搬运工，并不可耻。盖起贝聿铭的是搬运工搬来的一石一木，建起卡拉特拉瓦的是搬运工运来的一砖一瓦。”</p></blockquote><p>Python 有那么多内置的库，还有更多的第三方库。初学者在看一些代码的时候，总是会惊讶的发现，别人写的代码里调用一大堆的库，比如，这是我随手写了玩的一个小玩具项目：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2janymihj31890u0ke4.jpg" alt="image-20200322111540766"></p><p>这足够让初学者目瞪口呆了——这么多的库，怎么学得过来啊！</p><p>其实刚才那个还很少了，这是我的一个稍微复杂一点的项目中，几十个文件中的一个的 import 部分：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2jf16dbej31890u0b29.jpg" alt="image-20200322111952115"></p><p>这里有69条import，导了69个不同的包，全都用上了——这么多，怎么记得住、搞得清啊！</p><p>其实我的方法很简单——对于这些库，我<strong>全都不学习、不记忆</strong>。我只需要有一个印象——世界上有一个库，可以完成我想要的这个功能。<strong>具体怎么用，用到再说；到底怎么说，必应谷歌</strong>。</p><p>（记住这两句粗体的话啊，这就是本文可以教给你的所有东西。）</p><p>在现实中认识我的朋友都知道，我从不背书，（几乎）从不刷题。我是个极端讨厌记忆、重复、无效工作的人（曾经的我好像还为此当中拍案而起触怒过我最敬爱的🐒老师？前几天朋友给我说好像有这么一事，我有点记不清了），所以，我当然更是不会去记忆这些库的，这么多库这么烦，谁记得呀。</p><p>当我在项目中遇到一个需要的功能，我就会打开谷歌搜索这个东西的关键词，比如 <code>python gui</code>，<code>android 开发 二维码</code>，<code>docker wordpress</code>……</p><p>然后，几乎是绝大多数情况下，你都可以看到大佬的文章有介绍用什么库、要怎么搞，跟着做就行。</p><p>（至于搜不到的情况，你可以更改你的关键词。如果确实没有，或是搜出来的都不喜欢，自己写一个就行，就费点事嘛，问题不大）</p><p>所以，对我来说，其实我不会多少库，但我会用搜索引擎，而且用的比许多初学者要好一点点。</p><p>每次我写项目的时候，浏览器绝对是工作量仅次于我的思维以及 IDE 的软件（这图片上还只是一部分，全部打开的有这样好几页，最多的时候可以有大概100页）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2khd8e36j31co0u0u0x.jpg" alt="image-20200322114451829"></p><p>在接下来的文章中，我会教你怎么用搜索引擎帮助你使用库（当然只是最基础的部分，高级的技巧又是单独的一篇长文了）。</p><p>我们假设一个场景，你的项目中，需要你用 Python 做个 GUI，你可以参考以下步骤：</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>Step 1</strong>. 打开 Chrome 或是任何你喜欢的浏览器（作为一名Web开发者，我真挚地提醒您，IE除外）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2hvzdpddj31c00u0e81.jpg" alt="屏幕快照 2020-03-22 10.07.38"></p><p><strong>Step 2</strong>. 打开 Google 或是任何你熟悉的搜索引擎（百度除外）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2hyzdzmvj316w0u0tpf.jpg" alt="屏幕快照 2020-03-22 10.08.20"></p><p><strong>Step 3</strong>. 在浏览器的搜索框中输入 <code>python + 空格 + 您感兴趣的问题</code>：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2hz77p6ej316w0u0wxm.jpg" alt="屏幕快照 2020-03-22 10.10.03"></p><p><strong>Step 4</strong>. 看到这样的搜索结果：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2i2xx8lpj316w0u0e75.jpg" alt="屏幕快照 2020-03-22 10.10.13"></p><p>P.S. 本人不歧视任何搜索引擎，但如果你非要用百度，请注意鉴别广告。事实上，第一页基本都是广告：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2hs79g4pj316w0u0e81.jpg" alt="屏幕快照 2020-03-22 10.15.52"></p><p><strong>Step 5</strong>. 点开搜索结果前一屏上的条目，看里面相似的单词，以及中文内容：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2idhlpp5j31nf0u07q6.jpg" alt="屏幕快照 2020-03-22 10.36.17"></p><p><strong>Step 6</strong>. 新开一个搜索，搜索 <code>python + 空格 + 刚才出现最多的库名</code>：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2if9tkuxj316w0u0kin.jpg" alt="image-20200322104530335"></p><p><strong>Step 7</strong>. 随便打开一个结果，里面有教你怎么安装（这个tkinter是内置库，不用安装）、导入、写helloworld，照着做一遍：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2imfc2euj316w0u01kx.jpg" alt="屏幕快照 2020-03-22 10.50.58"></p><p>结果：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2iqiimxrj31cb0u0tgb.jpg" alt="image-20200322105619261"></p><p><strong>Step 8</strong>. 把刚才打开的网页里这些东西里第一页随便看一下，有印象就行（不用记忆，但你可以跟着做一遍，如果你时间充足的话，但一般我也不会去做，只是看，有印象就行）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2irldad5j30u00ytdni.jpg" alt="image-20200322105721864"></p><p><strong>Step 9</strong>. 在项目里使用该库（知道了这东西能用，那就开始用它了）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2iurh59bj317b0u04qp.jpg" alt="image-20200322110023854"></p><p>遇到你想用的功能，比如对话框，Google 搜索 <code>python + 库名 + 功能</code>：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ix3mtsvj316w0u01kx.jpg" alt="image-20200322110238916"></p><p>看见了没，都是中文！随便点开一个看：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2iyzm1qsj316w0u0b29.jpg" alt="image-20200322110427510"></p><p>代码抄一下，效果就出来了：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2j0y5yijj31950u0n6n.jpg" alt="屏幕快照 2020-03-22 11.06.05"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用库基本上就等于使用搜索引擎，不用记忆，遇到想要的功能搜索一下、抄一下就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P150 逆波兰表达式求值</title>
      <link href="/2020/03/19/School/Leetcode_P150_evaluate-reverse-polish-notation/"/>
      <url>/2020/03/19/School/Leetcode_P150_evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P150-逆波兰表达式求值"><a href="#Leetcode-P150-逆波兰表达式求值" class="headerlink" title="Leetcode P150 逆波兰表达式求值"></a>Leetcode P150 逆波兰表达式求值</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p>From <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个东西只要写过简单计算器的话，肯定不在话下。这个题目逆波兰表达式求值最简单的情况了，原理很简单：</p><blockquote><p> 读到数字就入栈；</p><p>读到符号就出栈两个元素运算，结果入栈。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="标准栈实现"><a href="#标准栈实现" class="headerlink" title="标准栈实现"></a>标准栈实现</h4><p>基本版本，实现一个标准的栈，进行操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">s := newStack()</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> tokens &#123;</span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">a, b := s.pop(), s.pop()</span><br><span class="line">s.push(b + a)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">a, b := s.pop(), s.pop()</span><br><span class="line">s.push(b - a)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">a, b := s.pop(), s.pop()</span><br><span class="line">s.push(b * a)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">a, b := s.pop(), s.pop()</span><br><span class="line">s.push(b / a)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">n, _ := strconv.Atoi(i)</span><br><span class="line">s.push(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s.data = <span class="built_in">append</span>(s.data, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">top := s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">s.data = s.data[<span class="number">0</span> : <span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="成熟的栈应该学会自己完成计算"><a href="#成熟的栈应该学会自己完成计算" class="headerlink" title="成熟的栈应该学会自己完成计算"></a>成熟的栈应该学会自己完成计算</h4><p>那一大堆 <code>a, b := s.pop(), s.pop()</code> 和 <code> s.push(b * a)</code> 很烦，优化一下，把刚才的标准 stack 换成一个“子类” calcStack。我们的 calcStack 是个成熟的栈了，应该学会自己完成计算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">s := newCalcStack()</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> tokens &#123;</span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b + a&#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b - a&#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b * a&#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b / a&#125;)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">n, _ := strconv.Atoi(i)</span><br><span class="line">s.push(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> calcStack <span class="keyword">struct</span> &#123;</span><br><span class="line">data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCalcStack</span><span class="params">()</span> *<span class="title">calcStack</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;calcStack&#123;</span><br><span class="line">data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *calcStack)</span> <span class="title">push</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s.data = <span class="built_in">append</span>(s.data, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *calcStack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">top := s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">s.data = s.data[<span class="number">0</span> : <span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *calcStack)</span> <span class="title">calc</span><span class="params">(opt <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><span class="title">int</span>)</span> &#123;</span><br><span class="line">s.push(opt(s.pop(), s.pop()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcz29bech9j31460u04ps.jpg" alt="屏幕快照 2020-03-19 11.09.01"></p><h4 id="多用指针"><a href="#多用指针" class="headerlink" title="多用指针"></a>多用指针</h4><p>如果你喜欢用指针，还可以再优化，我们甚至可以不需要 pop 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">s := newCalcStack()</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> tokens &#123;</span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123; *b += *a &#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123; *b -= *a &#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123; *b *= *a &#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">s.calc(<span class="function"><span class="keyword">func</span> <span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123; *b /= *a &#125;)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">n, _ := strconv.Atoi(i)</span><br><span class="line">s.push(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return s.pop()</span></span><br><span class="line"><span class="keyword">return</span> s.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> calcStack <span class="keyword">struct</span> &#123;</span><br><span class="line">data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCalcStack</span><span class="params">()</span> *<span class="title">calcStack</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;calcStack&#123;</span><br><span class="line">data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *calcStack)</span> <span class="title">push</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s.data = <span class="built_in">append</span>(s.data, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func (s *calcStack) pop() int &#123;</span></span><br><span class="line"><span class="comment">// top := s.data[len(s.data)-1]</span></span><br><span class="line"><span class="comment">// s.data = s.data[0 : len(s.data)-1]</span></span><br><span class="line"><span class="comment">// return top</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *calcStack)</span> <span class="title">calc</span><span class="params">(opt <span class="keyword">func</span>(*<span class="keyword">int</span>, *<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="comment">// s.push(opt(s.pop(), s.pop()))</span></span><br><span class="line">opt(&amp;s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>], &amp;s.data[<span class="built_in">len</span>(s.data)<span class="number">-2</span>])</span><br><span class="line">s.data = s.data[<span class="number">0</span> : <span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P155 最小栈</title>
      <link href="/2020/03/18/School/Leetcode_P155_min-stack/"/>
      <url>/2020/03/18/School/Leetcode_P155_min-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P155-最小栈"><a href="#Leetcode-P155-最小栈" class="headerlink" title="Leetcode P155 最小栈"></a>Leetcode P155 最小栈</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> – 将元素 x 推入栈中。</li><li><code>pop()</code> – 删除栈顶的元素。</li><li><code>top()</code> – 获取栈顶元素。</li><li><code>getMin()</code> – 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><hr><p>From <a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><h2 id="额外最小栈"><a href="#额外最小栈" class="headerlink" title="额外最小栈"></a>额外最小栈</h2><p>其实这个问题，直接用两个栈，一个存用户放入的数据，一个存对应另一个栈每一个位置的最小值就可以了，两个栈同时操作，同时 push、同时 pop：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">int</span></span><br><span class="line">    min []<span class="keyword">int</span></span><br><span class="line">    top <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">        min: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">        top: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.data = <span class="built_in">append</span>(this.data, x)</span><br><span class="line">    <span class="keyword">if</span> (this.top == <span class="number">0</span> || x &lt; this.min[this.top<span class="number">-1</span>]) &#123;</span><br><span class="line">        this.min = <span class="built_in">append</span>(this.min, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.min = <span class="built_in">append</span>(this.min, this.min[this.top<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    this.top++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    this.data = this.data[<span class="number">0</span>: this.top<span class="number">-1</span>]</span><br><span class="line">    this.min = this.min[<span class="number">0</span>: this.top<span class="number">-1</span>]</span><br><span class="line">    this.top--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.data[this.top<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.min[this.top<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcyd9w7yf9j31460u0kir.jpg" alt="屏幕快照 2020-03-18 20.43.23"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在 min 的这个存最小值的栈里会有大量的重复的元素，所以我们干脆不要一对一的存最小值，而是最小值变更时再去操作最小值栈：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">int</span></span><br><span class="line">    min []<span class="keyword">int</span></span><br><span class="line">    top <span class="keyword">int</span></span><br><span class="line">    minTop <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">        min: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">        top: <span class="number">0</span>,</span><br><span class="line">        minTop: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.data = <span class="built_in">append</span>(this.data, x)</span><br><span class="line">    <span class="keyword">if</span> (this.top == <span class="number">0</span> || x &lt;= this.min[this.minTop<span class="number">-1</span>]) &#123;</span><br><span class="line">        this.min = <span class="built_in">append</span>(this.min, x)</span><br><span class="line">        this.minTop++</span><br><span class="line">    &#125;</span><br><span class="line">    this.top++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 下面这个语句写优雅一点就是，但刷题嘛，尽量减少函数调用快一点：if t := this.Top(); t == this.Min() &#123;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> t := this.data[this.top<span class="number">-1</span>]; t == this.min[this.minTop<span class="number">-1</span>] &#123;</span><br><span class="line">        this.min = this.min[<span class="number">0</span>: this.minTop<span class="number">-1</span>]</span><br><span class="line">        this.minTop--</span><br><span class="line">    &#125;</span><br><span class="line">    this.data = this.data[<span class="number">0</span>: this.top<span class="number">-1</span>]</span><br><span class="line">    this.top--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.data[this.top<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.min[this.minTop<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcydgmblqvj31460u01kx.jpg" alt="屏幕快照 2020-03-18 20.50.07"></p><p>当然，把 top 属性去掉也是可以的，但调用 <code>len</code> 函数的话，消耗会大一点点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">int</span></span><br><span class="line">    min  []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">        min:  <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.data = <span class="built_in">append</span>(this.data, x)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(this.min) == <span class="number">0</span> || x &lt;= this.min[<span class="built_in">len</span>(this.min)<span class="number">-1</span>]) &#123;</span><br><span class="line">        this.min = <span class="built_in">append</span>(this.min, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> t := this.data[<span class="built_in">len</span>(this.data)<span class="number">-1</span>]; t == this.min[<span class="built_in">len</span>(this.min)<span class="number">-1</span>] &#123;</span><br><span class="line">        this.min = this.min[<span class="number">0</span>: <span class="built_in">len</span>(this.min)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    this.data = this.data[<span class="number">0</span>: <span class="built_in">len</span>(this.data)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.data[<span class="built_in">len</span>(this.data)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.min[<span class="built_in">len</span>(this.min)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="In-Python-Way"><a href="#In-Python-Way" class="headerlink" title="In Python Way"></a>In Python Way</h2><p>对于这种问题，我还是喜欢用 Python 的内置工具去解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(self.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcydvphv7pj31460u01kx.jpg" alt="image-20200318210602995"></p><p>这个 <code>min</code> 消耗太大了，我们把策略改成和刚才第一个版本的 Golang 一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = []</span><br><span class="line">        self.<span class="built_in">min</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line">        self.<span class="built_in">min</span>.append(<span class="built_in">min</span>(x, self.<span class="built_in">min</span>[-<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(self.<span class="built_in">min</span>) <span class="keyword">else</span> <span class="number">2147483648</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data.pop()</span><br><span class="line">        self.<span class="built_in">min</span>.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">min</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcye5sgkw7j31460u01kx.jpg" alt="image-20200318211544338"></p><p>还可以继续优化，但懒得写了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Docker部署WordPress</title>
      <link href="/2020/03/16/blog/Docker-WordPress/"/>
      <url>/2020/03/16/blog/Docker-WordPress/</url>
      
        <content type="html"><![CDATA[<h1 id="用-Docker-部署-WordPress"><a href="#用-Docker-部署-WordPress" class="headerlink" title="用 Docker 部署 WordPress"></a>用 Docker 部署 WordPress</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都爱用 WordPress，(几乎)一行代码都不用写，就能得到一个好看、实用的动态网站。</p><p>这东西用来<del>敷衍</del>帮助各种找你写奇怪小网站的朋友再好不过了。通常，帮朋友部署 WordPress 的这个场景下，你可以找朋友开一台新的服务器，初始化一套 LAMP，直接把 WordPress 给 wget 进去，就可以在你的浏览器里完成配置了。 有时候，比如您的朋友使用阿里云、百度云或是其他比较大的云服务商，您甚至可以直接初始化一个 WordPress 应用镜像，直接在浏览器里开始设置。</p><p>但是，前两天我需要在自己的服务器上部署一个 WordPress 服务。我这样的蒟蒻当然是无缘使用世界上最好的编程语言—— PHP 的啦。没有 PHP，还部署个屁的 WordPress。装一个 PHP 吧，平时也不用，还增加了安全风险，不划算。</p><p>还是有一台全新的 LAMP 服务器好啊，但不可能再买一台服务器吧。所以就想到了—— <strong>Docker</strong>，用容器去把它装起来就好了嘛。</p><p>想到就动手做，接下来我们就看看怎么用 Docker 部署 WordPress。</p><p>所以，现在，您的服务器或个人电脑上应该已经安装好了 Docker，在绝大多数非 Windows 的常规系统下，安装 Docker 就是几条简单的命令。</p><h2 id="在继续之前……"><a href="#在继续之前……" class="headerlink" title="在继续之前……"></a>在继续之前……</h2><p>根据法律规定，任何探讨容器的文章都必须附上满载集装箱的集装箱船的图片，正如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcvuveckw8j30m80dfqfs.jpg" alt="image-20200316163711817"></p><p>（这个传统是从 <a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-getting-started-docker-and-kubernetes/index.html">IBM Developer 上的这篇文章</a> 学的，咱也不知道为什么，但遵纪守法的优秀共青团员当然是要遵守规定的啦。）</p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>WordPress 这么常用的东西当然是有现成的镜像的，我们就不用自己去建了。</p><p>果断拉一个 wordpress 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull wordpress:latest</span><br></pre></td></tr></table></figure><p>然后，您应该知道，WordPress 需要 MySQL。</p><p>这里我们有两种选择，一是使用宿主机或是其他任何服务器上的 MySQL 数据库；二是用一个 MySQL Docker 镜像。为了方便，同时也多练习 Docker 的使用，我们干脆再拉一个 mysql 镜像，让整套服务完全在 docker 里运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:latest</span><br></pre></td></tr></table></figure><p>注意，这篇文章写在 2020 年春，所以这里 <code>mysql:latest</code> 是 <code>MySQL V8.0.19 </code>。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>废话不多说，有了镜像，我们直接开服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --privileged=<span class="literal">true</span> --name Mysql_Test -v /data/mysql:/var/lib/mysql -e MYSQL_DATABASE=wordpress -e MYSQL_ROOT_PASSWORD=233333  mysql</span><br><span class="line">$ docker run -d --name Wordpress_Test -e WORDPRESS_DB_HOST=mysql -e WORDPRESS_DB_PASSWORD=233333 -p 2020:80 --link Mysql_Test:mysql wordpress</span><br></pre></td></tr></table></figure><p>OK，这就是 Docker 的魔力，不用装 PHP，不用为了安全悉心考虑、大肆设置，前前后后就 4 个命令搞的！（当然，我只是开一个简单的小服务，基本没人用，所以也就几乎没有安全风险，但您在部署的时候还是要花点时间认真考虑安全问题的）</p><p>接下来就是在您的浏览器访问 <code>http://xxx:2020/wp-admin/index.php</code>，完成 “著名的” wordpress 5分钟安装了！</p><h2 id="但是……"><a href="#但是……" class="headerlink" title="但是……"></a>但是……</h2><p>当你满心欢喜打开您的新网站时，，你会发现，wordpress 提醒你：连不上 mysql。（我忘截图了，它会写一堆英文告诉你这个事，你能看懂）</p><p>Google 会告诉您，这个问题是由于 mysql 8 的默认用户认证方式改了，wordpress 不认识。要解决不难，打开 mysql 设置一下，把认证方式改成 Wordpress 认识的样子就行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it Mysql_Test mysql -p</span><br></pre></td></tr></table></figure><p>执行 mysql 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; select host, user, plugin from user;</span><br><span class="line">mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;233333&#39;;</span><br><span class="line">mysql&gt; select host, user, plugin from user;</span><br></pre></td></tr></table></figure><p>我们把 root 的 plugin 从 <code>caching_sha2_password</code> 改成了 <code>mysql_native_password</code>，这样就没问题了。</p><p>然后再次浏览器访问 <code>http://xxx:2020/wp-admin/index.php</code>，这次就应该是 “著名的” wordpress 5分钟安装了，您可以自行完成 :)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P141 环形链表</title>
      <link href="/2020/03/12/School/Leetcode_P141_linked-list-cycle/"/>
      <url>/2020/03/12/School/Leetcode_P141_linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P141-环形链表"><a href="#Leetcode-P141-环形链表" class="headerlink" title="Leetcode P141 环形链表"></a>Leetcode P141 环形链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h2><p>首先，最简单直接的想法，用哈希表，遍历一个存一个，每次都检查当前节点是否已经存过，存过就说明有环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> nodes := <span class="keyword">map</span>[*ListNode]<span class="keyword">bool</span>&#123;&#125;; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[head] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodes[head] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcr749hdvdj31d60u01kx.jpg" alt="屏幕快照 2020-03-12 15.33.08"></p><h2 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h2><p>还可以用快慢指针法。</p><p>想象这样的情景：两人比赛跑步，甲快，乙慢。如果赛道无环，相当于就一条直线，肯定是甲先到终点；如果赛道有环，在环上跑，速度不一样的甲乙必然在某一时刻相遇。</p><p>利用这个思路，赛道是链表，甲乙化身快慢指针，就得到了空间消耗 $O(1)$ 的解法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nil</span>) || (head.Next == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast, slow = fast.Next.Next, slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcr730im9jj31d60u01kx.jpg" alt="image-20200312155153189"></p><hr><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>总有人问我每天写代码快乐吗？图个啥呀？</p><p>今天看书的时候，看到一段很有感触的话，算是对这个问题的回答吧，收藏了：</p><blockquote><p>There is much joy in programming. There is joy in analyzing a problem, breaking it down into pieces, formulating a solution, mapping out a strategy, approaching it from different directions, and crafting the code. There is very much joy in seeing the program run for the first time, and then more joy in eagerly diving back into the code to make it better and faster.</p><p>There is also often joy in hunting down bugs, in ensuring that the program runs smoothly and predictably. Few occasions are quite as joyful as finally identifying a particularly recalcitrant bug and defin- itively stamping it out.</p><p>There is even joy in realizing that the original approach you took is not quite the best. Many developers discover that they’ve learned a lot while writing a program, including that there’s a better way to structure the code. Sometimes, a partial or even a total rewrite can result in a much better application, or simply one that is structurally more coherent and easier to maintain. The process is like standing on one’s own shoulders, and there is much joy in attaining that perspective and knowledge.</p><hr><p>​    From <em>Creating Mobile Apps with Xamarin</em></p><p>​            Chapter 1 <em>How does Xamarin.Forms fit in?</em></p></blockquote><p>哈哈，伟人站在巨人肩膀上随和微笑，蒟蒻站在自己肩膀上看着代码傻笑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P83 删除排序链表中的重复元素</title>
      <link href="/2020/03/11/School/Leetcode_P83_remove-duplicates-from-sorted-list/"/>
      <url>/2020/03/11/School/Leetcode_P83_remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P83-删除排序链表中的重复元素"><a href="#Leetcode-P83-删除排序链表中的重复元素" class="headerlink" title="Leetcode P83 删除排序链表中的重复元素"></a>Leetcode P83 删除排序链表中的重复元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>这道题还是很容易的，双指针法，和 <a href="https://blog.csdn.net/u012419550/article/details/104402182">Leetcode P26 删除排序数组中的重复项</a> 一样的算法，只是把数组改成链表（甚至我还觉得更简单了？）</p><p>就搞两个指针 <code>current</code> 和 <code>toDel</code>，<code>current</code> 遍历链表，维护 <code>toDel</code> 前的节点值不重复。直接上代码吧，Golang：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    current := head</span><br><span class="line">    toDel := head</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Val != toDel.Val &#123;</span><br><span class="line">            toDel.Next = current</span><br><span class="line">            toDel = current</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> toDel != <span class="literal">nil</span> &amp;&amp; toDel.Next != <span class="literal">nil</span> &amp;&amp; toDel.Next.Val == toDel.Val &#123;</span><br><span class="line">        toDel.Next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcq2u4ysbpj31d60u0e7f.jpg" alt="屏幕快照 2020-03-11 16.36.36"></p><h2 id="优化：单指针"><a href="#优化：单指针" class="headerlink" title="优化：单指针"></a>优化：单指针</h2><p>这个题还可以只用一个指针完成，因为链表是用指针指下一个的嘛，我们可以方便地把任意节点的下一节点改成其后的某一节点，来达到“删除”中间的一些节点的目的。比如<code>current.Next = current.Next.Next</code>，就相当于把 <code>current.Next</code> 删除了。</p><p>用这个思路就可以用一个指针把链表中的重复元素删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> (current != <span class="literal">nil</span>) &amp;&amp; (current.Next != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Next.Val == current.Val &#123;</span><br><span class="line">            current.Next = current.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcq3j6dznqj31d60u04qp.jpg" alt="image-20200311170330484"></p><p>哈哈，一开始我没写 else 分句，<code>current = current.Next</code> 写在外面，这么做是错的，如果输入是 <code>[1,1,1,1]</code>，就会输出 <code>[1,1]</code>，少了尾部最后的处理。然后我改这个的时候顺手把 for 条件里的 <code>current != nil</code> 也删了，但他有 <code>[]</code> 的输入，又错了一次🤦‍♂️</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P21 合并两个有序链表</title>
      <link href="/2020/03/10/School/Leetcode_P21_merge-two-sorted-lists/"/>
      <url>/2020/03/10/School/Leetcode_P21_merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P21-合并两个有序链表"><a href="#Leetcode-P21-合并两个有序链表" class="headerlink" title="Leetcode P21 合并两个有序链表"></a>Leetcode P21 合并两个有序链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="直观解法"><a href="#直观解法" class="headerlink" title="直观解法"></a>直观解法</h2><p>首先我们尝试用归并的方法，和我们做 <a href="https://blog.csdn.net/u012419550/article/details/104527464">Leetcode P88</a> 的方法一样，只是把数组换成链表。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    merged := &amp;ListNode&#123;&#125;</span><br><span class="line">    head := merged</span><br><span class="line">    <span class="keyword">for</span> (l1 != <span class="literal">nil</span>) || (l2 != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            merged.Val = l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">            <span class="keyword">goto</span> NEXT_MERGED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            merged.Val = l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">            <span class="keyword">goto</span> NEXT_MERGED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            merged.Val = l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            merged.Val = l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">NEXT_MERGED:</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">nil</span>) || (l2 != <span class="literal">nil</span>) &#123;</span><br><span class="line">            merged.Next = &amp;ListNode&#123;&#125;</span><br><span class="line">            merged = merged.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别介意我的 <code>goto</code>，都说不要用 goto，但我觉得用在这里就挺好！你写个正常的条件跳转，变成汇编的时候不还是个 goto 么……</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcp3ipsv29j31d60u0e7r.jpg" alt="屏幕快照 2020-03-10 20.09.22"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>Woc，我刚才傻了，居然不停的 new 出 <code> &amp;ListNode&#123;&#125;</code> 来，直接用原来的节点不就好了么，难怪刚才那么高空间占用。。。</p><p>优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    merged := &amp;ListNode&#123;&#125;</span><br><span class="line">    head := merged</span><br><span class="line">    <span class="keyword">for</span> (l1 != <span class="literal">nil</span>) || (l2 != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            merged.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">            <span class="keyword">goto</span> NEXT_MERGED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            merged.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">            <span class="keyword">goto</span> NEXT_MERGED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            merged.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            merged.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">NEXT_MERGED:</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">nil</span>) || (l2 != <span class="literal">nil</span>) &#123;</span><br><span class="line">            merged = merged.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcp3saqmlbj31d60u01kx.jpg" alt="image-20200310202641869"></p><p>……</p><p>好吧，这 Leetcode 就这样，经常是你去优化一下代码还更慢了😂</p><h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>其实，还可以再优化一点，如果一条链为空了，那直接把另一条链接到合并后的链上就好了，不用再迭代着一个一个节点地接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    merged := &amp;ListNode&#123;&#125;</span><br><span class="line">    head := merged</span><br><span class="line">    <span class="keyword">for</span> (l1 != <span class="literal">nil</span>) &amp;&amp; (l2 != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            merged.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            merged.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        merged = merged.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        merged.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        merged.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcp3xaldorj31d60u01kx.jpg" alt="image-20200310203129875"></p><p>差不多就这样了吧🤷‍♂️</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表实践——城市列表</title>
      <link href="/2020/03/05/School/TrySLinkList_CityList/"/>
      <url>/2020/03/05/School/TrySLinkList_CityList/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表实践——城市列表"><a href="#单链表实践——城市列表" class="headerlink" title="单链表实践——城市列表"></a>单链表实践——城市列表</h1><p>（多图警告！我放了一大堆类图、截图）</p><p>（多废话警告！我不小心在心情不好的时候写了一大堆废话进来）</p><p>（多代码警告！我懒得拣关键的代码了，我把整个工程里和题目相关的代码全扔进来了，编辑的时候 Typora 都有点卡了）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gciubwcduej30la0g1jta.jpg" alt="UNADJUSTEDNONRAW_thumb_28c8"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gciubzcavxj30lc0fymyl.jpg" alt="UNADJUSTEDNONRAW_thumb_28c9"></p><h2 id="（蒟蒻的抱怨）"><a href="#（蒟蒻的抱怨）" class="headerlink" title="（蒟蒻的抱怨）"></a>（蒟蒻的抱怨）</h2><p>“这可太难了呀！”</p><p>电脑前的蒟蒻猛地坐直了身子，那双颤巍巍的手像是来自罹患帕金森的老人，几经尝试，才一只抓起了乱扔的抹布，狠狠地擦拭着并不脏的屏幕；另一只揉起了自己的眼睛——蒟蒻相信，这不是幻觉就是屏幕出了问题。</p><p>窗体应用呐！又是窗体应用！蒟蒻还记得几个月前自己为了完成要求用 C# 写的窗体小闹钟，关掉了 IDEA、退出了 Xcode，翻越了保护着他生命财产安全的高墙，下载了 dotnet core，安装了 Visual Studio for Mac，开始在 Xamarin 的世界里四处碰壁，碰得鼻青脸肿、碰得头破血流。最后虽然如期把东西做了出来，却落得个128GB的 MacBook 硬盘爆满的下场。</p><p>如今伤痛未愈、磁盘未清，又惨遭窗体作业当头一棒！蒟蒻除了怀疑自己的眼睛或屏幕还有其他选择嘛？</p><p>“我***不写 C# 了！Swing 过气了么？PyTk 不能用么？Web 开发不香么？”，蒟蒻无声地在内心咆哮着，“iOS 虽然还不熟，但尝试写也没问题！再不济，我还会 Android 开发……”</p><p>……（👆一个让人意外的强行转折👇）……</p><p>三月的昆明依然迷人。昨天下了雨，今天又是艳阳高照，窗外长了7层楼高的行道树随风欢舞——春风时而和煦、忽又暴躁，谁知道是哪来的力气，它似乎从不疲惫，它不断地把未散尽泥土芳香的甘甜空气送进蒟蒻塞满了纸张、书籍和电子产品的房间。调皮的<del>风元素</del>风儿走时还不忘在蒟蒻的清茶上漾起一个微笑。</p><p>“呼——”，一时被这景象吸取了魂魄的蒟蒻这才缓缓回神，看着不知不觉在 Typora 里敲下的这堆文字，一时心里不是滋味。</p><p>是啊，最近蒟蒻有些迷茫，不知道该用什么语言、什么框架写作业或是自己的项目了。蒟蒻学的太杂了，每次开发都必须从那么多种技术中挑一个出来用，这时的蒟蒻总是不堪承受抛弃其他语言的痛苦。</p><p>“但是没办法，谁让我乐意呢……”</p><p>蒟蒻没有办法，只好让上天来决定这一切了。蒟蒻闭上了眼睛，仿佛这样能减轻内心的痛苦。摸起桌上的 D12，蒟蒻的手颤抖地更厉害了，现在是线性马达而不是帕金森了——掷骰子的结果着实让蒟蒻吃了一惊——</p><p>是 Xamarin！</p><p>不过 Xamarin 就 Xamarin 吧，上天总是对蒟蒻做些奇奇怪怪的事情，蒟蒻已经不相信上帝或任何神灵了。</p><p>双眼的焦距在慢慢恢复，手指的颤动像是断了电般骤然止住，在触控板上一划一点，分毫不差，Visual Studio for Mac 在蒟蒻眼前浮现。</p><hr><p>（这两天心里颇不宁静……一不小心就写了这么多有的没的，浪费了自己的时间，没有任何意义……）</p><p>（生活、梦境、学习中的事都让人头疼，还是写代码让人愉快啊！所以写代码去了，一会儿再接着写这篇文章。）</p><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>Ok，代码我写好了，回来接着水博客。现在距离写上面那一段东西过去了两天。中间遇到了一些问题严重拖延了进度，最后还是或优雅或笨拙地解决了，一会儿我们会提到。</p><p>话不多说，先看成果！</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmbm5cgscj32b50u0hac.jpg" alt="IMG_467"></p><p>（是的，这个城市链表只是这个 App 里的一个功能！我想把这个 App 写成一个比较全的数据结构与算法演示。）</p><p>再看看 Android 中的效果（我设计 UI 的时候是按全面屏来的，我的老 Android 手机屏幕小，效果不太好）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gclnjf1t53j32ce0u0n5o.jpg" alt="IMG_455"></p><p>这就是比起 Flutter，我有时更喜欢 Xamarin 的地方，我几乎完全没有自定义布局，得到的 App 在 iOS 上就是遵守 Human Interface Guidelines 的原生 iOS 的感觉，在 Android 上就是符合 Material Design 的谷歌原生的感觉！我用 Mac 不能生成 UWP，不然这套代码还可以生成一个在 Windows 10 上实现 Fluent Design 的微软原生的版本！</p><p>而且在这里我还有意外的发现，在 iOS 13 上，Xamarin 生成的 App 自动支持 Dark Mode！只要是没指定颜色的控件，都会自动按照 Apple 的设计准则支持暗色模式。但由于我一开始写了几个 <code>Background=&quot;#FAFAFA&quot;</code> 之类的细节颜色指定，就会在暗色中夹杂一块纯白，很丑，我之后再想办法解决。</p><p>接下来，我们讨论如何实现这样的一个 Demo App（我们只着重讨论题目部分的东西，也就是“城市链表”点进去的具体 Demo 部分）。</p><h2 id="城市列表设计实现"><a href="#城市列表设计实现" class="headerlink" title="城市列表设计实现"></a>城市列表设计实现</h2><p>因为我们的目标很明确，就是一个链表放城市，实现增删改查。涉及到的功能也不多，所以设计这个东西不难。我们先从数据结构讲起。</p><p>数据结构这一块大体上就是按照上课讲的写。不过按照自己的命名习惯，我修改了一些命名，还有内部的实现也是按照我自己的喜好写的，和老师的稍微有点区别。</p><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>在这个 Demo 里，我们用到了顺序表 <code>SeqList</code>、单链表 <code>SLinkList</code>。这两个东西都实现了线性表接口 <code>ILinearList</code>，提供 <code>Insert</code>，<code>Remove</code>，<code>IsEmpty</code>，<code>Clear</code>，<code>Search</code> 和取下标等操作，具体的类图如下（用软件生成的好像有点错，不管了，以实际代码为准）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmn3fojbaj311u0qw79h.jpg" alt="LinearList"></p><p><strong>代码实现</strong>（由于文章空间有限，代码我做过一些调整）：</p><p>线性表接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStructureAlgorithm/LinearList/ILinearList.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructureAlgorithm.LinearList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILinearList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> Length &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        T <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T data</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">Search</span>(<span class="params">T data</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">IsEmpty</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStructureAlgorithm/LinearList/SeqList.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructureAlgorithm.LinearList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SeqList</span>&lt;<span class="title">T</span>&gt; : <span class="title">ILinearList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> T[] dataSet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> MaxLength &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SeqList</span>(<span class="params"><span class="built_in">int</span> maxLength</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLength &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;max Length should &gt;= 0.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            MaxLength = maxLength;</span><br><span class="line">            dataSet = <span class="keyword">new</span> T[MaxLength];</span><br><span class="line">            Length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dataSet[index];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">                &#125;</span><br><span class="line">                dataSet[index] = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Length == MaxLength)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to Insert: SeqList is already full (Length == MaxLength)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = Length; i &gt; index; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                dataSet[i] = dataSet[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dataSet[index] = data;</span><br><span class="line">            Length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsEmpty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> (Length == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt; Length - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dataSet[i] = dataSet[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            Length--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params">T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.CompareTo(dataSet[i]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStructureAlgorithm/LinearList/SLinkList.cs + SNode.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructureAlgorithm.LinearList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SNode</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> SNode&lt;T&gt; Next &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SNode</span>(<span class="params">T data, SNode&lt;T&gt; next</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Data = data;</span><br><span class="line">            Next = (next != <span class="literal">null</span> ? next : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SNode</span>(<span class="params">T data</span>) : <span class="title">this</span>(<span class="params">data, <span class="literal">null</span></span>)</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SLinkList</span>&lt;<span class="title">T</span>&gt; : <span class="title">ILinearList</span>&lt;<span class="title">T</span>&gt;, <span class="title">INotifyPropertyChanged</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> LengthStr = <span class="string">&quot;Length&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> SNode&lt;T&gt; HeadNode &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> HeadNodeStr = <span class="string">&quot;HeadNode&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SLinkList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Length = <span class="number">0</span>;</span><br><span class="line">            HeadNode = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SNode&lt;T&gt; <span class="title">NodeAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SNode&lt;T&gt; node = HeadNode;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                node = node.Next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> NodeAt(index).Data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                NodeAt(index).Data = <span class="keyword">value</span>;</span><br><span class="line">                OnPropertyChanged(IndexerName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> IndexerName = <span class="string">&quot;this[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            HeadNode = <span class="literal">null</span>;</span><br><span class="line">            Length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SNode&lt;T&gt; current = <span class="keyword">new</span> SNode&lt;T&gt;(data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current.Next = HeadNode;</span><br><span class="line">                HeadNode = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                SNode&lt;T&gt; prev = NodeAt(index - <span class="number">1</span>);</span><br><span class="line">                current.Next = prev.Next;</span><br><span class="line">                prev.Next = current;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Length++;</span><br><span class="line">            OnPropertyChanged(LengthStr);</span><br><span class="line">            OnPropertyChanged(IndexerName);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertAtHead</span>(<span class="params">T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Insert(<span class="number">0</span>, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertAtRear</span>(<span class="params">T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Insert(Length, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsEmpty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> (Length == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; Length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                HeadNode = HeadNode.Next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                SNode&lt;T&gt; prev = NodeAt(index - <span class="number">1</span>);</span><br><span class="line">                prev.Next = prev.Next.Next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Length--;</span><br><span class="line"></span><br><span class="line">            OnPropertyChanged(LengthStr);</span><br><span class="line">            OnPropertyChanged(IndexerName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params">T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> current = HeadNode; current != <span class="literal">null</span>; current = current.Next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.CompareTo(current.Data) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">event</span> PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add</span></span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged += <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">remove</span></span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged -= <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            OnPropertyChanged(<span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params">PropertyChangedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (PropertyChanged != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged(<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(里面有些看不懂的代码对吧，比如 <code>INotifyPropertyChanged</code> 什么的，这些先不管，之后再讨论。)</p><p>写完这些东西，随手做个单元测试，然后就可以开始考虑怎么用它们了。</p><h3 id="城市、坐标"><a href="#城市、坐标" class="headerlink" title="城市、坐标"></a>城市、坐标</h3><p>我们的目标是写城市列表，那当然一个 <code>City</code> 类是必不可少的，这只是一个简单的 data 类，但是因为题目有个用距离去搜索的要求，我觉得让 <code>City</code> 类或是使用 <code>City</code> 类的其他东西去实现两点之间距离的计算不够优雅，所以再抽象出一个 <code>Point2D</code> 类来描述一个平面点，同时提供点间距离的计算方法。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmn2v20aej30ew0kmwgd.jpg" alt="CityAndPoint2D"></p><p><strong>代码实现</strong>：</p><p>City:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStructureAlgorithm/LinearList/City.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">City</span> : <span class="title">IComparable</span>&lt;<span class="title">City</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Point2D Location &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> LocationStr</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Location.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">City</span>(<span class="params"><span class="built_in">string</span> name, Point2D location</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">            Location = location;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">City other</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.Location.CompareTo(other.Location);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;Name&#125;</span> <span class="subst">&#123;Location&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Point2D:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStructureAlgorithm/LinearList/Point2D.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point2D</span> : <span class="title">IComparable</span>&lt;<span class="title">Point2D</span>&gt;, <span class="title">IEquatable</span>&lt;<span class="title">Point2D</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point2D</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            X = x;</span><br><span class="line">            Y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">DistanceTo</span>(<span class="params">Point2D other</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">double</span> xd = <span class="keyword">this</span>.X - other.X;</span><br><span class="line">            <span class="built_in">double</span> yd = <span class="keyword">this</span>.Y - other.Y;</span><br><span class="line">            <span class="keyword">return</span> Math.Sqrt(xd * xd + yd * yd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Point2D other</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.X == other.Y) &amp;&amp; (<span class="keyword">this</span>.Y == other.Y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.X &lt;= other.X) || (<span class="keyword">this</span>.Y == other.Y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Point2D other</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.CompareTo(other) == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们表示出了城市。结合刚才的线性表，我们就可以储存满足题目需要的若干城市数据了！但是，我们直接用 <code>ILinearList&lt;City&gt;</code> 的话，还有一点不足。问题是什么呢？题目需要我们完成通过城市名和通过中心半径两种方式进行搜索。而我们的 <code>ILinearList</code> 只能完成给定完整的 object 的搜索，也就是说只能同时给出城市名、坐标去查找这个城市在不在我们的线性表中。</p><h3 id="城市列表"><a href="#城市列表" class="headerlink" title="城市列表"></a>城市列表</h3><p>要实现题目要求的两种搜索，我们就要往已经实现的基础线性表中加方法。所以我们考虑构建一个新的 <code>CityList</code> 去继承已经实现好的 <code>SLinkList</code>，同时添加城市链表所特需的两种搜索操作。</p><p>我们的 ILinearList 接口里的 Search 是返回一个整数的，但这里我们的搜索结果可不一定是只有一个数，所以搜索的结果还得用一个集合去存，所以我们可以尝试在这里使用我们实现的另一种线性表——<code>SeqList</code>。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmn4rlejcj30mq0ayq45.jpg" alt="CityList"></p><p><strong>代码实现：</strong>(这里我们额外还实现了IEnumerable, INotifyPropertyChanged这两个接口，理由后面再讨论)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo/DataStructDemo/CityListPage.xaml.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> DataStructureAlgorithm.LinearList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CityList</span> : <span class="title">SLinkList</span>&lt;<span class="title">City</span>&gt;, <span class="title">IEnumerable</span>, <span class="title">INotifyPropertyChanged</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SearchByName 通过城市名搜索，返回给定名称的城市索引列表(SeqList&lt;int&gt;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SeqList&lt;<span class="built_in">int</span>&gt; <span class="title">SearchByName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            SeqList&lt;<span class="built_in">int</span>&gt; find = <span class="keyword">new</span> SeqList&lt;<span class="built_in">int</span>&gt;(Length);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> current = HeadNode; current != <span class="literal">null</span>; current = current.Next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.CompareTo(current.Data.Name) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    find.Insert(<span class="number">0</span>, index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> find;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SearchByLocation 通过给定中心点、搜索半径搜索城市，返回给定范围内的城市索引列表(SeqList&lt;int&gt;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SeqList&lt;<span class="built_in">int</span>&gt; <span class="title">SearchByLocation</span>(<span class="params">Point2D center, <span class="built_in">double</span> radius</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            SeqList&lt;<span class="built_in">int</span>&gt; find = <span class="keyword">new</span> SeqList&lt;<span class="built_in">int</span>&gt;(Length);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> current = HeadNode; current != <span class="literal">null</span>; current = current.Next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (center.DistanceTo(current.Data.Location) &lt;= radius)</span><br><span class="line">                &#123;</span><br><span class="line">                    find.Insert(<span class="number">0</span>, index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> find;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerator&lt;City&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> current = HeadNode; current != <span class="literal">null</span>; current = current.Next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> current.Data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (IEnumerator)GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList <span class="title">ToArrayList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> current = HeadNode; current != <span class="literal">null</span>; current = current.Next)</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.Add(current.Data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，核心的数据表示、存储部分就全部搞定了：我们可以表示了城市，然后把它们储存到链表中，并提供了要求的几种增删改查操作。</p><p>接下来就是实行一个 UI 界面去展示这个城市链表，并给用户提供完成各种操作的接口了。</p><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>之前讨论过了，由于一些不知名的原因，我们选择了使用 Xamarin 完成 UI（准确地说是跨平台的 Xamarin.Forms）。</p><p>很自然的，展现一个列表，我们当然是使用 <code>ListView</code>，而用户要操作数据，就需要有接收用户输入的 <code>Entry</code> 以及发起操作的 <code>Button</code> 了。</p><p>还有如果我们给每个增删改查操作都在界面上分配一个按钮的话手机屏幕肯定放不下（放下了也极端不好看），所以我们可以考虑在运行时用 <code>DisplayActionSheet</code> 来让用户选择操作，这样界面就比较清爽了。</p><p>至于搜索功能，因为涉及到两种搜索，比较复杂。如果我们在一个页面里又要完成城市显示，又要提供增删改查操作，还有有两种不同的搜索，界面就会变得和老师提供的参考页面一摸一样，很复杂，往你手机那几寸屏幕里塞这么多东西是不优雅、不简洁、不易用的。所以我们把搜索功能单独放到一个 Page 里，在 City List Page 只留下一个进入 Search Page 按钮。完成这些之后，我们就得到了这样的 City List Page，差强人意，但我可以接受了：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gclsi51c5vj30u00whq4x.jpg" alt="IMG_448"></p><p><strong>代码实现</strong>：</p><p>界面：<code>Demo/DataStructDemo/CityListPage.xaml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ContentPage</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xamarin.com/schemas/2014/forms&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">x:Class</span>=<span class="string">&quot;DataStructDemo.CityListPage&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">Title</span>=<span class="string">&quot;City List&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ContentPage.ToolbarItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ToolbarItem</span> <span class="attr">Text</span>=<span class="string">&quot;Search&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">Clicked</span>=<span class="string">&quot;OnSearchClicked&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ContentPage.ToolbarItems</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">BackgroundColor</span>=<span class="string">&quot;#FAFAFA&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;CityListView&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">Margin</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">BackgroundColor</span>=<span class="string">&quot;#FAFAFA&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">ItemSelected</span>=<span class="string">&quot;OnListViewItemSelected&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ListView.ItemTemplate</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextCell</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">Detail</span>=<span class="string">&quot;&#123;Binding LocationStr&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ListView.ItemTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">BackgroundColor</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">x:Name</span>=<span class="string">&quot;SelectedAndOperate&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">BoxView</span> <span class="attr">Color</span>=<span class="string">&quot;#000000&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">WidthRequest</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">HeightRequest</span>=<span class="string">&quot;0.17&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;Selected:&quot;</span> </span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalOptions</span>=<span class="string">&quot;Start&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">VerticalOptions</span>=<span class="string">&quot;CenterAndExpand&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Margin</span>=<span class="string">&quot;20, 5, 20, 5&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">Orientation</span>=<span class="string">&quot;Horizontal&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">HorizontalOptions</span>=<span class="string">&quot;Center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;City Name&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputCityName&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">WidthRequest</span>=<span class="string">&quot;125&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Margin</span>=<span class="string">&quot;5, 0, 5, 0&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;Index&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputIndex&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">WidthRequest</span>=<span class="string">&quot;125&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Margin</span>=<span class="string">&quot;5, 0, 5, 0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">Orientation</span>=<span class="string">&quot;Horizontal&quot;</span> </span></span><br><span class="line"><span class="tag">                         <span class="attr">HorizontalOptions</span>=<span class="string">&quot;Center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;Location X&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputLocationX&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">WidthRequest</span>=<span class="string">&quot;125&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Margin</span>=<span class="string">&quot;5, 0, 5, 0&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;Location Y&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputLocationY&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">WidthRequest</span>=<span class="string">&quot;125&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Margin</span>=<span class="string">&quot;5, 0, 5, 0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Text</span>=<span class="string">&quot;<span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span> Operate <span class="symbol">&amp;lt;</span><span class="symbol">&amp;lt;</span>&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">Clicked</span>=<span class="string">&quot;OnOperateClicked&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">Margin</span>=<span class="string">&quot;10, 10, 10, 10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ContentPage</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo/DataStructDemo/CityListPage.xaml.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Xamarin.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Collections.ObjectModel;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">CityListPage</span> : <span class="title">ContentPage</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CityList cities;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//private ObservableCollection&lt;City&gt; lst;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CityListPage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"></span><br><span class="line">            cities = <span class="keyword">new</span> CityList();</span><br><span class="line">            AddSomeCitys(cities);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lst = new ObservableCollection&lt;City&gt;();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// lst.Add(new City(&quot;Foo&quot;, new Point2D(500, 500)));</span></span><br><span class="line">            <span class="comment">// lst.Add(new City(&quot;Bar&quot;, new Point2D(703, 500)));</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAppearing</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnAppearing();</span><br><span class="line"></span><br><span class="line">            CityListView.ItemsSource = cities;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnSearchClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// DisplayAlert(&quot;未完成的功能&quot;, &quot;现在还不能用哦&quot;, &quot;取消&quot;);</span></span><br><span class="line">            <span class="keyword">await</span> Navigation.PushAsync(<span class="keyword">new</span> CitySearchPage(cities));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnListViewItemSelected</span>(<span class="params"><span class="built_in">object</span> sender, SelectedItemChangedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InputCityName.Text = (e.SelectedItem <span class="keyword">as</span> City).Name;</span><br><span class="line">            InputIndex.Text = (e.SelectedItemIndex).ToString();</span><br><span class="line">            InputLocationX.Text = ((e.SelectedItem <span class="keyword">as</span> City).Location.X).ToString();</span><br><span class="line">            InputLocationY.Text = ((e.SelectedItem <span class="keyword">as</span> City).Location.Y).ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnOperateClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (InputCityName.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;City Name cannot be empty.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (InputLocationX.Text == <span class="string">&quot;&quot;</span> || InputLocationY.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Location X/Y cannot be empty.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">string</span> cityName = InputCityName.Text;</span><br><span class="line">                <span class="built_in">double</span> locX = <span class="built_in">double</span>.Parse(InputLocationX.Text);</span><br><span class="line">                <span class="built_in">double</span> locY = <span class="built_in">double</span>.Parse(InputLocationY.Text);</span><br><span class="line">                <span class="built_in">int</span> index = <span class="built_in">int</span>.Parse(InputIndex.Text);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">string</span> action = <span class="keyword">await</span> DisplayActionSheet(<span class="string">$&quot;以选择 <span class="subst">&#123;cityName&#125;</span> (<span class="subst">&#123;locX&#125;</span>, <span class="subst">&#123;locY&#125;</span>), index=<span class="subst">&#123;index&#125;</span>&quot;</span>, <span class="string">&quot;Cancel&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;头插&quot;</span>, <span class="string">&quot;尾插&quot;</span>, <span class="string">&quot;插入到index处&quot;</span>, <span class="string">&quot;删除index处的城市&quot;</span>, <span class="string">&quot;更新index处的城市&quot;</span>);</span><br><span class="line">                <span class="keyword">await</span> HandOperateAction(action, cityName, locX, locY, index);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> DisplayActionSheet(<span class="string">&quot;输入有误，无法继续操作: \n&quot;</span> + ex.Message, <span class="string">&quot;Cancel&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">HandOperateAction</span>(<span class="params"><span class="built_in">string</span> action, <span class="built_in">string</span> cityName, <span class="built_in">double</span> locX, <span class="built_in">double</span> locY, <span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                City city = <span class="keyword">new</span> City(cityName, <span class="keyword">new</span> Point2D(locX, locY));</span><br><span class="line">                <span class="keyword">switch</span> (action)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;头插&quot;</span>:</span><br><span class="line">                        cities.InsertAtHead(city);</span><br><span class="line">                        <span class="comment">// lst.Insert(0, city);</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;尾插&quot;</span>:</span><br><span class="line">                        cities.InsertAtRear(city);</span><br><span class="line">                        <span class="comment">// lst.Add(city);</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;插入到index处&quot;</span>:</span><br><span class="line">                        cities.Insert(index, city);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;删除index处的城市&quot;</span>:</span><br><span class="line">                        cities.RemoveAt(index);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;更新index处的城市&quot;</span>:</span><br><span class="line">                        cities[index] = city;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> DisplayAlert(<span class="string">&quot;出错啦!&quot;</span>, <span class="string">&quot;不能完成操作:\n&quot;</span> + ex.Message, <span class="string">&quot;取消&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                RefreshCityListView();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ok;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RefreshCityListView</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CityListView.BeginRefresh();</span><br><span class="line">            CityListView.ItemsSource = <span class="literal">null</span>;</span><br><span class="line">            CityListView.EndRefresh();</span><br><span class="line">            CityListView.ItemsSource = cities;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddSomeCitys</span>(<span class="params">CityList cities</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            cities.InsertAtRear(<span class="keyword">new</span> City(<span class="string">&quot;Foo&quot;</span>, <span class="keyword">new</span> Point2D(<span class="number">500</span>, <span class="number">500</span>)));</span><br><span class="line">            cities.InsertAtRear(<span class="keyword">new</span> City(<span class="string">&quot;Bar&quot;</span>, <span class="keyword">new</span> Point2D(<span class="number">703</span>, <span class="number">500</span>)));</span><br><span class="line">            cities.InsertAtRear(<span class="keyword">new</span> City(<span class="string">&quot;Gophers&#x27; City&quot;</span>, <span class="keyword">new</span> Point2D(<span class="number">600</span>, <span class="number">1200</span>)));</span><br><span class="line">            cities.InsertAtRear(<span class="keyword">new</span> City(<span class="string">&quot;川坨&quot;</span>, <span class="keyword">new</span> Point2D(<span class="number">100</span>, <span class="number">20</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续，写我们刚才落下的搜索页面。其实这里要实现的好看很麻烦了，你可以去根据用户选择搜名字还是搜坐标而动态响应，给出不同的搜索框，然后进行搜索、结果展示。我不想这么做（我还是个 Xamarin 新手，我有点害怕这么复杂的页面），还是简单暴力一点，直接把两种输入做到一起比较方便：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gclstvjqawj30u00whgn8.jpg" alt="IMG_449"></p><p><strong>代码实现：</strong></p><p>界面：<code>Demo/DataStructDemo/CitySearchPage.xaml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ContentPage</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xamarin.com/schemas/2014/forms&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">x:Class</span>=<span class="string">&quot;DataStructDemo.CitySearchPage&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">Title</span>=<span class="string">&quot;City Search&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">Margin</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;0.2*&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;0.2*&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;0.2*&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;0.25*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">RowDefinition</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">RowDefinition</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">RowDefinition</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">RowDefinition</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;通过城市名搜索：&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HeightRequest</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.ColumnSpan</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;City Name&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputName&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Column</span>=<span class="string">&quot;0&quot;</span> <span class="attr">Grid.ColumnSpan</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Text</span>=<span class="string">&quot;Search&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Clicked</span>=<span class="string">&quot;SearchByNameClicked&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Column</span>=<span class="string">&quot;3&quot;</span> <span class="attr">Grid.ColumnSpan</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;或 通过中心坐标、半径搜索：&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Margin</span>=<span class="string">&quot;0,10,0,10&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HeightRequest</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.ColumnSpan</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;X&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputX&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Column</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;Y&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputY&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Column</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Entry</span> <span class="attr">Placeholder</span>=<span class="string">&quot;Radius&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">x:Name</span>=<span class="string">&quot;InputRadius&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HorizontalTextAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Column</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Text</span>=<span class="string">&quot;Search&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Clicked</span>=<span class="string">&quot;SearchByLocationClicked&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Row</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">Grid.Column</span>=<span class="string">&quot;3&quot;</span> <span class="attr">Grid.ColumnSpan</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">BoxView</span> <span class="attr">Color</span>=<span class="string">&quot;#000000&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">WidthRequest</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">HeightRequest</span>=<span class="string">&quot;0.17&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;搜索结果:&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">HeightRequest</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">Margin</span>=<span class="string">&quot;0,10,0,10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;CitySearchListView&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">HeightRequest</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">ItemSelected</span>=<span class="string">&quot;OnListViewItemSelected&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ListView.ItemTemplate</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextCell</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">Detail</span>=<span class="string">&quot;&#123;Binding LocationStr&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ListView.ItemTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ContentPage</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo/DataStructDemo/CitySearchPage.xaml.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> DataStructureAlgorithm.LinearList;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Xamarin.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">CitySearchPage</span> : <span class="title">ContentPage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> CityList cities;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CitySearchPage</span>(<span class="params">CityList cityList</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            cities = cityList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnListViewItemSelected</span>(<span class="params"><span class="built_in">object</span> sender, SelectedItemChangedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DisplayAlert(<span class="string">&quot;未完成的功能&quot;</span>, <span class="string">&quot;你点它干嘛啊，我想不出这里要做什么操作。&quot;</span>, <span class="string">&quot;取消&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SearchByNameClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (InputName.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;要搜索的城市名不能为空。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                SeqList&lt;<span class="built_in">int</span>&gt; indices = cities.SearchByName(InputName.Text);</span><br><span class="line">                ShowFoundCities(indices);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                DisplayActionSheet(<span class="string">&quot;发生错误，未能完成搜索: \n&quot;</span> + ex.Message, <span class="string">&quot;Cancel&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SearchByLocationClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((InputX.Text == <span class="string">&quot;&quot;</span>) || (InputY.Text == <span class="string">&quot;&quot;</span>) || (InputRadius.Text == <span class="string">&quot;&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;要搜索的中心坐标X、Y以及搜索半径Radius不能为空。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Point2D center = <span class="keyword">new</span> Point2D(<span class="built_in">double</span>.Parse(InputX.Text), <span class="built_in">double</span>.Parse(InputY.Text));</span><br><span class="line">                <span class="built_in">double</span> radius = <span class="built_in">double</span>.Parse(InputRadius.Text);</span><br><span class="line"></span><br><span class="line">                SeqList&lt;<span class="built_in">int</span>&gt; indices = cities.SearchByLocation(center, radius);</span><br><span class="line">                ShowFoundCities(indices);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                DisplayActionSheet(<span class="string">&quot;发生错误，未能完成搜索: \n&quot;</span> + ex.Message, <span class="string">&quot;Cancel&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ShowFoundCities</span>(<span class="params">SeqList&lt;<span class="built_in">int</span>&gt; indices</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CityList foundCities = <span class="keyword">new</span> CityList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; indices.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                foundCities.InsertAtHead(cities[indices[i]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CitySearchListView.ItemsSource = foundCities;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (foundCities.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                NoResultFound();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">NoResultFound</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DisplayAlert(<span class="string">&quot;无结果&quot;</span>, <span class="string">&quot;没有找到符合条件的城市。&quot;</span>, <span class="string">&quot;取消&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK了，界面的设计也完成了，，，这个东西好像已经全部介绍完了，因为简单嘛，没多少好说的。我先去睡个觉再接着介绍一下我遇到的一些问题。</p><p>…… Me.Sleep(11 * time.Hour);    // 几个小时过去了</p><h2 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h2><p>我前面给出代码的里面有些 IEnumerable, INotifyPropertyChanged 之类的东西，我没有解释这是干什么的，是因为这个问题比较复杂（是因为我还没有优雅地解决问题），留到这里来单独讨论。</p><p>在我们实现的设计的时候，城市放到了继承自 <code>SLinkList</code> 的 <code>CityList</code>，然后我们把这个 <code>CityList</code> 放到了 Xamarin 提供的 <code>ListView</code> 中显示出来。注意到了没有？问题就是人家 Xamarin 的组件为什么支持咱自己实现的野生数据结构？</p><p><code>ListView</code> 是通过 set <code>ItemsSource</code> 来给定要显示的列表的，而这个 <code>ItemsSource</code> 的接收的是 <code>IEnumerable</code> 接口的实现。所以我们只需要让 <code>CityList</code> 实现一个 <code>IEnumerable</code> 就可以显示出来了。</p><p>但，仅仅是现实出来！如果你去尝试运行，会发现，在 <code>CityList</code> 在屏幕上显示出来后，你尽管往里面添加、删除、修改，显示出来的列表总是纹丝不动！</p><p>这看上去好像是我们自己实现的 <code>CityList</code> 还是有缺陷，不能支持 ListView 的自动更新，那么我们换一个系统的列表实现，用 <code>List&lt;City&gt;</code> 代替 <code>CityList</code>。再次尝试，你还是会发现 ListView 不会自动更新！</p><p>这就有点离谱了啊，ListView 不支持系统标准实现的 List!</p><p>事已至此，我们只好看谷歌眼色行事。网上一些大佬给出的 Xamarin.Forms ListView 最佳实践中，总是会在代码里给 <code>ItemsSource</code> 传一个 <code>List&lt;&gt;</code> 的数据，然后顺便提那么一句：“这里更推荐用 ObservableCollection，以实现数据刷新后列表的更新显示……”</p><p>那好吧，看来我们按照大佬的建议 把 List 换成 <code>ObservableCollection</code>，然后数据更新真的会自动显示了！</p><p>我继续研究了一下这个 <code>ObservableCollection</code>，网上说因为 ObservableCollection 实现了<code>INotifyPropertyChanged</code>，所以 ListView 才可以自动更新。</p><p>仿照 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=netframework-4.8">INotifyPropertyChanged Interface的文档</a> 我实现的 INotifyPropertyChanged 大概是这样的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotifyPropertyChanged</span>(<span class="params">String info</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.PropertyChanged != <span class="literal">null</span>)<span class="comment">// 这里还可以简化成委托，效果是一样的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.PropertyChanged(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(info));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    NotifyPropertyChanged(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    NotifyPropertyChanged(<span class="string">&quot;insert&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样也不行！数据还是不会自动刷新。</p><p>然后我查了 <a href="https://referencesource.microsoft.com/#System/compmod/system/collections/objectmodel/observablecollection.cs,4eb38b95b10327e7">ObservableCollection的源码</a> ，我尝试抄他的代码，得到了一个这样的 SLinkList（这里简化细节了，详细的代码就是之前设计实现部分给出的 SLinkList 源码）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructureAlgorithm.LinearList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SLinkList</span>&lt;<span class="title">T</span>&gt; : <span class="title">ILinearList</span>&lt;<span class="title">T</span>&gt;, <span class="title">INotifyPropertyChanged</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> LengthStr = <span class="string">&quot;Length&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> SNode&lt;T&gt; HeadNode &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> HeadNodeStr = <span class="string">&quot;HeadNode&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SLinkList</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SNode&lt;T&gt; <span class="title">NodeAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123; ... &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;...&#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">                OnPropertyChanged(IndexerName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> IndexerName = <span class="string">&quot;this[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ...</span><br><span class="line">            OnPropertyChanged(LengthStr);</span><br><span class="line">            OnPropertyChanged(IndexerName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T data</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ...</span><br><span class="line">            OnPropertyChanged(LengthStr);</span><br><span class="line">            OnPropertyChanged(IndexerName);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertAtHead</span>(<span class="params">T data</span>)</span> &#123; Insert(<span class="number">0</span>, data); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertAtRear</span>(<span class="params">T data</span>)</span> &#123; Insert(Length, data); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsEmpty</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ...</span><br><span class="line">            OnPropertyChanged(LengthStr);</span><br><span class="line">            OnPropertyChanged(IndexerName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params">T data</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">event</span> PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add</span></span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged += <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">remove</span></span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged -= <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            OnPropertyChanged(<span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params">PropertyChangedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (PropertyChanged != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged(<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样还是不行。。。。。。我觉得问题可能是出在我写的 <code>OnPropertyChanged(IndexerName)</code>、<code>protected string IndexerName = &quot;this[]&quot;;</code> 这里，我觉得不应该是 <code>this[]</code>，但我完全不知道这个 <code>propertyName</code> 是什么东西、应该写什么。。。</p><hr><p>目前，我解决的方法是，强制 ListView 去重新载入数据源，这肯定不是个好办法，这样去刷新界面会快速闪出新数据，而不是像使用 ObservableCollection 作为数据源那样修改数据后会自动有平滑的动画去展示列表变动：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshCityListView</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CityListView.BeginRefresh();</span></span><br><span class="line">    CityListView.ItemsSource = <span class="literal">null</span>;</span><br><span class="line">    CityListView.ItemsSource = cities;</span><br><span class="line">    <span class="comment">// CityListView.EndRefresh();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做实在笨拙，但一时半会我确实无能解决如何实现一个 <code>ObservableCollection</code> 的问题。如果你有更好的解决方案请务必与我分享🥺</p><h2 id="关于整体-App-设计与展望"><a href="#关于整体-App-设计与展望" class="headerlink" title="关于整体 App 设计与展望"></a>关于整体 App 设计与展望</h2><p>在一开始我提到过我把这个城市链表只写成了这个 App 里的一个功能！我想把这个 App 写成一个比较全的数据结构与算法演示。</p><p>但其实这也挺难的，是个不小的工程了！在我的构想中，这个 App 的完整形态应该是分成 4 个板块的：</p><ul><li><em>学习</em>：就是放数据结构与算法学习的资料，参考“算法动画图解”；</li><li><em>试验</em>：就是放比如我们这次的城市链表这样的数据结构使用实践的地方，即现在已经实现的“目录”页；</li><li><em>交流</em>：就是一个 WebView 打开个 Wordpress 论坛了；</li><li><em>我的</em>：登录、收藏、设置、关于、反馈这一套。</li></ul><p>这个要做起来时间就比较长了，慢慢来吧，有机会就把它做出来。(主要是咱交不起99美元的年费，不然这东西做出来感觉都可以上架 App Store 了:)</p><hr><p>该 App 的开发日后会放到 Github 开源进行（在我把基本的框架重构出来之后），欢迎参与。</p><h2 id="（蒟蒻的抱怨-Part2）"><a href="#（蒟蒻的抱怨-Part2）" class="headerlink" title="（蒟蒻的抱怨-Part2）"></a>（蒟蒻的抱怨-Part2）</h2><p><del>“这 App 开发还是不容易啊……”, 瘫坐在椅子上的蒟蒻抱怨到。</del></p><p>“这 App 开发还是很有意思的～”，蒟蒻兴高采烈地写下这篇文章的最后一句。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P122 买卖股票的最佳时机 II</title>
      <link href="/2020/03/04/School/Leetcode_P122_best-time-to-buy-and-sell-stock-ii/"/>
      <url>/2020/03/04/School/Leetcode_P122_best-time-to-buy-and-sell-stock-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P122-买卖股票的最佳时机-II"><a href="#Leetcode-P122-买卖股票的最佳时机-II" class="headerlink" title="Leetcode P122 买卖股票的最佳时机 II"></a>Leetcode P122 买卖股票的最佳时机 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>有点忙，没空好好研究了，一遍代码把它过了。</p><p>这个题就一句话，<strong>低买高卖</strong>！具体一点，是<strong>最低买，最高卖</strong>。</p><p>遵循这个原则，代码直接就出来了，Golang实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    prices = <span class="built_in">append</span>(prices, <span class="number">-1</span>)</span><br><span class="line">    in := <span class="number">0</span></span><br><span class="line">    profit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; prices[in] &#123;</span><br><span class="line">            in = i  <span class="comment">// 低买</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> prices[i] &gt; prices[in] &amp;&amp; prices[i+<span class="number">1</span>] &lt; prices[i] &#123;</span><br><span class="line">            profit += prices[i] - prices[in]    <span class="comment">// 高卖</span></span><br><span class="line">            in = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gci0b5zipvj318t0u0qu4.jpg" alt="屏幕快照 2020-03-04 17.03.51"></p><p>速度还行，一次遍历嘛，$O(n)$，空间上为了方便，我加了一个尾哨兵（当然是可以避免的，完全可以去掉，就不会才 8.12% 了）。</p><h2 id="一行代码解法"><a href="#一行代码解法" class="headerlink" title="一行代码解法"></a>一行代码解法</h2><p>这次我不想写一行代码解法了，没时间搞。</p><p>反正基本上，只要是你能用一次迭代完成的算法你都可以用 Python 写函数式编程，用下面这个模式一行代码解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>/reduce/<span class="built_in">filter</span>(<span class="keyword">lambda</span>函数, [列表生成器])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 实战——微信公众号课程提醒系统</title>
      <link href="/2020/03/04/blog/WechatCourseNotifierInGolang/"/>
      <url>/2020/03/04/blog/WechatCourseNotifierInGolang/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-实战——微信公众号课程提醒系统"><a href="#Golang-实战——微信公众号课程提醒系统" class="headerlink" title="Golang 实战——微信公众号课程提醒系统"></a>Golang 实战——微信公众号课程提醒系统</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最早开始学 Golang 已经是整整一年前了，当时就把基础语法那一块学完了，然后拿 Golang 写了点 leetcode 题。之后由于项目里一直用 Python 和 Java，Golang 这一块就搁置下来没学了。</p><p>之前寒假本来是打算学 iOS、Mac 开发这一块的，搞了两个星期，感觉暂时不想学下去了。（我想学 SwiftUI，我觉得这才够酷，但我不想拿赖以生存的老 Macbook 尝试 Catalina，Mojave 写 SwiftUI 没有及时预览，感觉没有灵魂了。）</p><p>所以就搬出 Golang 来接着学了。看完了函数、接口、并发这一块，然后就学了一些 Web 开发方面的。（这才实在，不然语言学完就只能刷 leetcode。）</p><p>学完了差不多就开学了，刚好我一直憎恶超级课程表广告的烦扰，所以就打算写一个可以自动从教务系统获取课程表、在上课前提醒的课程表项目。这个照理来说是个前端项目，但 iOS 开发这一块还没学完。本来 Android 也行，但我用 iPhone 啊。所以想了个曲线救国的方法——微信公众号开发，纯后端，拿来练习 Golang 再好不过。</p><hr><p>由于时间、空间有限很多地方我写的不太清晰。所以在开始阅读本文之前，我建议你打开源码，对照阅读。：<a href="https://github.com/cdfmlr/CoursesNotifier">https://github.com/cdfmlr/CoursesNotifier</a>（我仍在持续对该项目进行其调整和拓展，本文所述试用于 <code>72e6165</code> 版本，which is committed on Mar 25, 2020）</p><hr><p>我在这个项目中的很多地方尝试了 Golang 的“面向对象”。Go 不是一个面向对象的语言，这给写惯了 Java、Python 的我们还是带来了一些不适应的。但没关系，正如它的发明者们所说，Go 是用来构建系统的实用语言。面向对象不可否认是构建系统的强有力工具，Golang 当然会有所支持。当然，也只是有所支持，而不是真正的面向对象，我在 coding 的时候，就在一个需要多态的地方碰到了困难，最后不得不更改设计，稍微没那么优雅了。</p><p>在这篇文章中，我尝试记录我开发这个系统的整个过程、解释尽可能多的代码设计。但因为毕竟整个项目有接近3000行代码，我不可能逐一解释到位。如果你想看懂所有东西，请去 GitHub 打开这个项目的源码对照来看，我也是个初学者，写出的代码应该还是很简单的。</p><p>另外，这篇文章不是 Golang 的入门，在开始阅读前请确保你掌握了（起码是有所了解）以下技能：</p><ul><li>Go语言基础：<a href="https://tour.go-zh.org/welcome/1">A Tour of Go</a> ：全部内容；</li><li>Go语言Web开发基础：<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md">astaxie/build-web-application-with-golang</a> ：1～7章；</li><li>微信公众号开发基础：<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Getting_Started_Guide.html">微信公众号入门指引</a> ：1、2、4节；</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我的目的很明确，就是做一个微信公众号系统，在上课前发个通知提醒快上课了。但我不想手动输入课程信息，不然 iDaily Corp 开发的《课程表·ClassTable》就已经很好了。</p><p>所以还需要自动从教务系统获取课程表，学校用的新教务系统是：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnh3mn82nj318t0u07wh.jpg" alt="屏幕快照 2020-03-09 10.35.24"></p><p>嗯，我研究了一下，他这个web端反爬虫还是做的不错的，可以爬，但不好爬！那我们怎么搞到课表？</p><p>还好我发现了这个项目：<a href="https://github.com/TLingC">TLingC</a>/**<a href="https://github.com/TLingC/QZAPI">QZAPI</a>**。这位大佬爬了强智的 App，抓出了这公司的 API。可以直接调用这个接口获取课表了：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnse0hy1gj318t0u0kcz.jpg" alt="image-20200309170649126"></p><p>这个 API 文档做的挺好，无可挑剔；但这个 API 着实很恶心，看看他返回的课表：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhjlijzyj30t0090dii.jpg" alt="image-20200309105136147"></p><p>这就是我们“领先的教学一体化平台”——强(ruo)智教务系统！</p><p>我找不到一个合适的、不带个人感情色彩的词语来客观公正地评价这个设计。不管了，也只能将就着用了。</p><hr><p>肿的来说，我们的系统有两方面：</p><ul><li>一个是输入(I)：自动从教务系统获取课表；</li><li>还有是输出(O)：自动提醒学生上课。</li></ul><p>接下来我们就一步一步把这个系统实现：</p><h2 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>首先是数据库设计。</p><p>本来写这东西 MongoDB 用挺方便的，但这学期有数据库课嘛，肯定不学这些 NoSQL，所以还是复习一下 SQL，用一下关系型数据库。</p><p>其实这个东西挺传统啊，就是数据库书上的例子嘛，主要就三个表：</p><ul><li>一个 Student 表，存学号、微信号（公众号里的openid）还有教务密码（这个可以不存的，存了还不安全，我不知道我设计的时候是怎么想的，后悔了，但懒得改😂）</li><li>一个 Course 表，存课程名、上课时间、教室地点、授课老师……（就是强智API返回的那些）</li><li>还有就是 S-C 选课关系表。</li><li>最后，还有一个储存当前是那个学期之类的信息的表。</li></ul><p>来看最后设计好的表结构：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gchylz4iwyj30ra0f20vl.jpg" alt="屏幕快照 2020-03-04 16.03.36"></p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>有了数据库，我们还要在程序里使用数据库。也就要把数据库里的记录对应到程序里的结构体（Models）中。</p><p>为了方便（懒），我们直接把数据库里的东西对应过来，弄成这几个模型，里面的属性和数据库的属性一一对应（那个current太简单了，就是一个时间嘛， <code>time.Time</code>直接就可以用了，不用再去封装了）：·Student</p><ul><li>Course</li><li>Relationship</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gchz85gatjj313m0kq0w7.jpg" alt="屏幕快照 2020-03-04 16.28.03 2"></p><blockquote><p><code>蓝T</code>是结构体，下面的<code>黄f</code>是属性，<code>红f</code>是函数/方法</p></blockquote><p>（这些图都是从 IDEA 截图出来自己随手拼的，没时间好好调，所以有点丑）</p><p>（对，没错，我用 IDEA 写 Golang，MacBook 硬盘小鸭，没办法，咱坚强的 IDEA 带上几个插件就肩负起了我家 Java、Android、Python、Go 的所有“大型“项目开发）</p><p>注意这里强智系统API请求来的课程是没有 <code>cid</code> 的，但我们为了唯一识别一个课程，所以在构造函数 <code>NewCourse</code> 里自动通过计算 Name,Teacher,Location,Begin,End,Week,When 的 md5 和得出。</p><p>有了模型，我们再实现数据操作(Data) :<code>StudentDatabase</code>、<code>CourseDatabase</code>、<code>StudentCourseRelationshipDatabase</code>。</p><p>这几个东西实现数据库与模型的转化，提供增删改查操作。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnj23azd8j319y0q6tor.jpg" alt="屏幕快照 2020-03-04 16.28.03 3"></p><p>(这里有很多方法其实都是不必要的，都是一样的操作，我只是一开始为了图方便，复制粘贴出来的)</p><h3 id="教务API-amp-Client"><a href="#教务API-amp-Client" class="headerlink" title="教务API&amp;Client"></a>教务API&amp;Client</h3><p>有了这些数据模型，我们就可以访问强智教务系统了。</p><p>我们先用 Golang 把【强智教务系统API文档】(<a href="https://github.com/TLingC">TLingC</a>/<strong><a href="https://github.com/TLingC/QZAPI">QZAPI</a></strong>)里我们需要用到的接口封装一下。我们需要用到的只是“课程信息”，但使用“课程信息”，又需要我们请求“登录”和“时间信息”。所以我们需要封装这三个请求。</p><p>阅读这个强智教务系统API文档，我们会发现所有请求都是类似的 GET：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;jwxt.xxxx.edu.cn&#x2F;app.do?method&#x3D;...&amp;...</span><br><span class="line"></span><br><span class="line">request.header&#123;token:&#39;运行身份验证authUser时获取到的token，有过期机制&#39;&#125;,</span><br><span class="line">request.data&#123;</span><br><span class="line">    &#39;method&#39;:&#39;登录&#x2F;时间&#x2F;课程信息等的方法名&#39;,</span><br><span class="line">    &#39;...&#39;:  &#39;一些特定的参数&#39;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以把这种 “强智 API GET” 封装起来，做成一个 <code>qzApiGet</code> 函数，简化后面的工作。这个函数通过给定学校域名（就是<code>jwxt.xxxx.edu.cn</code>的<code>xxxx</code>，例如华电是<code>ncepu</code>）、token（如果是登录不需要token就传空字符串<code>&quot;&quot;</code>）、还有解析请求结果的结构体实例res、以及一个请求参数的map（就是method那些）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qzApiGet</span><span class="params">(school <span class="keyword">string</span>, token <span class="keyword">string</span>, res <span class="keyword">interface</span>&#123;&#125;, a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Make URL</span></span><br><span class="line">rawUrl := fmt.Sprintf(<span class="string">&quot;http://jwxt.%s.edu.cn/app.do&quot;</span>, school)</span><br><span class="line">Url, err := url.Parse(rawUrl)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add params</span></span><br><span class="line">params := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">params.Set(k, v)</span><br><span class="line">&#125;</span><br><span class="line">Url.RawQuery = params.Encode()</span><br><span class="line">urlPath := Url.String()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make Request</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, urlPath, <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add token</span></span><br><span class="line"><span class="keyword">if</span> token != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">req.Header.Add(<span class="string">&quot;token&quot;</span>, token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET and Parse Response</span></span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">err = json.Unmarshal(body, res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handle Error and Return</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个 <code>qzApiGet</code>，我们就可以方便地封装出我们需要的三个请求了：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnssefvudj319y0q6tga.jpg" alt="屏幕快照 2020-03-04 16.28.03 4"></p><p>这里面的个函数大同小异，我举其中一个例子就好了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentTime</span><span class="params">(school, token, currDate <span class="keyword">string</span>)</span> <span class="params">(*GetCurrentTimeRespBody, error)</span></span> &#123;</span><br><span class="line">resp := &amp;GetCurrentTimeRespBody&#123;&#125;</span><br><span class="line">q := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;method&quot;</span>:   <span class="string">&quot;getCurrentTime&quot;</span>,</span><br><span class="line"><span class="string">&quot;currDate&quot;</span>: currDate,</span><br><span class="line">&#125;</span><br><span class="line">err := qzApiGet(school, token, resp, q)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> &amp;GetCurrentTimeRespBody&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都是一些相当于面向对象里的 <code>public static</code> 的方法啊，调用起来还是不方便。</p><p>我们希望有一个 <code>QzClient</code>，这个东西的实例就像我们使用 app 一样的一个客户端，给这个客户端用户名、密码他就可以登录了，然后你要课表就直接取这个实例的 <code>Courses</code> 属性，一切请求都在黑箱里完成。</p><p>我们把这个 Client 写出来：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnt5k5hgrj30si0iaq6h.jpg" alt="image-20200309173318272"></p><p>。。。这乍一看，还是很可怕的。没关系，我们一个个慢慢解释。</p><p>首先说属性，</p><ul><li><code>Student</code>：就是来用这个强智客户端的学生，</li><li><code>token</code>：是该学生登录后获取的 token，</li><li><code>CurrentXnxqId</code>：表示当前学年学期Id（别问我为什么这么命名，找强智公司去！），</li><li><code>CurrentWeek</code>：当前周次</li><li><code>Courses</code>：就是当前学期这个同学的所有课程啦，因为需要去重，所以我直接用了一个 map，key 放我们的 <code>Cid</code>（md5和），value 是 <code>Course</code> ，这样就保证了数据不重复。</li></ul><p>再来看方法：</p><ul><li><code>AuthUser</code>：调用我们 强智 api 里的 <code>AuthUser</code>，登录强智系统，获取操作 token，在该 token 过期之前可以做其他操作;</li><li><code>FetchCurrentTime</code>：调用 强智api 获取当前学期、周次，储存在 <code>CurrentXnxqId</code>、<code>CurrentWeek</code> 里；</li><li><code>FetchWeekCoursesSlowly</code>：获取某个星期的课表，要反爬虫，所以里面放了一个Sleep，速度很慢，用 chan 去“返回”结果。</li><li><code>FetchAllTermCourses</code>，对一个学期的每个周调用 <code>FetchWeekCoursesSlowly</code>，获取真学期的课表，并通过 <code>appendCourse</code> 把这些课程添加到结构体的 <code>Courses</code> 属性中。</li><li><code>Save</code>：分别调用 <code>saveStudent</code>, <code>saveCourses</code>, <code>saveSCRelationships</code> 把这个客户端的学生、课程、选课关系写入库！这就是我们唯一写入数据的地方！</li></ul><p>呼——终于写完这些了，这里有点枯燥，用强智烂系统的恶心 API 嘛，没多少意思。</p><p>小结一下，到现在为止，我们有了数据模型、数据库，可以访问教务系统、从教务系统自动获取给定学生的课表，并把学生、课程、选课关系写入数据库了。</p><p>接下来就比较有意思了，我们来看课程时钟的设计。</p><h3 id="课程时钟"><a href="#课程时钟" class="headerlink" title="课程时钟"></a>课程时钟</h3><p>啥？课程时钟？什么是课程时钟？就是说，咱们要在上课前提醒同学们上课，这就需要服务器知道现在是什么时间、上课在什么时间。也就是一个像“钟”一样的东西，不停地走，在指定的几个时间点“响”（提醒上课），所以我们把这个模块叫做课程时钟——CourseTicker。</p><p>这个 CourseTicker 的实现很简单也很直观，就像钟“滴答滴答”地走嘛。CourseTicker 需要定时启动，检测当前是不是快上课了，如果是，就提醒学生，不是就什么都不做。</p><p>在 Go 中，要实现这样的定时启动任务很方便，只需要在一个 for 无限循环中睡眠一段时间，然后启动执行任务即可，当然，我们不希望这样永不停止的任务运行在主线程中，所以用一个「匿名函数立即执行」手法把它包装起来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 计算下一个执行时间</span></span><br><span class="line">        now := time.Now()</span><br><span class="line">        next := now.Add(t.period)</span><br><span class="line">        <span class="comment">// 等待到时间</span></span><br><span class="line">        timer := time.NewTimer(next.Sub(now))</span><br><span class="line">        &lt;-timer.C</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        RunTickTask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h4 id="抽象周期运行器"><a href="#抽象周期运行器" class="headerlink" title="抽象周期运行器"></a>抽象周期运行器</h4><p>上面这个方法虽然做到了不停运行、定时执行，但是我们不方便控制它的开始、结束，而且这段代码也不方便复用。所以我们考虑封装一个可以控制开始、结束，能不停运行、定时执行的 Ticker 结构体（相当于 OOP 的类）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcjx4wz2sbj30e609k3z9.jpg" alt="image-20200306084846495"></p><p>解释一下它是怎么工作的：</p><ul><li><code>tickerId</code>: 只是一个标识符，因为我们完全可以在一个系统中使用多个这样的 Ticker 实例，所以搞一个 tickerId ，打日志的时候做区分。</li><li><code>period</code>: 就是间隔的时间了，每隔这么久就跑一次 <code>RunTickTask</code> 方法。</li><li><code>end</code>: 这是用来控制结束的 channel，往里面传值就代表结束 Ticker 的周期性运行了。</li><li><code>task</code>: 就是你要用这个 Ticker 周期性完成的工作，直接传一个函数进来（函数是 Go 的一等公民嘛）</li><li><code>Start</code>: 开始周期性任务。传一个时间进来，代表从这个时候再开始，这么做是因为我们可能希望比如每个小时整点的时候跑任务，但我们不想等到正点再去开启这个服务，就可以通过给 Start 传一个 <code>08:00</code>(这里只是举个例子，你要传的是完整的时间，比如 <code>time.Now()</code> 哦)，这样它第一次开始就是正点，睡眠一个小时后再运行，还是正点……这样就比较方便了。</li><li><code>RunTickTask</code>: 要周期性运行的任务，其实就是打个日志，然后调用属性里的 <code>task</code>。单独搞一个函数出来做这个，一个是把功能划分细，不在 Start 里写具体运行的逻辑，还有一个就是方便你可以在非周期到的时候手动调用任务。</li><li><code>End</code>: 通知 TickTask 终止运行。实际上就是往 <code>end</code> 里传个值，让 Start 里开始的周期性匿名函数收到这个消息，终止运行。</li></ul><p>来看一下大概的代码实现（空间有限，我删了不必要的注释和空行，看起来可能有点丑）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">tickerId <span class="keyword">string</span></span><br><span class="line">period   time.Duration</span><br><span class="line">end      <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">task     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Start</span><span class="params">(time2Start time.Time)</span></span> &#123;</span><br><span class="line">time2Start = time2Start.Add(t.period * <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> time2Start.Sub(time.Now()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">timer := time.NewTimer(time2Start.Sub(time.Now()))</span><br><span class="line">&lt;-timer.C</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.end:</span><br><span class="line">log.Printf(<span class="string">&quot;(Ticker &#123;%s&#125;) TickTask End Exed...\n&quot;</span>, t.tickerId)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">now := time.Now()</span><br><span class="line">next := now.Add(t.period)</span><br><span class="line">timer := time.NewTimer(next.Sub(now))</span><br><span class="line">&lt;-timer.C</span><br><span class="line">t.RunTickTask()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">RunTickTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;(Ticker &#123;%s&#125;) TickTask Run...\n&quot;</span>, t.tickerId)</span><br><span class="line"><span class="keyword">if</span> t.task != <span class="literal">nil</span> &#123;</span><br><span class="line">t.task()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">End</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.end &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="课程时钟-1"><a href="#课程时钟-1" class="headerlink" title="课程时钟"></a>课程时钟</h4><p>现在有了周期运行器 Ticker，再来看之前说的 CourseTicker，不过就是一个简单的继承嘛。我们让 CourseTicker “继承” Ticker，这样它就有了周期性运行的技能，再给他一些具体的检查是否快要上课了、以及提醒上课的功能就行了：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcnianyzkaj30t40dwju8.jpg" alt="image-20200309111736674"></p><p>哈哈，说起来简单，实现起来还是不容易的。由于强智教务系统的鬼畜设计，我们不得不把代码写得很恶心了。</p><p>这里大概的思路就是 CoursesTicker 的 <code>NotifyApproachingCourses</code> 方法作为 Ticker 的周期性 task，这个方法会查询现在有没有课快开始了（就是 <code>开始上课时间 - 当前时间 &lt;= minuteBeforeCourseToNotify</code>），如果有课快开始了，就找出上这些课的学生，去发通知给他们。</p><p>具体的实现里我们需要这几个辅助的函数：</p><ul><li><code>getNearestBeginTime</code> 获取距离当前最近的课程时间，就是用 <code>SELECT DISTINCT begin FROM course</code> 查询出所有可能的上课时间，找出最近的一个。</li><li><code>getCurrentWeek</code> 获取当前教学周次</li><li><code>isCourseInWeek</code> 判断一个 models.Course 是否在指定周次(week) 有课</li></ul><p>而这几个辅助函数的实现又会调用这几个辅助辅助函数(这里我直接抄了代码里的文档注释)：</p><ul><li><code>_getPossibleCourseBeginTime</code>: 返回数据库中今、明两天的所有可能上课时间</li><li><code>_durationToWeek</code>: convert a duration into week</li><li><code>_roundTime</code>: helps getting a reasonable int from a float, which is of great help when converting the duration into week</li></ul><p><code>NotifyApproachingCourses</code> 的内部实现就是首先调用 <code>getCurrentWeek</code> 获取今天是第几周、调用 <code>time.Now().Weekday()</code> 获取今天是星期几（这里还需要把系统的星期表示方式换算成强智系统内的星期表示方式），然后调用 <code>getNearestBeginTime</code> 最近一个可能上课的时间，如果这个时间距离现在已经 <code>&lt;= minuteBeforeCourseToNotify</code> 了，就要找出在这个时间开始的所有课程，并通过 <code>isCourseInWeek</code> 过滤出本周这个时间要上的课，最后就找上这些课的学生，通知ta们要开始上课了。</p><p>到这里 CourseTicker 要做的事就完了，我们可不想在已经这么复杂的一个模块里再实现一个微信通知的功能了，那样这个“类”就长到爆炸了呀。</p><p>通知应该是一个通知模块做的事。但在 CourseTicker 里我们要完成通知呀！怎么办？</p><p>调用暂时没有具体实现的东西——当然是使用<strong>接口</strong>了。</p><h3 id="通知接口"><a href="#通知接口" class="headerlink" title="通知接口"></a>通知接口</h3><p>这个通知接口很简单就两三行代码，只需要提供一个通知函数 <code>Notify</code>。通过给定要通知的学生、要通知的课程，这个 <code>Notify</code> 函数去完成通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">Notify(student *models.Student, course *models.Course)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以顺手实现一个 <code>Notifier</code> 接口的实现—— <code>LogNotifier</code>，把通知的学生、课程打印到 Log 里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogNotifier <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l LogNotifier)</span> <span class="title">Notify</span><span class="params">(student *models.Student, course *models.Course)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;(LogNotifier %s) Course Notify:\n\t|--&gt; student: %s\n\t|--&gt; course: %s (%s)&quot;</span>, l, student.Sid, course.Cid, course.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于微信提醒，就比较复杂了，我们在下面单独来说。</p><h3 id="微信系统"><a href="#微信系统" class="headerlink" title="微信系统"></a>微信系统</h3><p>我们这个系统是基于微信公众号的，现在我们终于讲到微信系统了。我们需要的微信系统有两个方面，一个是微信公众号的被动服务，就是接受用户发来的消息，完成课程提醒的订阅、退订操作的；还有一方面就是通过微信公众号发送上课提醒给用户了。</p><h4 id="微信上课通知"><a href="#微信上课通知" class="headerlink" title="微信上课通知"></a>微信上课通知</h4><p>我们继续刚才的通知接口，先看微信提醒的实现：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcolo3lgl3j31kk07swg8.jpg" alt="image-20200310095953835"></p><p>这个 <code>WxNotifier</code> 只有一个 public 的方法，就是实现 Notifier 的 <code>Notify</code>。调用这个 <code>Notify</code> 的时候，我们要完成微信通知的构造和发送，这两个任务分别由 <code>makeCourseNoticeBody</code> 和 <code>postCourseNotify</code> 完成。</p><p>让我们研究一下怎么通过微信公众号发消息，消息体又需要构造成什么样的：</p><p>通过微信公众号主动发送消息给用户，我大概看了一遍文档，最简单的应该就是<a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html">发送模版消息</a>了。所以我们来实现这个。</p><hr><p>（先来读文档：）</p><p>要使用模版消息，要先定义一个模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#123; &#123;result.DATA&#125; &#125;\n\n领奖金额:&#123; &#123;withdrawMoney.DATA&#125; &#125;\n领奖  时间:    &#123; &#123;withdrawTime.DATA&#125; &#125;\n银行信息:&#123; &#123;cardInfo.DATA&#125; &#125;\n到账时间:  &#123; &#123;arrivedTime.DATA&#125; &#125;\n&#123; &#123;remark.DATA&#125; &#125;</span><br></pre></td></tr></table></figure><p>发送模版消息的 http 请求方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;message&#x2F;template&#x2F;send?access_token&#x3D;ACCESS_TOKEN</span><br></pre></td></tr></table></figure><p>POST 请求体 JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;touser&quot;</span>:<span class="string">&quot;OPENID&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;template_id&quot;</span>:<span class="string">&quot;ngqIpbwh8bUfcSsECmogfXcV14J0tQlEpBO27izEYtY&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;http://weixin.qq.com/download&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;miniprogram&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;appid&quot;</span>:<span class="string">&quot;xiaochengxuappid12345&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;pagepath&quot;</span>:<span class="string">&quot;index?foo=bar&quot;</span></span><br><span class="line">    &#125;,          </span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;first&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>:<span class="string">&quot;恭喜你购买成功！&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#173177&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;keyword1&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>:<span class="string">&quot;巧克力&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#173177&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;keyword2&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>:<span class="string">&quot;39.8元&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#173177&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;keyword3&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>:<span class="string">&quot;2014年9月22日&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#173177&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;remark&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>:<span class="string">&quot;欢迎再次购买！&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#173177&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（：文档读完了，接下来实现咱自己的）</p><hr><p>我们首先来写一个自己的消息模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;first.DATA&#125;&#125;</span><br><span class="line">课程：&#123;&#123;course.DATA&#125;&#125;</span><br><span class="line">地点：&#123;&#123;location.DATA&#125;&#125;</span><br><span class="line">老师：&#123;&#123;teacher.DATA&#125;&#125;</span><br><span class="line">时间：&#123;&#123;time.DATA&#125;&#125;</span><br><span class="line">教学周：&#123;&#123;week.DATA&#125;&#125;</span><br><span class="line">--- </span><br><span class="line">&#123;&#123;bullshit.DATA&#125;&#125;</span><br><span class="line">&#123;&#123;remark.DATA&#125;&#125;</span><br></pre></td></tr></table></figure><p>这个模版消息的效果大概是这样（这个截图是开发过程中的老版本的，和上面的模版稍有区别）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcomni4m6ij30go0h97hi.jpg" alt="IMG_0486"></p><p>然后就是在 Golang 里封装这个请求了。这需要我们把JSON写成结构体：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcolkz8llzj31iq0ey436.jpg" alt="屏幕快照 2020-03-10 09.55.50"></p><p>然后就可以写一个 <code>makeCourseNoticeBody</code> 方法来填充数据了(为了节省空间我删了一些代码，很简单，大家可以自行脑补出来)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeCourseNoticeBody 构建微信上课通知 json</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w WxNotifier)</span> <span class="title">makeCourseNoticeBody</span><span class="params">(toUser, course, location, teacher, begin, end, week <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">notice := WxNotice&#123;</span><br><span class="line">ToUser:     toUser,</span><br><span class="line">TemplateId: w.courseNoticeTemplateID,</span><br><span class="line">Data: CourseData&#123;</span><br><span class="line">First: NoticeItem&#123;</span><br><span class="line">Value: <span class="string">&quot;滚去上课&quot;</span> + <span class="string">&quot;\n\n&quot;</span>,</span><br><span class="line">Color: <span class="string">&quot;#e51c23&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Course: NoticeItem&#123;</span><br><span class="line">Value: course + <span class="string">&quot;\n\n&quot;</span>,</span><br><span class="line">Color: <span class="string">&quot;#173177&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Location: NoticeItem&#123;...&#125;,</span><br><span class="line">Teacher: NoticeItem&#123;...&#125;,</span><br><span class="line">BETime: NoticeItem&#123;...&#125;,</span><br><span class="line">Week: NoticeItem&#123;...&#125;,</span><br><span class="line">Bullshit: NoticeItem&#123;...&#125;,</span><br><span class="line">Remark: NoticeItem&#123;</span><br><span class="line">Value: <span class="string">&quot;但还是要好好听课哦💪&quot;</span> + <span class="string">&quot;\n\n&quot;</span>,</span><br><span class="line">Color: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> json.MarshalIndent(notice, <span class="string">&quot; &quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建出了消息，然后就是 POST 发送了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postCourseNotify 发送微信公众号上课通知请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w WxNotifier)</span> <span class="title">postCourseNotify</span><span class="params">(CourseNoticeBody []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">url := fmt.Sprintf(</span><br><span class="line"><span class="string">&quot;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=%s&quot;</span>,</span><br><span class="line">w.wxTokenHolder.Get(),</span><br><span class="line">)</span><br><span class="line">resp, err := http.Post(url, <span class="string">&quot;application/json&quot;</span>, bytes.NewBuffer(CourseNoticeBody))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;postCourseNotify Failed:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">err = NotifyFailed(<span class="string">&quot;postCourseNotify Failed&quot;</span>)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NotifyFailed 请求返回状态值不为200时抛出的错误</span></span><br><span class="line"><span class="keyword">type</span> NotifyFailed <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NotifyFailed)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里有一个 <code>wxTokenHolder.Get()</code>，看上去是获取 Token 用的，其实它还真是获取 Token 的。</p><h4 id="全局微信-Token-Holder"><a href="#全局微信-Token-Holder" class="headerlink" title="全局微信 Token Holder"></a>全局微信 Token Holder</h4><p>微信公众平台<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">关于 access_token 的文档</a>里说了：</p><blockquote><p>建议公众号开发者使用中控服务器统一获取和刷新access_token，其他业务逻辑服务器所使用的access_token均来自于该中控服务器，不应该各自去刷新，否则容易造成冲突，导致access_token覆盖而影响业务。</p></blockquote><p>所以咱们就按照这个思路，做一个全局的 Token Holder。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcoly3zu7qj30l20ba3zu.jpg" alt="image-20200310100931107"></p><p>这个 Token Holder 只在咱们的整个系统中实例化一次（其实就是个单例，但我没有尝试怎么用 Go 写单例模式），在需要用到 微信 access_token 的地方，就通过这一个全局唯一的 Token Holder 获取。</p><p>调用 Get 的时候，Holder 会自动检测上一次获取的 token 有没有过期，没有的话就直接返回上一次获取的，如果过期了那就重新获取一个，这样就完成了微信文档里建议的统一 token 获取机制。</p><h4 id="微信前台服务"><a href="#微信前台服务" class="headerlink" title="微信前台服务"></a>微信前台服务</h4><p>现在我们已经实现了自动从教务系统获取课表，自动在上课前发送微信提醒。其实这个系统现在已经可以使用了！你随便写个 <code>main</code>，在里面 New 一个 Student 把自己的学号、教务密码、微信open_id 传进去，然后实例化一个强智 Client，登录、获取时间、获取课表、保存，然后开一个 CourseTicker，你就可以收到课程提醒了！</p><p>这么做对咱们开发者来说倒是方便了，但对用户可不太友好、或者说是完全没有可用性！用户需要一套可以看得懂、完得成的操作界面。所以还有最后一步——微信的前台服务。</p><p>这最后一步可不容易。这一步才真正开始了Web服务开发呢。</p><p>先看看我们想要达到的目的（也就是最后完成后的结果）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gconlhwh9jj31nr0u07wh.jpg" alt="屏幕快照 2020-03-10 11.06.18"></p><p>是不是有种10086的感觉😂</p><p>没办法，这种实现是最简单方便的了，而且就这个看似简单的服务都要花上不少代码来实现呢！</p><p>首先，我们来实现一个基本的微信公众号服务：</p><h5 id="微信公众号服务Hello-World"><a href="#微信公众号服务Hello-World" class="headerlink" title="微信公众号服务Hello World"></a>微信公众号服务Hello World</h5><p>在这里我不想详细介绍怎么写一个微信公众号Hello World，我只是把代码贴出来（我也是到处东拼西凑刚学来的），你如果不熟悉微信公众号服务，可以结合着我在文章一开始列出的那片微信公众号入门教程，对应着看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开微信服务：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">WxToken = <span class="string">&quot;wwwwwww&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/wx&quot;</span>, weixinSer)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">weixinSer</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseForm()</span><br><span class="line"><span class="keyword">if</span> !validateWechatRequest(w, r) &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Wechat Service: this http request is not from Wechat platform!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">&quot;POST&quot;</span> &#123;</span><br><span class="line">textRequestBody := parseTextRequestBody(r)</span><br><span class="line"><span class="keyword">if</span> textRequestBody != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Wechat Service: Recv text msg [%s] form user [%s]\n&quot;</span>,</span><br><span class="line">textRequestBody.Content,</span><br><span class="line">textRequestBody.FromUserName,</span><br><span class="line">)</span><br><span class="line">responseTextBody, err := makeTextResponseBody(</span><br><span class="line">textRequestBody.ToUserName,</span><br><span class="line">textRequestBody.FromUserName,</span><br><span class="line"><span class="string">&quot;Hello, &quot;</span>+textRequestBody.FromUserName,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Wechat Service: makeTextResponseBody error: &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprint(w, <span class="keyword">string</span>(responseTextBody))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证消息是否来自微信：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateWechatRequest</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">r.ParseForm()</span><br><span class="line"></span><br><span class="line">signature := r.FormValue(<span class="string">&quot;signature&quot;</span>)</span><br><span class="line"></span><br><span class="line">timestamp := r.FormValue(<span class="string">&quot;timestamp&quot;</span>)</span><br><span class="line">nonce := r.FormValue(<span class="string">&quot;nonce&quot;</span>)</span><br><span class="line"></span><br><span class="line">echostr := r.FormValue(<span class="string">&quot;echostr&quot;</span>)</span><br><span class="line"></span><br><span class="line">hashcode := makeSignature(WxToken, timestamp, nonce)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Try validateWechatRequest: hashcode: %s, signature: %s\n&quot;</span>, hashcode, signature)</span><br><span class="line"><span class="keyword">if</span> hashcode == signature &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s&quot;</span>, echostr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;hashcode != signature&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSignature</span><span class="params">(token, timestamp, nonce <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">sl := []<span class="keyword">string</span>&#123;token, timestamp, nonce&#125;</span><br><span class="line">sort.Strings(sl)</span><br><span class="line"></span><br><span class="line">s := sha1.New()</span><br><span class="line">io.WriteString(s, strings.Join(sl, <span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, s.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信消息解析：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TextRequestBody <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName      xml.Name <span class="string">`xml:&quot;xml&quot;`</span></span><br><span class="line">ToUserName   <span class="keyword">string</span></span><br><span class="line">FromUserName <span class="keyword">string</span></span><br><span class="line">CreateTime   time.Duration</span><br><span class="line">MsgType      <span class="keyword">string</span></span><br><span class="line">Content      <span class="keyword">string</span></span><br><span class="line">MsgId        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseTextRequestBody</span><span class="params">(r *http.Request)</span> *<span class="title">TextRequestBody</span></span> &#123;</span><br><span class="line">body, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">requestBody := &amp;TextRequestBody&#123;&#125;</span><br><span class="line">xml.Unmarshal(body, requestBody)</span><br><span class="line"><span class="keyword">return</span> requestBody</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信消息响应：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TextResponseBody <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName      xml.Name <span class="string">`xml:&quot;xml&quot;`</span></span><br><span class="line">ToUserName   CDATAText</span><br><span class="line">FromUserName CDATAText</span><br><span class="line">CreateTime   time.Duration</span><br><span class="line">MsgType      CDATAText</span><br><span class="line">Content      CDATAText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CDATAText <span class="keyword">struct</span> &#123;</span><br><span class="line">Text <span class="keyword">string</span> <span class="string">`xml:&quot;,innerxml&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value2CDATA</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">CDATAText</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> CDATAText&#123;<span class="string">&quot;&lt;![CDATA[&quot;</span> + v + <span class="string">&quot;]]&gt;&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTextResponseBody</span><span class="params">(fromUserName, toUserName, content <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">textResponseBody := &amp;TextResponseBody&#123;&#125;</span><br><span class="line">textResponseBody.FromUserName = value2CDATA(fromUserName)</span><br><span class="line">textResponseBody.ToUserName = value2CDATA(toUserName)</span><br><span class="line">textResponseBody.MsgType = value2CDATA(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">textResponseBody.Content = value2CDATA(content)</span><br><span class="line">textResponseBody.CreateTime = time.Duration(time.Now().Unix())</span><br><span class="line"><span class="keyword">return</span> xml.MarshalIndent(textResponseBody, <span class="string">&quot; &quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可别被这些代码吓到呀，其实思路很简单的，只是实现有些繁琐：其实就是开一个web服务，这个服务接收到请求的时候调用 <code>validateWechatRequest</code> 来验证该请求是否发自微信，若验证通过确实是微信，那么就用 <code>parseTextRequestBody</code> 解析这个消息(我们只处理文本消息)，解析出来有些发送用户啊、消息内容啊这些东西，然后就可以用 <code>makeTextResponseBody</code> 构造一个响应返回给微信了。</p><p>从这个 HelloWorld 里，我们可以想到，只要我们根据 <code>parseTextRequestBody</code> 出来的东西处理后传一个合适的 <code>content</code> 给 <code>makeTextResponseBody</code>，就可以实现微信消息的响应了。</p><p>按照这个思路，我们就可以做出一个<strong>通用</strong>的微信公众号服务框架。</p><h5 id="通用微信公众号服务框架"><a href="#通用微信公众号服务框架" class="headerlink" title="通用微信公众号服务框架"></a>通用微信公众号服务框架</h5><p>其实这个服务框架基本就是上面的 HelloWorld 做一个抽象。</p><p>我们不是需要对 <code>parseTextRequestBody</code> 出来的结果做一些处理然后得到要 <code>makeTextResponseBody</code> 的 content 嘛。所以我们要做一些操作，但我们暂时还没有写出这个操作来，所以我们就想：</p><p>“啊～如果这里有一个写好的函数就好了，我们直接调用这个函数，把请求传给它，它就把需要的 content 返回出来”</p><p>这个问题是不是很熟悉，解决方法呼之欲出 —— 和我们写 CourseTicker 的时候一样 —— <strong>接口</strong>！</p><p>来把 helloworld 里的代码改一改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">textRequestBody := parseTextRequestBody(r)</span><br><span class="line"><span class="keyword">if</span> textRequestBody != <span class="literal">nil</span> &#123;</span><br><span class="line">    thisSer := textRequestBody.ToUserName</span><br><span class="line">    reqUser := textRequestBody.FromUserName</span><br><span class="line">    reqContent := textRequestBody.Content</span><br><span class="line"></span><br><span class="line">    respContent := responser.Do(reqUser, reqContent)</span><br><span class="line">    <span class="comment">// 👆上面这行代码有个不知道哪来的 responser</span></span><br><span class="line"></span><br><span class="line">    responseTextBody, err := makeTextResponseBody(thisSer, reqUser, respContent)</span><br><span class="line">    _, err = fmt.Fprint(w, <span class="keyword">string</span>(responseTextBody))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就是这样！我们希望有一个 <code>responser.Do(reqUser, reqContent)</code> ，调用它要返回的响应结果就出来了。所以，我们就写出这样的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Responser <span class="keyword">interface</span> &#123;</span><br><span class="line">Do(reqUser <span class="keyword">string</span>, reqContent <span class="keyword">string</span>) (respContent <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok，除了一个 responser，我们再来想想我们的 Helloworld 里跑起微信服务还需哪些东西。我们还有一个服务token（不是我们写了 holder 的那种 access_token 啊，是验证请求的 token）。</p><p>以 responser 和 token 为属性，helloworld 里那一大堆验证、消息解析/构造函数为私有方法，我们就可以写出微信服务框架“类”了，来看结构图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcooc46z5lj310t0u00yf.jpg" alt="image-20200310113210047"></p><p>哈哈，这个东西也是说起来简单，实现起来一大堆东西挺吓人的。不过，这就是 helloworld 加了个 responser，写成了结构体，你细品。</p><blockquote><p>【勘误】这里有个<code>databaseSource</code>属性，这显然不是一个通用的微信服务框架该有的，微信服务框架本身可不会去读写数据库，数据库操作应该是 Responser 的私事，这是我实现的错误。</p><p>事实上，好像我也没有在除了构造函数的地方使用这个<code>databaseSource</code>，所以它是没用的、应该删除掉的）</p></blockquote><p>我们先不管实现，来看他的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">WxToken := <span class="string">&quot;wwwwwww&quot;</span></span><br><span class="line">responser := NewSomething();</span><br><span class="line">databaseSource := <span class="string">&quot;who:psd@where/database?charset=utf8&quot;</span>;</span><br><span class="line">    </span><br><span class="line">WxSer = wxPlatformServer.New(WxToken, responser, databaseSource)</span><br><span class="line">    </span><br><span class="line">http.HandleFunc(<span class="string">&quot;/wx&quot;</span>, WxSer.Handle)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用起来可以说是很方便的了。</p><h5 id="实现CourseNotifierResponser"><a href="#实现CourseNotifierResponser" class="headerlink" title="实现CourseNotifierResponser"></a>实现CourseNotifierResponser</h5><p>现在，我们来实现一个具体的 Responser。我们的系统叫做 CoruseNotifier，所以这个系统的 Responser 就叫做 <code>CourseNotifierResponser</code> 好了。</p><p>这个<code>CourseNotifierResponser</code>应该要可以接受用户的消息，完成课程提醒的<strong>订阅</strong>、<strong>退订</strong>操作。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcotpt3g8cj30v209a0uh.jpg" alt="image-20200310143818625"></p><p>这个东西还是比较有意思的，我们来看工作流程图（我不擅长画这个，可能表达的不是很清晰）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcow9pl2aqj30rt0dtjsl.jpg" alt="Untitled Diagram-3"></p><p>来解释一下，我们想考虑订阅、退订到底是个什么流程：</p><p><strong>订阅</strong>课表首先是粗略判断用户输入是否合法，然后尝试拿用户的输入登录强智系统，如果登录成功，则返回真实姓名、系、课表以及一个验证码给用户，问他正不正确、要不要办。然后我们就等待用户返回验证码，如果这时接收到一条消息是之前的用户发的，同时内容是刚才那个验证码，就给他写入库，告诉他服务开好了。</p><p><strong>退订</strong>也差不多这个流程：判断 -&gt; 预操作 -&gt; 验证码 -&gt; 写库。</p><p>我把这个操作模式总结成三个方法：Verify、GenerateVerification、Continue。</p><p>还是以订阅为例，在 Verify 中，我们完成登录强智系统，如果登录成功，则返回真实姓名、系、课表的操作，然后返回一个 GenerateVerification 生成的验证码，然后这时，如果<em>接收到一条消息是之前的用户发</em>，然后就调用 Continue 检测验证码是否正确，是则完成数据库操作。</p><p>也就是说我们的操作流程为： <code>Verify() -&gt; return GenerateVerification() -&gt; Continue()</code></p><p>既然订阅和退订的操作类似，我们就把它们相似的地方抽象出来，做成一个“虚拟类”，然后去继承实现它。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcovabfugbj31dw0ev143.jpg" alt="Untitled Diagram"></p><p>这里我们是真的要继承了！用 Go 实现虚拟类继承，我认为比较方便的一种方式是「结构体 + 接口」，我们来实现这样的一个结构体和一个接口作为“父类”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CoursesSerSession <span class="keyword">struct</span> &#123;<span class="comment">// 结构体</span></span><br><span class="line">verification   <span class="keyword">string</span></span><br><span class="line">databaseSource <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CoursesSerSession)</span> <span class="title">GenerateVerification</span><span class="params">()</span></span> &#123;</span><br><span class="line">randI := rand.New(rand.NewSource(time.Now().UnixNano())).Int31n(<span class="number">10000</span>) <span class="comment">// 4位随机数</span></span><br><span class="line">randS4 := fmt.Sprintf(<span class="string">&quot;%04v&quot;</span>, randI)                                   <span class="comment">// 4位随机数字字符串</span></span><br><span class="line">s.verification = randS4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VerifySerSession <span class="keyword">interface</span> &#123;<span class="comment">// 接口</span></span><br><span class="line">GenerateVerification()</span><br><span class="line">Verify() <span class="keyword">string</span><span class="comment">// 虚方法，需要在“子类”中实现</span></span><br><span class="line">Continue(verificationCode <span class="keyword">string</span>) <span class="keyword">string</span><span class="comment">// 虚方法，需要在“子类”中实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去“继承”这个“父类”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CoursesSubscribeSession <span class="keyword">struct</span> &#123;</span><br><span class="line">CoursesSerSession<span class="comment">// 继承结构体，同时也就继承了父类中实现的方法</span></span><br><span class="line"></span><br><span class="line">reqUser    <span class="keyword">string</span></span><br><span class="line">reqContent <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">qzClient     *qzclient.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoursesSubscribeSession</span><span class="params">(reqUser <span class="keyword">string</span>, reqContent <span class="keyword">string</span>, databaseSource <span class="keyword">string</span>)</span> *<span class="title">CoursesSubscribeSession</span></span> &#123;</span><br><span class="line">s := &amp;CoursesSubscribeSession&#123;reqUser: reqUser, reqContent: reqContent&#125;</span><br><span class="line">s.CoursesSerSession.databaseSource = databaseSource<span class="comment">// 初始化父类</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////</span></span><br><span class="line"><span class="comment">// 下面实现接口中的方法 //</span></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify 尝试拿用户请求中的信息登录强智系统，检测是否具有办理订阅课表的资格</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CoursesSubscribeSession)</span> <span class="title">Verify</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 尝试登录强智系统，如果登录成功，则返回真实姓名、系、课表</span></span><br><span class="line">    <span class="comment">// 出错就地返回</span></span><br><span class="line">s.GenerateVerification()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 真实姓名、系、课表 和 验证码，提示用户继续操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Continue 为用户办理课程提醒登记，完成数据库操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CoursesSubscribeSession)</span> <span class="title">Continue</span><span class="params">(verificationCode <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 完成数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退订是类似的，这里就不写了。</p><p>有了这个我们就可以继续实现 CourseNotifierResponser 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CourseNotifierResponser <span class="keyword">struct</span> &#123;</span><br><span class="line">sessionMap     <span class="keyword">map</span>[<span class="keyword">string</span>]VerifySerSession<span class="comment">// 这里是我们的“父类”里的接口</span></span><br><span class="line">databaseSource <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCourseNotifierResponser</span><span class="params">(databaseSource <span class="keyword">string</span>)</span> *<span class="title">CourseNotifierResponser</span></span> &#123;</span><br><span class="line">c := &amp;CourseNotifierResponser&#123;databaseSource: databaseSource&#125;</span><br><span class="line">c.sessionMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]VerifySerSession)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CourseNotifierResponser)</span> <span class="title">Do</span><span class="params">(reqUser <span class="keyword">string</span>, reqContent <span class="keyword">string</span>)</span> <span class="params">(respContent <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> isReqSubscribe(reqContent):</span><br><span class="line">c.sessionMap[reqUser] = NewCoursesSubscribeSession(reqUser, reqContent, c.databaseSource)</span><br><span class="line"><span class="keyword">return</span> c.sessionMap[reqUser].Verify()</span><br><span class="line"><span class="keyword">case</span> isReqUnsubscribe(reqContent):</span><br><span class="line">c.sessionMap[reqUser] = NewCoursesUnsubscribeSession(reqUser, reqContent, c.databaseSource)</span><br><span class="line"><span class="keyword">return</span> c.sessionMap[reqUser].Verify()</span><br><span class="line"><span class="keyword">case</span> isReqVerification(reqContent):</span><br><span class="line"><span class="keyword">if</span> c.sessionMap[reqUser] != <span class="literal">nil</span> &#123;</span><br><span class="line">ret := c.sessionMap[reqUser].Continue(reqContent)</span><br><span class="line">c.sessionMap[reqUser] = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;无法处理的信息&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`欢迎、操作提示`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isReqSubscribe 判断请求是否为**订阅**操作，是则返回 true，否则 false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isReqSubscribe</span><span class="params">(reqContent <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isReqSubscribe 判断请求是否为**退订**操作，是则返回 true，否则 false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isReqUnsubscribe</span><span class="params">(reqContent <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isReqVerification 判断请求是否为**验证码**，是则返回 true，否则 false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isReqVerification</span><span class="params">(reqContent <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不好意思，这一块变量名取太长了，看起来比较吃力。</p><p>总算好了，现在我们把这个系统的所有组件都完成了！我们可以从微信公众号前台服务获取处理用户订阅、退订操作，通过强智Client可以获取、保存课表，然后还有 CourseTicker 完成上课的提醒。</p><p>接下来我们只要把这些东西集成在一起，让他们有分工、有合作地工作起来，整个课程提醒系统就完成了！</p><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>要让这些模块在一起工作，最直接的方式，就是在 main 函数里调用。但是，为了让系统的启动、配置、拓展更为方便，经过考虑，我设计了这样的一个 App “类”：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcowy32x5bj31lt0c64aj.jpg" alt="Untitled Diagram-4"></p><p>实例化这个 App 类后，其中的配置部分——AppConf 可以直接解析 JSON 配置文件获取配置；然后 App 类通过 init 和 run，按照配置文件的信息初始化并启动我们的各个运行组件。</p><p>这样完成一个 App 类之后，我们的 <code>main.go</code> 就可以很简洁了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;example.com/CoursesNotifier/app&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Usage = usage</span><br><span class="line"><span class="comment">// 读取命令行参数</span></span><br><span class="line">confFile := flag.String(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;set configuration `file`&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *confFile == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, <span class="string">&quot;Cannot run without configuration file given.&quot;</span>)</span><br><span class="line">flag.Usage()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化 App</span></span><br><span class="line">coursesNotifier := app.New(*confFile)</span><br><span class="line"><span class="keyword">if</span> err := coursesNotifier.Test(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Println(<span class="string">&quot;Cannot run app with error config.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 运行 App</span></span><br><span class="line">coursesNotifier.Run()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;CoursesNotifier Running...&quot;</span>)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, greet)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:9001&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello World! %s&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usage</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">`</span></span><br><span class="line"><span class="string">CoursesNotifier v0.1.0 for NCEPU(Baoding)</span></span><br><span class="line"><span class="string">All rights reserved (c) 2020 CDFMLR</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage: CoursesNotifier [-c filename]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">flag.PrintDefaults()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 main 完成了从获取命令行参数、初始化并启动app。我想这就是一个 main 函数的意义——程序的入口。</p><p>再来小结一下，这次我们从 main 函数开始，把自己当作这个课程提醒系统，看看自己从被管理员启动开始都在做些什么：</p><ol><li>管理员在服务器上敲下这行命令，启动服务：<code>nohup ./coursesNotifier -c ./config.json &amp;</code></li><li><code>main</code> 函数启动，解析命令行参数，尝试读取配置文件，若不成功，则退出；</li><li>初始化一个 App 对象，把配置文件传给这个 App 对象；</li><li>App 对象拿到配置文件，尝试将其中内容读取到自己的 conf 属性中；</li><li>验证配置是否齐全，若没有问题，则初始化各运行时组件（全局微信access_token Holder，CourseTicker、微信前台服务）；若配置不足，无法启动，则先 main 函数返回错误，进而由 main 退出；</li><li>配置、检测完成，main 函数调用 <code>app.Run()</code>，app 启动 CourseTicker、微信前台服务；</li><li>CourseTicker 定时检查有没有快开始上的课，有则通过微信通知系统通知要上课的学生。</li><li>微信前台服务等待用户发送消息，为用户办理订阅、退订业务。</li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>终于写完了！这篇文章可是花了不少时间的。我不认为有很多人可以看到这里，因为我清楚地知道自己的写作能力有限，可能许多地方都表述地不够清晰，不够吸引人。但是我希望每个看这篇文章的人都有所收获吧。Golang 每年都是程序猿们最想学习的技术之一（这是否意味着大家每年都并没有实际去学它😂），希望我这个东西可以给你学习 Go 增添一点乐趣。</p><p>除了这个系统本身的功能（我现在每天都在用），我自己写这个系统最大的收获是「Go 的面向对象」，我觉得还是很迷人的。Go 不是面向对象的语言，但我们也能用 Go 写出确实能解决问题、甚至还解决地比较优雅的 OOP 代码。</p><p>其实这个系统还有很多需要去完善、改进的地方，如果你感兴趣，欢迎参与这个系统的开发：<a href="https://github.com/cdfmlr/CoursesNotifier">https://github.com/cdfmlr/CoursesNotifier</a>。</p><p>写完这么一个东西，我觉得自己大概勉强可能算是基本完成 Golang 入门了吧。Go 给我的感受还是很好的——我爱用 Go 编程，就像我爱 C 和 Python。</p><p>就这样吧，废话不多说了，还有代码要写呢！</p><p><strong>全文终</strong></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猜测随机数</title>
      <link href="/2020/03/03/School/GuessANumber/"/>
      <url>/2020/03/03/School/GuessANumber/</url>
      
        <content type="html"><![CDATA[<h1 id="猜测随机数"><a href="#猜测随机数" class="headerlink" title="猜测随机数"></a>猜测随机数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcgr2q1foqj31qc0u0wps.jpg" alt="2271583200846_.pic_hd"></p><p>今天这个题目很别致啊。。。</p><h2 id="昔日旧解"><a href="#昔日旧解" class="headerlink" title="昔日旧解"></a>昔日旧解</h2><p>大一的时候写过这个题，翻一下那个时候的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> randNum, usersNum;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//char *tip;// GCC warning: ISO C++ forbids converting a string constant to &#x27;char*&#x27;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> tip;<span class="comment">// 使用C++ 11的string类</span></span><br><span class="line"></span><br><span class="line">srand(time(<span class="literal">NULL</span>));<span class="comment">// 用当前时间作随机数种子</span></span><br><span class="line">randNum = rand() &lt;&lt; <span class="number">2</span> + rand() &lt;&lt; <span class="number">4</span>;<span class="comment">// rand()提供的值在0～RAND_MAX == 32767之间, 通过运算防止每次结果太接近</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(randNum &gt; <span class="number">100</span>)<span class="comment">// 保证randNum的值在0～100</span></span><br><span class="line">randNum /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter a int to guess:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; usersNum;</span><br><span class="line"><span class="keyword">if</span> (usersNum == randNum)&#123;</span><br><span class="line">tip = <span class="string">&quot;You are RIGHT!&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">usersNum &gt; randNum ? tip = <span class="string">&quot;Yours is bigger!&quot;</span> : tip = <span class="string">&quot;Yours is too small!&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Try &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;: &quot;</span>&lt;&lt; tip &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(cnt &lt; <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (cnt &lt;= <span class="number">10</span>)<span class="comment">//当猜中终止循环时，补充break跳过的输出</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Try &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;: &quot;</span>&lt;&lt; tip &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Gussing over!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码好怪，又慢又不安全，还有bug，，不管了，直接编译吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ guess.cc</span></span><br></pre></td></tr></table></figure><p>结果一大堆报错：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcgr7yimr3j31ey0u07wi.jpg" alt="屏幕快照 2020-03-03 15.07.02"></p><p>吓得我满头<del>大汉</del>大汗，定睛一看主要是我写的是 <code>C++11</code>，编译器好像不认识<code>C++11</code>代码……先看一下gcc版本，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[c@My-MacBook:] guess !549 $ g++ --version</span><br><span class="line">Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/4.2.1</span><br><span class="line">Apple clang version 11.0.0 (clang-1100.0.33.12)</span><br><span class="line">Target: x86_64-apple-darwin18.7.0</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</span><br></pre></td></tr></table></figure><p>4.2.1的 gcc，还是 Xcode 的 clang！编译不了 <code>C++11</code> 也就不奇怪了。那我以前是怎么搞的？？？</p><p>我肯定不是用这个呀，翻了好久才翻到了正宗的 <code>GNU GCC</code> ，他原本的 <code>gcc</code> 链接都被 xcode 覆盖了，要 <code>gcc-9</code> 才是他😂</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c@My-MacBook:] guess !551 $ g++-9 --version</span><br><span class="line">g++-9 (Homebrew GCC 9.2.0) 9.2.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>这个就肯定没问题了，编译运行：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcgrhgp86dj31di0u0h8x.jpg" alt="image-20200303151634979"></p><h2 id="正常解决方案"><a href="#正常解决方案" class="headerlink" title="正常解决方案"></a>正常解决方案</h2><p>刚才那个代码有点怪，而且没做异常处理，再好好写一个。</p><p>这段时间都在用 Golang，所以今天写一个大家喜闻乐见的 Python3 版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num = random.randint(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    print(<span class="string">&quot;猜测一个0到100之间的整数.&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> cnt &lt; <span class="number">100</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            inp = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;第 <span class="subst">&#123;cnt&#125;</span> 次猜，请输入一个整形数字: &quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> inp == num:</span><br><span class="line">                print(<span class="string">&quot;恭喜你猜对了，这个数是 %d。&quot;</span> % num)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            print(<span class="string">&quot;太大&quot;</span> <span class="keyword">if</span> inp &gt; num <span class="keyword">else</span> <span class="string">&quot;太小&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(<span class="string">&quot;输入无效，这次不算。&quot;</span>)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;你怕不是个傻子！&quot;</span>)</span><br></pre></td></tr></table></figure><p>顺便提一下，这里我写了平时基本见不到大家写的 <code>f-String</code>。<code>f-String</code> 是 Python 3.6 引入的，更优雅的字符串插值方案，想要了解更多我推荐 <a href="https://realpython.com/python-f-strings/">这篇文章</a>（这个网站挺不错的），当然你也可以直接读 <a href="https://www.python.org/dev/peps/pep-0498/">PEP 498</a> 这是 f-String 的来源。</p><h2 id="一行代码解法"><a href="#一行代码解法" class="headerlink" title="一行代码解法"></a>一行代码解法</h2><p>这个要一行代码解决就麻烦了，但还是值得一试。</p><p>为了方便阅读，先拆成几个部分来写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [x[<span class="number">0</span>], print(<span class="string">&quot;猜中了&quot;</span>) <span class="keyword">if</span> x[<span class="number">3</span>]==x[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span>, exit(<span class="number">0</span>) <span class="keyword">if</span> x[<span class="number">3</span>]==x[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span>, <span class="built_in">int</span>(<span class="built_in">input</span>((<span class="string">&quot;太大&quot;</span> <span class="keyword">if</span> x[<span class="number">3</span>] &gt; x[<span class="number">0</span>] <span class="keyword">else</span> <span class="string">&quot;太小&quot;</span>) + <span class="string">&quot;\n再试一次: &quot;</span>))]</span><br><span class="line"></span><br><span class="line">reduce(d, [[random.randint(<span class="number">0</span>,<span class="number">100</span>), <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>] <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">else</span> [<span class="number">0</span>, <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;你傻了&quot;</span>)</span><br></pre></td></tr></table></figure><p>只是这么做有个小 bug，一开始会输出一个“太小”，这当然也是可以解决的，但会让代码更恶心一点，我们在把代码压缩到一行的同时解决一下它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;你傻了吧&quot;</span> <span class="keyword">if</span> reduce(<span class="keyword">lambda</span> x, y: [x[<span class="number">0</span>], print(<span class="string">&quot;猜中了&quot;</span>) <span class="keyword">if</span> x[<span class="number">3</span>]==x[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span>, exit(<span class="number">0</span>) <span class="keyword">if</span> x[<span class="number">3</span>]==x[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">None</span>, <span class="built_in">int</span>(<span class="built_in">input</span>((<span class="string">&quot;太大&quot;</span> <span class="keyword">if</span> x[<span class="number">3</span>] &gt; x[<span class="number">0</span>] <span class="keyword">else</span> (<span class="string">&quot;太小&quot;</span> <span class="keyword">if</span> x[<span class="number">3</span>]&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;猜测一个0到100之间的整数.&quot;</span>)) + <span class="string">&quot;\n你的猜测: &quot;</span>))], [[random.randint(<span class="number">0</span>,<span class="number">100</span>), <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>] <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">else</span> [<span class="number">0</span>, <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])[-<span class="number">1</span>] &lt; <span class="number">50</span> <span class="keyword">else</span> <span class="string">&quot;你傻了呀&quot;</span>)</span><br></pre></td></tr></table></figure><p>这就完成了一行代码解法，但是这么做就不能判断用户输入是否异常了。还是不推荐写这种代码，看起来看不懂、用起来也有隐患，只是娱乐一下了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Golang if err != nil 泛滥成灾的优化方案</title>
      <link href="/2020/02/27/blog/Golang-if-err-nil-awkward/"/>
      <url>/2020/02/27/blog/Golang-if-err-nil-awkward/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-Golang-if-err-nil-泛滥成灾的优化方案"><a href="#关于-Golang-if-err-nil-泛滥成灾的优化方案" class="headerlink" title="关于 Golang if err != nil 泛滥成灾的优化方案"></a>关于 Golang <code>if err != nil</code> 泛滥成灾的优化方案</h1><p>刚才我尝试用 Golang 写一个项目，其中有一个并不复杂的方法，主要涉及到两次正则匹配和两个字符串读取，然后，我发现这个方法里我写了四段一模一样的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺手搜了一下，发现整个工程里有 78 个 <code>if err != nil</code>，要知道，这是个刚刚起步的工程，总共才差不多2K的代码呀！差不多每二十几行代码就要来一发 <code>if err != nil</code>，，，太可怕了。</p><p>但我尝试在 Google 输入 <code>if err</code> 的时候，我看到了搜索建议里的这行代码，于是尬笑着点开了它，然后发现，这是个新手常犯的尴尬，也有很多种优化方法，所以我当然是选择——抄官方的作业了！</p><p>这是 <a href="https://blog.golang.org/errors-are-values">一篇官方的blog</a> 里介绍的解决 <code>if err != nil</code> 尴尬的方法：</p><p>Lament：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_, err = fd.Write(p0[a:b])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p1[c:d])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p2[e:f])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// and so on</span></span><br></pre></td></tr></table></figure><p>Grace:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">write := <span class="function"><span class="keyword">func</span><span class="params">(buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err = w.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line">write(p0[a:b])</span><br><span class="line">write(p1[c:d])</span><br><span class="line">write(p2[e:f])</span><br><span class="line"><span class="comment">// and so on</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More cleaner:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    w   io.Writer</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ew *errWriter)</span> <span class="title">write</span><span class="params">(buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, ew.err = ew.w.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class="line">ew.write(p0[a:b])</span><br><span class="line">ew.write(p1[c:d])</span><br><span class="line">ew.write(p2[e:f])</span><br><span class="line"><span class="comment">// and so on</span></span><br><span class="line"><span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang SQL 查询使用 LIKE 分句的坑</title>
      <link href="/2020/02/27/blog/Golang-SQL-LIKE-Query/"/>
      <url>/2020/02/27/blog/Golang-SQL-LIKE-Query/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-SQL-查询使用-LIKE-分句的坑"><a href="#Golang-SQL-查询使用-LIKE-分句的坑" class="headerlink" title="Golang SQL 查询使用 LIKE 分句的坑"></a>Golang SQL 查询使用 LIKE 分句的坑</h1><p>我想在 golang 里执行一个涉及到模糊查询的 SQL Query。</p><p>使用 LIKE 分句的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,<span class="type">time</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> <span class="type">time</span> <span class="keyword">LIKE</span> <span class="string">&#x27;4%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后我写了如下 Golang 代码，专门搞了一下 <code>&#39;&#39;</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BUG</span></span><br><span class="line">timeLike := fmt.Sprintf(<span class="string">&quot;&#x27;%d%%&#x27;&quot;</span>, day)</span><br><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT name,time FROM course WHERE time LIKE ?&quot;</span>, timeLike)</span><br></pre></td></tr></table></figure><p>查询出来的是空。</p><p>之后，参考 <a href="https://www.cnblogs.com/huangliang-hb/p/10048666.html%EF%BC%8C%E6%88%91%E5%8F%91%E7%8E%B0%E4%B8%8D%E8%83%BD%E5%86%99">https://www.cnblogs.com/huangliang-hb/p/10048666.html，我发现不能写</a> <code>&#39;&#39;</code>，把这东西去掉就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CORRECT</span></span><br><span class="line">timeLike := fmt.Sprintf(<span class="string">&quot;%d%%&quot;</span>, day)</span><br><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT name,time FROM course time LIKE ?&quot;</span>, timeLike)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P121 买卖股票的最佳时机</title>
      <link href="/2020/02/27/School/Leetcode_P121_BestTimeToBuyAndSellStock/"/>
      <url>/2020/02/27/School/Leetcode_P121_BestTimeToBuyAndSellStock/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P121-买卖股票的最佳时机"><a href="#Leetcode-P121-买卖股票的最佳时机" class="headerlink" title="Leetcode P121 买卖股票的最佳时机"></a>Leetcode P121 买卖股票的最佳时机</h1><p>TODO: 按照给定要领完成文中 TODO。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="某种不知名的野生解法（也许是贪心？）"><a href="#某种不知名的野生解法（也许是贪心？）" class="headerlink" title="某种不知名的野生解法（也许是贪心？）"></a>某种不知名的野生解法（也许是贪心？）</h2><p>TODO：bullshit here。要领：总而言之就是遍历中更新最大值、最小值、极大值、极小值，最后输出最大值减最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt;=<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    lowest := <span class="number">0</span></span><br><span class="line">    highest := <span class="number">0</span></span><br><span class="line">    l := prices[<span class="number">0</span>]</span><br><span class="line">    h := prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, current := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="keyword">if</span> current &lt; l &#123;</span><br><span class="line">            l = current</span><br><span class="line">            h = current</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> current &gt; h &#123;</span><br><span class="line">            h = current</span><br><span class="line">            <span class="keyword">if</span> h - l &gt; highest - lowest &#123;</span><br><span class="line">                highest, lowest = h, l</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> highest - lowest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcanzsukqqj319s0u01kx.jpg" alt="屏幕快照 2020-02-27 08.38.49"></p><p>这个算法只遍历一次数组，所以时间复杂度是 $O(n)$，空间消耗是常数，$O(1)$。</p><h2 id="优化后的不知名的野生算法"><a href="#优化后的不知名的野生算法" class="headerlink" title="优化后的不知名的野生算法"></a>优化后的不知名的野生算法</h2><p>TODO: bullshit +1。要领：pure bullshit。</p><p>这么做效率上区别不大，但代码简洁一些。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt;=<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    lowest := prices[<span class="number">0</span>]</span><br><span class="line">    bestProfit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, current := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="keyword">if</span> current &lt; lowest &#123;</span><br><span class="line">            lowest = current</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> current - lowest &gt; bestProfit &#123;</span><br><span class="line">            bestProfit = current - lowest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcao6m00isj319s0u01kx.jpg" alt="屏幕快照 2020-02-27 08.47.47"></p><h2 id="两行代码解法"><a href="#两行代码解法" class="headerlink" title="两行代码解法"></a>两行代码解法</h2><p>因为它这个题有点恶心，会给个 <code>[]</code> 的测试数据，要判断是否为空，所以一行代码对这种特殊情况不好处理，要写两行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        r = reduce(<span class="keyword">lambda</span> x, y: (<span class="built_in">min</span>(x[<span class="number">0</span>], y[<span class="number">0</span>]), <span class="built_in">max</span>(y[<span class="number">0</span>]-x[<span class="number">0</span>],x[<span class="number">1</span>])), [(i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> prices])[<span class="number">1</span>] <span class="keyword">if</span> prices <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcaosnz1uyj319s0u01kx.jpg" alt="image-20200227091010143"></p><p>TODO: Final bullshit。要领：自己意会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P88 合并两个有序数组</title>
      <link href="/2020/02/26/School/Leetcode_P88_MergeSortedArray/"/>
      <url>/2020/02/26/School/Leetcode_P88_MergeSortedArray/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P88-合并两个有序数组"><a href="#Leetcode-P88-合并两个有序数组" class="headerlink" title="Leetcode P88 合并两个有序数组"></a>Leetcode P88 合并两个有序数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="一行代码解法"><a href="#一行代码解法" class="headerlink" title="一行代码解法"></a>一行代码解法</h2><p>这道题好简单的啊，如果是在现实中遇到，我肯定直接一行代码上了：</p><p>Python3 实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums1[:] = <span class="built_in">sorted</span>(nums1[<span class="number">0</span>:m] + nums2[<span class="number">0</span>:n])</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9w4t8dazj31d90u0hch.jpg" alt="屏幕快照 2020-02-26 16.32.16"></p><p>直接搞了个排序居然还击败了 96% 😂 问题是 python 的 sorted 实现是什么？好像没研究过噢👀</p><p>我去搜了一下，python 的 document 里面好像没写，懒得查源码了，大佬们说那个是 Timsort，是个结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法。。。</p><p>好吧，这就超出咱的认知范围了，有时间再研究了。我们还是接着写这道题的正经解法吧。</p><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>刚才的那个 merge sort 给了我们足够完成这道题的启示啊，这道题要干的就是归并排序里做的那种归并！</p><p>算法的思路大概是这样：由于两个数组都已经排好序了，那么要合成一个数组，就是不断比较两个数组的头部，看哪个头部元素比较小就把它拿到目标数组里的下一个位置。</p><p>e.g. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step1: t&#x3D;[],            n1&#x3D;[1,2,3],  n2&#x3D;[2,5,6] # 1比2小，把1移到t里</span><br><span class="line">step2: t&#x3D;[1],           n1&#x3D;[2,3],    n2&#x3D;[2,5,6] # 2和2一样大啊，随便放一个</span><br><span class="line">step3: t&#x3D;[1,2],         n1&#x3D;[3],      n2&#x3D;[2,5,6] # 2比3小，放2</span><br><span class="line">step4: t&#x3D;[1,2,2],       n1&#x3D;[3],      n2&#x3D;[5,6]   # 3比5小，放3</span><br><span class="line">step5: t&#x3D;[1,2,2,3],     n1&#x3D;[],       n2&#x3D;[5,6]   # n1空了，放n2的</span><br><span class="line">step6: t&#x3D;[1,2,2,3,5],   n1&#x3D;[],       n2&#x3D;[6]     # n1空了，放n2的</span><br><span class="line">step6: t&#x3D;[1,2,2,3,5,6], n1&#x3D;[],       n2&#x3D;[]      # 完成</span><br></pre></td></tr></table></figure><p>这里怎么判断空，有很多种方法，我比较喜欢的一种方法是：在两个数组的末尾都放上一个超级大的元素，要保证它们比所有数据元素都大，这样的话，随便和谁比较，小的都不可能是它们，所以只要规定好目标数组的长度，它们就不会被加到最后的目标数组里。而且这么做还避免了写判断语句，判断在每一次迭代里都要执行，时间消耗很可能大于我们添加大数所用的常数时间。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    nums1Copy := <span class="built_in">make</span>([]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">copy</span>(nums1Copy, nums1)</span><br><span class="line">    nums1Copy[m] = math.MaxInt32</span><br><span class="line">    nums2 = <span class="built_in">append</span>(nums2, math.MaxInt32)</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; m + n; k++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1Copy[i] &lt;= nums2[j] &#123;</span><br><span class="line">            nums1[k] = nums1Copy[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9x8pno43j31ag0u07w5.jpg" alt="屏幕快照 2020-02-26 17.15.34"></p><p>分析一下这个算法：时间复杂度 : $O(n+m)$，空间复杂度 : $O(m)$。</p><h2 id="逆序归并"><a href="#逆序归并" class="headerlink" title="逆序归并"></a>逆序归并</h2><p>在刚才的归并解法中，我们可以观察到，在一开始（迭代之前），需要拷贝 <code>nums1</code> 的有效数据部分，这一步会消耗时间、空间；而 <code>nums1</code> 后面却有着大量的空白空间没有很好的利用起来。</p><p>我们来考虑是否可以把后面的空间利用起来，同时避免数据的拷贝。</p><p>事实上，如果我们<strong>从大到小</strong>逆序去完成归并，就可以达成这两个目的。</p><p>在逆序的归并中，我们依次把两个有序数组中的<strong>较大者</strong>，<strong>从尾到头</strong>放入目标数组。这样，<code>nums1</code> 后面的空白空间就利用起来了，同时，我们还不用拷贝 <code>nums1</code> 的数据部分了（因为题目保证了 <code>nums1</code> 的尾部可以放下整个 <code>nums2</code>，也就不可能出现数据被覆盖的情况了）。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    i, j := m<span class="number">-1</span>, n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> k := m+n<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j--</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">0</span> &#123;</span><br><span class="line">            nums1[k] = nums1[i]</span><br><span class="line">            i--</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &gt;= nums2[j] &#123;</span><br><span class="line">            nums1[k] = nums1[i]</span><br><span class="line">            i--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了另外一种判断数组是否已经到空的方法。</p><p>来看看运行结果：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gca528ctr9j31ag0u01kx.jpg" alt="屏幕快照 2020-02-26 21.43.46"></p><p>在空间上明显有了很大的进步，时间上看不出来区别。事实上，这个算法时间复杂度依然是 $O(n+m)$。空间复杂度降到了 $O(1)$。</p><hr><p>其实，我感觉还可以写的更好一点，但我做了大量的尝试（都是自己感觉可以了，然后提交上去就 runtime error😂）最后发现根本没有提升，最后通过的这个版本的代码巨丑就不放到这里污染环境了。。。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gca74mcylkj30ru0gmjtn.jpg" alt="image-20200226225852251"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P53 最大子序和</title>
      <link href="/2020/02/25/School/Leetcode_P53_maxSubArray/"/>
      <url>/2020/02/25/School/Leetcode_P53_maxSubArray/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P53-最大子序和"><a href="#Leetcode-P53-最大子序和" class="headerlink" title="Leetcode P53 最大子序和"></a>Leetcode P53 最大子序和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>emmm，一看又是动规题。但我不（bu）爱（hui）写动规，每次写动规都要爆炸好久。。。先试试能不能贪心贪出来吧。</p><p>我们来考虑这样的贪心策略：</p><blockquote><p>从头到尾遍历数组，在每一个元素 <code>i</code> 处，贪最大和。</p></blockquote><p>也就是在每次迭代里，一个部分最大和要么是<em>前面的某一部分和</em> + <em>当前元素值</em>，要么是当前元素一个就比前面辛苦积累起来的和大了，那部分最大和就变成当前元素一个人的值了；之后，如果我们新得到的这个部分和比之前的全局的最优解还大，那么全局最优解就变成现在的这个部分和了。</p><p>用代码来表示，即当前部分最大和 <code>part = Max(part + nums[i], nums[i])</code>，以及全局最大和 <code>max = Max(max, part)</code>，这样我们每一步都保证 <code>part</code>、<code>max</code> 都是最优的，完成遍历就得到了全局最优解。</p><p>Golang 实现，首先为了突出贪心策略，我们实现一个辅助的 <code>MaxI()</code> 来返回两个 <code>int</code> 的最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1 (记住这些代码版本的标号呀。本文代码版本比较多，而且有相互比较)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxI</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">part, max := nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">part = MaxI(nums[i], part + nums[i])</span><br><span class="line">max = MaxI(part, max)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om3s4ngj319q0u0hc0.jpg" alt="屏幕快照 2020-02-25 15.15.03"></p><p>Nice，过了，难得有这种懒得动规拿贪心这么简单就贪到的题目。</p><p>再整理一下代码，去掉 <code>MaxI</code>，减少函数调用的消耗：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">part, max := nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        part += nums[i]</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; part &#123;</span><br><span class="line">            part = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> part &gt; max &#123;</span><br><span class="line">            max = part</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om9mpytj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 15.17.46"></p><p>Emmm，不但没有优化，还更差了，不管了，这个是运气问题。</p><p>分析一下这个算法，时间上只遍历了一次数组，$O(n)$；空间上都是常量空间，$O(1)$。应该说这个算法还是不错的。</p><h2 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h2><p>虽然不喜欢，但还是要练习嘛，动规肝起。</p><p>建一个备忘录 <code>memo</code> 来记录各个可能的部分和，最后返回 <code>memo</code> 中最大的就好了。</p><p>这里“各个可能的部分和”，我们采取和刚才贪心类似的思路，记录每一个元素处的最大值。具体来说，我们可以采用这样的方法：看看备忘录 <code>memo</code> 中前面一个元素处的最大值如果这个值是负的了，那当前元素加上它肯定更小了，所以当前最大和就是当前元素本身；如果记录中前面的值是正的，那加上就更大了，所以我们务必把它加上。</p><p>继续 Golang 实现：（Golang 写服务和写题都是很舒服的😌）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V3</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">memo := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">memo[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> memo[i<span class="number">-1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">memo[i] = nums[i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memo[i] = memo[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(memo)</span><br><span class="line"><span class="keyword">return</span> memo[<span class="built_in">len</span>(memo)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8prg5j7dj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 16.06.33"></p><p>。。。我们这里用了一个标准库里的 <code>sort.Ints</code>，它的代码实现是个 quick sort。这居然没有影响速度，空间的影响倒是看出来了。</p><p>（其实这个动规也不难）</p><p>分析一下这个算法，时间主要是一个迭代（$n$）还有一个快排（$n\log n$），合起来是 $O(n\log n)$；空间上，写了一个 $n$ 的备忘录，$O(n)$。</p><p>其实这一个版本的代码里有好几个地方可以优化，第一这个快排完全是可以避免的，用之前贪心时的策略，用一个 <code>max</code> 取记录每一步后的全局最优解:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">memo := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">memo[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">max := nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> memo[i<span class="number">-1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">memo[i] = nums[i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memo[i] = memo[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> memo[i] &gt; max &#123;</span><br><span class="line">max = memo[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不忙跑这个版本，还可以继续优化，再观察代码，我们自始至终只使用了 <code>memo[i-1]</code> 这一个记录值来更新下一个记录值 <code>memo[i]</code>，之前的所有记录都不会用到。既然如此，何不直接用一个 <code>int</code> 变量把之前的数组取代掉，空间就从 $O(n)$ 降到 $O(1)$ 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">memo := nums[<span class="number">0</span>]</span><br><span class="line">max := nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> memo &lt; <span class="number">0</span> &#123;</span><br><span class="line">memo = nums[i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memo += nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> memo &gt; max &#123;</span><br><span class="line">max = memo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8qbpo8axj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 16.30.49"></p><p>这个结果比较好，时间上比之前的所有版本都要快。</p><p>接下来再研究一下能不能搞出分治。，，嗯？？！！等一下！发现一个有意思的东西！</p><p>我们再来观察一下 <code>V5</code> 和 <code>V2</code> 这两个版本的代码，一个是优化后的贪心，一个是优化后的动规。为了方便观察，我们稍微修改一下代码表述（算法、大体框架都不动），然后把它们肩并肩比较一下：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8qmkxcpvj31yi0tm7bl.jpg" alt="屏幕快照 2020-02-25 16.42.05"></p><p>我们会发现，这两个版本的大体框架是一样的，区别在于迭代里的处理。而且，这不一样的代码都是用来这一步当前的最大部分和的！稍微思考一下这两个方法，V5 里如果前面的记录是正的我们才加，负的就不加了；V2 里我们是先加上去试试看，如果加上去变小了就不加了。而我们知道由 $a + b &lt; a$ 可以推出 $b &lt; 0$。也就是说，我们的这两种处理在本质上是一样的！</p><p>哈，一个是优化后的贪心，一个是优化后的动规，从不同的思想出发，居然殊途同归！还是很有意思的。</p><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><del>【16:46】：分治好难的，平时用的也不多，好多东西我都忘了。。。</del></p><p><del>【16:49】: 唉，早知不能回学校就应该把《算法导论》（还有我的琴23333）带回来的，看扫描版的 PDF 好难受啊。😭</del></p><p><del>【17:26】：啊，天呐，我发现我完全忘了，只会归并排序了（归并可能都不能完全流畅手写了），不想做了。</del></p><p><del>【17:39】：我直接看了题解。。。试着自己复述一遍吧。</del></p><hr><p>用类似于二分法的思想啊，最大和子串的所有元素可能在这三个位置：</p><ul><li>全在数组中心左边</li><li>跨过数组中心</li><li>全在数组中心右边</li></ul><p>我们“分治“就是”分“这几种情况了。其中比较特殊的是跨中心的，跨中心的需要从中心左侧和中心右侧分别用贪心，求得跨中心的最大和。</p><p>而非跨中心的情况就分左右去递归嘛，把问题看成只有左边一半、右边一半分别求解。</p><p>我们的递归需要有基础情况，那这个问题中的基础情况就是递归到子串只是单独的一个元素了，那这个元素自己就是这个子序的最大子序了，直接返回它本身。而非基础情况的时候，也就是子串长度&gt;1时，就像刚才说的那样递归下去，继续用上面讨论的三种情况找子串啊。</p><p>递归到头后，返回来时有点像棵树，比较兄弟（左半、右半、跨中 三种情况分别取得的最大和）的值，找到最大的往上返回……这样返回到头问题就解决了。</p><p>（好乱啊，没写代码，边思考边来写思路好怪，其实我还没完全搞懂这个算法是在干什么，不管了，来试一下代码实现，代码出来思路就清晰了。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> getMaxSubArray(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxSubArray</span><span class="params">(nums []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == right &#123;</span><br><span class="line"><span class="keyword">return</span> nums[right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">center := (left + right) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">leftSum := getMaxSubArray(nums, left, center)</span><br><span class="line">crossSum := getCrossSum(nums, left, center, right)</span><br><span class="line">rightSum := getMaxSubArray(nums, center+<span class="number">1</span>, right)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> maxI(leftSum, crossSum, rightSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCrossSum</span><span class="params">(nums []<span class="keyword">int</span>, left, center, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == right &#123;</span><br><span class="line"><span class="keyword">return</span> nums[right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leftSubMaxSum := nums[center]</span><br><span class="line">memo := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := center; i &gt;= left; i-- &#123;</span><br><span class="line">memo += nums[i]</span><br><span class="line"><span class="keyword">if</span> memo &gt;= leftSubMaxSum &#123;</span><br><span class="line">leftSubMaxSum = memo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rightSubMaxSum := nums[center+<span class="number">1</span>]</span><br><span class="line">memo = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := center + <span class="number">1</span>; i &lt;= right; i++ &#123;</span><br><span class="line">memo += nums[i]</span><br><span class="line"><span class="keyword">if</span> memo &gt;= rightSubMaxSum &#123;</span><br><span class="line">rightSubMaxSum = memo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftSubMaxSum + rightSubMaxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxI</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> a &gt;= b &amp;&amp; a &gt;= c:</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">case</span> b &gt;= a &amp;&amp; b &gt;= c:</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9110gn6pj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 22.38.51"></p><p>这样，分治法就过了，其实分治没有之前的那些算法快，这个分治是个 $O(n\log n)$，递归调用也会比较耗时，还有空间消耗也会比较大，因为开递归栈要了 $O(\log n)$，但整个问题解决的比较精妙，代码很漂亮。</p><p>P.S. 我前面写的思路不太清楚，所以补一张图来说明这个算法是在干什么（我思考的时候随手画的，不一定正确，仅供参考）：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc91o1k64ij30u00yegro.jpg" alt="image-20200225230422143"></p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>再补一个暴力解法吧，把这道题主要的几种方法都写全。</p><p>暴力法就是把所有的可能子序都搞出来，比较它们的和，返回最大的。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">maxSubSum := nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt; <span class="built_in">len</span>(nums); l++ &#123;</span><br><span class="line">part := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r := l; r &lt; <span class="built_in">len</span>(nums); r++ &#123;</span><br><span class="line">part += nums[r]</span><br><span class="line"><span class="keyword">if</span> part &gt; maxSubSum &#123;</span><br><span class="line">maxSubSum = part</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxSubSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9ibdwblmj319q0u04qg.jpg" alt="屏幕快照 2020-02-26 08.37.10"></p><h2 id="一行代码的解法"><a href="#一行代码的解法" class="headerlink" title="一行代码的解法"></a>一行代码的解法</h2><p>按照传统，我还是尽力想出一个使用最短代码行数的解法。</p><p>我们首先来看一个两行代码的 Python3 解法：（不算<code>import</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># V8</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums[<span class="number">0</span>] = (nums[<span class="number">0</span>], nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: (<span class="built_in">max</span>(x[<span class="number">0</span>]+y, y), <span class="built_in">max</span>(x[<span class="number">1</span>], x[<span class="number">0</span>]+y, y)), nums)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>其实这就是我们的贪心/动规解法嘛，只是利用了 reduce 来在一行代码里完成所有操作（另一行代码为这一行代码做了必要的准备），我挺喜欢这个解法的，还是很优雅的。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9jkwzn71j319q0u04pc.jpg" alt="屏幕快照 2020-02-26 09.21.26"></p><p>再来把代码减少到一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># V9</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: (<span class="built_in">max</span>(x[<span class="number">0</span>]+y[<span class="number">0</span>], y[<span class="number">0</span>]), <span class="built_in">max</span>(x[<span class="number">1</span>], x[<span class="number">0</span>]+y[<span class="number">0</span>], y[<span class="number">0</span>])), [(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> nums])[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>为了完成一行代码的任务，我们用了一个生成器生成了好多无用的数据，造成了时间、空间的浪费，结果就不太好了：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9k4h6ab8j31d90u01kx.jpg" alt="image-20200226094257065"></p><h2 id="最后的废话"><a href="#最后的废话" class="headerlink" title="最后的废话"></a>最后的废话</h2><p>这一道题，我们写出来 9 个版本的代码，还是很有意思的，从贪心、动规到分治，最后居然还用一行代码解决了它！不同的思考角度出发，我们写出过几乎相同的代码；用相同的思想去实现，我们又写出了不同的程序……这或许就是编程的魅力吧。我不喜欢编程，但编程的这种魅力深深地吸引着我，为我指引着未来或许没有希望的方向。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 基本使用</title>
      <link href="/2020/02/20/blog/SQL_CRUD/"/>
      <url>/2020/02/20/blog/SQL_CRUD/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-基本使用"><a href="#SQL-基本使用" class="headerlink" title="SQL 基本使用"></a>SQL 基本使用</h1><p>最近半年多一直都是用 MongoDB，好久没 SQL 了。</p><p>这学期有个数据库课，，上了几节课了，还没看过课本😂，但想来后面肯定是学 SQL，要复习一下了。</p><p>所以想在下一个项目里用用 SQL，所以先来复习一下基本的 SQL CRUD。</p><h2 id="SQL-基本概念"><a href="#SQL-基本概念" class="headerlink" title="SQL 基本概念"></a>SQL 基本概念</h2><p>SQL：Structured Query Language，结构化查询语言，访问和处理数据库用的。</p><p>SQL 有这几种能力：</p><ul><li><strong>DDL</strong>：Data Definition Language，定义数据的：建表、删表、修改表结构的；</li><li><strong>DQL</strong>：Data Query Language，查询数据的；</li><li><strong>DML</strong>：Data Manipulation Language，修改数据的：添加、删除、更新数据的；</li></ul><h2 id="SQL-语法特点"><a href="#SQL-语法特点" class="headerlink" title="SQL 语法特点"></a>SQL 语法特点</h2><ul><li><p>语句末要写分号</p></li><li><p>关键字不区分大小写；</p><p>表名、列名、(可能)区分大小写。</p><p>一般情况下，我们可以把 SQL 关键字大写，表名、列名等使用小写。</p></li><li><p>文本字段用单引号包裹（e.g. <code>&#39;String&#39;</code>），数值字段不能加引号。</p></li></ul><h2 id="SQL-数据类型"><a href="#SQL-数据类型" class="headerlink" title="SQL 数据类型"></a>SQL 数据类型</h2><table><thead><tr><th align="left">名称</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">INT</td><td align="left">整型</td><td align="left">4字节整数类型，范围约+/-21亿</td></tr><tr><td align="left">BIGINT</td><td align="left">长整型</td><td align="left">8字节整数类型，范围约+/-922亿亿</td></tr><tr><td align="left">REAL</td><td align="left">浮点型</td><td align="left">4字节浮点数，范围约+/-1038</td></tr><tr><td align="left">DOUBLE</td><td align="left">浮点型</td><td align="left">8字节浮点数，范围约+/-10308</td></tr><tr><td align="left">DECIMAL(M,N)</td><td align="left">高精度小数</td><td align="left">由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td align="left">CHAR(N)</td><td align="left">定长字符串</td><td align="left">存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td align="left">VARCHAR(N)</td><td align="left">变长字符串</td><td align="left">存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td align="left">BOOLEAN</td><td align="left">布尔类型</td><td align="left">存储True或者False</td></tr><tr><td align="left">DATE</td><td align="left">日期类型</td><td align="left">存储日期，例如，2018-06-22</td></tr><tr><td align="left">TIME</td><td align="left">时间类型</td><td align="left">存储时间，例如，12:20:59</td></tr><tr><td align="left">DATETIME</td><td align="left">日期和时间类型</td><td align="left">存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><h2 id="SQL-基本语句"><a href="#SQL-基本语句" class="headerlink" title="SQL 基本语句"></a>SQL 基本语句</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><h5 id="CREATE"><a href="#CREATE" class="headerlink" title="- CREATE"></a>- CREATE</h5><blockquote><p><code>CREATE DATABASE</code> 用来建数据库。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name;</span><br></pre></td></tr></table></figure><h5 id="DROP"><a href="#DROP" class="headerlink" title="- DROP"></a>- DROP</h5><blockquote><p><code>DROP DATABASE</code> 用来删库。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE database_name;</span><br></pre></td></tr></table></figure><h5 id="USE"><a href="#USE" class="headerlink" title="- USE"></a>- USE</h5><blockquote><p><code>USE</code> 用来选择要操作的数据库。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE database_name;</span><br></pre></td></tr></table></figure><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><h5 id="CREATE-1"><a href="#CREATE-1" class="headerlink" title="- CREATE"></a>- CREATE</h5><blockquote><p><code>CREATE TABLE</code> 创建数据表。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] table_name (</span><br><span class="line">    &#96;column_name&#96; column_type,</span><br><span class="line">    &#96;column_name&#96; column_type,</span><br><span class="line">    ...,</span><br><span class="line">    PRIMARY KEY ( &#96;key_column_name&#96; )</span><br><span class="line">)[ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8];</span><br></pre></td></tr></table></figure><p>注：<code>[]</code>里的是可选的。</p><h5 id="DROP-1"><a href="#DROP-1" class="headerlink" title="- DROP"></a>- DROP</h5><blockquote><p><code>DROP TABLE</code> 用来删除表。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><blockquote><p> <code>SELECT</code> 语句用于从数据库中选取数据。</p></blockquote><p>SELECT 从数据库中选取字段，把结构放到一个结果表中，成为结果集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><blockquote><p><code>SELECT DISTINCT</code> 语句用于返回列里唯一不同的值</p></blockquote><p>SELECT DISTINCT 是把所选列去重输出，给你看这一列里有多少种不同情况的，如果查询的是多列会输出每一种不同组合。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>比如一张放了全国人名的表，<code>SELECT DISTINCT sex FROM people</code> 会输出 <code>男</code>，<code>女</code> 两项）</p><p>再举个🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM userinfo;</span><br><span class="line">+-----+----------+-------------+------------+</span><br><span class="line">| uid | username | department  | created    |</span><br><span class="line">+-----+----------+-------------+------------+</span><br><span class="line">|   2 | Foo      | Bar         | 2020-02-20 |</span><br><span class="line">|   3 | Fuzz     | Bar         | 2020-02-09 |</span><br><span class="line">|   4 | Joe      | Development | 2020-02-02 |</span><br><span class="line">|   5 | Ann      | Development | 2020-02-20 |</span><br><span class="line">+-----+----------+-------------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT DISTINCT department FROM userinfo;</span><br><span class="line">+-------------+</span><br><span class="line">| department  |</span><br><span class="line">+-------------+</span><br><span class="line">| Bar         |</span><br><span class="line">| Development |</span><br><span class="line">+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT DISTINCT department,created FROM userinfo;</span><br><span class="line">+-------------+------------+</span><br><span class="line">| department  | created    |</span><br><span class="line">+-------------+------------+</span><br><span class="line">| Bar         | 2020-02-20 |</span><br><span class="line">| Bar         | 2020-02-09 |</span><br><span class="line">| Development | 2020-02-02 |</span><br><span class="line">| Development | 2020-02-20 |</span><br><span class="line">+-------------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><blockquote><p><code>WHERE</code> 子句用于过滤记录，提取满足指定条件的记录。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>operator 运算符有以下几种：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于。<strong>注释：</strong>在 SQL 的一些版本中，该操作符可被写成 !=</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">BETWEEN</td><td align="left">在某个范围内</td></tr><tr><td align="left">LIKE</td><td align="left">搜索某种模式</td></tr><tr><td align="left">IN</td><td align="left">指定针对某个列的多个可能值</td></tr></tbody></table><p>栗子🌰（还是上面那个例子的表）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> department<span class="operator">=</span><span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> uid <span class="operator">|</span> username <span class="operator">|</span> department <span class="operator">|</span> created    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span> Foo      <span class="operator">|</span> Bar        <span class="operator">|</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span> Fuzz     <span class="operator">|</span> Bar        <span class="operator">|</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-09</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="AND-amp-OR"><a href="#AND-amp-OR" class="headerlink" title="AND &amp; OR"></a>AND &amp; OR</h4><blockquote><p><code>AND</code> &amp; <code>OR</code> 运算符用于基于一个以上的条件对记录进行过滤（用在 WHERE 里）。</p></blockquote><p>e.g.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> department<span class="operator">=</span><span class="string">&#x27;Bar&#x27;</span> <span class="keyword">AND</span> created<span class="operator">=</span><span class="string">&#x27;2020-02-20&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> uid <span class="operator">|</span> username <span class="operator">|</span> department <span class="operator">|</span> created    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span> Foo      <span class="operator">|</span> Bar        <span class="operator">|</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> department<span class="operator">=</span><span class="string">&#x27;Bar&#x27;</span> <span class="keyword">OR</span> created<span class="operator">=</span><span class="string">&#x27;2020-02-20&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> uid <span class="operator">|</span> username <span class="operator">|</span> department  <span class="operator">|</span> created    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span> Foo      <span class="operator">|</span> Bar         <span class="operator">|</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span> Fuzz     <span class="operator">|</span> Bar         <span class="operator">|</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-09</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span> Ann      <span class="operator">|</span> Development <span class="operator">|</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+-------------+------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><blockquote><p><code>ORDER BY</code> 用于对结果集进行排序。</p></blockquote><p>ORDER BY 默认按照<strong>升序</strong>(ASC)对记录进行排序。降序要使用 <code>DESC</code> 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name,column_name <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><blockquote><p><code>LIMIT</code> 或 <code>ROWNUM</code> 或 <code>TOP</code> 用于规定要返回的记录的数目。</p></blockquote><p>TOP、LIMIT、ROWNUM 是不同家的数据库里不同的写法。</p><ul><li><p><code>LIMIT</code>：MySQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT number;</span><br></pre></td></tr></table></figure></li><li><p><code>ROWNUM</code>：Oracle</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> number;</span><br></pre></td></tr></table></figure></li><li><p><code>TOP</code>：SQL Server，Access</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP number<span class="operator">|</span><span class="keyword">percent</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3></li></ul><h4 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h4><blockquote><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>或不指定要插入数据的列名，需要列出插入行的每一列数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> userinfo (username, department, created) <span class="keyword">VALUES</span> (<span class="string">&#x27;WhoKnown&#x27;</span>,<span class="string">&#x27;Market&#x27;</span>,<span class="string">&#x27;2001-10-12&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> created <span class="operator">&lt;</span> <span class="string">&#x27;2020-01-01&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> uid <span class="operator">|</span> username <span class="operator">|</span> department <span class="operator">|</span> created    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">6</span> <span class="operator">|</span> WhoKnown <span class="operator">|</span> Market     <span class="operator">|</span> <span class="number">2001</span><span class="number">-10</span><span class="number">-12</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><blockquote><p><code>UPDATE</code> 语句用于更新表中已存在的记录。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><p>如果没写 WHERE，表示更新<strong>所有记录</strong>。</p><p>e.g.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> userinfo </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> uid<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> created <span class="operator">&lt;</span> <span class="string">&#x27;2020-01-01&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> uid <span class="operator">|</span> username <span class="operator">|</span> department <span class="operator">|</span> created    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">6</span> <span class="operator">|</span> Jack     <span class="operator">|</span> Market     <span class="operator">|</span> <span class="number">2001</span><span class="number">-10</span><span class="number">-12</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+----------+------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><blockquote><p><code>DELETE</code> 用于删除表中的记录。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><p>⚠️注意，漏写 WHERE 就<strong>删除所有记录</strong>了（不如 <code>sudo rm -rf /*</code> 得劲🤪）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P27 移除元素</title>
      <link href="/2020/02/20/School/Leetcode_P27_RemoveElement/"/>
      <url>/2020/02/20/School/Leetcode_P27_RemoveElement/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P27-移除元素"><a href="#Leetcode-P27-移除元素" class="headerlink" title="Leetcode P27 移除元素"></a>Leetcode P27 移除元素</h1><p>还是作业题，leetcode 简单题+1。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>emmmm，这个题基本和昨天做的 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">leetcode P26 删除排序数组中的重复项</a> 一模一样，直接套用那个题的方法就好了，具体算法见昨上一篇文章。</p><p>双指针法，Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    t := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != val &#123;</span><br><span class="line">            t++</span><br><span class="line">            nums[t] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc2olfvu1uj30mc05kmxz.jpg" alt="屏幕快照 2020-02-20 10.57.43"></p><p>好的，0ms、2.1MB，击败 100%、99.78%，已经是最优了。</p><p>但看了一下题解，还有其他方法，学习了：</p><h2 id="双指针-——-动态数组长度"><a href="#双指针-——-动态数组长度" class="headerlink" title="双指针 —— 动态数组长度"></a>双指针 —— 动态数组长度</h2><p>这个优化的思路是这样啊，因为从数组里移除特定的元素，这个元素一般比较少嘛，但我们需要为此完整遍历整个数组，不太划算。</p><p>既然题目不要求排序，所以我们考虑不把待删除的用下一个不相等的覆盖，而是用数组末尾元素覆盖，这样就不用遍历到原来最后一个哪里了，相当于把元素后面的不确定是否要删的提到前面来、把明确要删的扔到后面。这样就相当于干掉了一个长度，减少了一次迭代嘛。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">            nums[i] = nums[l - <span class="number">1</span>]</span><br><span class="line">            l--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的结果和我们的上一个版本也差不多，<del>内存排名还下去了一些</del>。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc2p2ppnccj30lk05ct9i.jpg" alt="image-20200220111518525"></p><h2 id="一行代码解法"><a href="#一行代码解法" class="headerlink" title="一行代码解法"></a>一行代码解法</h2><p>既然优化不了了，就试点好玩的嘛，这个问题也有只用一行代码的解法。</p><p>方法是利用函数式编程的 <code>filter</code> 来把等于要删除的那个值的元素直接全部过滤掉。</p><p>Python3 实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums[:] = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x != val, nums)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc2q35ak4nj30ni056aaw.jpg" alt="image-20200220115019134"></p><p>当然，在 Python 中，还有另一种写法，用列表生成器完成过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums[:] = [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x != val]</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc2v9wfloqj30nq05egmh.jpg" alt="image-20200220144948410"></p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P26 删除排序数组中的重复项</title>
      <link href="/2020/02/19/School/Leetcode_P26_RemoveDuplicatesFromSortedArray/"/>
      <url>/2020/02/19/School/Leetcode_P26_RemoveDuplicatesFromSortedArray/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-P26-删除排序数组中的重复项"><a href="#Leetcode-P26-删除排序数组中的重复项" class="headerlink" title="Leetcode P26 删除排序数组中的重复项"></a>Leetcode P26 删除排序数组中的重复项</h1><p>还是写学校作业，依然是 leetcode 简单题。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。</p><p><strong>示例 1</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="一行代码的解法"><a href="#一行代码的解法" class="headerlink" title="一行代码的解法"></a>一行代码的解法</h2><p>这个问题很！简！单！就是过滤重复项嘛，这个问题在生活中很常见，我一般是用 <code>Set</code> 保证元素不重复的性质来解决这个问题的，具体实现是把列表转成集合再转回来就完成了。但这个题目还要要求排序，<code>Set</code> 不一定能保证有序性，那就再套一个排序好了。</p><p>虽然这个方法在时间、空间上消耗都不小，但代码十分简洁，emmmm，再利用合适的语言 + 一小点奇技淫巧，大概就一行代码：</p><p>Python3 解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums[:] = <span class="built_in">sorted</span>(<span class="built_in">set</span>(nums))</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :248 ms, 在所有 Python3 提交中击败了11.22%的用户</p><p>内存消耗 :30.7 MB, 在所有 Python3 提交中击败了5.05%的用户</p></blockquote><p>😂</p><p>但是这种方法有个小问题，在 Golang 里没有 <code>Set</code> 怎么办？用类似的思想，哈希表可以保证键唯一，把 <code>nums</code> 里的值做 key，全放入一个 <code>map</code> 里，迭代出来再排序也就完了。</p><hr><p>以上纯属娱乐，下面开始正解：</p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>因为题目给的数组是已经排好序的，所以某一元素要么等于其前面一个元素，要么大于前面一个元素。</p><p>对某一元素，若等于前一元素，则说明改项重复，即需要“删除”。</p><p>我们不容易从数组中直接“删除”一个元素，但可以考虑用其他合适的元素来覆盖它。在这个问题中， 我们可以用一个不重复的元素来覆盖掉一个重复的元素。</p><p>所以，我们算法的思路就是：用指针 <code>i</code> 遍历数组，维护指针 <code>t</code> 保证 <code>t</code> 前的数组不重复，若 <code>i</code> 遍历到的元素不在 <code>t</code> 前的不重复部分（由于已经排序，也就是 <code>elementAt(i) != elementAt(t)</code> ），则将其加入（即用它覆盖 <code>t</code> 后一个元素，并且 <code>t</code> 自增 1）。</p><p>具体的实现上，，，emmm，我不想写了，直接抄一下题解吧。（难得自己的算法几乎和题解<strong>一摸一样</strong>）</p><blockquote><p>数组完成排序后，我们可以放置两个指针 <code>i</code> 和 <code>j</code>，其中 <code>i</code> 是慢指针，而 <code>j</code> 是快指针。只要 <code>nums[i]=nums[j]</code>，我们就增加 <code>j</code> 以跳过重复项。当我们遇到 <code>nums[j] != nums[i]</code> 时，跳过重复项的运行已经结束，因此我们必须把它（<code>nums[j]</code>）的值复制到 <code>nums[i+1]</code>。然后递增 <code>i</code>，接着我们将再次重复相同的过程，直到 <code>j</code> 到达数组的末尾为止。</p><p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line">    t := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[t] &#123;</span><br><span class="line">            t++</span><br><span class="line">            nums[t] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :8 ms, 在所有 Go 提交中击败了93.95%的用户</p><p>内存消耗 :4.6 MB, 在所有 Go 提交中击败了62.06%的用户</p></blockquote><hr><p>吐槽一句，我不认为我写的比这没有缩进的丑陋 0 ms 的写的差！</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc21h8o0kqj31to0n479r.jpg" alt="image-20200219213850376"></p><p>唯一的区别就是我把长度为 1 的也直接返回了，一个元素肯定也不重复嘛！但就多一个 <code>len()</code> 的调用我不认为可以把时间拉慢这么多，事实上，我把我的代码改成和他一模一样的依然是 8 ms。</p><p>还有在时间上，我跑了好几次，有的时候是 4.5 MB 击败 100%，有的时候是 4.6 MB 击败 62.06%。咱也不知道这个运气问题要怎么解决🤷‍♂️。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode P1 两数之和</title>
      <link href="/2020/02/18/School/Leetcode_P1_TwoSum/"/>
      <url>/2020/02/18/School/Leetcode_P1_TwoSum/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>Emmmm，写一篇学校作业。</p><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>这是 Leetcode 的第一题，最简单的题，其实没什么好写的，最简单的方法，暴力求解直接上，遍历两次数组，找到就返回。</p><p>曾经写的 C++ 代码（我刚开始刷题的时候写的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(&#123;i, j&#125;)</span></span>;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间 $O(n^2)$，空间 $O(1)$。通过用了 200ms，9.2MB。时间上只战胜了29.63%。。。</p><p>Emmmm，毕竟是很长时间之前写的了，不能责备过去的自己，但是这个成绩实在看不下去了，重新写一个吧。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>稍微考虑一下上面的暴力解法，我们做了这样的一件事：遍历数组，找有没有和当前元素对应的补，找到就返回当前元素和他的补的索引，没找到就继续。</p><p>内部的那个循环就是用来找 <code>nums</code> 中有没有一个 <code>nums[i]</code> 的补，即等于 <code>target - nums[i]</code> 的元素。</p><p>既然是要从一堆东西里快速找一个明确的，那就上哈希表嘛。空间复杂度加个 $n$，换来时间上减个 $n$，就这个问题来说还行吧。</p><p>Golang 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    numsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        cmpl := target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> v, ok := numsMap[cmpl]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;v, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numsMap[nums[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就勉强看得过去了，时间 $O(n)$，空间 $O(n)$。通过用了 4ms、3.8MB。时间上战胜了 96.76%、空间是 44.82%，，，还行。</p><hr><p>哈，看了一眼官方题解，上述两个解法刚好是题解的第一个方法和最后一个方法。</p><p>其实我写哈希表的时候差点写成了官方题解的<em>方法二</em>，先构建一张完整的表再找符合的两数，后来发现它这个题目说：</p><blockquote><p>每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><p>先构建一张表出来我跑了一下执行会有重复😂，key已经有了的时候，会更新值嘛，碰到输入 <code>[1, 1, 1], target=2</code>，这种就会返回 <code>[2, 2]</code>，炸了。</p><p>要避免这个问题，可以像题解里方法二那种。但还可以更好，就有点类似与动规那种感觉嘛，放一个 for 里迭代，有了返回，没有再更新表就好了——实现就是上面写的第二版本代码。</p><h2 id="最短代码解法（Just-for-fun）"><a href="#最短代码解法（Just-for-fun）" class="headerlink" title="最短代码解法（Just for fun）"></a>最短代码解法（Just for fun）</h2><p>既然是 leetcode 的第一道题，我觉得我们应该可以用更少的代码来完成它。</p><p>虽然不想 <a href="https://blog.csdn.net/u012419550/article/details/104402182">P26</a>、<a href="https://blog.csdn.net/u012419550/article/details/104411279">P27</a> 那种可以直接一行代码解决，但我想到了一个比较有趣的 4 行代码的 Python3 解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cis = [nums.index(c) <span class="keyword">for</span> c <span class="keyword">in</span> nums <span class="keyword">if</span> c == target - v]</span><br><span class="line">            <span class="keyword">if</span> cis <span class="keyword">and</span> cis[-<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> i:</span><br><span class="line">                <span class="keyword">return</span> [i, cis[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>行用时 :4972 ms, 在所有 Python3 提交中击败了17.35%的用户</p><p>内存消耗 :29.6 MB, 在所有 Python3 提交中击败了5.04%的用户</p></blockquote><p>你可能说用你用 Python 搞一个暴力解法也是 4 行代码，但是，我觉得用列表生成器更可爱😕。</p>]]></content>
      
      
      
        <tags>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么？导致我leetcode超时的不是算法是并发？</title>
      <link href="/2020/02/15/blog/goroutines_cause_leetcode_timeout/"/>
      <url>/2020/02/15/blog/goroutines_cause_leetcode_timeout/</url>
      
        <content type="html"><![CDATA[<h1 id="什么？导致我leetcode超时的不是算法是并发？"><a href="#什么？导致我leetcode超时的不是算法是并发？" class="headerlink" title="什么？导致我leetcode超时的不是算法是并发？"></a>什么？导致我leetcode超时的不是算法是并发？</h1><p>（我写这篇文章真的只是为了<strong>打发时间</strong>，内容严重<em>逻辑不清</em>，既<em>不易懂</em>也<em>不深入</em>，我不认为这篇文章具有阅读价值，所以看到这里就可以<strong>把它关掉</strong>了！）</p><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>Emmmm，我很久很久（快半年了吧）没有刷过题了，昨天晚上无聊就打开了 leetcode 随便写了一道题：</p><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>emmmm，首先的想法是<strong>动规</strong>，我一般都不爱用动规，空间消耗大。做了那么久开发再回来看算法，就觉得，时间稍微慢点可以等，内存一满就彻底炸了。</p><p>然后，我想到了最长公共子串，把这个字符串和它的反串求一个最长公共子串就是最长回文子串了。。。最长公共子串又是动规。😠</p><p>不想用动规，又不齿于暴力，那就硬写吧。</p><p>我的思路是遍历一次字符串，尝试以每个字符为回文中心，尽量去往两边“拓展”，得到以每个字符为中心的最长回文串，取这些拓展得的回文串中最长的输出。</p><p>我这个思路时间应该也许大概是 $O(n^2)$ 吧（颓废到连这个都不会算了😭）；空间可能比较好，都是调整指针的值，$O(1)$ 吧。</p><p>然后，我准备开始写代码，突然意识到回文有两！种！情！况！</p><ul><li>第一种，形如 <code>aba</code>，中心是一个字符 <code>b</code>；</li><li>第二种，形如 <code>abba</code>，中心在两个字符 <code>b</code> 之间，或者也可以看作中心是两个字符 <code>bb</code></li></ul><p>所以，遍历字符串时，每个迭代要拓展两次，一次是以当前字符为中心（<code>aba</code> 型），一次是以当前字符+后一个字符为中心（<code>abba</code> 型）。</p><p>Golang 实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">l, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">laba := ext(b, i, i)</span><br><span class="line">labba := ext(b, i, i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> laba &gt; labba &#123;</span><br><span class="line">m = laba</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m = labba</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> m &gt; r-l+<span class="number">1</span> &#123;</span><br><span class="line">l = i - (m<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">r = i + m/<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b[l : r+<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ext</span><span class="params">(b []<span class="keyword">byte</span>, l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> l &gt;= <span class="number">0</span> &amp;&amp; r &lt; <span class="built_in">len</span>(b) &amp;&amp; b[l] == b[r] &#123;</span><br><span class="line">l--</span><br><span class="line">r++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r - l - <span class="number">1</span> <span class="comment">// r - l + 1 - 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交跑一下，4ms（击败91.02%），2.3MB（击败49.75%）。</p><p>emmm，我不理解为什么空间占用这么高，传参到时候 Golang 里的 <code>[]byte</code> 应该是传了引用呀（可以理解成也就是传指针），其他的基本都是 <code>int</code> 了，我暂时想不到好办法继续在空间上做优化。</p><p>所以我考虑了一下能不能在时间上更进一步。考虑这一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">laba := ext(b, i, i)</span><br><span class="line">labba := ext(b, i, i+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>就是分别计算 <code>aba</code> 型和 <code>abba</code> 型的回文拓展。先算完一个，再算另一个，我想这里会比较耗时。如果让他们同时算会发生什么？</p><p>试试看，主要的改动就是开两个 goroutine 去执行这两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ext</span><span class="params">(b []<span class="keyword">byte</span>, l, r <span class="keyword">int</span>, cl <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> l &gt;= <span class="number">0</span> &amp;&amp; r &lt; <span class="built_in">len</span>(b) &amp;&amp; b[l] == b[r] &#123;</span><br><span class="line">l--;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line">cl &lt;- r - l <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">b := []<span class="keyword">byte</span>(s )</span><br><span class="line">l, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        </span><br><span class="line">cl1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">cl2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> ext(b, i, i, cl1)</span><br><span class="line"><span class="keyword">go</span> ext(b, i, i+<span class="number">1</span>, cl2)</span><br><span class="line"></span><br><span class="line">laba := &lt;- cl1</span><br><span class="line">labba := &lt;- cl2</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> laba &gt; labba &#123;</span><br><span class="line">m = laba</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m = labba</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> m &gt; r - l + <span class="number">1</span> &#123;</span><br><span class="line">l = i - (m - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">r = i + m / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b[l: r + <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交，😱😱😱，40ms，6.2MB，发生了什么？</p><p>我以为问题出在这里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">laba := &lt;- cl1</span><br><span class="line">labba := &lt;- cl2</span><br></pre></td></tr></table></figure><p>这里是先阻塞在 <code>laba</code> 这里等 <code>cl1</code> 传出来，然后再等 <code>cl2</code> 出来。万一 <code>cl2</code> 先算完出来了，还是要阻塞到 <code>cl1</code> 出来，可能这里耗时了。所以再改一下 <code>longestPalindrome</code>的策略，用一个 <code>for-select</code>：</p><p><code>select</code> 不能 <code>fallthrough</code>，所以为了及时 break，减少一次阻塞把每个 <code>case</code> 里都写了退出判断，恶心了一点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">b := []<span class="keyword">byte</span>(s )</span><br><span class="line">l, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line"><span class="comment">// laba := ext(b, i, i)</span></span><br><span class="line"><span class="comment">// labba := ext(b, i, i+1)</span></span><br><span class="line">cl1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">cl2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> ext(b, i, i, cl1)</span><br><span class="line"><span class="keyword">go</span> ext(b, i, i+<span class="number">1</span>, cl2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> laba <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> labba <span class="keyword">int</span></span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">LOOP:<span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> laba = &lt;- cl1:</span><br><span class="line">cnt++</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> labba = &lt;- cl2:</span><br><span class="line">cnt++</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> laba &gt; labba &#123;</span><br><span class="line">m = laba</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m = labba</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> m &gt; r - l + <span class="number">1</span> &#123;</span><br><span class="line">l = i - (m - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">r = i + m / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b[l: r + <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再提交，应该会快一点吧，结果是——<strong>超。出。时。间。限。制</strong>。而且超的还很多，只过了22个测试用例。</p><p>我哭了，并发了不是应该更快吗？是 leetcode 的锅吧。</p><p>还是在本地测试一下吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">&quot;babad&quot;</span>, <span class="string">&quot;cbbd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aaaa&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">longestPalindrome(s[i%<span class="number">7</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随便搞几个例子循环着跑10000次，<code>$ time go run</code> 看一下。</p><p>第一个版本（不并发）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real    0m0.246s</span><br><span class="line">user    0m0.216s</span><br><span class="line">sys     0m0.137s</span><br></pre></td></tr></table></figure><p>最后一个版本（<code>for-select</code>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real    0m1.005s</span><br><span class="line">user    0m1.036s</span><br><span class="line">sys     0m0.518s</span><br></pre></td></tr></table></figure><p>\拍桌 还真的是并发导致了慢啊！</p><p>但是，为什么？</p><h2 id="问题的分析"><a href="#问题的分析" class="headerlink" title="问题的分析"></a>问题的分析</h2><p>为了研究这个问题，我们把刚才三个版本的代码都简化一下：</p><p>v1，不并发：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">somethingCost</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">foo := somethingCost()</span><br><span class="line">bar := somethingCost()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == bar &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2，并发，阻塞在第一个 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">somethingCost</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> somethingCost(ch1)</span><br><span class="line"><span class="keyword">go</span> somethingCost(ch2)</span><br><span class="line"></span><br><span class="line">foo := &lt;-ch1</span><br><span class="line">bar := &lt;-ch2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == bar &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v3，运用 <code>select</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v3.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">somethingCost</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> somethingCost(ch1)</span><br><span class="line"><span class="keyword">go</span> somethingCost(ch2)</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">cnt++</span><br><span class="line"><span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">cnt++</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> cnt &gt;= <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先在 <code>somethingCost</code> 里睡眠了相同的时间，来模拟执行一个慢速任务，运行代码得到类似如下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ time go run v1.go</span><br><span class="line"></span><br><span class="line">real    0m0.553s</span><br><span class="line">user    0m0.204s</span><br><span class="line">sys     0m0.159s</span><br><span class="line"></span><br><span class="line">$ time go run v2.go</span><br><span class="line"></span><br><span class="line">real    0m0.379s</span><br><span class="line">user    0m0.182s</span><br><span class="line">sys     0m0.135s</span><br><span class="line"></span><br><span class="line">$ time go run v3.go</span><br><span class="line"></span><br><span class="line">real    0m0.362s</span><br><span class="line">user    0m0.314s</span><br><span class="line">sys     0m0.138s</span><br></pre></td></tr></table></figure><blockquote><p>【补充】real时间、user时间和sys时间。</p><ul><li>real时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。</li><li>user时间是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。</li><li>sys时间是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。</li></ul><p>参考： Linux命令大全. time命令[OL].<a href="https://man.linuxde.net/time">https://man.linuxde.net/time</a>, 2020</p></blockquote><p>用<strong>物理实验</strong>的方法，多次重复实验，得到如下结果：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbx40vkouzj30u00xxtd1.jpg" alt="屏幕快照 2020-02-15 15.18.22"></p><p> <img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbx415ayr5j30tu0yo78f.jpg" alt="屏幕快照 2020-02-15 15.18.33"></p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbx419iuzqj30tw0ysq77.jpg" alt="屏幕快照 2020-02-15 15.18.40"></p><blockquote><p>【注】实验环境：</p><ul><li><p>Computer: MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports)</p></li><li><p>CPU: 2.3 GHz Intel Core i5</p></li><li><p>RAM: 8 GB 2133 MHz LPDDR3</p></li><li><p>OS: macOS Mojave 10.14.6</p></li><li><p>Golang: go version go1.12 darwin/amd64</p></li></ul></blockquote><p>实验次数少，数据不太好，不管了，我懒得搞大规模的实验（其实我只是边研究边写这篇文章打发时间）。</p><p>从实验的结果来看，有两点比较肯定：</p><ol><li>Real 时间上，v3 略优于 v2 优于 v1</li><li>User 时间上，v1 约等于 v2 优于 v3</li></ol><p>由此，可以推知：</p><ol><li>在现实环境（正常的多核计算机）使用中，如 v3 版本的程序，使用 <code>goroutine-for-select</code> 的方案可以运行得比较快（real time，与不并发相比），但在等待返回的 channel 不多时与不使用 <code>for-select</code> 区别不大。</li><li>在 goroutine 和 channel 比较少的时候使用 <code>for-select</code> 的策略，进程所花费的时间（user time）会明显加大。</li></ol><p>注意，是在 goroutine 和 channel 比较少的时候 v2 的 user time 优于 v3。当我们增多 goroutine，比如开到 1000 个，结果就不一样了（我不想用 v1 依次执行1000次函数，结果可想而知，没有可比性了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ time <span class="keyword">go</span> run v2.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">real</span>    <span class="number">0</span>m5<span class="number">.824</span>s</span><br><span class="line">user    <span class="number">0</span>m8<span class="number">.036</span>s</span><br><span class="line">sys     <span class="number">0</span>m3<span class="number">.967</span>s</span><br><span class="line"></span><br><span class="line">$ time <span class="keyword">go</span> run v3.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">real</span>    <span class="number">0</span>m1<span class="number">.919</span>s</span><br><span class="line">user    <span class="number">0</span>m3<span class="number">.006</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.244</span>s</span><br></pre></td></tr></table></figure><p>所以，在慢速任务比较多的时候，使用类似于 v3 的 <code>for-select</code> 会大幅度提高效率。</p><p>我们再来看一下如果任务速度比较快，例如我们直接把 Sleep 注释掉，然后开最外层的循环次加到100次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ time go run v1.go</span><br><span class="line"></span><br><span class="line">real    0m0.302s</span><br><span class="line">user    0m0.168s</span><br><span class="line">sys     0m0.127s</span><br><span class="line"></span><br><span class="line">$ time go run v2.go</span><br><span class="line"></span><br><span class="line">real    0m0.373s</span><br><span class="line">user    0m0.198s</span><br><span class="line">sys     0m0.149s</span><br><span class="line"></span><br><span class="line">$ time go run v3.go</span><br><span class="line"></span><br><span class="line">real    0m0.353s</span><br><span class="line">user    0m0.301s</span><br><span class="line">sys     0m0.142s</span><br></pre></td></tr></table></figure><p>这种情况下 v2、 v3 就显得没有优势了，这时多线程上下午切换等等的开支会造成比较大的额外开支，导致整体运行效率低下。这也就是我们提交到 leetcode 的代码超时的问题所在。</p><h2 id="问题的总结"><a href="#问题的总结" class="headerlink" title="问题的总结"></a>问题的总结</h2><p>这个故事告诉我们，不要在需要并发的任务少，通信不复杂的情况下（比如刷 leetcode 的算法题）尝试使用处理高并发的手段，异步的方法还是用来处理比较慢的任务比较好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang-并发</title>
      <link href="/2020/02/07/Golang/go-5-Concurrency/"/>
      <url>/2020/02/07/Golang/go-5-Concurrency/</url>
      
        <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h3><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure><p>会启动一个新的 Go 程并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></table></figure><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href="https://golang.org/pkg/sync/"><code>sync</code></a> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一节）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    &#x2F;&#x2F; 将 v 发送至信道 ch。</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收值并赋予 v。</span><br></pre></td></tr></table></figure><p>（“箭头”就是数据流的方向。）</p><p>和映射与切片一样，信道在使用前必须创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br></pre></td></tr></table></figure><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int, 100)</span><br></pre></td></tr></table></figure><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><p>修改示例填满缓冲区，然后看看会发生什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧跟 <code>ch &lt;- 2</code> 加一行 <code>ch &lt;- 3</code> 会抛出 <code>fatal error: all goroutines are asleep - deadlock!</code>。</p><h3 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h3><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok :&#x3D; &lt;-ch</span><br></pre></td></tr></table></figure><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p><p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。如果一直不关闭信道，for range 这里会出现 <code>fatal error: all goroutines are asleep - deadlock!</code>。</p><p><strong>注意</strong>： 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p><p><strong>还要注意</strong>： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br></pre></td></tr></table></figure><h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p><p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><h4 id="默认选择"><a href="#默认选择" class="headerlink" title="默认选择"></a>默认选择</h4><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p><p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">&quot;tick.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-boom:</span><br><span class="line">fmt.Println(<span class="string">&quot;BOOM!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;    .&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">BOOM!</span><br></pre></td></tr></table></figure><h3 id="练习：等价二叉查找树"><a href="#练习：等价二叉查找树" class="headerlink" title="练习：等价二叉查找树"></a>练习：等价二叉查找树</h3><p>不同二叉树的叶节点上可以保存相同的值序列。例如，以下两个二叉树都保存了序列 <code>1，1，2，3，5，8，13</code>。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbo70c7fd7j30dn0513ym.jpg" alt="img"></p><p>在大多数语言中，检查两个二叉树是否保存了相同序列的函数都相当复杂。 我们将使用 Go 的并发和信道来编写一个简单的解法。</p><p>本例使用了 <code>tree</code> 包，它定义了类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Tree struct &#123;</span><br><span class="line">    Left  *Tree</span><br><span class="line">    Value int</span><br><span class="line">    Right *Tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO：</p><p><strong>1.</strong> 实现 <code>Walk</code> 函数。</p><p><strong>2.</strong> 测试 <code>Walk</code> 函数。</p><p>函数 <code>tree.New(k)</code> 用于构造一个随机结构的已排序二叉查找树，它保存了值 <code>k</code>, <code>2k</code>, <code>3k</code>, …, <code>10k</code>。</p><p>创建一个新的信道 <code>ch</code> 并且对其进行步进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go Walk(tree.New(1), ch)</span><br></pre></td></tr></table></figure><p>然后从信道中读取并打印 10 个值。应当是数字 <code>1, 2, 3, ..., 10</code>。</p><p><strong>3.</strong> 用 <code>Walk</code> 实现 <code>Same</code> 函数来检测 <code>t1</code> 和 <code>t2</code> 是否存储了相同的值。</p><p><strong>4.</strong> 测试 <code>Same</code> 函数。</p><p><code>Same(tree.New(1), tree.New(1))</code> 应当返回 <code>true</code>，而 <code>Same(tree.New(1), tree.New(2))</code> 应当返回 <code>false</code>。</p><p><code>Tree</code> 的文档可在<a href="https://godoc.org/golang.org/x/tour/tree#Tree">这里</a>找到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;./tree&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Note: 不能 go Walk “递归”！</span></span><br><span class="line">Walk(t.Left, ch)</span><br><span class="line">ch &lt;- t.Value</span><br><span class="line">Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(t1, c1)</span><br><span class="line"><span class="keyword">go</span> Walk(t2, c2)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> &lt;-c1 != &lt;-c2 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testWalk()</span><br><span class="line">testSame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testWalk</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(tree.New(<span class="number">1</span>), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c); i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSame</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">1</span>)))</span><br><span class="line">fmt.Println(Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>P.S. 把树的节点数增加到10000000，在同一机器上，执行同样的testSame函数，可以看到使用 go程，比不使用要快上一些（我的不使用go程的实现是把信道改为用<code>*[]int</code>传递数据）：</p><p>使用Go程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real1m4.306s</span><br><span class="line">user1m20.332s</span><br><span class="line">sys0m1.277s</span><br></pre></td></tr></table></figure><p>不使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real1m7.141s</span><br><span class="line">user1m24.107s</span><br><span class="line">sys0m1.851s</span><br></pre></td></tr></table></figure><h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p><p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这里涉及的概念叫做 <em>互斥</em>（mutual exclusion），我们通常使用 <em>互斥锁</em>（Mutex）这一数据结构来提供这种机制。</p><p>Go 标准库中提供了 <a href="https://golang.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code></li></ul><p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见下例 <code>Inc</code> 方法。</p><p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见下例 <code>Value</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h3 id="练习：Web-爬虫"><a href="#练习：Web-爬虫" class="headerlink" title="练习：Web 爬虫"></a>练习：Web 爬虫</h3><p>在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。</p><p>修改 <code>Crawl</code> 函数来并行地抓取 URL，并且保证不重复。</p><p><em>提示</em>：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。</span></span><br><span class="line">Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SafeCrawler <span class="keyword">struct</span> &#123;</span><br><span class="line">fetched <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">mux     sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCrawler)</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.fetched[url] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.fetched[url] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">body, urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line"><span class="keyword">if</span> !c.fetched[u] &#123;</span><br><span class="line"><span class="keyword">go</span> c.Crawl(u, depth<span class="number">-1</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCrawler&#123;fetched: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">c.Crawl(<span class="string">&quot;https://golang.org/&quot;</span>, <span class="number">4</span>, fetcher)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="comment">// fmt.Println(c.fetched)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher 是返回若干结果的 Fetcher。</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher 是填充后的 fakeFetcher。</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">found: https:&#x2F;&#x2F;golang.org&#x2F; &quot;The Go Programming Language&quot;</span><br><span class="line">not found: https:&#x2F;&#x2F;golang.org&#x2F;cmd&#x2F;</span><br><span class="line">found: https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F; &quot;Packages&quot;</span><br><span class="line">found: https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F;os&#x2F; &quot;Package os&quot;</span><br><span class="line">found: https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F;fmt&#x2F; &quot;Package fmt&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-方法和接口</title>
      <link href="/2020/02/07/Golang/go-4-MethodsInterfaces/"/>
      <url>/2020/02/07/Golang/go-4-MethodsInterfaces/</url>
      
        <content type="html"><![CDATA[<h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go 没有类。不过你可以为结构体类型定义方法。</p><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p><h4 id="方法即函数"><a href="#方法即函数" class="headerlink" title="方法即函数"></a>方法即函数</h4><p>记住：方法只是个带接收者参数的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>这个例子中 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化。</p><h4 id="方法（续）"><a href="#方法（续）" class="headerlink" title="方法（续）"></a>方法（续）</h4><p>你也可以为非结构体类型声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">MyFloat</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -f</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.4142135623730951</span><br></pre></td></tr></table></figure><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p><p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法。</p><p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为其他包中声明的类型声明方法。）</p><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>你可以为指针接收者声明方法。</p><p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code>这样的指针。）</p><p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p><p>试着移除第 16 行 <code>Scale</code> 函数声明中的 <code>*</code>，观察此程序的行为如何变化。</p><p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p><h4 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h4><p>现在我们要把 <code>Abs</code> 和 <code>Scale</code> 方法重写为函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><p>同样，我们先试着移除掉第 16 行 <code>Scale</code> 函数声明中的 <code>*</code>。尝试编译，会得到 <code>./src.go:23:8: cannot use &amp;v (type *Vertex) as type Vertex in argument to Scale</code>，按照提示，我们再把 <code>main</code> 函数中 <code>Scale</code> 函数的调用里的 <code>&amp;v</code> 改成 <code>v</code>，再尝试编译，通过了，输出结果为 <code>5</code>。</p><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X *= f</span><br><span class="line">v.Y *= f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X *= f</span><br><span class="line">v.Y *= f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">2</span>)</span><br><span class="line">ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">p.Scale(<span class="number">3</span>)</span><br><span class="line">ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(v, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;60 80&#125; &amp;&#123;96 72&#125;</span><br></pre></td></tr></table></figure><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// 编译错误！</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</p><h4 id="方法与指针重定向（续）"><a href="#方法与指针重定向（续）" class="headerlink" title="方法与指针重定向（续）"></a>方法与指针重定向（续）</h4><p>同样的事情也发生在相反的方向。</p><p>接受一个值作为参数的函数必须接受一个指定类型的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  <span class="comment">// OK</span></span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) <span class="comment">// 编译错误！</span></span><br></pre></td></tr></table></figure><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">fmt.Println(v.Abs()) <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsFunc</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(p.Abs())</span><br><span class="line">fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><p>使用指针接收者的原因有二：</p><ol><li><p>方法能够修改其接收者指向的值。</p></li><li><p>这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">v.Scale(<span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;After scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before scaling: &amp;&#123;X:3 Y:4&#125;, Abs: 5</span><br><span class="line">After scaling: &amp;&#123;X:15 Y:20&#125;, Abs: 25</span><br></pre></td></tr></table></figure><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几节中明白为什么。）</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p><p>接口类型的变量可以保存任何实现了这些方法的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line"><span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 示例代码的 22 行存在一个错误。由于 <code>Abs</code> 方法只为 <code>*Vertex</code> （指针类型）定义，因此 <code>Vertex</code>（值类型）并未实现 <code>Abser</code>。</p><p>将第22行注释后，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="接口是隐式实现的"><a href="#接口是隐式实现的" class="headerlink" title="接口是隐式实现的"></a>接口是隐式实现的</h4><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p><p>隐式接口将接口的定义与其实现分离，这样随后的接口实现可以出现在任何包中，而无需提前准备。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>接口也是值。它们可以像其它值一样传递。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, type)</span><br></pre></td></tr></table></figure><p>接口值保存了一个具体底层类型的具体值。</p><p>接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = F(math.Pi)</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&amp;&#123;Hello&#125;, *main.T)</span><br><span class="line">Hello</span><br><span class="line">(3.141592653589793, main.F)</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure><h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line"></span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&lt;nil&gt;, *main.T)</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">(&amp;&#123;hello&#125;, *main.T)</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p><p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p><h4 id="nil-接口值"><a href="#nil-接口值" class="headerlink" title="nil 接口值"></a>nil 接口值</h4><p>nil 接口值既不保存值也不保存具体类型。</p><p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(&lt;nil&gt;, &lt;nil&gt;)</span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code&#x3D;0x1 addr&#x3D;0x0 pc&#x3D;0x1093e31]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">&#x2F;a-tour-of-go&#x2F;Nil-interface-values&#x2F;src.go:12 +0x91</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;</span><br></pre></td></tr></table></figure><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;nil&gt;, &lt;nil&gt;)</span><br><span class="line">(42, int)</span><br><span class="line">(hello, string)</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t :&#x3D; i.(T)</span><br></pre></td></tr></table></figure><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个 panic。</p><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok :&#x3D; i.(T)</span><br></pre></td></tr></table></figure><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p><p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p><p>请注意这种语法和读取一个映射时的相同之处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="keyword">float64</span>) <span class="comment">// panic</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello true</span><br><span class="line">0 false</span><br><span class="line">panic: interface conversion: interface &#123;&#125; is string, not float64</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">&#x2F;go-tour&#x2F;Type-assertions&#x2F;src.go:17 +0x1f7</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p><strong>类型选择</strong>(Type switches)是一种按顺序从几个类型断言中选择分支的结构。</p><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch v :&#x3D; i.(type) &#123;</span><br><span class="line">case T:</span><br><span class="line">    &#x2F;&#x2F; v 的类型为 T</span><br><span class="line">case S:</span><br><span class="line">    &#x2F;&#x2F; v 的类型为 S</span><br><span class="line">default:</span><br><span class="line">    &#x2F;&#x2F; 没有匹配，v 与 i 的类型相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Twice 21 is 42</span><br><span class="line">&quot;hello&quot; is 5 bytes long</span><br><span class="line">I don&#39;t know about type bool!</span><br></pre></td></tr></table></figure><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Foo&quot;</span>, <span class="number">12</span>&#125;</span><br><span class="line">b := Person&#123;<span class="string">&quot;Buzz&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo (12 years) Buzz (23 years)</span><br></pre></td></tr></table></figure><h5 id="练习：Stringer"><a href="#练习：Stringer" class="headerlink" title="练习：Stringer"></a>练习：Stringer</h5><p>通过让 <code>IPAddr</code> 类型实现 <code>fmt.Stringer</code> 来打印点号分隔的地址。</p><p>例如，<code>IPAddr&#123;1, 2, 3, 4&#125;</code> 应当打印为 <code>&quot;1.2.3.4&quot;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i IPAddr)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v.%v.%v.%v&quot;</span>, i[<span class="number">0</span>], i[<span class="number">1</span>], i[<span class="number">2</span>], i[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hosts := <span class="keyword">map</span>[<span class="keyword">string</span>]IPAddr&#123;</span><br><span class="line"><span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line"><span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会看看值是否满足 <code>error</code> 接口。）</p><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err :&#x3D; strconv.Atoi(&quot;42&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">When time.Time</span><br><span class="line">What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>, e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">time.Now(),</span><br><span class="line"><span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at 2020-02-07 17:26:08.694498 +0800 CST m&#x3D;+0.000541141, it didn&#39;t work</span><br></pre></td></tr></table></figure><h5 id="练习：错误"><a href="#练习：错误" class="headerlink" title="练习：错误"></a>练习：错误</h5><p>从<a href="https://tour.golang.org/flowcontrol/8">之前的练习</a>中复制 <code>Sqrt</code> 函数，修改它使其返回 <code>error</code> 值。</p><p><code>Sqrt</code> 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。</p><p>创建一个新的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ErrNegativeSqrt float64</span><br></pre></td></tr></table></figure><p>并为其实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (e ErrNegativeSqrt) Error() string</span><br></pre></td></tr></table></figure><p>方法使其拥有 <code>error</code> 值，通过 <code>ErrNegativeSqrt(-2).Error()</code> 调用该方法应返回 <code>&quot;cannot Sqrt negative number: -2&quot;</code>。</p><p><strong>注意:</strong> 在 <code>Error</code> 方法内调用 <code>fmt.Sprint(e)</code> 会让程序陷入死循环。可以通过先转换 <code>e</code>来避免这个问题：<code>fmt.Sprint(float64(e))</code>。这是为什么呢？</p><p>修改 <code>Sqrt</code> 函数，使其接受一个负数时，返回 <code>ErrNegativeSqrt</code> 值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt&#123;x&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">struct</span> &#123;</span><br><span class="line">val<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Error Negative Sqrt of %v&quot;</span>, e.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float64</span> = <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> res, err := Sqrt(a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Sqrt(&quot;</span>, a, <span class="string">&quot;) is &quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Negative Sqrt of -1</span><br></pre></td></tr></table></figure><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p><p>Go 标准库包含了该接口的<a href="https://golang.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p><p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p><p>示例代码创建了一个 <a href="https://golang.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n=%v err=%v b=%v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n]=%q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n&#x3D;8 err&#x3D;&lt;nil&gt; b&#x3D;[72 101 108 108 111 44 32 82]</span><br><span class="line">b[:n]&#x3D;&quot;Hello, R&quot;</span><br><span class="line">n&#x3D;6 err&#x3D;&lt;nil&gt; b&#x3D;[101 97 100 101 114 33 32 82]</span><br><span class="line">b[:n]&#x3D;&quot;eader!&quot;</span><br><span class="line">n&#x3D;0 err&#x3D;EOF b&#x3D;[101 97 100 101 114 33 32 82]</span><br><span class="line">b[:n]&#x3D;&quot;&quot;</span><br></pre></td></tr></table></figure><h5 id="练习：Reader"><a href="#练习：Reader" class="headerlink" title="练习：Reader"></a>练习：Reader</h5><p>实现一个 <code>Reader</code> 类型，它产生一个 ASCII 字符 <code>&#39;A&#39;</code> 的无限流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./reader&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyReader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">b[i] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习：rot13Reader"><a href="#练习：rot13Reader" class="headerlink" title="练习：rot13Reader"></a>练习：rot13Reader</h5><p>有种常见的模式是一个 <a href="https://go-zh.org/pkg/io/#Reader"><code>io.Reader</code></a> 包装另一个 <code>io.Reader</code>，然后通过某种方式修改其数据流。</p><p>例如，<a href="https://go-zh.org/pkg/compress/gzip/#NewReader"><code>gzip.NewReader</code></a> 函数接受一个 <code>io.Reader</code>（已压缩的数据流）并返回一个同样实现了 <code>io.Reader</code> 的 <code>*gzip.Reader</code>（解压后的数据流）。</p><p>编写一个实现了 <code>io.Reader</code> 并从另一个 <code>io.Reader</code> 中读取数据的 <code>rot13Reader</code>，通过应用 <a href="http://en.wikipedia.org/wiki/ROT13">rot13</a> 代换密码对数据流进行修改。</p><p><code>rot13Reader</code> 类型已经提供。实现 <code>Read</code> 方法以满足 <code>io.Reader</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">bt := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">_, erra := a.r.Read(bt)</span><br><span class="line"><span class="keyword">if</span> erra != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i, erra</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> (bt[<span class="number">0</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; bt[<span class="number">0</span>] &lt;= <span class="string">&#x27;M&#x27;</span>) || (bt[<span class="number">0</span>] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; bt[<span class="number">0</span>] &lt;= <span class="string">&#x27;m&#x27;</span>):</span><br><span class="line">b[i] = bt[<span class="number">0</span>] + <span class="number">13</span></span><br><span class="line"><span class="keyword">case</span> (bt[<span class="number">0</span>] &gt;= <span class="string">&#x27;N&#x27;</span> &amp;&amp; bt[<span class="number">0</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>) || (bt[<span class="number">0</span>] &gt;= <span class="string">&#x27;n&#x27;</span> &amp;&amp; bt[<span class="number">0</span>] &lt;= <span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">b[i] = bt[<span class="number">0</span>] - <span class="number">13</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">b[i] = bt[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := strings.NewReader(<span class="string">&quot;Lbh penpxrq gur pbqr!&quot;</span>)</span><br><span class="line">r := rot13Reader&#123;s&#125;</span><br><span class="line">io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You cracked the code!</span><br></pre></td></tr></table></figure><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><a href="https://golang.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="keyword">int</span>) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a href="https://golang.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p><p>（请参阅<a href="https://golang.org/pkg/image/#Image">文档</a>了解全部信息。）</p><p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a href="https://golang.org/pkg/image/color/"><code>image/color</code></a>包定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;image&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">fmt.Println(m.Bounds())</span><br><span class="line">fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0,0)-(100,100)</span><br><span class="line">0 0 0 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 掠影</title>
      <link href="/2020/01/28/blog/a-swift-tour-cn-md/"/>
      <url>/2020/01/28/blog/a-swift-tour-cn-md/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift-掠影"><a href="#Swift-掠影" class="headerlink" title="Swift 掠影"></a>Swift 掠影</h1><blockquote><p>本文翻译自 Swift 官网的 <a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html#">A Swift Tour</a> (Swift 5.1)。</p></blockquote><p>按照传统，学习一门新的编程语言时，我们写的第一个程序应该是在屏幕上打印出“Hello, world!”。在 Swift 中，只要一行代码就可以完成这个仪式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure><p>如果你写过 C 或者 Objective-C，一定会觉得 Swift 的语法很亲切。在 Swift 中，这一行代码就是一个完整的程序了。你不必导入任何库就可以完成输入输出以及字符串处理。在全局作用域中写的代码就是程序的入口点，所以你不在需要写 <code>main</code> 函数了。在每一个语句的末尾，也不用写分号。</p><p>本文会提供足够多的信息让你可以开始用 Swift 写代码，我们会为你展现如何用 Swift 完成各种编程任务。如果你有地方没有理解，请不要担心，这里介绍的所有东西在本书后续的章节中都有详尽的讨论。</p><blockquote><p>【注】</p><p>为获得最好的体验，你可以在 Xcode 中打开该节的 playground。Playground 让你可以编辑这里的代码并及时看到运行的结果。</p><p><a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.playground.zip">下载 Playground</a></p></blockquote><h2 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h2><p>Swift 用 <code>let</code> 声明常量，用 <code>var</code> 声明变量。虽然常量的值在变异的过程中是不需要知道的，但你必须在声明时立刻为其赋值。这意味着你可以用常量来命名一个你决定好不在改变、需要在多处使用的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable <span class="operator">=</span> <span class="number">42</span></span><br><span class="line">myVariable <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> myConstant <span class="operator">=</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><p>常量或变量会拥有与你期望赋给它的值相同的类型，但你不必每次都指明类型，在创建变量或常量时，提供一个值就可以让编译器自动推断它的类型。在上面的例子中，编译器会推测 <code>myVariable</code> 是一个整数，因为赋给它的初值是一个整数。</p><p>如果通过初值不能提供足够的信息（或不打算赋初值），你可以自己指明类型，在变量名后面写上类型，用冒号隔开即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> implicitInteger <span class="operator">=</span> <span class="number">70</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble <span class="operator">=</span> <span class="number">70.0</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> <span class="operator">=</span> <span class="number">70</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>创建一个常量，显式地指明类型为 <code>Float</code>，值为 <code>4</code>。</p></blockquote><p>一个值永远不会被隐式转化为其他类型的。如果你需要把某个值转换成其他类型的，需要显式地创建一个目标类型实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="string">&quot;The width is &quot;</span></span><br><span class="line"><span class="keyword">let</span> width <span class="operator">=</span> <span class="number">94</span></span><br><span class="line"><span class="keyword">let</span> widthLabel <span class="operator">=</span> label <span class="operator">+</span> <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>尝试在上面代码的最后一把到 <code>String</code> 的转化删除，看看会发生什么？</p></blockquote><p>Swift 中，有一个简单的办法让你在字符串中包含一些值：在小括号里写上需要的值，并在括号前面加一个反斜杠（<code>\</code>），例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary <span class="operator">=</span> <span class="string">&quot;I have <span class="subst">\(apples)</span> apples.&quot;</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary <span class="operator">=</span> <span class="string">&quot;I have <span class="subst">\(apples <span class="operator">+</span> oranges)</span> pieces of fruit.&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>在一个字符串中使用 <code>\()</code> 去包含一个浮点数计算，再包含某人的名字来和他打个招呼。</p></blockquote><p>用三个双引号（<code>&quot;&quot;&quot;</code>）可以写多行的字符串。其中每行前面的、对齐结束引号的缩进会被自动移除。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">I said &quot;I have <span class="subst">\(apples)</span> apples.&quot;</span></span><br><span class="line"><span class="string">And then I said &quot;I have <span class="subst">\(apples <span class="operator">+</span> oranges)</span> pieces of fruit.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>用方括号（<code>[]</code>）可以创建数组或字典。通过在方括号中写索引或键，可以取出其中元素。在最后一个元素后面加个逗号也是被允许的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;catfish&quot;</span>, <span class="string">&quot;water&quot;</span>, <span class="string">&quot;tulips&quot;</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] <span class="operator">=</span> <span class="string">&quot;bottle of water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> occupations <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Malcolm&quot;</span>: <span class="string">&quot;Captain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Kaylee&quot;</span>: <span class="string">&quot;Mechanic&quot;</span>,</span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">&quot;Jayne&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Public Relations&quot;</span></span><br></pre></td></tr></table></figure><p>当添加元素时，数组会自动增长：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.append(<span class="string">&quot;blue paint&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(shoppingList)</span><br></pre></td></tr></table></figure><p>如果要创建空数组或字典，需要使用构造器语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Float</span>]()</span><br></pre></td></tr></table></figure><p>如果类型可以被推断出来，那你就可以把空数组写成 <code>[]</code>，把空字典写成 <code>[:]</code>——例如，当你给变量设置新的值，或给函数传参数的时候就可以这么做。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList <span class="operator">=</span> []</span><br><span class="line">occupations <span class="operator">=</span> [:]</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>用 <code>if</code> 和 <code>switch</code> 来写条件语句，用 <code>for-in</code>、<code>while</code> 和 <code>repeat-while</code> 来写迭代语句。条件或循环变量前后的小括号是可选的，循环/条件主体前后的大括号是必须的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> individualScores <span class="operator">=</span> [<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> teamScore <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">    <span class="keyword">if</span> score <span class="operator">&gt;</span> <span class="number">50</span> &#123;</span><br><span class="line">        teamScore <span class="operator">+=</span> <span class="number">3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        teamScore <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(teamScore)</span><br><span class="line"><span class="comment">// Prints &quot;11&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>if</code> 语句中，条件必须是值为布尔型的表达式——这意味着类似于 <code>if score &#123;...&#125;</code> 这样的代码是错误的，其他类型的值不会自动转化为布尔值。</p><p>你可以使用 <code>if</code> 和 <code>let</code> 配合工作，来处理可能缺失的值。这些值使用可选项表示。一个可选的值要么是一个明确的值，要么是 <code>nil</code> 来代表该值缺失。在值的类型后面加一个问号（ <code>?</code>）来表示该值可选。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(optionalString <span class="operator">==</span> <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// Prints &quot;false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> optionalName &#123;</span><br><span class="line">    greeting <span class="operator">=</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>将上述代码中的 <code>optionalName</code> 值改为 <code>nil</code>，看看你会得到什么。加一个 <code>else</code> 情况来当 <code>optionalName</code> 为 <code>nil</code> 时为问候设置一个默认值。</p></blockquote><p>如果可选值为 <code>nil</code>，则条件为 <code>false</code>，在大括号中的代码会被跳过。否则，可选值会把其代表的值赋给 <code>let</code> 后面的常量，这样这个值就可以在大括号里使用了。</p><p>另一种对可选值的处理是使用 <code>??</code> 运算符来提供默认值。利用这种方法，一旦可选值缺失，则默认值就会替代它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nickName: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting <span class="operator">=</span> <span class="string">&quot;Hi <span class="subst">\(nickName <span class="operator">??</span> fullName)</span>&quot;</span></span><br></pre></td></tr></table></figure><p><code>switch</code> 语句可以接受任何类型的数据以及多样的比较运算——不局限于整数和测试相等：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable <span class="operator">=</span> <span class="string">&quot;red pepper&quot;</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;celery&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Add some raisins and make ants on a log.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;cucumber&quot;</span>, <span class="string">&quot;watercress&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That would make a good tea sandwich.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">&quot;pepper&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Is it a spicy <span class="subst">\(x)</span>?&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Everything tastes good in soup.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Is it a spicy red pepper?&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>尝试移除 <code>default</code> 选项，看看会得到什么错误。</p></blockquote><p>注意 <code>let</code> 可以使匹配某个模式的值赋给一个常量。</p><p>在 <code>switch</code> 语句中，执行了匹配的 <code>case</code> 情况后，程序会自动退出 <code>switch</code> 语句，而不会继续执行下一个 <code>case</code> 的代码。所以，不必在每个 <code>case</code> 的代码结尾写 <code>break</code>。</p><p>用 <code>for-in</code> 来迭代字典中的元素，提供一对名字来取用每一个 key-value 对。字典是无序集合，所以键值对会以随机顺序进行迭代。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Prime&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">&quot;Fibonacci&quot;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&quot;Square&quot;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number <span class="operator">&gt;</span> largest &#123;</span><br><span class="line">            largest <span class="operator">=</span> number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest)</span><br><span class="line"><span class="comment">// Prints &quot;25&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>添加一个变量来记录哪一类数最大、最大的数是多少。</p></blockquote><p>用 <code>while</code> 重复一块代码，直到条件改变。循环的条件也可以被放在末尾，以确保循环被运行至少一次。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    n <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="comment">// Prints &quot;128&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    m <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m <span class="operator">&lt;</span> <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment">// Prints &quot;128&quot;</span></span><br></pre></td></tr></table></figure><p>你可以用 <code>..&lt;</code> 来创建一系列在顺序的索引，并在 <code>for</code> 循环中迭代之。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span> &#123;</span><br><span class="line">    total <span class="operator">+=</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"><span class="comment">// Prints &quot;6&quot;</span></span><br></pre></td></tr></table></figure><p>使用 <code>..&lt;</code> 创建的序列不包括上界，用 <code>...</code> 创建的序列包括上下界。</p><h2 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h2><p>用 <code>func</code> 来声明函数。调用函数时，写函数的名字，并在其后写一对圆括号，括号里面是一系列参数。用 <code>-&gt;</code> 来分隔参数列表和返回值类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(person: <span class="string">&quot;Bob&quot;</span>, day: <span class="string">&quot;Tuesday&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>把参数 <code>day</code> 移除，添加一个包含今天午餐吃什么的参数，将其添加到欢迎语句里。</p></blockquote><p>默认情况下，函数用形式参数的名称作为实际参数的标签。也可以在形参前面加上自定义的实参标签，或者写 <code>_</code> 来指明无需标签。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="keyword">_</span> person: String, on day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>, on: <span class="string">&quot;Wednesday&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用元组可以创建复合值——例如，从函数中返回多个值。元组中的元素可以通过名字或索引调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStatistics</span><span class="params">(scores: [Int])</span></span> -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> min <span class="operator">=</span> scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> max <span class="operator">=</span> scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score <span class="operator">&gt;</span> max &#123;</span><br><span class="line">            max <span class="operator">=</span> score</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> score <span class="operator">&lt;</span> min &#123;</span><br><span class="line">            min <span class="operator">=</span> score</span><br><span class="line">        &#125;</span><br><span class="line">        sum <span class="operator">+=</span> score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (min, max, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> statistics <span class="operator">=</span> calculateStatistics(scores: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="comment">// Prints &quot;120&quot;</span></span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br><span class="line"><span class="comment">// Prints &quot;120&quot;</span></span><br></pre></td></tr></table></figure><p>函数可以嵌套。嵌套的内部函数可以访问外部函数中的变量。你可以用嵌套函数来组织代码，以免一个函数太长、太复杂。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y <span class="operator">+=</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure><p>函数是<em>第一类对象</em>。这意味着一个函数可以返回另一个函数作为返回值。</p><blockquote><p>【译者注】From Wikipedia</p><p><strong>第一类对象</strong>（英语：First-class object）在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中指可以在<a href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E6%9C%9F">执行期</a>创造并作为参数传递给其他函数或存入一个<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8">变数</a>的实体[<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6#cite_note-1">1]</a>。将一个实体变为第一类对象的过程叫做“<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6%E5%8C%96">物件化</a>”（Reification）[<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6#cite_note-2">2]</a>。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="operator">+</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment <span class="operator">=</span> makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>一个函数也可以接受其他函数作为参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: [Int], condition: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers <span class="operator">=</span> [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure><p>函数其实是一种特殊情形的闭包：一块可以被稍后调用的代码。在闭包中的代码可以访问存在于其声明时的作用域的变量或函数等东西，哪怕这个闭包在其他作用域中被调用执行——嵌套函数正是这样的例子。你可以这样写一个闭包：写一段没有名字的、用花括号（<code>&#123;&#125;</code>）包裹的代码。用 <code>in</code> 来将参数、返回值同主体代码分离。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers.map(&#123; (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="number">3</span> <span class="operator">*</span> number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>重写闭包，使所有的奇数返回零。</p></blockquote><p>你还有更多的选择来把闭包写得更简洁。当闭包的类型明确时，例如一个委托的回调，你可以省略参数的类型，或省略返回值的类型，或两者都省略。单语句的闭包隐式地返回该语句的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedNumbers <span class="operator">=</span> numbers.map(&#123; number <span class="keyword">in</span> <span class="number">3</span> <span class="operator">*</span> number &#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br><span class="line"><span class="comment">// Prints &quot;[60, 57, 21, 36]&quot;</span></span><br></pre></td></tr></table></figure><p>你可以用数字而非名称来使用参数——这个方法在极其简短的闭包中尤为实用。一个闭包作为最后一个参数传给函数时，可以直接写在圆括号后面。当一个闭包是一个函数唯一的参数时，可以直接省略圆括号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNumbers <span class="operator">=</span> numbers.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br><span class="line"><span class="comment">// Prints &quot;[20, 19, 12, 7]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>在关键字 <code>class</code> 后加上类的名字来创建一个类。类中属性的声明和常量、变量的声明方式是相同的，唯一的一定区别是属性声明是写在一个类里面的。同样地，方法和函数的声明也是同之前的写法一样。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A shape with <span class="subst">\(numberOfSides)</span> sides.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>用 <code>let</code> 添加一个常量属性，再写一个接受参数的方法。</p></blockquote><p>在类名后面放一对圆括号来创建类的实例。用<em>点</em>语法来取实例中的属性和方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shape <span class="operator">=</span> <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription <span class="operator">=</span> shape.simpleDescription()</span><br></pre></td></tr></table></figure><p>在刚才写的这一版本 <code>Shape</code> 类中，缺少了一个重要的东西：用来在实例被创建时对类进行设置的<strong>构造器</strong>。用 <code>init</code> 来创建一个构造器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A shape with <span class="subst">\(numberOfSides)</span> sides.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>self</code> 的使用区分了构造器的参数 <code>name</code> 与类的属性 <code>name</code>。在创建类的实例时，传入构造器的参数和调用函数时的传参很类似。每一个属性都需要被赋值——要么在声明时赋值（比如 <code>numberOfSides</code>），要么在构造器中赋值（比如 <code>name</code>）。</p><p>如果你需要在对象被销毁前执行一些清理工作的话，用 <code>deinit</code> 来创建一个析构器（译注，为保持简洁，我借用了C++里构造函数/析构函数的说法，deinitializer 直译为反构造器）。</p><p>子类应该在其类名后面写上父类的名称，用分号分隔。Swift 不要求一个类必须从某个标准的根类开始继承，所以你可以按需求包括或省略父类。</p><p>如果子类中需要重写父类中实现的方法，需要标注 <code>override</code> 以强调是重写，否则会被编译器认为是错误。编译器同样会检测出标记了 <code>override</code> 但在父类中没有实现的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength <span class="operator">=</span> sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength <span class="operator">*</span> sideLength</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A square with sides of length <span class="subst">\(sideLength)</span>.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">&quot;my test square&quot;</span>)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>创建 <code>NamedShape</code> 的另一个子类 <code>Circle</code>，该类的构造器接受半径radius 和 名字name 两个参数。在 <code>Circle</code> 中实现 <code>area()</code> 和 <code>simpleDescription()</code> 方法。</p></blockquote><p>除了已经提及的简单属性，属性还可以拥有 getter 和 setter。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilateralTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength <span class="operator">=</span> sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> <span class="operator">*</span> sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sideLength <span class="operator">=</span> newValue <span class="operator">/</span> <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;An equilateral triangle with sides of length <span class="subst">\(sideLength)</span>.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangle <span class="operator">=</span> <span class="type">EquilateralTriangle</span>(sideLength: <span class="number">3.1</span>, name: <span class="string">&quot;a triangle&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line"><span class="comment">// Prints &quot;9.3&quot;</span></span><br><span class="line">triangle.perimeter <span class="operator">=</span> <span class="number">9.9</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br><span class="line"><span class="comment">// Prints &quot;3.3000000000000003&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>perimeter</code> 的 setter 中，新的值被自动命名为 <code>newValue</code>。你也可以提供一个自定义的名称，这个名称在 <code>set</code> 后面添加的一对圆括号里写明。</p><p>注意，在 <code>EquilateralTriangle</code> 类的构造器中有三个不同的步骤：</p><ol><li>设置子类中声明的属性值；</li><li>调用父类的构造器；</li><li>修改父类中定义的属性值。其他各种需要的使用方法、getter、setter的附加设置也在这一步完成。</li></ol><p>如果你不需要计算属性，但是需要在设置一个新的值的前后运行一些代码，你可以使用 <code>willSet</code> 和 <code>didSet</code>。在构造器意外改变值时，其中的代码就会被执行。例如，下面的类保证三角形的边长始终等于正方形的边长：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength <span class="operator">=</span> newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength <span class="operator">=</span> newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(size: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        square <span class="operator">=</span> <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle <span class="operator">=</span> <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangleAndSquare <span class="operator">=</span> <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">&quot;another test shape&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="comment">// Prints &quot;10.0&quot;</span></span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line"><span class="comment">// Prints &quot;10.0&quot;</span></span><br><span class="line">triangleAndSquare.square <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">&quot;larger square&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line"><span class="comment">// Prints &quot;50.0&quot;</span></span><br></pre></td></tr></table></figure><p>当使用可选值时，你可以在方法、属性、下标等操作前面写 <code>?</code>。如果 <code>?</code> 前面的值是 <code>nil</code>，则 <code>?</code> 后的一切都会被忽略，整个表达式的值为 <code>nil</code>。否则，可选值会被展开，<code>?</code> 后的活动作用于展开的值。在两种情况下，整个表达式的值都是可选值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">&quot;optional square&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> sideLength <span class="operator">=</span> optionalSquare<span class="operator">?</span>.sideLength</span><br></pre></td></tr></table></figure><h2 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h2><p>用 <code>enum</code> 来创建枚举。和类以及其他有名字的类型一样，枚举可以包含属于自己的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ace <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> two, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">    <span class="keyword">case</span> jack, queen, king</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .ace:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ace&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .jack:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;jack&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .queen:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;queen&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .king:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;king&quot;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ace <span class="operator">=</span> <span class="type">Rank</span>.ace</span><br><span class="line"><span class="keyword">let</span> aceRawValue <span class="operator">=</span> ace.rawValue</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>写一个通过原始值来比较两个 Rank 值的函数。</p></blockquote><p>在默认情况下，swift 会从零开始为枚举情况赋值，逐个递增。但你可以通过直接指定值来打破这一规律。在上面的例子中，<code>Ace</code> 被直接赋予了原始值 <code>1</code>，其余的元素随即被顺序依次赋值。你也可以创建用字符串或浮点数来作为原始值的枚举。用 <code>rawValue</code> 属性来取出一个枚举情况的原始值。</p><p>用构造器 <code>init?(rawValue:)</code> 来从原始值实例化枚举实例。当提供的原始值匹配上某枚举情况时，它返回该匹配的枚举情况实例；否则，没有匹配的项就返回 <code>nil</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spades, hearts, diamonds, clubs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .spades:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;spades&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .hearts:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hearts&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .diamonds:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;diamonds&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .clubs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;clubs&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hearts <span class="operator">=</span> <span class="type">Suit</span>.hearts</span><br><span class="line"><span class="keyword">let</span> heartsDescription <span class="operator">=</span> hearts.simpleDescription()</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>为 <code>Suit</code> 添加一个 <code>color()</code> 函数，当枚举情况是 spades 或 clubs 时该函数返回 <code>black</code> ，当枚举情况是 hearts 或 diamonds 时该函数返回 <code>red</code> 。</p></blockquote><p>注意上面的代码中，枚举情况 <code>hearts</code> 的两种表示方式：当将至赋给 <code>hearts</code> 常量时，枚举情况 <code>Suit.hearts</code> 是用全名来取用的，因为这个常量没有直接的类型指明。在<code> switch</code> 中，枚举情况的取用是用了缩写 <code>.hearts</code>，因为已经知道值 <code>self</code> 是一个 <code>Suit</code>。对于任何已知值的类型的情况，你都可以使用这样的缩写。</p><p>如果一个枚举有原始值，则原始值在声明时即被确定，因此，每个特定枚举情况的实例总是拥有相同的原始值。还有另一种枚举情况可以使情况与值相关联——这些值在创建实例时被确定，这种情况下同一枚举情况的不同实例可能拥有不同的关联值。你可以认为这些关联值就像是储存在枚举情况实例中的属性。例如，考虑从服务器请求日出日落时间的场景，服务器要么返回被请求的信息，要么返回发生错误时的描述。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> result(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> success <span class="operator">=</span> <span class="type">ServerResponse</span>.result(<span class="string">&quot;6:00 am&quot;</span>, <span class="string">&quot;8:09 pm&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> failure <span class="operator">=</span> <span class="type">ServerResponse</span>.failure(<span class="string">&quot;Out of cheese.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise, sunset):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sunrise is at <span class="subst">\(sunrise)</span> and sunset is at <span class="subst">\(sunset)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failure...  <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Sunrise is at 6:00 am and sunset is at 8:09 pm.&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>添加第三种情况到 <code>ServerResponse</code> 和 switch。</p></blockquote><p>注意 sunrise 和 sunset 时间是如何从 <code>ServerResponse</code> 以匹配 switch case 的形式中提取出来的。</p><p>用 <code>struct</code> 来创建结构体。结构体支持许多与类相似的行为，包括方法和构造器。结构体和类最重要的区别之一是：当在代码中被传递时，结构体总是会被复制，而类重视被引用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The <span class="subst">\(rank.simpleDescription())</span> of <span class="subst">\(suit.simpleDescription())</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeOfSpades <span class="operator">=</span> <span class="type">Card</span>(rank: .three, suit: .spades)</span><br><span class="line"><span class="keyword">let</span> threeOfSpadesDescription <span class="operator">=</span> threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>写一个函数，返回一套完整的扑克牌，并把每张牌的 rank 和 suit 对应起来。</p></blockquote><h2 id="协议和拓展"><a href="#协议和拓展" class="headerlink" title="协议和拓展"></a>协议和拓展</h2><p>用 <code>protocol</code> 来声明协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类、枚举和结构体都可以采用协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;A very simple class.&quot;</span></span><br><span class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> <span class="operator">=</span> <span class="number">69105</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription <span class="operator">+=</span> <span class="string">&quot;  Now 100% adjusted.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription <span class="operator">=</span> a.simpleDescription</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;A simple structure&quot;</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription <span class="operator">+=</span> <span class="string">&quot; (adjusted)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="type">SimpleStructure</span>()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription <span class="operator">=</span> b.simpleDescription</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>在 <code>ExampleProtocol</code> 里添加一个要求，看看需要怎么修改 <code>SimpleClass</code> 和 <code>SimpleStructure</code> 来使它们仍然遵从协议。</p></blockquote><p>注意，用关键字 <code>mutating</code> 来在 <code>SimpleStructure</code> 中声明一个会修改结构体的方法。而在 <code>SimpleClass</code> 的声明中，不需要标记 <code>mutating</code> 是因为类中的任意方法总是可以修改改类的。</p><p>用关键词 <code>extension</code> 来给现有的类添加一些功能，例如新的方法、计算属性。你可以用 <code>extension</code> 给在其他地方声明的（甚至是你在你导入的包中的）类型添加拓展，使其遵守你指定的协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The number <span class="subst">\(<span class="keyword">self</span>)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">+=</span> <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br><span class="line"><span class="comment">// Prints &quot;The number 7&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>给 <code>Double</code> 类型添加一个 <code>absoluteValue</code> 属性。</p></blockquote><p>你可以像其他任何命名类型一样使用协议——例如，创建一个集合来存放遵守相同协议但互不相同的类型的对象。当你处理协议类型的值时，协议之外的属性都是不可用的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> <span class="operator">=</span> a</span><br><span class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</span><br><span class="line"><span class="comment">// Prints &quot;A very simple class.  Now 100% adjusted.&quot;</span></span><br><span class="line"><span class="comment">// print(protocolValue.anotherProperty)  // Uncomment to see the error</span></span><br></pre></td></tr></table></figure><p>即时变量 <code>protocolValue</code> 在运行时拥有类型 <code>SimpleClass</code>， 编译器还是会按照给定的类型 <code>ExampleProtocol</code> 来看待它。也就是说，你不可以这个类在协议规定以外额外实现的方法和属性。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>你可以使用任何遵守了 <code>Error</code> 协议的类型来代表错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrinterError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>throw</code> 来抛出错误，用 <code>throws</code> 来标记一个函数有可能会抛出错误。如果你在一个函数中抛出了错误，那么函数就会立刻返回，调用函数的代码会要处理错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName <span class="operator">==</span> <span class="string">&quot;Never Has Toner&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Job sent&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 中有多种方法可以处理错误，其中之一是使用 <code>do-catch</code>。在 <code>do</code> 语句块中，你可以在可能抛出错误的代码前面写上 <code>try</code>，在 <code>catch</code> 语句块中，错误会被自动赋给名称 <code>error</code>，或者你自定义的其他名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse <span class="operator">=</span> <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">&quot;Bi Sheng&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Job sent&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>把 pointer 的名字换成 “Never Has Toner”，使 <code>send()</code> 函数抛出一个错误。</p></blockquote><p>你可以提供多个 <code>catch</code> 语句块来处理不同的错误。在 <code>catch</code> 后面的代码模式类似于你在 switch 语句的 <code>case</code> 后面写的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse <span class="operator">=</span> <span class="keyword">try</span> send(job: <span class="number">1440</span>, toPrinter: <span class="string">&quot;Gutenberg&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">PrinterError</span>.onFire &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll just put this over here, with the rest of the fire.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrinterError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printer error: <span class="subst">\(printerError)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Job sent&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>添加代码，在 <code>do</code> 语句块中抛出一个错误，需要抛出什么错误来使该错误被第一个 <code>catch</code> 块处理？第二个、第三个又如何？</p></blockquote><p>另一种处理错误的办法是使用 <code>try?</code> 来把结果转化为可选值。如果函数抛出错误，具体的错误会被忽略，返回值为 <code>nil</code>。否则，返回值会是包含了函数返回值的可选值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printerSuccess <span class="operator">=</span> <span class="keyword">try?</span> send(job: <span class="number">1884</span>, toPrinter: <span class="string">&quot;Mergenthaler&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> printerFailure <span class="operator">=</span> <span class="keyword">try?</span> send(job: <span class="number">1885</span>, toPrinter: <span class="string">&quot;Never Has Toner&quot;</span>)</span><br></pre></td></tr></table></figure><p>用 <code>defer</code> 来写一块在函数中的所有代码执行完成后、函数返回之前执行的代码。不论函数是否抛出了错误，这段 defer 代码都会被执行。你可以利用 <code>defer</code>，把设置和清理的代码写在一起，即使它们将在不同时候被执行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fridgeIsOpen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> fridgeContent <span class="operator">=</span> [<span class="string">&quot;milk&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;leftovers&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fridgeContains</span><span class="params">(<span class="keyword">_</span> food: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    fridgeIsOpen <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        fridgeIsOpen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> fridgeContent.contains(food)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">fridgeContains(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fridgeIsOpen)</span><br><span class="line"><span class="comment">// Prints &quot;false&quot;</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在一对尖括号中写一个名字来创建泛型函数或类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArray</span>&lt;Item&gt;<span class="params">(repeating item: Item, numberOfTimes: Int)</span></span> -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">Item</span>]()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfTimes &#123;</span><br><span class="line">        result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">makeArray(repeating: <span class="string">&quot;knock&quot;</span>, numberOfTimes: <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>你可以创建泛型的函数和方法，也可以创建泛型的类、枚举和结构体。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reimplement the Swift standard library&#x27;s optional type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> .none</span><br><span class="line">possibleInteger <span class="operator">=</span> .some(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在函数体前用 <code>where</code> 来明确一系列对泛型的要求——例如，要求这种类型要实现某种协议，或者某两个类型要相同，再或者要求一个类有特定的子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;T: Sequence, U: Sequence&gt;<span class="params">(<span class="keyword">_</span> lhs: T, <span class="keyword">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">U</span>.<span class="type">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem <span class="operator">==</span> rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure><blockquote><p>【实验】</p><p>修改函数 <code>anyCommonElements(_:_:)</code> 使之返回一个数组，该数组包括所有两个序列中共有的元素。</p></blockquote><p>写 <code>&lt;T: Equatable&gt;</code> 和写 <code>&lt;T&gt; ... where T: Eauatable</code> 是一样的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Andrew Ng 机器学习笔记总结</title>
      <link href="/2020/01/16/AndrewNgML/AndrewNgMLNotes/"/>
      <url>/2020/01/16/AndrewNgML/AndrewNgMLNotes/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>Emmmm，这学期在 Coursera 学完了 Andrew Ng 的 Machine Learning 课程。我对这个课程一向是不以为意的，却不小心报了个名，还手贱申请了个经济援助，学完就可以免费拿证书（卖几百块哒），课程期间还送正版的 Matlab Online，这一系列的偶(占)然(小)事(便)件(宜)促使我开始刷这个课了。越学越觉得，嗯，真香，是真的很香！这个课真的是很好的机器学习入门，难怪那么多人推荐。</p><p>Coursera 里课程笔记有每一章的总结，总结的非常好，推荐学完之后看一看。但我还是喜欢自己写自己的，所以我之前边看视频边写了几乎涵盖整个课程的<a href="https://clownote.github.io/categories/Machine-Learning/AndrewNg/">笔记</a>，其实好多是在抄老师的原话和PPT😂，就当练习打字、英语还有 $\LaTeX$ 了。放假回家在火车上<del>百无聊赖</del>心血来潮，想到了应该整理一下课程里面学到的东西，就有了这篇文章。</p><p>这里我主要是写了各种算法的描述，还从编程作业里提取了算法大概的代码实现，方便日后快速查阅吧。一开始的回归比较简单，所以我写的很少，就堆了点公式（其实是硬卧上铺空调太冷致使我生病了，思路堵塞写不出东西来😷）；后面SVM、推荐系统什么的比较复杂就多写了一些（其实是我掌握的不好，归纳不出重点🤯）。至于课程里老师花大力气讲的关于机器学习系统的设计、优化、debug 还有各种<del>奇技淫巧</del> <del>骚操作</del> 实用技巧 以及 Octave 入门哪一块我就一概不提了，这些东西还是要看老师的视频才能体会到精髓（…优(挂)秀(科)的大学生自然是不能承认原因是自己懒惰的😎）。</p><p>由于我看课程的时候全程没有开中文字幕，平时查阅的中文资料也比较少，所以好多术语我都不知道要怎么翻译，写这篇文章的时候我大概查了一些自己难以表达的，其他的全靠臆测，我不保证正确。</p><p>Emmm，不小心就写了几百字的废话😂下面就开始吧。</p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是给x、y数据去训练的。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n5s7zmffj30lv0ca40u.jpg" alt="image-20191105144318970"></p><h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><blockquote><p>做预测，值域为连续的数（例如区间$[0,100]$）</p></blockquote><p>数学模型：</p><ul><li><p><strong>预测函数</strong>：<br>$$</p><h1 id="h-theta-x"><a href="#h-theta-x" class="headerlink" title="h_\theta(x)"></a>h_\theta(x)</h1><h1 id="sum-i-0-m-theta-ix-i"><a href="#sum-i-0-m-theta-ix-i" class="headerlink" title="\sum_{i=0}^m \theta_ix_i"></a>\sum_{i=0}^m \theta_ix_i</h1><p>\left[\begin{array}{c}\theta_0 &amp; \theta_1 &amp; \ldots &amp; \theta_n\end{array}\right]</p><h1 id="left-begin-array-c-x-0-x-1-vdots-x-n-end-array-right"><a href="#left-begin-array-c-x-0-x-1-vdots-x-n-end-array-right" class="headerlink" title="\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]"></a>\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]</h1><p>\theta^TX<br>$$</p></li><li><p><strong>待求参数</strong>：$\theta=\left[\begin{array}{c}\theta_0 &amp; \theta_1 &amp; \ldots &amp; \theta_n\end{array}\right]$</p></li><li><p><strong>代价函数</strong>：<br>$$<br>J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2<br>=\frac{(\sum_{i=1}^mh_\theta(X)-Y)^2}{2m}<br>$$</p></li></ul><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">J</span> = <span class="title">computeCostMulti</span><span class="params">(X, y, theta)</span></span></span><br><span class="line"><span class="comment">%COMPUTECOSTMULTI Compute cost for linear regression with multiple variables</span></span><br><span class="line"><span class="comment">%   J = COMPUTECOSTMULTI(X, y, theta) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for linear regression to fit the data points in X and y</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span> / (<span class="number">2</span>*m) * (X*theta - y)&#x27; * (X*theta - y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% or less vectorizedly: </span></span><br><span class="line"><span class="comment">% predictions = X * theta;</span></span><br><span class="line"><span class="comment">% sqrErrors = (predictions - y) .^ 2;</span></span><br><span class="line"><span class="comment">% J = 1 / (2*m) * sum(sqrErrors);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>优化目标</strong>：找到一组$\theta$使$J$最小。</li></ul><p>求解方法：</p><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>（这里暂且只讨论 batch gradient descent）</p><p>$$<br>\begin{array}{ll}<br>\textrm{repeat until convergence } { \<br>\qquad \theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\<br>\qquad\quad:= \theta_j - \alpha \frac{1}{m} \sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}] \cdot x_j^{(i)}\qquad \textrm{for }j:=0, …, n \<br>}<br>\end{array}<br>$$</p><p>向量化表示：$\theta=\theta-\frac{\alpha}{m}X^T(h_\theta(X)-Y)$</p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta, J_history]</span> = <span class="title">gradientDescentMulti</span><span class="params">(X, y, theta, alpha, num_iters)</span></span></span><br><span class="line"><span class="comment">%GRADIENTDESCENTMULTI Performs gradient descent to learn theta</span></span><br><span class="line"><span class="comment">%   theta = GRADIENTDESCENTMULTI(x, y, theta, alpha, num_iters) updates theta by</span></span><br><span class="line"><span class="comment">%   taking num_iters gradient steps with learning rate alpha</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line">J_history = <span class="built_in">zeros</span>(num_iters, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line"></span><br><span class="line">    predictions = X * theta;</span><br><span class="line">    errors = (predictions - y);</span><br><span class="line">    theta = theta - alpha / m * (X&#x27; * errors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Save the cost J in every iteration    </span></span><br><span class="line">    J_history(iter) = computeCostMulti(X, y, theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h4><p>$$<br>\theta = (X^TX)^{-1}X^Ty<br>$$<br>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta]</span> = <span class="title">normalEqn</span><span class="params">(X, y)</span></span></span><br><span class="line"><span class="comment">%NORMALEQN Computes the closed-form solution to linear regression </span></span><br><span class="line"><span class="comment">%   NORMALEQN(X,y) computes the closed-form solution to linear </span></span><br><span class="line"><span class="comment">%   regression using the normal equations.</span></span><br><span class="line"></span><br><span class="line">theta = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">2</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">theta = pinv(X&#x27; * X) * X&#x27; * y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里我们求伪逆以确保正常运行。通常造成$X^TX$不可逆的原因是：</p><ol><li>存在可约特征，即给定的某两/多个特征线性相关，只保留一个删除其他即可解决。（e.g. there are the size of house in feet^2 and the size of house in meter^2, where we know that 1 meter = 3.28 feet）</li><li>给定特征过多，($m \le n$). 可以删除一些不重要的特征（考虑PCA算法）</li></ol><h4 id="梯度下降vs正规方程"><a href="#梯度下降vs正规方程" class="headerlink" title="梯度下降vs正规方程"></a>梯度下降vs正规方程</h4><table><thead><tr><th></th><th>Gradient Descent</th><th>Normal Equation</th></tr></thead><tbody><tr><td>需要选择 alpha</td><td>✅</td><td>-</td></tr><tr><td>第三方</td><td>✅</td><td>-</td></tr><tr><td>时间复杂度</td><td>$O(kn^2)$</td><td>求$X^TX$的伪逆需要$O(n^3)$</td></tr><tr><td>n 相当大时</td><td>可以工作</td><td>十分缓慢甚至不可计算</td></tr></tbody></table><p>实际上，当 $n&gt;10,000$ 时，我们通常更倾向于使用梯度下降，否则正规方程一般都表现得更好。</p><h4 id="注：特征缩放"><a href="#注：特征缩放" class="headerlink" title="注：特征缩放"></a>注：特征缩放</h4><p>我们可以通过使输入值大概在一定的范围内来使梯度下降运行更快，比如说，我们可以把所有值变到 $[-1,1]$ 的范围内，同时，我们还可以通过处理让输入值之间的差距不要太大（例如，输入值中同时有 0.000001 和 1 这样差距大的值会影响梯度下降的效率）。</p><p>在实践中，我们通常想要保证变量值在 $[-3,-\frac{1}{3}) \cup (+\frac{1}{3}, +3]$ 这个范围内取值。</p><p>为达成该目标，我们做如下操作：</p><ol><li>Feature scaling</li></ol><p>$$<br>\begin{array}{rl}<br>\textrm{Range:} &amp; s_i = max(x_i)-min(x_i)\<br>\textrm{Or Range:} &amp; s_i = \textrm{standard deviation of } x_i\<br>\textrm{Scaling:} &amp; x_i:=\frac{x_i}{s_i}<br>\end{array}<br>$$</p><ol start="2"><li>Mean normalizaton</li></ol><p>$$<br>\begin{array}{rl}<br>\textrm{Mean(Average):} &amp; \mu_i = \frac{sum(x_i)}{m}\<br>\textrm{normalizing:} &amp; x_i:=x_i-\mu_i<br>\end{array}<br>$$</p><p>把两个操作和在一起，即：<br>$$<br>x_i:=\frac{x_i-\mu_i}{s_i}<br>$$<br>其中，$\mu_i$ 是特征(i)的值的平均，$s_i$是值的范围。</p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X_norm, mu, sigma]</span> = <span class="title">featureNormalize</span><span class="params">(X)</span></span></span><br><span class="line"><span class="comment">%FEATURENORMALIZE Normalizes the features in X </span></span><br><span class="line"><span class="comment">%   FEATURENORMALIZE(X) returns a normalized version of X where</span></span><br><span class="line"><span class="comment">%   the mean value of each feature is 0 and the standard deviation</span></span><br><span class="line"><span class="comment">%   is 1. This is often a good preprocessing step to do when</span></span><br><span class="line"><span class="comment">%   working with learning algorithms.</span></span><br><span class="line"></span><br><span class="line">X_norm = X;</span><br><span class="line">mu = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">size</span>(X, <span class="number">2</span>));</span><br><span class="line">sigma = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">size</span>(X, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">mu = <span class="built_in">mean</span>(X);</span><br><span class="line">sigma = std(X);</span><br><span class="line">X_norm = (X - mu) ./ sigma;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><blockquote><p>做预测，值域为离散的几个特定值（例如 0 或 1；0/1/2/3）</p></blockquote><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>假设函数：<br>$$<br>\left{\begin{array}{l}<br>h_\theta(x) = g(\theta^Tx)\<br>z = \theta^T x\<br>g(z) = \frac{1}{1+e^{-z}}\<br>\end{array}\right.<br>$$<br>其中，$g(z)$ 称为 Simoid 函数，或逻辑函数，其图像如下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauxvtzb5qj30ur0g8wgd.jpg" alt="image-20190917162504420"></p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> = <span class="title">sigmoid</span><span class="params">(z)</span></span></span><br><span class="line"><span class="comment">%SIGMOID Compute sigmoid functoon</span></span><br><span class="line"><span class="comment">%   J = SIGMOID(z) computes the sigmoid of z.</span></span><br><span class="line"></span><br><span class="line">g = <span class="number">1.0</span> ./ (<span class="number">1.0</span> + <span class="built_in">exp</span>(-z));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上式可化简得：<br>$$<br>h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}<br>$$</p><p>$h_\theta$ 的输出是预测值为1的可能性，并有下两式成立：<br>$$<br>h_\theta(x)=P(y=1 \mid x;\theta)=1-P(y=0 \mid x; \theta)<br>$$</p><p>$$<br>P(y=0 \mid x;\theta) + P(y=1 \mid x;\theta) = 1<br>$$</p><p><strong>决策边界</strong>：逻辑回归的决策边界就是将区域分成$y=0$和 $y=1$ 两部分的一个超平面。</p><p>决策边界由假设函数决定。这是由于要完成分类，需用$h_\theta$的输出来决定结果是 0 还是 1。定 0.5 为分界，即：<br>$$<br>\begin{array}{rcl}<br>h_\theta(x) \ge 0.5 &amp;\Rightarrow&amp; y=1\<br>h_\theta(x) &lt; 0.5 &amp;\Rightarrow&amp; y=0<br>\end{array}<br>$$<br>由 Simoid 函数的性质，上式等价为：<br>$$<br>\begin{array}{rcl}<br>\theta^TX \ge 0 &amp;\Rightarrow&amp; y=1\<br>\theta^TX \le 0 &amp;\Rightarrow&amp; y=0\<br>\end{array}<br>$$<br>那么对于给定的一组 $\theta$，例如$\theta=\left[\begin{array}{c}5\-1\0\end{array} \right]$，有 $y=1$ 当且仅当 $5+(-1)x_1+0x_2 \ge 0$，这时决策边界为 $x_1=5$。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauyq6oc10j306e04umx0.jpg" alt="image-20190917173722734"></p><p>决策边界也可以是下面这种复杂的情况：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauyt0wbq3j30mv08xwfh.jpg" alt="image-20190917174144868"></p><p><strong>逻辑回归模型</strong>：<br>$$<br>\begin{array}{rcl}<br>\textrm{Training set} &amp;:&amp; {(x^{(1)},y^{(1)}), (x^{(2)},y^{(2)}), \ldots, (x^{(m)},y^{(m)})}\<br>\<br>\textrm{m examples} &amp;:&amp;<br>x \in \left[\begin{array}{c}<br>x_0\x_1\ \vdots \ x_n<br>\end{array}\right] \textrm{where }(x_0=1)<br>,\quad y \in {0,1}\<br>\<br>\textrm{Hypothesis} &amp;:&amp; h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}\\<br>\textrm{Cost Function} &amp;:&amp;<br>J(\theta)=-\frac{1}{m}\sum_{i=1}^m\Bigg[y^{(i)}log\Big(h_\theta(x)\Big)+(1-y^{(i)})log\Big(1-h_\theta(x^{(i)})\Big)\Bigg]<br>\end{array}<br>$$<br>向量化表示：<br>$$<br>\begin{array}{l}<br>h=g(X\theta)\<br>J(\theta)=\frac{1}{m}\cdot\big(-y^T log(h) -(1-y)^T log(1-h)\big)<br>\end{array}<br>$$<br><strong>梯度下降</strong>：<br>$$<br>\begin{array}{l}<br>Repeat \quad {\<br>\qquad \theta_j:=\theta_j-\frac{\alpha}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})\cdot x_j^{(i)}\<br>}<br>\end{array}<br>$$<br>向量化表示：<br>$$<br>\theta:=\theta-\frac{\alpha}{m}X^T(g(X\theta)-\overrightarrow{y})<br>$$<br>👉代码实现（使用Advanced Optimization）：</p><ol><li>提供$J(\theta), \frac{\partial}{\partial\theta_j}J(\theta)$</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J, grad]</span> = <span class="title">costFunction</span><span class="params">(theta, X, y)</span></span></span><br><span class="line"><span class="comment">%COSTFUNCTION Compute cost and gradient for logistic regression</span></span><br><span class="line"><span class="comment">%   J = COSTFUNCTION(theta, X, y) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for logistic regression and the gradient of the cost</span></span><br><span class="line"><span class="comment">%   w.r.t. to the parameters.</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"></span><br><span class="line">h = sigmoid(X*theta);</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span>/m * (-y&#x27;*<span class="built_in">log</span>(h) - (<span class="number">1</span>-y)&#x27;*<span class="built_in">log</span>(<span class="number">1</span>-h));</span><br><span class="line"></span><br><span class="line">grad = <span class="number">1</span>/m * X&#x27;*(h-y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>调用 Advanced Optimization 函数解决优化问题：</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">initialTheta = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure><h5 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h5><p>我们采用一系列的单元（逻辑）分类来完成多元分类：<br>$$<br>\begin{array}{l}<br>y \in {0,1,\cdots,n}\\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\<br>\vdots\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\\<br>prediction = \mathop{max}\limits_{\theta}\big(h_\theta^{(i)}(x)\big)<br>\end{array}<br>$$</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78nj8fvy4j30d507agmp.jpg" alt="img"></p><h4 id="注：过拟合"><a href="#注：过拟合" class="headerlink" title="注：过拟合"></a>注：过拟合</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aopbltb1j30f0046dg2.jpg" alt="img"></p><p>过拟合对训练集中的数据预测的很好，但对没见过的新样本预测效果不佳。</p><p>解决过拟合的方法有：</p><ol><li><p>减少特征数量（PCA）</p></li><li><p>正则化：在代价函数中加入 $\theta$ 的权重：</p><p>$\mathop{min}\limits_{\theta} \dfrac{1}{2m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum_{j=1}^n \theta_j^2$</p><blockquote><p>注意，$\theta_0$是我们加上的常数项，不应该被正则化。</p></blockquote><p>代码实现：</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J, grad]</span> = <span class="title">lrCostFunction</span><span class="params">(theta, X, y, lambda)</span></span></span><br><span class="line"><span class="comment">%LRCOSTFUNCTION Compute cost and gradient for logistic regression with </span></span><br><span class="line"><span class="comment">%regularization</span></span><br><span class="line"><span class="comment">%   J = LRCOSTFUNCTION(theta, X, y, lambda) computes the cost of using</span></span><br><span class="line"><span class="comment">%   theta as the parameter for regularized logistic regression and the</span></span><br><span class="line"><span class="comment">%   gradient of the cost w.r.t. to the parameters. </span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Unregularized cost function &amp; gradient for logistic regression</span></span><br><span class="line">h = sigmoid(X * theta);</span><br><span class="line">J = <span class="number">1</span>/m * (-y&#x27;*<span class="built_in">log</span>(h) - (<span class="number">1</span>-y)&#x27;*<span class="built_in">log</span>(<span class="number">1</span>-h));</span><br><span class="line">grad = <span class="number">1</span>/m * X&#x27;*(h-y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Regularize</span></span><br><span class="line">temp = theta;</span><br><span class="line">temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">J = J + lambda/(<span class="number">2</span>*m) * sum(temp.^<span class="number">2</span>);</span><br><span class="line">grad = grad + lambda/m * temp;</span><br><span class="line"></span><br><span class="line">grad = grad(:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>$$<br>\left[\begin{array}{c}x_0 \ x_1 \ x_2 \ x_3\end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(2)} \ a_2^{(2)} \ a_3^{(2)} \ \end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(3)} \ a_2^{(3)} \ a_3^{(3)} \ \end{array}\right]<br>\rightarrow<br>h_\theta(x)<br>$$</p><p>第一层是数据集，称为输入层，可以看作 $a^{(0)}$ ；中间是数个隐藏层，最终得到的就是预测函数，这一层叫做输出层。</p><p>$$<br>z^{(j)} = \Theta^{(j-1)}a^{(j-1)}<br>$$</p><p>$$<br>a^{(j)} = g(z^{(j)})<br>$$</p><p>假设有 c 个层，则:</p><p>$$<br>h_\Theta(x)=a^{(c+1)}=g(z^{(c+1)})<br>$$</p><p>例如，用一层的神经网络，我们可以建立一些表达逻辑函数的神经网络：<br>$$<br>\begin{array}{l}AND:\&amp;\Theta^{(1)} &amp;=\begin{bmatrix}-30 &amp; 20 &amp; 20\end{bmatrix} \ NOR:\&amp;\Theta^{(1)} &amp;= \begin{bmatrix}10 &amp; -20 &amp; -20\end{bmatrix} \ OR:\&amp;\Theta^{(1)} &amp;= \begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix} \\end{array}<br>$$</p><h5 id="多元分类-1"><a href="#多元分类-1" class="headerlink" title="多元分类"></a>多元分类</h5><p>$$<br>y^{(i)}=\begin{bmatrix}1\0\0\0\end{bmatrix},\begin{bmatrix}0\1\0\0\end{bmatrix},\begin{bmatrix}0\0\1\0\end{bmatrix},\begin{bmatrix}0\0\0\1\end{bmatrix}<br>$$</p><p>$$<br>\left[\begin{array}{c}x_0 \ x_1 \ x_2 \ x_3\end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(2)} \ a_2^{(2)} \ a_3^{(2)} \ … \end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(3)} \ a_2^{(3)} \ a_3^{(3)} \ … \end{array}\right]<br>\rightarrow<br>\cdots<br>\rightarrow<br>\left[\begin{array}{c}h_\Theta(x)_1 \ h_\Theta(x)_2 \ h_\Theta(x)_3 \ h_\Theta(x)_4 \end{array}\right]<br>$$</p><h5 id="神经网络的拟合"><a href="#神经网络的拟合" class="headerlink" title="神经网络的拟合"></a>神经网络的拟合</h5><table><thead><tr><th>Notation</th><th>Represent</th></tr></thead><tbody><tr><td>$L$</td><td>神经网络中的总层数</td></tr><tr><td>$s_l$</td><td>第$l$层中的节点数（不算偏移单元$a_0$）</td></tr><tr><td>$K$</td><td>输出节点数</td></tr></tbody></table><p><strong>代价函数</strong>：<br>$$<br>J(\Theta)=-\frac{1}{m}\sum_{i=1}^{m}\sum_{k=1}^{K}\Big[<br>y_k^{(i)}log\Big(\big(h_\Theta(x^{(i)})\big)<em>k\Big)+<br>(1-y_k^{(i)})log\Big(1-\big(h_\Theta(x^{(i)})\big)<em>k\Big)<br>\Big]+<br>\frac{\lambda}{2m}\sum</em>{l=1}^{L-1}\sum</em>{i=1}^{s_l}\sum_{j=1}^{s_{l+1}}\Big(\Theta_{j,i}^{(l)}\Big)^2<br>$$<br><strong>向后传播算法</strong>：<br>$$<br>\begin{array}{lll}<br>\textrm{Give training set }{(x^{(1)},y^{(1)}),…,(x^{(m)},y^{(m)})}\<br>\textrm{Set }\Delta_{i,j}^{(l)}:=0\textrm{ for each } l,i,j \textrm{ (get a matrix full of zeros)}\<br>\mathop{\textrm{For}} \textrm{ training example $t=1$ to $m$}:\<br>\qquad a^{(1)}:= x^{(t)}\<br>\qquad \textrm{Compute $a^{(l)}$ for $l=2,3,\cdots,L$ by forward propagation}\<br>\qquad \textrm{Using $y^{(t)}$ to compute } \delta^{(L)}=a^{(L)}-y^{(t)}\<br>\qquad \textrm{Compute } \delta^{(l)}=\big((\Theta^{(l)})^T\delta^{(l+1)}\big).<em>a^{(l)}.</em>(1-a^{(l)}) \textrm{ for } \delta^{(L-1)},\delta^{(L-2)},…,\delta^{(2)}\<br>\qquad \Delta^{(l)}:=\Delta^{(l)}+\delta^{(l+1)}(a^{(l)})^T\<br>\textrm{End For}\<br>D_{i,j}^{(l)}:=\frac{1}{m}\Delta_{i,j}^{(l)}\textrm{ if } j=0\<br>D_{i,j}^{(l)}:=\frac{1}{m}\big(\Delta_{i,j}^{(l)}+\lambda\Theta_{i,j}^{(l)}\big) \textrm{ if } j\neq 0 \<br>\textrm{Get }<br>\frac{\partial}{\partial\Theta_{i,j}^{(l)}}J(\Theta)=D_{i,j}^{(l)}<br>\end{array}<br>$$<br>注：上式中 $.*$ 代表 Matlab/Octave 中的 element-wise 的乘法。</p><p><strong>向后传播的使用</strong>：</p><p>先看几个涉及到的方法：</p><ul><li>参数展开：为使用优化函数，我们需要把所有的$\Theta$矩阵展开并拼接成一个长向量：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thetaVector = [ Theta1(:); Theta2(:); Theta3(:) ];</span><br><span class="line">deltaVector = [ D1(:); D2(:); D3(:) ];</span><br></pre></td></tr></table></figure><p>在得到优化结果后返回原来的矩阵：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Theta1 = <span class="built_in">reshape</span>(thetaVector(<span class="number">1</span>:<span class="number">110</span>),<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(thetaVector(<span class="number">111</span>:<span class="number">220</span>),<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">Theta3 = <span class="built_in">reshape</span>(thetaVector(<span class="number">221</span>:<span class="number">231</span>),<span class="number">1</span>,<span class="number">11</span>)</span><br></pre></td></tr></table></figure><ul><li>梯度检查：利用 $\frac{\partial}{\partial\Theta_j}J(\Theta) \approx \frac{J(\Theta_1,…,\Theta_j+\epsilon,…,\Theta_n)-J(\Theta_1,…,\Theta_j-\epsilon,…,\Theta_n)}{2\epsilon}$ 取一个小的邻域如 $\epsilon=10^{-4}$，可以检查我们用向后传播求出的梯度是否正确（若正确，有 gradApprox ≈ deltaVector 成立）。代码实现：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">thetaPlus = theta;</span><br><span class="line">thetaPlus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">thetaMinus = theta;</span><br><span class="line">thetaMinus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">gradApprox(<span class="built_in">i</span>) = (J(thetaPlus) - J(thetaMinus)) / (<span class="number">2</span>*epsilon);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>随即初始化：在开始时，将 $\Theta_{ij}^{(l)}$ 随机初始化，应保证随机值的取值在一个 $[-\epsilon,\epsilon]$ 的范围内（这个 $\epsilon$ 与梯度检查中的无关）。代码实现：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.</span><br><span class="line"></span><br><span class="line">Theta1 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta2 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br></pre></td></tr></table></figure><p>将上述技巧与向后传播算法结合，我们就得到了了训练神经网络的方法：</p><ol><li>随机初始化</li><li>向前传播得到 $h_\Theta(x^{(i)})$ 对任意 $x^{(i)}$</li><li>计算代价函数</li><li>使用向后传播计算偏导</li><li>利用梯度检查验证向后传播是否正确，若没问题则关闭梯度检查功能</li><li>使用梯度下降或优化函数得到$\Theta$</li></ol><p>👉代码实现：</p><ol><li>随机初始化</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">W</span> = <span class="title">randInitializeWeights</span><span class="params">(L_in, L_out)</span></span></span><br><span class="line"><span class="comment">%RANDINITIALIZEWEIGHTS Randomly initialize the weights of a layer with L_in</span></span><br><span class="line"><span class="comment">%incoming connections and L_out outgoing connections</span></span><br><span class="line"><span class="comment">%   W = RANDINITIALIZEWEIGHTS(L_in, L_out) randomly initializes the weights </span></span><br><span class="line"><span class="comment">%   of a layer with L_in incoming connections and L_out outgoing </span></span><br><span class="line"><span class="comment">%   connections. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Note that W should be set to a matrix of size(L_out, 1 + L_in) as</span></span><br><span class="line"><span class="comment">%   the first column of W handles the &quot;bias&quot; terms</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">W = <span class="built_in">zeros</span>(L_out, <span class="number">1</span> + L_in);</span><br><span class="line"></span><br><span class="line"><span class="comment">% epsilon_init = 0.12</span></span><br><span class="line">epsilon_init = <span class="built_in">sqrt</span>(<span class="number">6</span> / (L_in + L_out));</span><br><span class="line">W = <span class="built_in">rand</span>(L_out, <span class="number">1</span> + L_in) * (<span class="number">2</span> * epsilon_init) - epsilon_init;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>计算代价</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J grad]</span> = <span class="title">nnCostFunction</span><span class="params">(nn_params, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   input_layer_size, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   hidden_layer_size, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   num_labels, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   X, y, lambda)</span></span></span><br><span class="line"><span class="comment">%NNCOSTFUNCTION Implements the neural network cost function for a two layer</span></span><br><span class="line"><span class="comment">%neural network which performs classification</span></span><br><span class="line"><span class="comment">%   [J grad] = NNCOSTFUNCTON(nn_params, hidden_layer_size, num_labels, ...</span></span><br><span class="line"><span class="comment">%   X, y, lambda) computes the cost and gradient of the neural network. The</span></span><br><span class="line"><span class="comment">%   parameters for the neural network are &quot;unrolled&quot; into the vector</span></span><br><span class="line"><span class="comment">%   nn_params and need to be converted back into the weight matrices. </span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">%   The returned parameter grad should be a &quot;unrolled&quot; vector of the</span></span><br><span class="line"><span class="comment">%   partial derivatives of the neural network.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Reshape nn_params back into the parameters Theta_1 and Theta_2, the weight matrices</span></span><br><span class="line"><span class="comment">% for our 2 layer neural network</span></span><br><span class="line">Theta_1 = <span class="built_in">reshape</span>(nn_params(<span class="number">1</span>:hidden_layer_size * (input_layer_size + <span class="number">1</span>)), ...</span><br><span class="line">                 hidden_layer_size, (input_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Theta_2 = <span class="built_in">reshape</span>(nn_params((<span class="number">1</span> + (hidden_layer_size * (input_layer_size + <span class="number">1</span>))):<span class="keyword">end</span>), ...</span><br><span class="line">                 num_labels, (hidden_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Setup some useful variables</span></span><br><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line">K = num_labels;</span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">Theta_1_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_1));</span><br><span class="line">Theta_2_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_2));</span><br><span class="line"></span><br><span class="line"><span class="comment">% y(5000x1) -&gt; Y(5000x10)</span></span><br><span class="line">Y = <span class="built_in">zeros</span>(m, K);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : m</span><br><span class="line">    Y(<span class="built_in">i</span>, y(<span class="built_in">i</span>)) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Feedforward</span></span><br><span class="line">a_1 = X;</span><br><span class="line">a_1_bias = [<span class="built_in">ones</span>(m, <span class="number">1</span>), a_1];</span><br><span class="line"></span><br><span class="line">z_2 = a_1_bias * Theta_1&#x27;;</span><br><span class="line">a_2 = sigmoid(z_2);</span><br><span class="line">a_2_bias = [<span class="built_in">ones</span>(m, <span class="number">1</span>), a_2];</span><br><span class="line"></span><br><span class="line">z_3 = a_2_bias * Theta_2&#x27;;</span><br><span class="line">a_3 = sigmoid(z_3);</span><br><span class="line">h = a_3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Cost Function</span></span><br><span class="line"><span class="comment">% for i = 1 : K</span></span><br><span class="line"><span class="comment">%     yK = Y(:, i);</span></span><br><span class="line"><span class="comment">%     hK = h(:, i);</span></span><br><span class="line"><span class="comment">%     J += 1/m * (-yK&#x27;*log(hK) - (1-yK)&#x27;*log(1-hK));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% J can be get by element-wise compute more elegantly.</span></span><br><span class="line">J = <span class="number">1</span>/m * sum(sum((-Y.*<span class="built_in">log</span>(h) - (<span class="number">1</span>-Y).*<span class="built_in">log</span>(<span class="number">1</span>-h))));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Regularize</span></span><br><span class="line">J = J + lambda/(<span class="number">2</span>*m) * (sum(sum(Theta_1(:, <span class="number">2</span>:<span class="keyword">end</span>).^<span class="number">2</span>)) + sum(sum(Theta_2(:, <span class="number">2</span>:<span class="keyword">end</span>).^<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Backpropagation</span></span><br><span class="line"></span><br><span class="line">delta_3 = a_3 .- Y;</span><br><span class="line">delta_2 = (delta_3 * Theta_2) .* sigmoidGradient([<span class="built_in">ones</span>(m, <span class="number">1</span>), z_2]);</span><br><span class="line"><span class="comment">% sigmoidGradient: return g = sigmoid(z) .* (1 - sigmoid(z));</span></span><br><span class="line">delta_2 = delta_2(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">Delta_1 = delta_2&#x27; * a_1_bias;</span><br><span class="line">Delta_2 = delta_3&#x27; * a_2_bias;</span><br><span class="line"></span><br><span class="line">Theta_1_grad = Delta_1 ./ m + lambda/m * [<span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_1, <span class="number">1</span>), <span class="number">1</span>), Theta_1(:, <span class="number">2</span>:<span class="keyword">end</span>)];</span><br><span class="line">Theta_2_grad = Delta_2 ./ m + lambda/m * [<span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_2, <span class="number">1</span>), <span class="number">1</span>), Theta_2(:, <span class="number">2</span>:<span class="keyword">end</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Unroll gradients</span></span><br><span class="line">grad = [Theta_1_grad(:) ; Theta_2_grad(:)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li>预测</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span> = <span class="title">predict</span><span class="params">(Theta1, Theta2, X)</span></span></span><br><span class="line"><span class="comment">%PREDICT Predict the label of an input given a trained neural network</span></span><br><span class="line"><span class="comment">%   p = PREDICT(Theta1, Theta2, X) outputs the predicted label of X given the</span></span><br><span class="line"><span class="comment">%   trained weights of a neural network (Theta1, Theta2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Useful values</span></span><br><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line">num_labels = <span class="built_in">size</span>(Theta2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">h1 = sigmoid([<span class="built_in">ones</span>(m, <span class="number">1</span>) X] * Theta1&#x27;);</span><br><span class="line">h2 = sigmoid([<span class="built_in">ones</span>(m, <span class="number">1</span>) h1] * Theta2&#x27;);</span><br><span class="line">[dummy, p] = <span class="built_in">max</span>(h2, [], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="4"><li>驱动</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">input_layer_size  = <span class="number">400</span>;  <span class="comment">% 20x20 Input Images of Digits</span></span><br><span class="line">hidden_layer_size = <span class="number">25</span>;   <span class="comment">% 25 hidden units</span></span><br><span class="line">num_labels = <span class="number">10</span>;          <span class="comment">% 10 labels, from 1 to 10   </span></span><br><span class="line">                          <span class="comment">% (note that we have mapped &quot;0&quot; to label 10)</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nInitializing Neural Network Parameters ...\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;Xy.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nTraining Neural Network... \n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%  value to see how more training helps.</span></span><br><span class="line">options = optimset(<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">lambda = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Create &quot;short hand&quot; for the cost function to be minimized</span></span><br><span class="line">costFunction = @(p) nnCostFunction(p, ...</span><br><span class="line">                                   input_layer_size, ...</span><br><span class="line">                                   hidden_layer_size, ...</span><br><span class="line">                                   num_labels, X, y, lambda);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Now, costFunction is a function that takes in only one argument (the</span></span><br><span class="line"><span class="comment">% neural network parameters)</span></span><br><span class="line">[nn_params, cost] = fmincg(costFunction, initial_nn_params, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Obtain Theta1 and Theta2 back from nn_params</span></span><br><span class="line">Theta1 = <span class="built_in">reshape</span>(nn_params(<span class="number">1</span>:hidden_layer_size * (input_layer_size + <span class="number">1</span>)), ...</span><br><span class="line">                 hidden_layer_size, (input_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(nn_params((<span class="number">1</span> + (hidden_layer_size * (input_layer_size + <span class="number">1</span>))):<span class="keyword">end</span>), ...</span><br><span class="line">                 num_labels, (hidden_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">pred = predict(Theta1, Theta2, X);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nTraining Set Accuracy: %f\n&#x27;</span>, <span class="built_in">mean</span>(double(pred == y)) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><p>优化目标：<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tx^{(i)})</p><ul><li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tx^{(i)})\large]</li><li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>当 $C$ 值比较大时，这个优化目标会选择将第一个求和项趋于零，这样优化目标就变成了：<br>$$<br>\begin{array}{l}<br>  \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2\\<br>  s.t. \quad \begin{array}{l}<pre><code>  \theta^Tx^&#123;(i)&#125; \ge 1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=1\\  \theta^Tx^&#123;(i)&#125; \le -1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=0</code></pre>  \end{array}<br>\end{array}<br>$$<br>由欧氏空间的知识：<br>$$<br>\begin{array}{ccl}<br>||u|| &amp;=&amp; \textrm{length of vector } u= \sqrt{u_1^2+u_2^2}\<br>p &amp;=&amp; \textrm{length of projection of } v \textrm{ onto } u \textrm{ (signed)} \ \<br>u^Tv &amp;=&amp; p \cdot ||u||<br>\end{array}<br>$$<br>上式可表示为：<br>$$<br>\begin{array}{l}<br>  \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2<br>  =\frac{1}{2}\Big(\sqrt{\sum_{j=1}^n\theta_j^2}\Big)^2<br>  =\frac{1}{2}||\theta||^2 \\<br>  s.t. \quad \begin{array}{l}<pre><code>  p^&#123;(i)&#125;\cdot ||\theta|| \ge 1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=1\\  p^&#123;(i)&#125;\cdot ||\theta|| \le -1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=0</code></pre>  \end{array}\\<br>  \textrm{where $p^{(i)}$ is the projection of $x^{(i)}$ onto the vector $\theta$.}<br>\end{array}<br>$$<br>SVM 会选择最大的间隙：</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gax9ziqe3sj324i0nu0z9.jpg" alt="屏幕快照 2019-10-31 12.58.43"></p><h5 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a>核方法</h5><p>面对如下分类问题：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaxa3eq7zuj30c5083gm3.jpg" alt="image-20191102114127170"></p><p>我们可以使用多项式来回归，例如，当 $\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1x_2+\theta_4x_1^2+\theta_5x_2^2+\cdots\ge 0$ 时预测 $y=1$；</p><p>这样有太多多项式比较麻烦，我们可以考虑如下方法：<br>$$<br>\begin{array}{lcl}<br>\textrm{Predict } y=1 &amp;\textrm{if}&amp;\theta_0+\theta_1f_1+\theta_2f_2+\theta_3f_3+\cdots\ge 0<br>\end{array}<br>$$<br>这里的 $f_1=x_1,f_2=x_2,f_3=x_1x_2,f_4=x_1^2,…$</p><p>我们用 $f_i$ 替换了多项式，避免了高次项的麻烦，那么如何确定 $f_i$？大概的思想如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jljliww8j30o90dmwjt.jpg" alt="image-20191102124615797"></p><p>为方便描述，假设我们只有 $x_0,x_1,x_2$，并且只打算构造 $f_1,f_2,f_3$。那么，不管 $x_0$（偏移项），我们从 $x_1$-$x_2$ 的图像中选择 3 个点，记为 $l^{(1)},l^{(2)},l^{(3)}$，称之为<em>标记点</em>。任给 $x$，我们通过计算其与各标记点的临近程度得到一组 $f_i$：<br>$$<br>f_i = \mathop{\textrm{similarity}}(x,l^{(i)}) = \exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{\sum_{j=1}^n(x_j-l_j^{(i)})^2}{2\sigma^2})<br>$$<br>这里具体的 similarity 函数称为<em>核函数</em>，核函数多种多样。我们这里写的是很常用的 $\exp(-\frac{\sum_{j=1}^n(x_j-l_j^{(i)})^2}{2\sigma^2})$ ，称为 Gaussian Kernel，他的代码实现如下：</p><p>由这种方法，我们知道，给定 $x$，对每个 $l^{(i)}$ 我们会得到一个 $f_i$，满足：</p><ol><li>当 $x$ 接近 $l^{(i)}$ 时</li></ol><p>$$<br>f_i \approx \lim_{x\to l^{(i)}}\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{0^2}{2\sigma^2}) = 1<br>$$</p><ol start="2"><li>当 $x$ 远离 $l^{(i)}$ 时</li></ol><p>$$<br>f_i \approx \lim_{||x-l^{(i)}||\to +\infin}\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{\infin^2}{2\sigma^2}) = 0<br>$$</p><p>$\sigma$ 的选择会影响 $f_i$ 值随 $x$ 远离 $l^{(i)}$ 而下降的速度，$\sigma^2$ 越大，$f_i$减小地越慢：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmrwo86pj30ph0dwwm1.jpg" alt="image-20191102132852867"></p><p>使用核方法，我们可以做出这种预测：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmzc2qq4j30ot0ditej.jpg" alt="image-20191102133600603"></p><p>当且仅当给定$x$临近$l^{(1)}$ 或 $l^{(2)}$ 时预测 1，否则预测 0.</p><h5 id="SVM-中使用核"><a href="#SVM-中使用核" class="headerlink" title="SVM 中使用核"></a>SVM 中使用核</h5><ol><li><p>给定训练集 $(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})$</p></li><li><p>选择标记点：$l^{(i)}=x^{(i)} \quad \textrm{for }i=1,2,\cdots,m$</p></li><li><p>对于样本 $x$，计算核：$f_i=\mathop{\textrm{similarity}}(x,l^{(i)}) \quad \textrm{for }i=1,2,\cdots,m$</p></li><li><p>令 $f=[f_0,f_1,f_2,\cdots,f_m]^T$，其中 $f_0 \equiv 1$。</p></li></ol><p>预测：</p><ul><li>给定 $x$，计算 $f\in\R^{m+1}$</li><li>预测 $y=1$ 如果 $\theta^Tf=\theta_0f_0+\theta_1f_1+\cdots\ge 0$</li></ul><p>训练：<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tf^{(i)})</p><ul><li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tf^{(i)})\large]</li><li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>实现：</li></ul><p>我们可以利用诸如 liblinear, libsvm 之类的库来得到 SVM 的 参数 $\theta$，要使用这些库，我们一般需要做以下工作：</p><ul><li>选择参数 $C$</li><li>选择核函数<ul><li><strong>No kernel</strong>（即线性核，亦即做逻辑回归：Predict $y=1$ if $\theta^Tx\ge0$），适用于 <strong>n大 m小</strong> 的情况（避免过拟合）</li><li><strong>Gaussian kernel</strong>（$f_i=\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})\textrm{ where } l^{(i)}=x^{(i)} \textrm{ for } i=1,\cdots,m$）适用于 <strong>m大 n小</strong> 的情况（可拟合更复杂的非线性边界）</li></ul></li><li>提供核函数（Gaussian kernel 为例）：</li></ul><p>$$<br>\begin{array}{l}<br>\textrm{function f = kernel(x1, x2)}\<br>\qquad \textrm{f} = \exp(-\frac{||\textrm{x1}-\textrm{x2}||^2}{2\sigma^2})\<br>\textrm{return}<br>\end{array}<br>$$</p><p>注意：使用 Gaussian Kernel 前务必做特征缩放！</p><p>👉无核函数的代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sim</span> = <span class="title">linearKernel</span><span class="params">(x1, x2)</span></span></span><br><span class="line"><span class="comment">%LINEARKERNEL returns a linear kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   sim = linearKernel(x1, x2) returns a linear kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   and returns the value in sim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Ensure that x1 and x2 are column vectors</span></span><br><span class="line">x1 = x1(:); x2 = x2(:);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the kernel</span></span><br><span class="line">sim = x1&#x27; * x2;  <span class="comment">% dot product</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>👉高斯核的代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sim</span> = <span class="title">gaussianKernel</span><span class="params">(x1, x2, sigma)</span></span></span><br><span class="line"><span class="comment">%RBFKERNEL returns a radial basis function kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   sim = gaussianKernel(x1, x2) returns a gaussian kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   and returns the value in sim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Ensure that x1 and x2 are column vectors</span></span><br><span class="line">x1 = x1(:); x2 = x2(:);</span><br><span class="line"></span><br><span class="line">sim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sim = <span class="built_in">exp</span>(-sum((x1 - x2).^<span class="number">2</span>) / (<span class="number">2</span> * sigma ^ <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>👉SVM 示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Load X, y, Xtest and ytest</span></span><br><span class="line">load(<span class="string">&#x27;data.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% SVM Parameters</span></span><br><span class="line">C = <span class="number">1</span>;         <span class="comment">% C = 1 ~ 100 is fine</span></span><br><span class="line">sigma = <span class="number">0.1</span>;    <span class="comment">% sigma = 0.03 ~ 0.1 gives somewhat good boundary, less is better</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% We set the tolerance and max_passes lower here so that the code will run</span></span><br><span class="line"><span class="comment">% faster. However, in practice, you will want to run the training to</span></span><br><span class="line"><span class="comment">% convergence.</span></span><br><span class="line">model= svmTrain(X, y, C, @(x1, x2) gaussianKernel(x1, x2, sigma)); </span><br><span class="line">p = svmPredict(model, Xtest);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;Test Accuracy: %f\n&#x27;</span>, <span class="built_in">mean</span>(double(p == ytest)) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h5 id="多元分类-2"><a href="#多元分类-2" class="headerlink" title="多元分类"></a>多元分类</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jul8myufj30mv0cz0xu.jpg" alt="image-20191102171432072"></p><h4 id="逻辑回归-vs-神经网络-vs-SVM"><a href="#逻辑回归-vs-神经网络-vs-SVM" class="headerlink" title="逻辑回归 vs 神经网络 vs SVM"></a>逻辑回归 vs 神经网络 vs SVM</h4><p>$n$ = 特征数（$x\in\R^{n+1}$）</p><p>$m$ = 训练样本数</p><ul><li>n相对于m大 （e.g. $n=10,000, m=10 \sim 1000$）<ul><li>逻辑回归，或 无核SVM</li></ul></li><li>n小、m适中（e.g. $n=1\sim1000,m=50,000$）<ul><li>用 Gaussian 核 SVM</li></ul></li><li>n小、m大<ul><li>创造/添加特征，然后用 逻辑回归或无核SVM</li></ul></li></ul><p>神经网络通常可以解决上述任何一种情况，但可能相对较慢。</p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习是只给x数据的，不给y。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n62mi54pj30lw0catay.jpg" alt="屏幕快照 2019-11-05 14.49.05"></p><h3 id="K-Means-聚类"><a href="#K-Means-聚类" class="headerlink" title="K-Means 聚类"></a>K-Means 聚类</h3><blockquote><p>把一堆东西自动分成K堆。</p></blockquote><p>输入：</p><ul><li>$K$：聚类的个数</li><li>${x^{(1)},x^{(2)},\cdots,x^{(m)}}$：训练集</li></ul><p>输出：</p><ul><li>$K$ 个类</li></ul><p>K-Means算法：<br>$$<br>\begin{array}{l}</p><p>\textrm{Randomly initialize $K$ cluster centroids $\mu_1, \mu_2,…\mu_k \in \R^n$}\<br>\textrm{Repeat }{\<br>\qquad \textrm{for $i=1$ to $m$:}\qquad\textrm{// Cluster assignment step}\<br>\qquad\qquad c^{(i)} := k \ \textrm{ s.t. } \min_k||x^{(i)}-\mu_k||^2 \<br>\qquad \textrm{for $k=1$ to $K$:}\qquad\textrm{// Move centroid step}\<br>\qquad\qquad \mu_k:= \textrm{average (mean) of points assigned to cluster $k$}\<br>}\</p><p>\end{array}<br>$$<br>代价函数：<br>$$<br>J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)=\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}-\mu_{c^{(i)}}||^2<br>$$<br>优化目标：<br>$$<br>\min_{<br>\begin{array}{c}<br>    {1}c^{(1)},\cdots,c^{(m)},\<br>    \mu_1,\cdots,\mu_K<br>\end{array}}<br>J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)<br>$$<br>得到较优解(不一定能得到最优解)的算法：<br>$$<br>\begin{array}{l}<br>\textrm{For $i=1$ to $100$ &lt;or 50~1000&gt; {}\<br>\qquad\textrm{Randomly initialize K-means.}\<br>\qquad\textrm{Run K-means. Get $c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_k$}\<br>\qquad\textrm{Compute cost function (distortion):}\<br>\qquad\qquad J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)\<br>\textrm{}}\<br>\textrm{pick clustering that gave lowest $J$.}<br>\end{array}<br>$$<br>$K$的选择：</p><ol><li>更具实际问题的需求易得；</li><li>选择拐点：<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaxja4d68ej30cb0c3jro.jpg" alt="image-20191106171612460"></li></ol><p>👉<strong>代码实现</strong></p><ol><li>找最近的类中心：</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idx</span> = <span class="title">findClosestCentroids</span><span class="params">(X, centroids)</span></span></span><br><span class="line"><span class="comment">%FINDCLOSESTCENTROIDS computes the centroid memberships for every example</span></span><br><span class="line"><span class="comment">%   idx = FINDCLOSESTCENTROIDS (X, centroids) returns the closest centroids</span></span><br><span class="line"><span class="comment">%   in idx for a dataset X where each row is a single example. idx = m x 1 </span></span><br><span class="line"><span class="comment">%   vector of centroid assignments (i.e. each entry in range [1..K])</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Set K</span></span><br><span class="line">K = <span class="built_in">size</span>(centroids, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">idx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X,<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(X, <span class="number">1</span>)</span><br><span class="line">    min_j = <span class="number">0</span>;</span><br><span class="line">    min_l = Inf;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : <span class="built_in">size</span>(centroids, <span class="number">1</span>)</span><br><span class="line">        l = sum((X(<span class="built_in">i</span>, :) - centroids(<span class="built_in">j</span>, :)) .^ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> l &lt;= min_l</span><br><span class="line">            min_j = <span class="built_in">j</span>;</span><br><span class="line">            min_l = l;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    idx(<span class="built_in">i</span>) = min_j;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>计算中心:</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">centroids</span> = <span class="title">computeCentroids</span><span class="params">(X, idx, K)</span></span></span><br><span class="line"><span class="comment">%COMPUTECENTROIDS returns the new centroids by computing the means of the </span></span><br><span class="line"><span class="comment">%data points assigned to each centroid.</span></span><br><span class="line"><span class="comment">%   centroids = COMPUTECENTROIDS(X, idx, K) returns the new centroids by </span></span><br><span class="line"><span class="comment">%   computing the means of the data points assigned to each centroid. It is</span></span><br><span class="line"><span class="comment">%   given a dataset X where each row is a single data point, a vector</span></span><br><span class="line"><span class="comment">%   idx of centroid assignments (i.e. each entry in range [1..K]) for each</span></span><br><span class="line"><span class="comment">%   example, and K, the number of centroids. You should return a matrix</span></span><br><span class="line"><span class="comment">%   centroids, where each row of centroids is the mean of the data points</span></span><br><span class="line"><span class="comment">%   assigned to it.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Useful variables</span></span><br><span class="line">[m n] = <span class="built_in">size</span>(X);</span><br><span class="line"></span><br><span class="line">centroids = <span class="built_in">zeros</span>(K, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : K</span><br><span class="line">    ck = <span class="built_in">find</span>(idx == <span class="built_in">i</span>);</span><br><span class="line">    centroids(<span class="built_in">i</span>, :) = sum(X(ck,:)) / <span class="built_in">size</span>(ck, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li>运行K-Means</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[centroids, idx]</span> = <span class="title">runkMeans</span><span class="params">(X, initial_centroids, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                      max_iters, plot_progress)</span></span></span><br><span class="line"><span class="comment">%RUNKMEANS runs the K-Means algorithm on data matrix X, where each row of X</span></span><br><span class="line"><span class="comment">%is a single example</span></span><br><span class="line"><span class="comment">%   [centroids, idx] = RUNKMEANS(X, initial_centroids, max_iters, ...</span></span><br><span class="line"><span class="comment">%   plot_progress) runs the K-Means algorithm on data matrix X, where each </span></span><br><span class="line"><span class="comment">%   row of X is a single example. It uses initial_centroids used as the</span></span><br><span class="line"><span class="comment">%   initial centroids. max_iters specifies the total number of interactions </span></span><br><span class="line"><span class="comment">%   of K-Means to execute. plot_progress is a true/false flag that </span></span><br><span class="line"><span class="comment">%   indicates if the function should also plot its progress as the </span></span><br><span class="line"><span class="comment">%   learning happens. This is set to false by default. runkMeans returns </span></span><br><span class="line"><span class="comment">%   centroids, a Kxn matrix of the computed centroids and idx, a m x 1 </span></span><br><span class="line"><span class="comment">%   vector of centroid assignments (i.e. each entry in range [1..K])</span></span><br><span class="line"><span class="comment">% 若使用 plot_progress 需要额外的画图函数实现，这里没有给出.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Set default value for plot progress</span></span><br><span class="line"><span class="keyword">if</span> ~exist(<span class="string">&#x27;plot_progress&#x27;</span>, <span class="string">&#x27;var&#x27;</span>) || <span class="built_in">isempty</span>(plot_progress)</span><br><span class="line">    plot_progress = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the data if we are plotting progress</span></span><br><span class="line"><span class="keyword">if</span> plot_progress</span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize values</span></span><br><span class="line">[m n] = <span class="built_in">size</span>(X);</span><br><span class="line">K = <span class="built_in">size</span>(initial_centroids, <span class="number">1</span>);</span><br><span class="line">centroids = initial_centroids;</span><br><span class="line">previous_centroids = centroids;</span><br><span class="line">idx = <span class="built_in">zeros</span>(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Run K-Means</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:max_iters</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Output progress</span></span><br><span class="line">    fprintf(<span class="string">&#x27;K-Means iteration %d/%d...\n&#x27;</span>, <span class="built_in">i</span>, max_iters);</span><br><span class="line">    <span class="keyword">if</span> exist(<span class="string">&#x27;OCTAVE_VERSION&#x27;</span>)</span><br><span class="line">        fflush(stdout);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% For each example in X, assign it to the closest centroid</span></span><br><span class="line">    idx = findClosestCentroids(X, centroids);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Optionally, plot progress here</span></span><br><span class="line">    <span class="keyword">if</span> plot_progress</span><br><span class="line">        plotProgresskMeans(X, centroids, previous_centroids, idx, K, <span class="built_in">i</span>);</span><br><span class="line">        previous_centroids = centroids;</span><br><span class="line">        fprintf(<span class="string">&#x27;Press enter to continue.\n&#x27;</span>);</span><br><span class="line">        input(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Given the memberships, compute new centroids</span></span><br><span class="line">    centroids = computeCentroids(X, idx, K);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Hold off if we are plotting progress</span></span><br><span class="line"><span class="keyword">if</span> plot_progress</span><br><span class="line">    <span class="built_in">hold</span> off;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="4"><li>驱动脚本：</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Load an example dataset</span></span><br><span class="line">load(<span class="string">&#x27;data.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Settings for running K-Means</span></span><br><span class="line">K = <span class="number">3</span>;</span><br><span class="line">max_iters = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% For consistency, here we set centroids to specific values</span></span><br><span class="line"><span class="comment">% but in practice you want to generate them automatically, such as by</span></span><br><span class="line"><span class="comment">% settings them to be random examples (as can be seen in</span></span><br><span class="line"><span class="comment">% kMeansInitCentroids).</span></span><br><span class="line">initial_centroids = [<span class="number">3</span> <span class="number">3</span>; <span class="number">6</span> <span class="number">2</span>; <span class="number">8</span> <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Run K-Means algorithm. The &#x27;true&#x27; at the end tells our function to plot</span></span><br><span class="line"><span class="comment">% the progress of K-Means</span></span><br><span class="line">[centroids, idx] = runkMeans(X, initial_centroids, max_iters, <span class="built_in">true</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;\nK-Means Done.\n\n&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="PCA-维数约减"><a href="#PCA-维数约减" class="headerlink" title="PCA 维数约减"></a>PCA 维数约减</h3><blockquote><p>主成分分析：把n维的数据(投影)降到k维，略去不重要的部分(k&lt;=n)。</p></blockquote><p><strong>PCA算法</strong>：</p><ol><li><p>数据预处理</p><p>训练集：$x^{(1)},x^{(2)},\cdots,x^{(m)}$</p><p>预处理(feature scaling &amp; mean normalization):</p><ul><li><p>$\mu_j=\frac{1}{m}\sum_{i=1}^m x_j^{(i)},\qquad s_j=\textrm{standard deviation of feature }j$</p></li><li><p>Replace each $x_j^{(i)}$ with $\frac{x_j-\mu_j}{s_j}$</p></li></ul></li></ol><p>2)降维</p><ol><li>计算协方差矩阵$\Sigma$（这个矩阵记做大Sigma，注意和求和号区分）：<br>$$<br>\Sigma = \frac{1}{m}\sum_{i=1}^n(x^{(i)})(x^{(i)})^T<br>$$</li><li>求$\Sigma$的特征值(实际上是奇异值分解)：<code>[U, S, V] = svd(Sigma);</code></li><li>从上一步svd得到:<br>$$<br>U = \left[\begin{array}{cccc}<br>| &amp; | &amp;  &amp; |\<br>u^{(1)} &amp; u^{(2)} &amp; \cdots &amp; u^{(n)}\<br>| &amp; | &amp;  &amp; |<br>\end{array}\right]<br>\in \R^{n\times n}<br>\Rightarrow<br>U_{reduce}=\left[\begin{array}{cccc}<br>| &amp; | &amp;  &amp; |\<br>u^{(1)} &amp; u^{(2)} &amp; \cdots &amp; u^{(k)}\<br>| &amp; | &amp;  &amp; |<br>\end{array}\right]<br>$$</li><li>完成降维：$x\in\R^n\to z\in\R^k$:<br>$$<br>z = U_{reduce}^Tx<br>=\left[\begin{array}{ccc}</li></ol><p>   – &amp; (u^{(1)})^T &amp; –\<br>    &amp; \vdots &amp; \<br>   – &amp; (u^{(k)})^T &amp; –\<br>   \end{array}\right]x<br>$$</p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% do feature scaling &amp; mean normalization</span></span><br><span class="line"></span><br><span class="line">Sigma = <span class="number">1</span>/m * X&#x27; * X;</span><br><span class="line">[U, S, V] = svd(Sigma);</span><br><span class="line"></span><br><span class="line">Ureduce = U(:, <span class="number">1</span>:K);</span><br><span class="line">Z = X * Ureduce;</span><br></pre></td></tr></table></figure><p><strong>数据复原</strong>：将数据还原到原来的维度（$z\in\R^k \to x_{approx}\in\R^n$）：<br>$$<br>x_{approx}=U_{reduce}z<br>$$<br>一般情况下 $x \neq x_{approx}$，我们只能期望 $x_{approx}$ 尽量接近 $x$. </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ta88gafkj30oz0djaeo.jpg" alt="image-20191110215011122"></p><p><strong>$k$(主成分个数)的选择</strong></p><p>一般，选择 $k$ 为使得下式成立的最小值：<br>$$<br>\frac{\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}\le0.01<br>$$<br>算法：<br>$$<br>\begin{array}{l}<br>\textrm{Try PCA with } k=1,\cdots,n:\<br>\quad \textrm{Compute } U_{reduce},z^{(1)},\cdots,z^{(m)},x_{approx}^{(1)},\cdots,x_{approx}^{m}\<br>\quad \textrm{Check if } \frac{\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}\le0.01<br>\end{array}<br>$$</p><h3 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h3><blockquote><p>从一堆数据中找出异常于其他的。</p></blockquote><p>问题描述：给定数据集 ${x^{(1)},x^{(2)},\cdots,x^{(m)}}$，通过训练，判断 $x_{test}$ 是否异常。</p><p>要解决这个问题，我们可以对$p(x)$（概率）建立一个模型，选择一个临界值 $\epsilon$，使：<br>$$<br>\begin{array}{l}<br>p(x_{test})&lt;\epsilon \Rightarrow \textrm{anomaly}\<br>p(x_{test})\ge\epsilon \Rightarrow \textrm{OK}<br>\end{array}<br>$$<br>这样问题可以转化为<em>密度值估计</em>。我们常用高斯分布解决这个问题。</p><h4 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h4><p>$x$ 服从高斯分布：$x \sim \mathcal{N}(\mu,\sigma^2)$</p><p>则，$x$ 的概率为：<br>$$<br>p(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)<br>$$<br>其中参数 $\mu$ 和 $\sigma$ 由下式确定（这是在机器学习里常用的格式，不一定和数学里的一样）：<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}<br>$$</p><p>$$<br>\sigma^2=\frac{1}{m}\sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^2<br>$$</p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[mu sigma2]</span> = <span class="title">estimateGaussian</span><span class="params">(X)</span></span></span><br><span class="line"><span class="comment">%ESTIMATEGAUSSIAN This function estimates the parameters of a </span></span><br><span class="line"><span class="comment">%Gaussian distribution using the data in X</span></span><br><span class="line"><span class="comment">%   [mu sigma2] = estimateGaussian(X), </span></span><br><span class="line"><span class="comment">%   The input X is the dataset with each n-dimensional data point in one row</span></span><br><span class="line"><span class="comment">%   The output is an n-dimensional vector mu, the mean of the data set</span></span><br><span class="line"><span class="comment">%   and the variances sigma^2, an n x 1 vector</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Useful variables</span></span><br><span class="line">[m, n] = <span class="built_in">size</span>(X);</span><br><span class="line"></span><br><span class="line">mu = <span class="built_in">zeros</span>(n, <span class="number">1</span>);</span><br><span class="line">sigma2 = <span class="built_in">zeros</span>(n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mu = <span class="built_in">mean</span>(X);</span><br><span class="line">sigma2 = var(X) * (m - <span class="number">1</span>) / m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>借此我们便可得到异常检查算法：</p><h5 id="异常检查算法"><a href="#异常检查算法" class="headerlink" title="异常检查算法"></a>异常检查算法</h5><ol><li>选择认为可能表现出样本异常的数据特征 $x_i$</li><li>计算参数 $\mu_1,\cdots,\mu_n,\sigma_1^2,\cdots,\sigma_n^2$ </li></ol><p>$$<br>\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}<br>$$</p><p>$$<br>\sigma^2=\frac{1}{m}\sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^2<br>$$</p><ol start="3"><li>对于新给的样本 $x$，计算 $p(x)$：</li></ol><p>$$<br>p(x)=\prod_{j=1}^{n}p(x_j;\mu_j,\sigma_j^2)=\prod_{j=1}^{n}\frac{1}{\sqrt{2\pi}\sigma_j}\exp\left(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2}\right)<br>$$</p><ol start="4"><li>如果$p(x)&lt;\epsilon$，则预测异常。</li></ol><h4 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h4><p>$$<br>p(x;\mu,\Sigma)=\frac<br>{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}<br>$$</p><p>参数：</p><ul><li>$\mu\in\R^n$</li><li>$\Sigma\in\R^{n\times n}$ (covariance matrix, <code>Sigma = 1/m * X&#39; * X;</code>)</li></ul><p>参数的计算：<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)} \qquad<br>\Sigma=\frac{1}{m}\sum_{i=1}^m\left(x^{(i)}-\mu\right)\left(x^{(i)}-\mu\right)^T<br>$$</p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span> = <span class="title">multivariateGaussian</span><span class="params">(X, mu, Sigma2)</span></span></span><br><span class="line"><span class="comment">%MULTIVARIATEGAUSSIAN Computes the probability density function of the</span></span><br><span class="line"><span class="comment">%multivariate gaussian distribution.</span></span><br><span class="line"><span class="comment">%    p = MULTIVARIATEGAUSSIAN(X, mu, Sigma2) Computes the probability </span></span><br><span class="line"><span class="comment">%    density function of the examples X under the multivariate gaussian </span></span><br><span class="line"><span class="comment">%    distribution with parameters mu and Sigma2. If Sigma2 is a matrix, it is</span></span><br><span class="line"><span class="comment">%    treated as the covariance matrix. If Sigma2 is a vector, it is treated</span></span><br><span class="line"><span class="comment">%    as the \sigma^2 values of the variances in each dimension (a diagonal</span></span><br><span class="line"><span class="comment">%    covariance matrix)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">k = <span class="built_in">length</span>(mu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span>(Sigma2, <span class="number">2</span>) == <span class="number">1</span>) || (<span class="built_in">size</span>(Sigma2, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    Sigma2 = <span class="built_in">diag</span>(Sigma2);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">X = <span class="built_in">bsxfun</span>(@minus, X, mu(:)&#x27;);</span><br><span class="line">p = (<span class="number">2</span> * <span class="built_in">pi</span>) ^ (- k / <span class="number">2</span>) * det(Sigma2) ^ (<span class="number">-0.5</span>) * ...</span><br><span class="line">    <span class="built_in">exp</span>(<span class="number">-0.5</span> * sum(<span class="built_in">bsxfun</span>(@times, X * pinv(Sigma2), X), <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="用多元高斯分布的异常检查"><a href="#用多元高斯分布的异常检查" class="headerlink" title="用多元高斯分布的异常检查"></a>用多元高斯分布的异常检查</h5><ol><li>拟合多元高斯分布的 $p(x)$ 模型，通过参数：</li></ol><p>$$<br>\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)} \qquad<br>\Sigma=\frac{1}{m}\sum_{i=1}^m\left(x^{(i)}-\mu\right)\left(x^{(i)}-\mu\right)^T<br>$$</p><ol start="2"><li>对于新给 $x$，计算：</li></ol><p>$$<br>p(x)=\frac<br>{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}<br>$$</p><ol start="3"><li>如果$p(x)&lt;\epsilon$，则预测异常。</li></ol><h4 id="门槛选择"><a href="#门槛选择" class="headerlink" title="门槛选择"></a>门槛选择</h4><p>通过计算 $F_1$ 值可以得到最适合的 $\epsilon$。</p><p>$F_1$ 值由 precision ($prec$) 和 recall ($rec$) 给出：<br>$$<br>F_1=\frac{2\cdot prec \cdot rec}{prec+rec}<br>$$<br>其中：<br>$$<br>prec = \frac{tp}{tp+fp}<br>$$</p><p>$$<br>rec = \frac{tp}{tp+fn}<br>$$</p><ul><li>$tp$ 是 true positives：预测为正，实际也为正</li><li>$fp$ 是 false positives：预测为正，实际为负</li><li>$fn$ 是 false negatives：预测为负，实际为正</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bmwqbebxj30po0dgahc.jpg" alt="image-20191026152903469"></p><p>👉代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[bestEpsilon bestF1]</span> = <span class="title">selectThreshold</span><span class="params">(yval, pval)</span></span></span><br><span class="line"><span class="comment">%SELECTTHRESHOLD Find the best threshold (epsilon) to use for selecting</span></span><br><span class="line"><span class="comment">%outliers</span></span><br><span class="line"><span class="comment">%   [bestEpsilon bestF1] = SELECTTHRESHOLD(yval, pval) finds the best</span></span><br><span class="line"><span class="comment">%   threshold to use for selecting outliers based on the results from a</span></span><br><span class="line"><span class="comment">%   validation set (pval) and the ground truth (yval).</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">bestEpsilon = <span class="number">0</span>;</span><br><span class="line">bestF1 = <span class="number">0</span>;</span><br><span class="line">F1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">stepsize = (<span class="built_in">max</span>(pval) - <span class="built_in">min</span>(pval)) / <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> epsilon = <span class="built_in">min</span>(pval):stepsize:<span class="built_in">max</span>(pval)</span><br><span class="line"></span><br><span class="line">    cvPredictions = pval &lt; epsilon;</span><br><span class="line">    </span><br><span class="line">    tp = sum((cvPredictions == <span class="number">1</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    fp = sum((cvPredictions == <span class="number">1</span>) &amp; (yval == <span class="number">0</span>));</span><br><span class="line">    fn = sum((cvPredictions == <span class="number">0</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    prec = tp / (tp + fp);</span><br><span class="line">    rec = tp / (tp + fn);</span><br><span class="line"></span><br><span class="line">    F1 = (<span class="number">2</span> * prec * rec) / (prec + rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> F1 &gt; bestF1</span><br><span class="line">       bestF1 = F1;</span><br><span class="line">       bestEpsilon = epsilon;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><blockquote><p>通过评分，推荐用户新内容。</p></blockquote><p>符号说明：（假设我们要推荐的东西是电影）</p><ul><li>$n_u$ = 用户数</li><li>$n_m$ = 电影数</li><li>$r(i,j)=1$ 若用户 $j$ 对电影 $i$ 评过分，否则为 0</li><li>$y^{(i,j)}$ = 用户 $j$ 给电影 $i$ 的评分(只有当 $r(i,j)=1$ 时才有定义)</li></ul><h4 id="基于内容推荐"><a href="#基于内容推荐" class="headerlink" title="基于内容推荐"></a>基于内容推荐</h4><p><strong>预测模型</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9bi5bv4etj30nz06lac1.jpg" alt="屏幕快照 2019-11-26 16.04.26"></p><ul><li>$r(i,j)=1$ 若用户 $j$ 对电影 $i$ 评过分</li><li>$y^{(i,j)}$ = 用户 $j$ 给电影 $i$ 的评分(如果有定义)</li><li>$\theta^{(j)}$ 用户 $j$ 的参数（向量）</li><li>$x^{(i)}$ 电影 $i$ 的特征（向量）</li></ul><p>对于用户 $j$，电影 $i$，预测评分：$(\theta^{(j)})^T(x^{(i)})$。</p><p><strong>优化目标</strong>：</p><ol><li>优化 $\theta^{(j)}$ （对于单个用户 $j$ 的参数）</li></ol><p>$$<br>\min_{\theta^{(j)}}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$</p><ol start="2"><li>优化 $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$（对所有用户）</li></ol><p>$$<br>\min_{\theta^{(1)},\cdots,\theta^{(n_u)}}<br>\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$</p><p>我们可以用梯度下降解决问题：<br>$$<br>\begin{array}{l}<br>Repeat\quad{\<br>\qquad \theta_0^{(j)}:=\theta_0^{(j)}-\alpha\sum_{i:r(i,j)=1} \big((\theta^{(j)})^T(x^{(i)})-y^{(i,j)}\big)x_0^{(i)}\<br>\qquad \theta_k^{(j)}:=\theta_k^{(j)}-\alpha\Big[\Big(\sum_{i:r(i,j)=1}\big((\theta^{(j)})^T(x^{(i)})-y^{(i)}\big)x_k^{(i)}\Big)+\lambda\theta_k^{(j)}\Big]\qquad (\textrm{for } k \neq 0)\<br>}<br>\end{array}<br>$$</p><h4 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h4><p>在基于内容推荐中我们有时会很难把握电影（我们要推荐的东西）有哪些特征（$x^{(i)}$），我们想让机器学习自己找特征，这就用到协同过滤。</p><p><strong>新加的优化目标</strong>：（之前在基于内容推荐里面的优化目标仍需考虑）</p><ul><li>给定 $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$，学习 $x^{(i)}$:</li></ul><p>$$<br>\min_{x^{(i)}}\frac{1}{2}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p><ul><li>给定 $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$ ，学习 $x^{(1)},\cdots,x^{(n_m)}$ ：</li></ul><p>$$<br>\min_{x^{(1)},\cdots,x^{(n_m)}}\frac{1}{2}<br>\sum_{i=1}^{n_m}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p><p><strong>协同过滤</strong>：</p><p>现在我们的问题是即没有训练好的 $\theta$，又没有一组充分优化的 $x$，但学习 $\theta$ 要先有 $x$，学习 $x$ 要先有 $\theta$。这就变成了一个类似鸡生蛋、蛋生鸡的问题。</p><p>我们可以考虑这样解决这个难题：</p><p>首先随机猜一组 $\theta$，然后用这组 $\theta$ 就可以得到一组 $x$；用这组得到的 $x$ 又可以优化 $\theta$，优化后的 $\theta$ 又拿来优化 $x$ …… 不断重复这个过程，我们可以期望得到一组 $x$ 和 $\theta$ 都充分优化的解（事实上它们最终是会收敛的）。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ds8xkjatj30ob0bd0w0.jpg" alt="屏幕快照 2019-11-28 15.20.59"><br>$$<br>\begin{array}{l}</p><p>\textrm{Given }<br>x^{(1)},\cdots,x^{(n_m)}<br>\textrm{ , estimate }<br>\theta^{(1)},\cdots,\theta^{(n_u)}:\<br>\quad<br>\min_{\theta^{(1)},\cdots,\theta^{(n_u)}}<br>\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2\</p><p>\textrm {Given }<br>\theta^{(1)},\cdots,\theta^{(n_u)}<br>\textrm{ , estimate }<br>x^{(1)},\cdots,x^{(n_m)}:\<br>\quad<br>\min_{x^{(1)},\cdots,x^{(n_m)}}\frac{1}{2}<br>\sum_{i=1}^{n_m}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>\end{array}<br>$$<br>我们随机初始化一组参数，然后重复来回计算 $\theta$ 和 $x$，最终会得到解，但这样比较麻烦，我们可以做的更高效：</p><p><strong>同时</strong>优化 $x^{(1)},\cdots,x^{(n_m)}$ 和 $\theta^{(1)},\cdots,\theta^{(n_u)}$:<br>$$<br>J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})=<br>\frac{1}{2}<br>\sum_{(i,j):r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2+<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p><p>$$<br>\min_{\begin{array}{c}x^{(1)},\cdots,x^{(n_m)}\\theta^{(1)},\cdots,\theta^{(n_u)}\end{array}}<br>J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})<br>$$</p><p><strong>协同过滤算法</strong>：</p><ol><li>将 $x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)}$ 随机初始化为一些比较小的随机值</li><li>优化 $J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})$</li><li>对于给定用户，该用户的参数是 $\theta$，则用训练得到的某电影的特征 $x$ ，我们可以预测该用户可能为此电影评分：$\theta^Tx$。</li></ol><p><strong>低秩矩阵分解</strong>：</p><p>我们可以看到，我们最终的预测是这样的：<br>$$<br>Predict = \left[\begin{array}{ccccc} (x^{(1)})^T(\theta^{(1)}) &amp; \ldots &amp; (x^{(1)})^T(\theta^{(n_u)})\ \vdots &amp; \ddots &amp; \vdots \ (x^{(n_m)})^T(\theta^{(1)}) &amp; \ldots &amp; (x^{(n_m)})^T(\theta^{(n_u)})\end{array}\right]<br>$$<br>考虑到几乎不可能有用户把接近所有的电影都评分，这个预测矩阵是稀疏的，存储这个矩阵会造成大量浪费，不妨令：<br>$$<br>X = \left[\begin{array}{ccc}</p><ul><li>&amp; (x^{(1)})^T &amp; - \<br>&amp; \vdots &amp; \</li><li>&amp; (x^{(n_m)})^T &amp; - \<br>\end{array}\right],<br>\qquad<br>\Theta = \left[\begin{array}{ccc}</li><li>&amp; (\theta^{(1)})^T &amp; - \<br>&amp; \vdots &amp; \</li><li>&amp; (\theta^{(n_u)})^T &amp; - \<br>\end{array}\right]<br>$$<br>则有：<br>$$<br>Predict=X\Theta^T<br>$$<br>我们便将它分为了两部分。用这个方法求取 $X$ 和 $\Theta$，获得推荐系统需要的参数，称之为<strong>低秩矩阵分解</strong>。该方法不仅能在编程时直接通过向量化的手法获得参数，还通过矩阵分解节省了内存空间。</li></ul><p><strong>寻找相关电影</strong>：</p><p>我们常需要推荐与电影 $i$ 相关的电影 $j$，可以这样找到：<br>$$<br>\mathop{\textrm{smallest}} ||x^{(i)}-x^{(j)}||<br>$$<br><strong>均值归一化处理</strong>：</p><p>再电影推荐问题中，由于评分总是1到5分（或其他范围），故不用特征缩放，但可以做 mean normalization：<br>$$<br>\mu_i=\mathop{\textrm{average}} y^{(i,:)}<br>$$</p><p>$$<br>Y_i = Y_i-\mu_i<br>$$</p><p>对用户 $j$, 电影 $i$, 预测:<br>$$<br>\left(\Theta^{(j)}\right)^T\left(x^{(i)}\right)+\mu_i<br>$$<br>👉<strong>代码实现</strong>：</p><ol><li>代价函数：</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J, grad]</span> = <span class="title">cofiCostFunc</span><span class="params">(params, Y, R, num_users, num_movies, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                  num_features, lambda)</span></span></span><br><span class="line"><span class="comment">%COFICOSTFUNC Collaborative filtering cost function</span></span><br><span class="line"><span class="comment">%   [J, grad] = COFICOSTFUNC(params, Y, R, num_users, num_movies, ...</span></span><br><span class="line"><span class="comment">%   num_features, lambda) returns the cost and gradient for the</span></span><br><span class="line"><span class="comment">%   collaborative filtering problem.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Unfold the U and W matrices from params</span></span><br><span class="line">X = <span class="built_in">reshape</span>(params(<span class="number">1</span>:num_movies*num_features), num_movies, num_features);</span><br><span class="line">Theta = <span class="built_in">reshape</span>(params(num_movies*num_features+<span class="number">1</span>:<span class="keyword">end</span>), ...</span><br><span class="line">                num_users, num_features);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">X_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X));</span><br><span class="line">Theta_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta));</span><br><span class="line"></span><br><span class="line">h = X * Theta&#x27;;</span><br><span class="line">er = (h - Y) .* R;</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span>/<span class="number">2</span> * sum(sum(er.^<span class="number">2</span>));</span><br><span class="line">X_grad = er * Theta;</span><br><span class="line">Theta_grad = er&#x27; * X; </span><br><span class="line"></span><br><span class="line"><span class="comment">% Regularized</span></span><br><span class="line"></span><br><span class="line">J += lambda/<span class="number">2</span> *(sum(sum(Theta.^<span class="number">2</span>)) + sum(sum(X.^<span class="number">2</span>)));</span><br><span class="line">X_grad += lambda * X;</span><br><span class="line">Theta_grad += lambda * Theta;</span><br><span class="line">grad = [X_grad(:); Theta_grad(:)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>均值归一</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Ynorm, Ymean]</span> = <span class="title">normalizeRatings</span><span class="params">(Y, R)</span></span></span><br><span class="line"><span class="comment">%NORMALIZERATINGS Preprocess data by subtracting mean rating for every </span></span><br><span class="line"><span class="comment">%movie (every row)</span></span><br><span class="line"><span class="comment">%   [Ynorm, Ymean] = NORMALIZERATINGS(Y, R) normalized Y so that each movie</span></span><br><span class="line"><span class="comment">%   has a rating of 0 on average, and returns the mean rating in Ymean.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">size</span>(Y);</span><br><span class="line">Ymean = <span class="built_in">zeros</span>(m, <span class="number">1</span>);</span><br><span class="line">Ynorm = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Y));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    idx = <span class="built_in">find</span>(R(<span class="built_in">i</span>, :) == <span class="number">1</span>);</span><br><span class="line">    Ymean(<span class="built_in">i</span>) = <span class="built_in">mean</span>(Y(<span class="built_in">i</span>, idx));</span><br><span class="line">    Ynorm(<span class="built_in">i</span>, idx) = Y(<span class="built_in">i</span>, idx) - Ymean(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li>驱动脚本</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%  Normalize Ratings</span></span><br><span class="line">[Ynorm, Ymean] = normalizeRatings(Y, R);</span><br><span class="line"></span><br><span class="line"><span class="comment">%  Useful Values</span></span><br><span class="line">num_users = <span class="built_in">size</span>(Y, <span class="number">2</span>);</span><br><span class="line">num_movies = <span class="built_in">size</span>(Y, <span class="number">1</span>);</span><br><span class="line">num_features = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set Initial Parameters (Theta, X)</span></span><br><span class="line">X = <span class="built_in">randn</span>(num_movies, num_features);</span><br><span class="line">Theta = <span class="built_in">randn</span>(num_users, num_features);</span><br><span class="line"></span><br><span class="line">initial_parameters = [X(:); Theta(:)];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set options for fmincg</span></span><br><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set Regularization</span></span><br><span class="line">lambda = <span class="number">10</span>;</span><br><span class="line">theta = fmincg (@(t)(cofiCostFunc(t, Ynorm, R, num_users, num_movies, ...</span><br><span class="line">                                num_features, lambda)), ...</span><br><span class="line">                initial_parameters, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Unfold the returned theta back into U and W</span></span><br><span class="line">X = <span class="built_in">reshape</span>(theta(<span class="number">1</span>:num_movies*num_features), num_movies, num_features);</span><br><span class="line">Theta = <span class="built_in">reshape</span>(theta(num_movies*num_features+<span class="number">1</span>:<span class="keyword">end</span>), ...</span><br><span class="line">                num_users, num_features);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;Recommender system learning completed.\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p = X * Theta&#x27;;</span><br><span class="line">my_predictions = p(:,<span class="number">1</span>) + Ymean;</span><br></pre></td></tr></table></figure><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据机器学习</title>
      <link href="/2019/12/17/AndrewNgML/AndrewNg-MachineLearning-17-LargeScaleMachineLearning/"/>
      <url>/2019/12/17/AndrewNgML/AndrewNg-MachineLearning-17-LargeScaleMachineLearning/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-17-Large-Scale-Machine-Learning"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-17-Large-Scale-Machine-Learning" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (17) Large Scale Machine Learning"></a>Notes of Andrew Ng’s Machine Learning —— (17) Large Scale Machine Learning</h1><h2 id="Gradient-Descent-with-Large-Datasets"><a href="#Gradient-Descent-with-Large-Datasets" class="headerlink" title="Gradient Descent with Large Datasets"></a>Gradient Descent with Large Datasets</h2><h3 id="Learning-With-Large-Datasets"><a href="#Learning-With-Large-Datasets" class="headerlink" title="Learning With Large Datasets"></a>Learning With Large Datasets</h3><p>When learning with large datasets, it can be high cost to do a gradient descent. So before we actually use this large datasets (say, $m = 100,000,000$) for model training, we’d better try to randomly pick a small part of data ($m=1,000$) from it and learning from it. If this subset works already satisfying, we’ll no longer need to do a learning with large dataset.</p><p>Suppose you are facing a supervised learning problem and have a very large dataset (m = 100,000,000). How can you tell if using all of the data is likely to perform much better than using a small subset of the data (say m = 1,000)?</p><p>What er can do is plotting  a learning curve for a range of values of m and verify that the algorithm has high variance when m is small.</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rn4jr6zxj30om07r0vl.jpg" alt="image-20191210150555045"></p><p>Facing a left-liked curve, maybe we use a large dataset can offer a better model. But if we get the curve like the right one, use a $m&gt;1000$ can not actually improve our model effectively.</p><h3 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h3><p>Before talking about the Stochastic Gradient Descent, let’s take a look at the gradient descent we used (Actually, it is called <em>Batch Gradient Descent</em>), A linear regression for example:</p><blockquote><p>$J_{\textrm{train}}(\theta)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2$ </p><p>Repeat {</p><p>​        $\quad \theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$    (for every $j=0,\cdots,n$)</p><p>}</p></blockquote><p>With this Batch Gradient Descent, every step we take will need to calculate the sum of derivatives of all data. If our dataset is large, the time cost will be very expensive.</p><p>To deal with a large dataset, here is the <em>Stochastic Gradient Descent</em>:</p><p>$$<br>\begin{array}{l}<br>cost\left(\theta,(x^{(i)},y^{(i)})\right)=\frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2\\<br>J_{train}(\theta)=\frac{1}{m}\sum_{i=1}^{m}cost\left(\theta,(x^{(i)},y^{(i)})\right)\\</p><p>1.\quad \textrm{Randomly shuffle(reorder) training examples}\<br>2.\quad \textrm{Repeat } { \<br>\qquad\qquad \textrm{for $i:= 1, \cdots,m$ } { \<br>\qquad\qquad\qquad\quad \theta_j:=\theta_j-\alpha(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} \quad \textrm{(for every $j=0,\cdots,n$)} \<br>\qquad\qquad\qquad\quad } \<br>\qquad\qquad } \<br>\end{array}<br>$$<br>Notice that, instead of calculate the sum of all derivatives and change the whole theta, in the inner for loop, each step we only care about the cost of one theta. When the training set size m is very large, stochastic gradient descent can be much faster than gradient descent.</p><p>Learning rate $\alpha$ is typically held constant. Can slowly decrease $\alpha$ over time if we want $\theta$ to converge better. (E.g. $\alpha=\frac{CONST_1}{iterationNumber+CONST_2}$)</p><h3 id="Mini-Batch-Gradient-Descent"><a href="#Mini-Batch-Gradient-Descent" class="headerlink" title="Mini-Batch Gradient Descent"></a>Mini-Batch Gradient Descent</h3><ul><li>Batch gradient descent: Use all $m$ examples in each iteration</li><li>Stochastic gradient descent: Use $1$ example in each iteration</li><li>Mini-batch gradient descent: Use $b$ examples in each iteration ($b\in[2, 100]$, Usual $10$)</li></ul><p>Mini-batch gradient descent sometimes faster than stochastic gradient descent:<br>$$<br>\begin{array}{l}<br>\textrm{Say $b=10,m=1000$.}\</p><p>\textrm{Repeat } { \<br>\qquad \textrm{for $i:= 1, 11, 21, 31, \cdots,991$ } { \<br>\qquad\qquad\quad \theta_j:=\theta_j-\alpha\frac{1}{10}\sum_{k=i}^{i+9}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} \quad \textrm{(for every $j=0,\cdots,n$)} \<br>\qquad\qquad\quad } \<br>} \<br>\end{array}<br>$$</p><h3 id="Stochastic-Gradient-Descent-Convergence"><a href="#Stochastic-Gradient-Descent-Convergence" class="headerlink" title="Stochastic Gradient Descent Convergence"></a>Stochastic Gradient Descent Convergence</h3><h4 id="Checking-for-convergence"><a href="#Checking-for-convergence" class="headerlink" title="Checking for convergence"></a>Checking for convergence</h4><ul><li><p><strong>Batch gradient descent</strong>:</p><p>Plot $J_{train}(\theta)$ as a function of the number of iterations of gradient descent.</p><p>$J_{train}(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2$</p></li><li><p><strong>Stochastic gradient descent</strong>:</p><p>$cost(\theta,(x^{(i)},y^{(i)}))=\frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2$</p><p>During learning, compute $cost(\theta,(x^{(i)},y^{(i)}))$ before updating $\theta$ using $(x^{(i)},y^{(i)})$.</p><p>Every 1000 iterations, plot $cost(\theta,(x^{(i)},y^{(i)}))$ averaged over the last 1000 examples processed by algorithm. (If we get a plot that is too noisy to see it’s converging or not, try ploting for every 5000 (or summat bigger than 1000) iterations rather than 1000)</p></li></ul><h2 id="Advanced-Topics"><a href="#Advanced-Topics" class="headerlink" title="Advanced Topics"></a>Advanced Topics</h2><h3 id="Online-Learning"><a href="#Online-Learning" class="headerlink" title="Online Learning"></a>Online Learning</h3><p>An online learning algorithm allows us to learn from a continuous stream of data (have no fixed dataset),  since we use each example once then no longer need to process it again. Another advantage of online learning is also that if we have a changing pool of users, or if the things we’re trying to predict are slowly changing, the online learning algorithm can slowly adapt our learned hypothesis to whatever the latest sets of user behaviors are like as well.</p><p>Here is an example:</p><blockquote><p>Shipping service website where user comes, specifies origin and destination, you offer to ship their package for some asking price, and users sometimes choose to use your shipping service ($y=1$), sometimes not ($y=0$).</p><p>Features $x$ capture properties of user, of origin/destination and asking price. We want to learn $p(y=1|x;\theta)$ to optimize price.</p></blockquote><p>Here is how an online learning version of logistic regression work for this problem:<br>$$<br>\begin{array}{l}<br>\textrm{Repeat forever } {\<br>\qquad \textrm{Get $(x,y)$ corresponding to user.}\<br>\qquad \textrm{Update $\theta$ using $(x,y)$:}\<br>\qquad \qquad \theta_j:=\theta_j-\alpha(h_\theta(x)-y)\cdot x_j (j=0,\cdots,n) \<br>}<br>\end{array}<br>$$</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ywywm9hgj30yg0ih79d.jpg" alt="image-20191216220518514"></p><h3 id="Map-Reduce-and-Data-Parallelism"><a href="#Map-Reduce-and-Data-Parallelism" class="headerlink" title="Map Reduce and Data Parallelism"></a>Map Reduce and Data Parallelism</h3><p>We can divide up batch gradient descent and dispatch the cost function for a subset of the data to many different machines so that we can train our algorithm in parallel.</p><p>You can split your training set into z subsets corresponding to the number of machines you have. On each of those machines calculate $\displaystyle \sum_{i=p}^{q}(h_{\theta}(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)}$, where we’ve split the data starting at p and ending at q.</p><p>MapReduce will take all these dispatched (or ‘mapped’) jobs and ‘reduce’ them by calculating:</p><p>$\Theta_j := \Theta_j - \alpha \dfrac{1}{z}(temp_j^{(1)} + temp_j^{(2)} + \cdots + temp_j^{(z)})$</p><p>For all $j=0,…,n$.</p><p>This is simply taking the computed cost from all the machines, calculating their average, multiplying by the learning rate, and updating theta.</p><p>Your learning algorithm is MapReduceable if it can be <em>expressed as computing sums of functions over the training set</em>. Linear regression and logistic regression are easily parallelizable.</p><p>For neural networks, you can compute forward propagation and back propagation on subsets of your data on many machines. Those machines can report their derivatives back to a ‘master’ server that will combine them.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 C# 语言实现跨平台小闹钟</title>
      <link href="/2019/12/10/blog/CSharpAlarm/"/>
      <url>/2019/12/10/blog/CSharpAlarm/</url>
      
        <content type="html"><![CDATA[<h1 id="利用-C-语言实现跨平台小闹钟"><a href="#利用-C-语言实现跨平台小闹钟" class="headerlink" title="利用 C# 语言实现跨平台小闹钟"></a>利用 C# 语言实现跨平台小闹钟</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学校的课程要求做一个 C# 小闹钟程序设计，具体要求如下：</p><ol><li>做一个小闹钟窗体应用程序。</li><li>具备实时显示数字时钟的功能，方便使用者获取当前的时间。</li><li>具备实时绘制表盘时钟的功能，根据当前时间再来绘制秒针、分针和时针。</li><li>具备整点报时的功能，当处于整点时，系统进行报时。</li><li>具备定点报时的功能，根据使用者的设定，进行报时。</li><li>把使用者设置的报时时间，记录在文本文件中，系统在启动时，自动加载该文本文件以便获取定点报时的时间。</li><li>系统最小化时，缩小为系统托盘。</li></ol><p>这个东西不难，就是最简单的 App 开发嘛，但要求用 C# 做 Windows 窗体就很烦。由于我不使用 Windows 系统，所以拿到题目，首先的想法就是<strong>跨平台</strong>，我希望在 Mac 上完成开发，然后直接打包发布到 Windows 平台。</p><p>以前看过好几个跨平台的开源的 UI 实现项目都是 C# 写的，比如 Pathos: Nethack Codex 用的 Invention。但因为我之前甚至从没用过 C#，所以对于它们具体的实现不是很了解。经过一阵 Google，我找到了 Microsoft 自家做的跨平台方案——Xamarin。</p><p>emmmm，Xamarin 还分好几个部分，Xamarin.Forms，Xamarin.Mac 什么的。其中，Xamarin.Forms 可以一套 UI 代码生成 Android、iOS、UWP(支持不完整，还是预览版)。这个框架下 Android、iOS 可以在 Mac 上用 Visual Studio for Mac 来开发并且生成，UWP 只能在 Windows 下生成。</p><p>这个东西感觉还不错，看文档里生成出来的 UI 效果挺好看的，代码也比较简单（相较于原生 Android 开发），所以我决定用这个 Xamarin.Forms 先在 Mac 下完成这个小闹钟的开发，然后借一台 Windows 电脑来生成 UWP。</p><p>决定了框架，然后就是 C# 基础语法和 Xamarin.Forms 的学习了。这两个东西微软都有详细的、针对各种不同技术水平的开发者的入门教程，顺着看一遍，把例子写一下也就足够完成这次的小闹钟任务了。</p><p>接下来就进入跨平台小闹钟开发的过程了。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>我们首先思考我们期望的 App 使用场景：用户点击打开 App，屏幕上显示出一个圆盘时钟，然后，可以从导航条（iOS 的习惯是底部，Android 和 UWP 为顶部）切换到一个现实这闹钟条目到界面，用户可以在这里点开一条闹钟条目进行编辑，或着添加新的闹钟条目。</p><p>iOS 自带的 “时钟” App 给了我们很好的参考（由于它没有圆盘时钟功能，我截了一张“就寝”界面替代😓）：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qnn9cnd8j31d50u0qft.jpg" alt="IMG_1573"></p><p>在我们的设计中，小闹钟 App 可以分为这样几个页面：</p><ul><li>🕤时钟页：显示一个圆盘时钟，展示当前时间；</li><li>⏰闹钟页：显示当前设定的所有闹钟条目，可以点开编辑、新建闹钟条目；</li><li>🧾详情页：新建、编辑一条闹钟的时间、注释的页面，并有保存、删除的功能。</li></ul><p>具体到 Xamarin.Forms 中，这些 Pages 如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qes7ga8nj30ea0ehmxj.jpg" alt="MyClockPagesDiagram"></p><p>然后，我们还需要设计另外一个重要的部分，一条“闹钟”的表示和储存。</p><p>可以考虑用一个 <code>AlarmItem</code> 类来代表一条闹钟，这个类要具有 唯一ID、时间、是否打开、注释 这几个属性。</p><p>在 Xamarin 中，我们可以很方便地引入 SQLite 储存这个对象，只需要写一个 <code>Database</code> 类，简单封装一下 CRUD，方便后续使用。</p><p>接下来就要开始代码实现了，先贴出最后成品截图，iOS上的效果：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qtdimzaxj31f20u0wop.jpg" alt="IMG_1576"></p><p>UWP 的效果：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9vdl50y0qj312o0u0gqs.jpg" alt="IMG_1600"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>整个 App 的基础大概有了，现在考虑一些实现的细节。</p><p>（在这里我只列出关键的或者任何我认为有意思的代码片段，完整代码见 <a href="https://github.com/cdfmlr/MyClock">GitHub</a>）</p><h3 id="圆盘时钟的实现"><a href="#圆盘时钟的实现" class="headerlink" title="圆盘时钟的实现"></a>圆盘时钟的实现</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qey1safbj305b05bmx7.jpg" alt="屏幕快照 2019-12-09 13.36.51"></p><p>绘制一个如上图所示的圆盘时钟，需要实时的矢量图绘制。Xamarin.Forms 不具有内置的矢量图形系统，但有一个 BoxView 可帮助进行补偿。<a href="https://docs.microsoft.com/zh-cn/dotnet/api/xamarin.forms.boxview">BoxView</a>  呈现指定的宽度、 高度和颜色的一个简单的矩形。参照微软的文档，我们可以按下面的思路实现一个时钟：</p><h4 id="表盘"><a href="#表盘" class="headerlink" title="表盘"></a>表盘</h4><p>对于表盘，通过简单的数学计算，就可以得到从12点开始的表盘上 60 个均匀分布的刻度点的位置坐标。在一个可以指定位置的 AbsoluteLayout 中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the tick marks</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tickMarks.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">tickMarks[i] = <span class="keyword">new</span> BoxView &#123; Color = Color.Black &#125;;</span><br><span class="line">absoluteLayout.Children.Add(tickMarks[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们生成了 60 个大小相同的正方形 BoxView，现将模5的点稍微加大，然后把它们放置到指定的位置，针对不同位置的正方形做一个使其正对中心的旋转，表盘就完成了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Size and position a tickMark</span></span><br><span class="line"><span class="built_in">double</span> size = radius / (index % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">15</span> : <span class="number">30</span>);</span><br><span class="line"><span class="built_in">double</span> radians = index * <span class="number">2</span> * Math.PI / tickMarks.Length;</span><br><span class="line"><span class="built_in">double</span> x = center.X + radius * Math.Sin(radians) - size / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">double</span> y = center.Y - radius * Math.Cos(radians) - size / <span class="number">2</span>;</span><br><span class="line">AbsoluteLayout.SetLayoutBounds(tickMarks[index], <span class="keyword">new</span> Rectangle(x, y, size, size));</span><br><span class="line">tickMarks[index].Rotation = <span class="number">180</span> * radians / Math.PI;</span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>接下来是指针，先在之前的 AbsoluteLayout 中实例化三个代表时分秒针的 BoxView：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AbsoluteLayout</span> <span class="attr">x:Name</span>=<span class="string">&quot;absoluteLayout&quot;</span> <span class="attr">SizeChanged</span>=<span class="string">&quot;OnAbsoluteLayoutSizeChanged&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BoxView</span> <span class="attr">x:Name</span>=<span class="string">&quot;hourHand&quot;</span> <span class="attr">Color</span>=<span class="string">&quot;Black&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BoxView</span> <span class="attr">x:Name</span>=<span class="string">&quot;minuteHand&quot;</span> <span class="attr">Color</span>=<span class="string">&quot;Black&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BoxView</span> <span class="attr">x:Name</span>=<span class="string">&quot;secondHand&quot;</span> <span class="attr">Color</span>=<span class="string">&quot;Black&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">AbsoluteLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写一个 <code>HandParams</code> 来指定三个时针的形状：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> HandParams</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandParams</span>(<span class="params"><span class="built_in">double</span> width, <span class="built_in">double</span> height, <span class="built_in">double</span> offset</span>) : <span class="title">this</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">        Offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Width &#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height &#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Offset &#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;<span class="comment">// 旋转中心</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> HandParams secondParams = <span class="keyword">new</span> HandParams(<span class="number">0.02</span>, <span class="number">1.1</span>, <span class="number">0.85</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> HandParams minuteParams = <span class="keyword">new</span> HandParams(<span class="number">0.05</span>, <span class="number">0.8</span>, <span class="number">0.9</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> HandParams hourParams = <span class="keyword">new</span> HandParams(<span class="number">0.125</span>, <span class="number">0.65</span>, <span class="number">0.9</span>);</span><br></pre></td></tr></table></figure><p>然后，写一个 <code>LayoutHand</code> 来把指针放到合适的地方：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayoutHand</span>(<span class="params">BoxView boxView, HandParams handParams, Point center, <span class="built_in">double</span> radius</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">double</span> width = handParams.Width * radius;</span><br><span class="line">    <span class="built_in">double</span> height = handParams.Height * radius;</span><br><span class="line">    <span class="built_in">double</span> offset = handParams.Offset;</span><br><span class="line"></span><br><span class="line">    AbsoluteLayout.SetLayoutBounds(boxView,</span><br><span class="line">                                   <span class="keyword">new</span> Rectangle(center.X - <span class="number">0.5</span> * width,</span><br><span class="line">                                                 center.Y - offset * height,</span><br><span class="line">                                                 width, height));</span><br><span class="line">    boxView.AnchorY = handParams.Offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LayoutHand(secondHand, secondParams, center, radius);</span><br><span class="line">LayoutHand(minuteHand, minuteParams, center, radius);</span><br><span class="line">LayoutHand(hourHand, hourParams, center, radius);</span><br></pre></td></tr></table></figure><p>在时间流动时，旋转指针，为了营造一种真实的感觉，我们可以用一个动画效果让秒钟的移动有真实的摆动感，但这个动画需要我们 Timer Tick 的频率高一点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClockPage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Device.StartTimer(TimeSpan.FromSeconds(<span class="number">1.0</span> / <span class="number">60</span>), OnTimerTick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">OnTimerTick</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateTime dateTime = DateTime.Now;</span><br><span class="line">    hourHand.Rotation = <span class="number">30</span> * (dateTime.Hour % <span class="number">12</span>) + <span class="number">0.5</span> * dateTime.Minute;</span><br><span class="line">    minuteHand.Rotation = <span class="number">6</span> * dateTime.Minute + <span class="number">0.1</span> * dateTime.Second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> t = dateTime.Millisecond / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &lt; <span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="number">0.5</span> * Easing.SpringIn.Ease(t / <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="number">0.5</span> * (<span class="number">1</span> + Easing.SpringOut.Ease((t - <span class="number">0.5</span>) / <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    secondHand.Rotation = <span class="number">6</span> * (dateTime.Second + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个圆盘时钟就完成了。</p><h3 id="闹钟功能实现"><a href="#闹钟功能实现" class="headerlink" title="闹钟功能实现"></a>闹钟功能实现</h3><h4 id="闹钟、数据库模块"><a href="#闹钟、数据库模块" class="headerlink" title="闹钟、数据库模块"></a>闹钟、数据库模块</h4><p>我们将使用 <code>SQLite.NET</code> 将数据库操作合并到应用程序。</p><p>首先要做的是使用 Visual Studio 中的 NuGet 包管理器将 NuGet 包添加到项目。这里我们需要添加的包叫做 <code>sqlite-net-pcl</code> （详细操作参考官方文档：<a href="https://docs.microsoft.com/zh-cn/xamarin/get-started/quickstarts/database">将数据存储在本地 SQLite.NET 数据库中</a>），添加完成后我们就可以将数据存储在本地 SQLite.NET 数据库中了。</p><p>接下来我们实现设计中提到的 <code>AlamItem</code> 类来表示一条闹钟：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> SQLite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyClock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AlarmItem</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">PrimaryKey, AutoIncrement</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> TimeSpan Time &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> Work &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Note &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> Time.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了 <code>PrimaryKey</code> 和 <code>AutoIncrement</code> 特性标记 <code>ID</code> 属性，以确保 SQLite.NET 数据库中的每个 <code>AlarmItem</code> 实例都具有 SQLite.NET 提供的唯一 id。</p><p>然后，创建一个 <code>Database</code> 类，包含用于创建数据库、从中读取数据、向其中写入数据以及从中删除数据的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SQLite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyClock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Database</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">readonly</span> SQLiteAsyncConnection _database;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Database</span>(<span class="params"><span class="built_in">string</span> dbPath</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _database = <span class="keyword">new</span> SQLiteAsyncConnection(dbPath);</span><br><span class="line">            _database.CreateTableAsync&lt;AlarmItem&gt;().Wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Task&lt;List&lt;AlarmItem&gt;&gt; GetAllAlarmItemsAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _database.Table&lt;AlarmItem&gt;().ToListAsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">SaveAlarmItemAsync</span>(<span class="params">AlarmItem alarmItem</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (alarmItem.ID != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _database.UpdateAsync(alarmItem);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _database.InsertAsync(alarmItem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">DeleteAlarmItemAsync</span>(<span class="params">AlarmItem alarmItem</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> _database.DeleteAsync(alarmItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用的全是将数据库操作移动到后台线程的异步 SQLite.NET API。 此外，<code>Database</code>构造函数将数据库文件的路径作为参数。</p><h4 id="闹钟相关的页面"><a href="#闹钟相关的页面" class="headerlink" title="闹钟相关的页面"></a>闹钟相关的页面</h4><p>接下来我们考虑先把和闹钟的CRUD相关的 <code>AlarmPage</code> 和 <code>AlarmEditPage</code> 页面实现。</p><p>首先是 <code>AlarmPage</code>，这个界面将罗列所有的已有闹钟条目，并且可以添加新的条目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ContentPage</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xamarin.com/schemas/2014/forms&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">x:Class</span>=<span class="string">&quot;MyClock.AlarmPage&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">Title</span>=<span class="string">&quot;闹钟&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ContentPage.ToolbarItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ToolbarItem</span> <span class="attr">Text</span>=<span class="string">&quot;+&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">IconImageSource</span>=<span class="string">&quot;add.png&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">Clicked</span>=<span class="string">&quot;OnAlarmItemAddClicked&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ContentPage.ToolbarItems</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">Margin</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;alarmListView&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">ItemSelected</span>=<span class="string">&quot;OnAlarmItemSelected&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ListView.ItemTemplate</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextCell</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding TimeString&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">Detail</span>=<span class="string">&quot;&#123;Binding Note&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ListView.ItemTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Text</span>=<span class="string">&quot;添加&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Clicked</span>=<span class="string">&quot;OnAlarmItemAddClicked&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ContentPage</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我在标题栏里写了一个添加新条目的 “<code>+</code>” 按钮，但由于调试中发现，它虽然在 Android、iOS 中都能很好的呈现，但在 UWP 里不可见（虽然把鼠标移到那里稍微移动屏幕后可以看到也可以点击到它），用户体验很差，所以就在 ListView 下面加了一个很显眼、也几乎不可能出意外的 “<code>添加</code>” Button。</p><p>当用户点击 ListView 里的闹钟条目 或者 添加新条目 时，将转到 <code>AlarmEditPage</code> 完成闹钟条目的查看、编辑、保存或删除：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnAlarmItemAddClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Navigation.PushAsync(<span class="keyword">new</span> AlarmEditPage</span><br><span class="line">&#123;</span><br><span class="line">BindingContext = <span class="keyword">new</span> AlarmItem()</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnAlarmItemSelected</span>(<span class="params"><span class="built_in">object</span> sender, SelectedItemChangedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.SelectedItem != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Navigation.PushAsync(<span class="keyword">new</span> AlarmEditPage</span><br><span class="line">&#123;</span><br><span class="line">BindingContext = e.SelectedItem <span class="keyword">as</span> AlarmItem</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AlarmEditPage</code> 的界面设计如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ContentPage</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xamarin.com/schemas/2014/forms&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">x:Class</span>=<span class="string">&quot;MyClock.AlarmEditPage&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">Title</span>=<span class="string">&quot;设置闹钟&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">Margin</span>=<span class="string">&quot;20, 35, 20, 20&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;时间:&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimePicker</span> <span class="attr">Time</span>=<span class="string">&quot;&#123;Binding Time&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">Format</span>=<span class="string">&quot;T&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">StackLayout</span> <span class="attr">Orientation</span>=<span class="string">&quot;Vertical&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;启用:&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Switch</span> <span class="attr">HorizontalOptions</span>=<span class="string">&quot;StartAndExpand&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">IsToggled</span>=<span class="string">&quot;&#123;Binding Work&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Text</span>=<span class="string">&quot;注释:&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Editor</span> <span class="attr">Placeholder</span>=<span class="string">&quot;输入注释&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Note&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">MaxLength</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">HeightRequest</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Margin</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Text</span>=<span class="string">&quot;保存&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">Clicked</span>=<span class="string">&quot;OnSaveButtonClicked&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Grid.Column</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">Text</span>=<span class="string">&quot;删除&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">Clicked</span>=<span class="string">&quot;OnDeleteButtonClicked&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ContentPage</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="闹钟条目的CRUD"><a href="#闹钟条目的CRUD" class="headerlink" title="闹钟条目的CRUD"></a>闹钟条目的CRUD</h4><p>因为我们将在整个程序的不同部分通用我们封装的 <code>Database</code> 这个数据库，所以在 <code>App.xaml.cs</code> 中将其实例化：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Database Database</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (database == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database = <span class="keyword">new</span> Database(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), <span class="string">&quot;alarm.db3&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> database;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在各处调用了，接下来我们将数据与界面联系起来。</p><p>在 <code>AlarmPage</code> 的 <code>OnAppearing</code> 中，我们将写这样的一行代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmListView.ItemsSource = <span class="keyword">await</span> App.Database.GetAllAlarmItemsAsync();</span><br></pre></td></tr></table></figure><p>这行代码将会把数据库中储存的所有闹钟条目读取出来，加载到界面上的 ListView 里。</p><p>然后，在 <code>AlarmEditPage</code> 中完成 保存、删除 两个按钮的点击事件处理：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnSaveButtonClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alarmItem = (AlarmItem)BindingContext;</span><br><span class="line">    <span class="keyword">await</span> App.Database.SaveAlarmItemAsync(alarmItem);</span><br><span class="line">    <span class="keyword">await</span> Navigation.PopAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnDeleteButtonClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alarmItem = (AlarmItem)BindingContext;</span><br><span class="line">    <span class="keyword">await</span> App.Database.DeleteAlarmItemAsync(alarmItem);</span><br><span class="line">    <span class="keyword">await</span> Navigation.PopAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在取出页面里显示的条目后，调用数据库中保存/删除它，然后退出到 <code>AlarmPage</code>。</p><h4 id="闹钟提醒"><a href="#闹钟提醒" class="headerlink" title="闹钟提醒"></a>闹钟提醒</h4><p>现在我们可以新建、保存、编辑、删除闹钟条目了，但这些还都是数据上的操作，接下来实现闹钟的提醒功能。</p><p>闹钟需要在指定的时间响起以提醒用户，我们可以要为每一个闹钟条目调用系统级的定时事件（模仿系统自带的闹钟功能），这个方法感觉很牛皮，但在代码实现、尤其是跨平台实现上麻烦，我不确定（没有尝试）这样的操作是否可以显著提升程序性能，我们只是做个简单的小闹钟作业，没有必要如此。所以我采用了最简单直观的方法——每隔一段时间检测一次是否有闹钟到时。这样做法最方便的地方是，可以和 ClockPage 里的时钟指针更新事件共用一个 Timer：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">OnTimerTick</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateTime dateTime = DateTime.Now;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// Do ui changes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dateTime.Second % <span class="number">30</span> &lt;= <span class="number">1</span> &amp;&amp; dateTime.Minute != _lastCheck)  <span class="comment">// To avoid high cpu occupying</span></span><br><span class="line">    &#123;</span><br><span class="line">        _lastCheck = dateTime.Minute;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整点报时</span></span><br><span class="line">        <span class="keyword">if</span> (onTheHourToggle.IsToggled &amp;&amp; dateTime.Minute == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Notify(dateTime.Hour);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时的闹钟</span></span><br><span class="line">        List&lt;AlarmItem&gt; alarms = App.Database.GetAllAlarmItemsAsync().Result;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> alarms)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.Work &amp;&amp; isOnTime(a.Time, dateTime))</span><br><span class="line">            &#123;</span><br><span class="line">                Notify(a);</span><br><span class="line">                a.Work = <span class="literal">false</span>;</span><br><span class="line">                App.Database.SaveAlarmItemAsync(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">isOnTime</span>(<span class="params">TimeSpan t, DateTime d</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.Hours == d.Hour &amp;&amp; t.Minutes == d.Minute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们设置的 Timer 在一秒内是要 Tick 好多次的，但闹钟到时检测只应该每分钟0秒时做一次（我再加了一次在30秒时的防止意外），所以有了 <code>dateTime.Second % 30 &lt;= 1 &amp;&amp; dateTime.Minute != _lastCheck</code> 这样的代码</p><p>在 <code>Notify</code> 方法中完成具体的通知用户的行为，比如弹出一个对话框：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For 闹钟</span></span><br><span class="line"><span class="keyword">await</span> DisplayAlert(alarmItem.TimeString, alarmItem.Note, <span class="string">&quot;OK&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For 整点报时</span></span><br><span class="line"><span class="keyword">await</span> DisplayAlert(<span class="string">&quot;整点报时&quot;</span>, <span class="string">&quot;现在时间&quot;</span> + hour + <span class="string">&quot;点整。&quot;</span>, <span class="string">&quot;OK&quot;</span>);</span><br></pre></td></tr></table></figure><p>其实，我还实现了闹钟到时播放音乐以及语音整点报时的功能，只要在 <code>Notify</code> 方法中加入对应的操作就行了，在此不赘述。但这些关于音频的实现在 iOS 和 Android 里没有任何问题，但我一次都没有成功在 UWP 上弄出来，可能是需要设置一下解决方案的打包方式什么的，但我没有找到 Microsoft 相应的文档介绍，咱也没深入研究😂。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，整个跨平台小闹钟项目就大概介绍完了，时间关系，我省略了太多的细节，可以到 Github 阅读源码，<a href="https://github.com/cdfmlr/MyClock">https://github.com/cdfmlr/MyClock</a> 。</p><p>通过这个项目，我们可以大概了解 C# 语言和 利用 Xamarin.Forms 开发跨平台 App 的方法，但需要一定的 Android/iOS/Flutter/UWP 开发基础才能很好的理解这些代码。其实，写完这个东西，虽然简单，基本稍微设计一下就照着文档写就好了，五六百行代码，几个小时搞定，但我还是很有收获的。C# 的好多地方感觉真的比 Java 写着方便（最显著的是 getter 和 setter），然而命名习惯什么的不太习惯，至于效率咱没详细研究也没有结论。Xamarin 也很好用，写起来代码简单易懂、开发速度比较快，比原生 Android 开发方便很多，跨平台的 UI 效果也确实不错（除了在微软自家的 UWP 下有小 Bugs😂） 。</p><p>再说一下不足。第一，我没有下功夫做 UI 设计，所以比较丑；第二，如前面多次提到的，这个实现在 UWP 平台下的效果不佳；最后，其实这个实现并没有完成题目要求的“最小化到系统托盘”（Xamarin 没有提供这种操作，这个东西显然跨不了平台，只能在 Windows 里实现）、“保存为文本文件”（我们知道，SQLite 算是二进制储存，谈不上“文本文件”）等。</p><h2 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h2><p>基于前面所说的诸多不足，我又借了一台 Windows PC，参考马老师多年前的文章 <a href="https://blog.csdn.net/lsgo_myp/article/details/53148238">利用C#语言实现小闹钟</a>，写了 <a href="https://github.com/cdfmlr/Alarm-WindowsForms">Alarm-WindowsForms</a> 项目，一个更符合题目要求但更加粗制滥造的 WindowsForms 实现。</p><p>WindowsForms 毕竟是上一个年代的产物了，它设计出来的东西也还是老的 Windows 样式，跟微软现在的 Fluent Design 一点边都不沾，除了历史遗留下来那些部分微软现在自家软件的开发也不用这个了，这东西在 VS 2019 里的设计界面里显示的居然都是个 Windows vista/7 样子的窗体😂。</p><p>我没有好好研究 C# 写 WindowsForms 的知识，整个实现基本就是凭 直觉 + 马老师的文章 + 小时候学 VB 残存的记忆。而且由于我不熟悉 Windows 和 Visual Studio 的操作，我甚至连对新建出来的类的命名都没做（吐槽一下 Windows 下 VS 的逻辑，新建一个 Class 或者其他什么东西的时候居然没有输入名称的地方，自动搞出些 Class1、Class2 之类的东西来，然后咱也不敢去重命名它，怕解决方案里注册的信息不对了（VS For Mac 有这个毛病，不知道 Win 上的如何）），所以不打算详细写了，大致的设计如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WindowsForms 小闹钟程序</span><br><span class="line">    |-- UI</span><br><span class="line">    |    |-- 在程序载入时绘制界面，读取储存的闹钟数据</span><br><span class="line">    |    |-- 在 Timer Tick (每1秒) 时:</span><br><span class="line">    | | 动态更新圆盘时钟</span><br><span class="line">    | |检测是否整点报时或闹钟提醒</span><br><span class="line">    |    |-- 在用户添加新闹钟时创建 Alarm 实例</span><br><span class="line">    | | 借助 AlarmDatabase 储存，并写入磁盘</span><br><span class="line">    |    |-- 在用户编辑&#x2F;删除闹钟时:</span><br><span class="line">    | |借助 AlarmDatabase 修改&#x2F;删除 Alarm 实例</span><br><span class="line">    | | 同时也从磁盘文件中修改&#x2F;删除数据</span><br><span class="line">    |    |-- 在最小化&#x2F;关闭时处理最小化到系统托盘</span><br><span class="line">    |</span><br><span class="line">    |-- 相关类</span><br><span class="line">         |-- class Alarm: 闹钟类，代表程序运行时的一个闹钟对象</span><br><span class="line">         |-- class AlarmDatabase: 闹钟数据库</span><br><span class="line">         |      处理将内存中的闹钟数据储存到磁盘以及从磁盘读取已保存的数据</span><br><span class="line">         |-- class TickMarkDrawHelper: 计算表盘刻度坐标的辅助类</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9vdfrwji1j30m40d8dg5.jpg" alt="1"></p><p>写这个实现收获就没有太多了，无非是再熟悉了一下 C# 还有 WindowsForms，但感触倒是颇多。写这个东西的时候，我想起自己一开始学编程的时候接触的 VB，当时用一台磁盘只有 10 GB 的 Windows 98 笔记本，跑年纪比自己还大的 VS6.0 （当时好像还是一个个分开的 VC6.0、VB6.0 什么的），那个时候写的 VB 就和现在这个 WindowsForms in C# 一样，还是那几个熟悉的控件，只是开发语言从 BASIC 变成了 C#。这个时候才猛然回忆起，从我的第一个 Hello World 到今天也有8年了……今后也还会一直继续这段程序人生，虽然写代码从来都不是我最喜欢的事，但是没办法，谁让我乐意呢……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统</title>
      <link href="/2019/12/05/AndrewNgML/AndrewNg-MachineLearning-16-RecommenderSystems/"/>
      <url>/2019/12/05/AndrewNgML/AndrewNg-MachineLearning-16-RecommenderSystems/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-16-Recommender-Systems"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-16-Recommender-Systems" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (16) Recommender Systems"></a>Notes of Andrew Ng’s Machine Learning —— (16) Recommender Systems</h1><h2 id="Predicting-Movie-Ratings"><a href="#Predicting-Movie-Ratings" class="headerlink" title="Predicting Movie Ratings"></a>Predicting Movie Ratings</h2><h3 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h3><p>Example: Predicting movies using zero to five stars.</p><p>Here we got some ratings for some movies given by  different users, where a <code>?</code> means this use not rated that movie:</p><table><thead><tr><th>Movie</th><th>Alice(1)</th><th>Bob(2)</th><th>Carol(3)</th><th>Dave(4)</th></tr></thead><tbody><tr><td>Love at last</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>Romance forever</td><td>5</td><td>?</td><td>?</td><td>0</td></tr><tr><td>Cute puppies of love</td><td>?</td><td>4</td><td>0</td><td>?</td></tr><tr><td>Nonstop car chases</td><td>0</td><td>0</td><td>5</td><td>4</td></tr><tr><td>Swords vs. karate</td><td>0</td><td>0</td><td>5</td><td>?</td></tr></tbody></table><p>Notation:</p><ul><li>$n_u$ = number of users</li><li>$n_m$ = number of movies</li><li>$r(i,j)=1$ if user $j$ has rated movie $i$</li><li>$y^{(i,j)}$ = rating given by user $j$ to movie $i$ (defined only if $r(i,j)=1$)</li></ul><p>In this example,  $n_u=4$ and $n_m=5$.We can see that the first three movies is somewhat romantic where the last two is action movies. And we know that our Alice and Bob is more interested in romance  movies so they may give a higher (say, 4 or 5) rate to they  no watched <em>Cute pupies of love</em> and <em>Romance forever</em>, but they may give 0 to <em>Nonstop car chases</em> and <em>Sword vs. karate</em>. And Carol and Dave will behave  on the contrary.</p><h3 id="Content-Based-Recommendations"><a href="#Content-Based-Recommendations" class="headerlink" title="Content Based Recommendations"></a>Content Based Recommendations</h3><p>We can asume we have a set of $x$ measures the degree to the kind of the movie.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9bi5bv4etj30nz06lac1.jpg" alt="屏幕快照 2019-11-26 16.04.26"></p><p>We can bulid a model like this: for each user $j$, learn a parameter $\theta^{(j)}\in\R^3$. Predict user $j$ as rating movie $i$ with $(\theta^{(j)})^Tx^{(i)}$ stars.</p><p>Here is what we will do:</p><ul><li><p>$r(i,j)=1$ if user $j$ has rated movie $i$ ($0$ otherwise)</p></li><li><p>$y^{(i,j)}$ = rating given by user $j$ to movie $i$ (if defined)</p></li><li><p>$\theta^{(j)}$ = parameter vector for user $j$</p></li><li><p>$x^{(i)}$ = feature vector for movie $i$</p></li></ul><p>For User $j$, movie $i$, predicted rating: $(\theta^{(j)})^T(x^{(i)})$</p><p>So our <strong>optimization objective</strong> is:</p><p>To learn $\theta^{(j)}$ (parameter for a single user $j$):<br>$$<br>\min_{\theta^{(j)}}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$<br>To learn $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$ (for all users):<br>$$<br>\min_{\theta^{(1)},\cdots,\theta^{(n_u)}}<br>\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$<br>We can use a gradient descent to solve it<br>$$<br>\begin{array}{l}<br>Repeat\quad{\<br>\qquad \theta_0^{(j)}:=\theta_0^{(j)}-\alpha\sum_{i:r(i,j)=1} \big((\theta^{(j)})^T(x^{(i)})-y^{(i,j)}\big)x_0^{(i)}\<br>\qquad \theta_k^{(j)}:=\theta_k^{(j)}-\alpha\Big[\Big(\sum_{i:r(i,j)=1}\big((\theta^{(j)})^T(x^{(i)})-y^{(i)}\big)x_k^{(i)}\Big)+\lambda\theta_k^{(j)}\Big]\qquad (\textrm{for } k \neq 0)\<br>}<br>\end{array}<br>$$</p><h2 id="Collaborative-Filtering"><a href="#Collaborative-Filtering" class="headerlink" title="Collaborative Filtering"></a>Collaborative Filtering</h2><h3 id="Collaborative-Filtering-1"><a href="#Collaborative-Filtering-1" class="headerlink" title="Collaborative Filtering"></a>Collaborative Filtering</h3><p>In many conditions, we have no idea of what features to use, so we need this algtorithm that is called <em>Collaborative Filtering</em> to help us <strong>learn the features</strong>.</p><p>Here is a example:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9drfoeqaoj30lo0avacu.jpg" alt="屏幕快照 2019-11-28 14.55.32"></p><p>Given rates of movies by people and how this people like different kinds of movies ($\theta$), we try to get what kind of a movie is likely to be ($x$).</p><p><strong>Optimization algorithm</strong></p><p>Given $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$, to learn $x^{(i)}$:<br>$$<br>\min_{x^{(i)}}\frac{1}{2}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$<br>Given $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$, to learn $x^{(1)},\cdots,x^{(n_m)}$:<br>$$<br>\min_{x^{(1)},\cdots,x^{(n_m)}}\frac{1}{2}<br>\sum_{i=1}^{n_m}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$<br><strong>Collaborative filtering</strong></p><p>So if we knew the features, we can learn the parameters theta for different users. If our users are willing to give us parameters, then we can estimate features for the different movies. </p><p>So this is kind of a chicken and egg problem. Which comes first? If we can get the thetas, we can know the xs. If we have the xs, we can learn the thetas.</p><p>What we can do is in fact <strong>randomly guess</strong> some value of the thetas. Now based on the initial random guess for the thetas, we can then go ahead and use the procedure that we just talked about in order to learn features for different movies. Then we get better thetas by using the new xs. Then another set of better xs, … Keep on doing this, it can finally coverage.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ds8xkjatj30ob0bd0w0.jpg" alt="屏幕快照 2019-11-28 15.20.59"></p><h3 id="Collaborative-Filtering-Algorithm"><a href="#Collaborative-Filtering-Algorithm" class="headerlink" title="Collaborative Filtering Algorithm"></a>Collaborative Filtering Algorithm</h3><p>Here is what we do in the previous content:</p><blockquote><p>Given $x^{(1)},\cdots,x^{(n_m)}$, estimate $\theta^{(1)},\cdots,\theta^{(n_u)}$:<br>$$<br>\min_{\theta^{(1)},\cdots,\theta^{(n_u)}}<br>\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$<br>Given $\theta^{(1)},\cdots,\theta^{(n_u)}$, estimate $x^{(1)},\cdots,x^{(n_m)}$:<br>$$<br>\min_{x^{(1)},\cdots,x^{(n_m)}}\frac{1}{2}<br>\sum_{i=1}^{n_m}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$<br>We randomly initialize the parameters and go back and forth between the x’s and the thetas, to get the objective.</p></blockquote><p>There is a more efficient way to do so:</p><p>Minimizing $x^{(1)},\cdots,x^{(n_m)}$ and $\theta^{(1)},\cdots,\theta^{(n_u)}$ simultaneously:<br>$$<br>J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})=<br>\frac{1}{2}<br>\sum_{(i,j):r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2+<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p><p>$$<br>\min_{\begin{array}{c}x^{(1)},\cdots,x^{(n_m)}\\theta^{(1)},\cdots,\theta^{(n_u)}\end{array}}<br>J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})<br>$$</p><p>Put everything together, we get the <strong>collaborative filtering algorithm</strong>:</p><ol><li><p>Initialize $x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)}$ to small random values</p></li><li><p>Minimize $J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})$ using gradient descent (or an advanced optimization algorithm).</p><p>E.g. for every $j=1,…,n_u,i=1,…,n_m$:<br>$$<br>x_k^{(i)}:=x_k^{(i)}-\alpha\Big[\Big(\sum_{j:r(i,j)=1}\big((\theta^{(j)})^T(x^{(i)})-y^{(i)}\big)\theta_k^{(j)}\Big)+\lambda x_k^{(i)}\Big]<br>$$</p><p>$$<br>\theta_k^{(j)}:=\theta_k^{(j)}-\alpha\Big[\Big(\sum_{i:r(i,j)=1}\big((\theta^{(j)})^T(x^{(i)})-y^{(i)}\big)x_k^{(i)}\Big)+\lambda\theta_k^{(j)}\Big]<br>$$</p></li><li><p>For a user with parameters $\theta$ and a movie with (learned) features $x$, predict a star rating of $\theta^Tx$.</p></li></ol><h2 id="Low-Rank-Matrix-Factorization"><a href="#Low-Rank-Matrix-Factorization" class="headerlink" title="Low Rank Matrix Factorization"></a>Low Rank Matrix Factorization</h2><h3 id="Vectorization-Low-Rank-Matrix-Factorization"><a href="#Vectorization-Low-Rank-Matrix-Factorization" class="headerlink" title="Vectorization: Low Rank Matrix Factorization"></a>Vectorization: Low Rank Matrix Factorization</h3><p>To vectorize the collaborative filtering algorithm, we are going to put xs/thetas together:</p><p>So, let:<br>$$<br>X = \left[\begin{array}{ccc}</p><ul><li>&amp; (x^{(1)})^T &amp; - \<br>&amp; \vdots &amp; \</li><li>&amp; (x^{(n_m)})^T &amp; - \<br>\end{array}\right],<br>\qquad<br>\Theta = \left[\begin{array}{ccc}</li><li>&amp; (\theta^{(1)})^T &amp; - \<br>&amp; \vdots &amp; \</li><li>&amp; (\theta^{(n_u)})^T &amp; - \<br>\end{array}\right]<br>$$<br>Then, we can get prediction by:<br>$$<br>X\Theta^T= \left[\begin{array}{ccccc} (x^{(1)})^T(\theta^{(1)}) &amp; \ldots &amp; (x^{(1)})^T(\theta^{(n_u)})\ \vdots &amp; \ddots &amp; \vdots \ (x^{(n_m)})^T(\theta^{(1)}) &amp; \ldots &amp; (x^{(n_m)})^T(\theta^{(n_u)})\end{array}\right]<br>$$<br>And this algorithm is called <em>Low Rank Matrix Factorization</em>.</li></ul><h4 id="Finding-related-movies"><a href="#Finding-related-movies" class="headerlink" title="Finding related movies"></a>Finding related movies</h4><p>For each product (e.g. movie) $i$, we learn a feature vector $x^{(i)}\in\R^n$. We can find a movie $j$ that is most related to movie $i$ by finding a $j$ that has:<br>$$<br>\mathop{\textrm{smallest}} ||x^{(i)}-x^{(j)}||.<br>$$</p><h3 id="Implementational-Detail-Mean-Normalization"><a href="#Implementational-Detail-Mean-Normalization" class="headerlink" title="Implementational Detail: Mean Normalization"></a>Implementational Detail: Mean Normalization</h3><p>If we use what we talked about above, given a user who ranked no movies, than, our recommend system will output a all zeros result, so we can recommend nothing to this user. We never hope this, so we do a mean normalization:<br>$$<br>\mu_i=\mathop{\textrm{average}} y^{(i,:)}<br>$$</p><p>$$<br>Y_i = Y_i-\mu_i<br>$$</p><p>For user $j$, on movie $i$, we predict:<br>$$<br>\left(\Theta^{(j)}\right)^T\left(x^{(i)}\right)+\mu_i<br>$$<br>Then we can get a set of “average” recommendation  for a no-ranked user.</p><p>We talked about mean normalization. However, unlike some other applications of feature scaling, we did not scale the movie ratings by dividing by the range (max – min value). This is because all the movie ratings are already comparable (e.g., 0 to 5 stars), so they are already on similar scales.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常检测</title>
      <link href="/2019/11/26/AndrewNgML/AndrewNg-MachineLearning-15-AnomalyDetection/"/>
      <url>/2019/11/26/AndrewNgML/AndrewNg-MachineLearning-15-AnomalyDetection/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-15-Anomaly-Detection"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-15-Anomaly-Detection" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (15) Anomaly Detection"></a>Notes of Andrew Ng’s Machine Learning —— (15) Anomaly Detection</h1><h2 id="Density-Estimation"><a href="#Density-Estimation" class="headerlink" title="Density Estimation"></a>Density Estimation</h2><h3 id="Problem-Motivation"><a href="#Problem-Motivation" class="headerlink" title="Problem Motivation"></a>Problem Motivation</h3><p><em>Anomaly Detection</em> is a type of machine learning problem.</p><p>Imagine that you’re a manufacturer of aircraft engines, and let’s say that as your aircraft engines roll off the assembly line, you’re doing quality assurance testing, and as part of that testing you measure features of your aircraft engine, like the heat generated, the vibrations and so on. So you now have a data set of $x_1$ through $x_m$, if you have manufactured $m$ aircraft engines and plot your data. Then, given a new engine $x_{test}$, you want to know is $x_{test}$ anomalous? This problem is called <strong>Anomaly Detection</strong>.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xdwc6zf8j30p10c2gpb.jpg" alt="image-20191114105935962"></p><p>Here is want we are going to do:</p><blockquote><p>Dataset: ${x^{(1)},x^{(2)},\cdots,x^{(m)}}$</p><p>Is $x_{test}$ anomalous?</p></blockquote><p>To solve this problem, we will train a model for $p(x)$ (i.e. a model for the <strong>probability</strong> of $x$, where $x$ are these features of, say, aircraft engines). We’re then going to say that for the new aircraft engine, if $p(x_{test})$ is less than some $\epsilon$ then we flag this as an anomaly:<br>$$<br>\begin{array}{l}<br>p(x_{test})&lt;\epsilon \Rightarrow \textrm{anomaly}\<br>p(x_{test})\ge\epsilon \Rightarrow \textrm{OK}<br>\end{array}<br>$$<br>This problem of estimating this distribution $p(x)$ are sometimes called the problem of <em>density estimation</em>.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xebhrku9j30nl0d7gqi.jpg" alt="image-20191114111418858"></p><h4 id="Anomaly-detection-example"><a href="#Anomaly-detection-example" class="headerlink" title="Anomaly detection example"></a>Anomaly detection example</h4><p><strong>Anomaly detec-on example</strong> </p><p>Fraud detection</p><ul><li>$x^{(i)}$= features of user $i$’s actvities </li><li>Model $p(x)$ from data.</li><li>Idenify unusual users by checking which have $p(x)&lt;\epsilon$</li></ul><p>Manufacturing  (Monitoring computers in a data center )</p><ul><li><p>$x^{(i)}$ = features of machine $i$</p></li><li><p>$x_1$ = memory use, $x_2$ = number of disk accesses/sec, $x_3$ = CPU load, $x_4$ = CPU load/network traffic …</p></li></ul><h3 id="Gaussian-Distribution"><a href="#Gaussian-Distribution" class="headerlink" title="Gaussian Distribution"></a>Gaussian Distribution</h3><p><strong>Gaussian distribution</strong> which is also called the <em>normal distribution</em>.</p><p>If $x$ is a distributed Gaussian with mean $\mu$, variance $\sigma^2$, we will write it as:<br>$$<br>x \sim \mathcal{N}(\mu,\sigma^2)<br>$$<br>In this case, the probability of $x$ is:<br>$$<br>p(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)<br>$$</p><p>There is some example of Gaussian distribution:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8yum81cydj30je0c3410.jpg" alt="image-20191115172344685"></p><p>We can see that the “center” of these plots is actually the value of $\mu$. And with our $\sigma$ increasing,  the plots is more and more “flat”. Or, it will be “thin &amp; tall” if $\sigma$ is small.</p><h4 id="Parameter-estimation"><a href="#Parameter-estimation" class="headerlink" title="Parameter estimation"></a>Parameter estimation</h4><p>Given a dataset: ${x^{(1)},x^{(2)},\cdots,x^{(m)}}$, we can get our $\mu$ and $\sigma$ by:<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}<br>$$</p><p>$$<br>\sigma^2=\frac{1}{m}\sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^2<br>$$</p><p>P.S. this is what people turn to use when handling a machine learning problem, it’s a little different from what we normally utilize in mathematics.</p><h3 id="Anomaly-detection-algorithm"><a href="#Anomaly-detection-algorithm" class="headerlink" title="Anomaly detection algorithm"></a>Anomaly detection algorithm</h3><ol><li><p>Choose features $x_i$ that you think might be indicative of anomalous examples.</p></li><li><p>Fit parameters $\mu_1,\cdots,\mu_n,\sigma_1^2,\cdots,\sigma_n^2$: (I wrote the vectorilized version)<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}<br>$$</p><p>$$<br>\sigma^2=\frac{1}{m}\sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^2<br>$$</p></li><li><p>Given new example $x$, compute $p(x)$:<br>$$<br>p(x)=\prod_{j=1}^{n}p(x_j;\mu_j,\sigma_j^2)=\prod_{j=1}^{n}\frac{1}{\sqrt{2\pi}\sigma_j}\exp\left(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2}\right)<br>$$</p></li><li><p>Anomaly if $p(x)&lt;\epsilon$</p></li></ol><h2 id="Building-an-Anomaly-Detection-System"><a href="#Building-an-Anomaly-Detection-System" class="headerlink" title="Building an Anomaly Detection System"></a>Building an Anomaly Detection System</h2><h3 id="Developing-and-Evaluating-an-Anomaly-Detection-System"><a href="#Developing-and-Evaluating-an-Anomaly-Detection-System" class="headerlink" title="Developing and Evaluating an Anomaly Detection System"></a>Developing and Evaluating an Anomaly Detection System</h3><p><strong>The importance of real-number evalua-on</strong> </p><p>When developing a learning algorithm (choosing features, etc.), making decisions is much easier if we have a way of evalua-ng our learning algorithm. </p><p>Assume we have some labeled data, of anomalous and non- anomalous examples. ($y=0$ if normal, $y=1$ if anomalous). </p><ul><li><p><code>Training set</code>: $x^{(1)},x^{(2)},\cdots,x^{(m)}$ (assume normal examples/not anomalous)</p></li><li><p><code>Cross validation set</code>: $\left(x_{cv}^{(1)},y_{cv}^{(1)}\right),\cdots,\left(x_{cv}^{(m_{cv})},y_{cv}^{(m_{cv})}\right)$</p></li><li><p><code>Test set</code>: $\left(x_{test}^{(1)},y_{test}^{(1)}\right),\cdots,\left(x_{test}^{(m_{test})},y_{test}^{(m_{test})}\right)$</p></li></ul><p><strong>Aircraft engines motivating example</strong> </p><p>Say, what we have is:</p><ul><li>10000 good (normal) engines  ($y=0$)</li><li>20 flawed engines (anomalous)   ($y=1$)</li></ul><p>Than we are going to choose:</p><ul><li>Training set: 6000 good engines</li><li>CV: 2000 good engines ($y=0$), 10 anomalous ($y=1$)</li><li>Test: 2000 good engines ($y=0$), 10 anomalous ($y=1$) </li></ul><p><strong>Algorithm evaluation</strong></p><p>Fit model $p(x)$ on training set ${x^{(1)},\cdots,x^{(m)}}$</p><p>On a cross validation/test example $x$, predict:<br>$$<br>y = \left{\begin{array}{ll}<br>1 &amp; \textrm{if } p(x) &lt; \epsilon \quad \textrm{(anomaly)}\<br>0 &amp; \textrm{if } p(x) \ge \epsilon \quad \textrm{(normal)}\<br>\end{array}\right.<br>$$<br>Possible evaluation matrices:</p><ul><li>True positive, false positive, false negative, true negative </li><li>Precision/Recall</li><li>$F_1$-score </li></ul><p>Can also use cross valida-on set to choose parameter $\epsilon$.</p><h3 id="Anomaly-Detection-vs-Supervised-Learning"><a href="#Anomaly-Detection-vs-Supervised-Learning" class="headerlink" title="Anomaly Detection vs. Supervised Learning"></a>Anomaly Detection vs. Supervised Learning</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zz0ijc4cj310f0khn20.jpg" alt="image-20191116164047663"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zz0b347dj31050jswgw.jpg" alt="image-20191116164113192"></p><p>There are some more examples:</p><ul><li><p>(Anomaly Detection) You run a power utility (supplying electricity to customers) and want to monitor your electric plants to see if any one of them might be behaving strangely.</p></li><li><p>(Supervised Learning) You run a power utility and want to predict tomorrow’s expected demand for electricity (so that you can plan to ramp up an appropriate amount of generation capacity).</p></li><li><p>(Anomaly Detection) A computer vision / security application, where you examine video images to see if anyone in your company’s parking lot is acting in an unusual way.</p></li><li><p>(Supervised Learning) A computer vision application, where you examine an image of a person entering your retail store to determine if the person is male or female.</p></li></ul><h3 id="Choosing-What-Features-to-Use"><a href="#Choosing-What-Features-to-Use" class="headerlink" title="Choosing What Features to Use"></a>Choosing What Features to Use</h3><h4 id="preprocess-non-gaussian-features"><a href="#preprocess-non-gaussian-features" class="headerlink" title="preprocess non-gaussian features"></a>preprocess non-gaussian features</h4><p>We can use <code>hist</code> in octave to plot out the histogram of our data, if we find that it is non-gaussian, we can try to apply a $\log(x+c)$ or $x^{\frac{1}{c}}$ (try different $c$ for a better result) to make it looks more gaussian. For example:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90vvgj48aj30qs08ijtu.jpg" alt="image-20191117113816740"></p><h4 id="Error-analysis-for-anomaly-detection"><a href="#Error-analysis-for-anomaly-detection" class="headerlink" title="Error analysis for anomaly detection"></a>Error analysis for anomaly detection</h4><p>What we want is:</p><ul><li>$p(x)$ large for normal examples $x$.</li><li>$p(x)$ small for anomalous examples $x$.</li></ul><p>And the most common problem is:</p><blockquote><p>$p(x)$ is comparable (say, both large) for normal and anomalous examples.</p></blockquote><p>Suppose our anomaly detection algorithm is performing poorly and outputs a large value of p(x) for many normal examples and for many anomalous examples in the cross validation dataset, what is most likely to help is to try coming up with more features to distinguish between the normal and the anomalous examples.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90wc7yk3gj30m807x40w.jpg" alt="image-20191117115423248"></p><h2 id="Multivariate-Gaussian-distribution"><a href="#Multivariate-Gaussian-distribution" class="headerlink" title="Multivariate Gaussian distribution"></a>Multivariate Gaussian distribution</h2><h3 id="Multivariate-Gaussian-Distribution"><a href="#Multivariate-Gaussian-Distribution" class="headerlink" title="Multivariate Gaussian Distribution"></a>Multivariate Gaussian Distribution</h3><p>What we still want to do is:</p><ul><li>Given $x\in\R^n$.</li><li>Don’t model $p(x_1),p(x_2),\cdots$ separately.</li><li>Model $p(x)$ all in one go.</li></ul><p><em>Multivariate gaussian</em> is able to make it:<br>$$<br>p(x;\mu,\Sigma)=\frac<br>{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}<br>$$<br>P.s. $|\Sigma| = \det\Sigma $ is the determinant of $\Sigma$ .</p><p>Where we need parameters:</p><ul><li>$\mu\in\R^n$</li><li>$\Sigma\in\R^{n\times n}$ (covariance matrix, <code>Sigma = 1/m * X&#39; * X;</code>)</li></ul><p>Given training set ${x^{(1)},\cdots,x^{(m)}}$, we can fit the parameters:<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)} \qquad<br>\Sigma=\frac{1}{m}\sum_{i=1}^m\left(x^{(i)}-\mu\right)\left(x^{(i)}-\mu\right)^T<br>$$</p><p>Here are lots of examples:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90zj4eo2fj31xy0h37wh.jpg" alt="屏幕快照 2019-11-17 13.39.08 3"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90zjbm1afj31xy0h31kx.jpg" alt="屏幕快照 2019-11-17 13.39.08 2"></p><h3 id="Anomaly-Detection-using-the-Multivariate-Gaussian-Distribution"><a href="#Anomaly-Detection-using-the-Multivariate-Gaussian-Distribution" class="headerlink" title="Anomaly Detection using the Multivariate Gaussian Distribution"></a>Anomaly Detection using the Multivariate Gaussian Distribution</h3><h4 id="Using-the-Multivariate-Gaussian-Distribution"><a href="#Using-the-Multivariate-Gaussian-Distribution" class="headerlink" title="Using the Multivariate Gaussian Distribution"></a>Using the Multivariate Gaussian Distribution</h4><ol><li><p>Fit model $p(x)$ by setting:<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)} \qquad<br>\Sigma=\frac{1}{m}\sum_{i=1}^m\left(x^{(i)}-\mu\right)\left(x^{(i)}-\mu\right)^T<br>$$</p></li><li><p>Given a new example $x$, compute:<br>$$<br>p(x)=\frac<br>{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}<br>$$</p></li><li><p>Flag an anomaly if $p(x)&lt;\epsilon$</p></li></ol><h4 id="Relationship-to-original-model"><a href="#Relationship-to-original-model" class="headerlink" title="Relationship to original model"></a>Relationship to original model</h4><p>Original model: $p(x)=p(x_1;\mu_1,\sigma_1^2)\times p(x_2;\mu_2,\sigma_2^2) \times \cdots \times p(x_n;\mu_n,\sigma_n^2)$</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g92bif84qwj30la05ajtx.jpg" alt="image-20191118172458083"></p><p>As we can see, the contours of the Original model are always <strong>axis aligned</strong>.</p><p> This model actually corresponds to a special case of a multivariate Gaussian distribution $p(x)=\frac{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}$ where:<br>$$<br>\Sigma=\left[\begin{array}{cccc}<br>\sigma_1^2 \<br> &amp; \sigma_1^2 \<br> &amp; &amp; \ddots \<br> &amp; &amp; &amp; \sigma_n^2<br>\end{array}\right]<br>$$</p><h4 id="Original-model-vs-Multivariate-gaussian"><a href="#Original-model-vs-Multivariate-gaussian" class="headerlink" title="Original model vs. Multivariate gaussian"></a>Original model vs. Multivariate gaussian</h4><p>Original model:</p><ul><li>$p(x)=p(x_1;\mu_1,\sigma_1^2)\times \cdots \times p(x_n;\mu_n,\sigma_n^2)$</li><li>Manually create features to capture anomalies where $x_1,x_2$ take unusual combinations of values. (e.g. $x_3=\frac{x_1}{x_2}$)</li><li>Computationally cheaper (alternatively, scales better to large $n$)</li><li>OK even if $m$ (training set size) is small</li></ul><p>Multivariate gaussian:</p><ul><li>$p(x)=\frac{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}$</li><li>Automatically captures correlations between features (no need to create a $x_3=\frac{x_1}{x_2}$)</li><li>Computationally more expensive</li><li>Must have $m&gt;n$ &amp; all features are not redundant (need to promise that there are no features that are linearly dependent) or else $\Sigma$ is non-invertible.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 本地快照占用空间问题</title>
      <link href="/2019/11/18/blog/mac-localsnapshot-occupy/"/>
      <url>/2019/11/18/blog/mac-localsnapshot-occupy/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-本地快照占用空间问题"><a href="#Mac-本地快照占用空间问题" class="headerlink" title="Mac 本地快照占用空间问题"></a>Mac 本地快照占用空间问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>在使用 Mac 的过程中，可能遇到如下问题：</p></blockquote><p>当我们在 App Store 中下载一个比较大的软件时（如 Xcode，&gt;6GB），弹出对话框提示说：“可用的磁盘空间不足，无法安装此产品”。</p><p>这时，我们点击菜单栏左上角”🍎”图标-&gt;“关于本机”-&gt;“储存空间”，或查看 Finder(访达)底部，发现显示的可用空间还有50GB，怎么可能“空间不足呢”？</p><p>带着疑问，我们又尝试使用其他方法查看磁盘剩余空间：如果你稍微了解 Unix/Linux，我想这时你的一个可能选择一定会是 “<code>$ df -h</code>”，而如果你对前面这句话不甚了解或一无所知对话，你可以打开 macOS 系统自带的“<strong>磁盘工具</strong>”。</p><p>通过前者的做法你可能看到类似下面这样的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Foo@Bar-MacBook:] 00:00  ~ !502 $ df -h</span><br><span class="line">Filesystem      Size   Used  Avail Capacity iused               ifree %iused  Mounted on</span><br><span class="line">&#x2F;dev&#x2F;disk1s1   113Gi   96Gi   13Gi    84% 1225588 9223372036853550219    0%   &#x2F;</span><br><span class="line">devfs          331Ki  331Ki    0Bi   100%    1146                   0  100%   &#x2F;dev</span><br><span class="line">&#x2F;dev&#x2F;disk1s4   113Gi  3.0Gi   13Gi     9%       3 9223372036854775804    0%   &#x2F;private&#x2F;var&#x2F;vm</span><br><span class="line">map -hosts       0Bi    0Bi    0Bi   100%       0                   0  100%   &#x2F;net</span><br><span class="line">map auto_home    0Bi    0Bi    0Bi   100%       0                   0  100%   &#x2F;home</span><br></pre></td></tr></table></figure><p>不用解释（如果你真的是我说的前者，否则，请看下一段），你吃惊地发现系统可用空间只有13GB了😱！</p><p>而在“<strong>磁盘工具</strong>”中你可以看见图条展示的可用“实际可用”只有13.34G，下面还写有一条”可用: 50GB（36.66GB<em>可清除</em>）”。🤔</p><p>“可清除”? 什么意思? 怎么清除? 到头来还是不能用嘛！</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>我知道你急于解决问题，而不是看我写问题分析的过程，所以，先贴出解决方案。若有兴趣，再请一瞥最后的问题分析。</p></blockquote><ol><li>打开终端（如果不知道可以 <code>command+空格</code> 聚焦搜索 “终端.app”），输入如下指令，回车:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmutil listlocalsnapshotdates</span><br></pre></td></tr></table></figure><p>然后，你会看到输出这样的东西:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Snapshot dates for all disks:</span><br><span class="line">2066-06-05-223724</span><br><span class="line">2066-06-05-230056</span><br><span class="line">2066-06-06-053724</span><br><span class="line">2066-06-06-060056</span><br></pre></td></tr></table></figure><ol start="2"><li>然后，再分别键入指令 <code>tmutil deletelocalsnapshots &lt;snapshot_date&gt;</code>，把里面的 ”<code>&lt;snapshot_date&gt;</code>“ 换成你在上面看到的某一行日期，回车后稍等，看到:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deleted local snapshot &#39;2066-06-05-223724&#39;</span><br></pre></td></tr></table></figure><p>嗯，删了一个某种东西，不管他是什么，反正可用可用磁盘空间会增大吧，故如法炮制，继续<code>tmutil deletelocalsnapshots</code> 干掉刚才 <code>tmutil listlocalsnapshotdates</code> 出来的所有日期。</p><ol start="3"><li><p>完成后，稍等几分钟，再 <code>df -h</code> 或打开”磁盘工具”，你会发现，实际可用空间大了几十G，之前的可清除，被我们清除了😊！</p></li><li><p>这时再尝试安装之前的软件就可以成功了。</p></li></ol><p>问题解决💪！</p><p>P.S. 参考”文本式截图”😜：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[foo@His-MacBook:] 06:06  ~ !501 $ tmutil listlocalsnapshotdates</span><br><span class="line">Snapshot dates for all disks:</span><br><span class="line">2066-06-20-133724</span><br><span class="line">2066-06-20-140056</span><br><span class="line">[foo@His-MacBook:] 06:06  ~ !502 $ tmutil deletelocalsnapshots 2066-06-20-133724</span><br><span class="line">Deleted local snapshot &#39;2066-06-20-133724&#39;</span><br><span class="line">[foo@His-MacBook:] 06:06  ~ !503 $</span><br></pre></td></tr></table></figure><p>【注】我也经历过在上述操作后完全没解决问题的情况。而在我做完上述所有操作并且重启，再重复一遍这些操作后，It works.</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>好的，问题解决了，但为什么可以这样操作呢？答案就藏在我们解决的办法里。</p><p>首先，“<code>tmutil</code>” 是什么东西，通过 <code>$ whatis tmutil</code>，我们可以知道，它的学名叫做“时间机器实用工具（Time Machine utility）”，又通过 <code>$ man tmutil</code>，我们会明白，我们刚才是列出(listlocalsnapshotdates)并逐个删除(deletelocalsnapshots)了磁盘中储存的“<strong>时间机器本地快照</strong>（local Time Machine snapshots）”。</p><p>现在，我们知道了占用我们”可清除”的磁盘空间、还逍遥“访达”外、不为”关于本机“所知的真凶是谁了————万恶的“<em>本地快照</em>”。接下来，我们打算人肉搜索，揭开它丑陋的外衣！</p><p>大肆 Google 后，我们在 Apple 官网找到了一篇名为 “<a href="https://support.apple.com/zh-cn/HT204015">关于“时间机器”本地快照</a>” 的文章，里面有记载：</p><blockquote><p>您的“时间机器”备份磁盘有时可能不可用，因此“时间机器”还会将某些备份储存在您的 Mac 上。这些备份称作本地快照。<br>您无需考虑本地快照所占用的储存空间大小，因为它们不会占用诸如下载文件、拷贝文件或安装新软件等任务所需的空间。<br>您的 Mac 将快照占用的空间计为可用储存空间。即便如此，“时间机器”只会将快照储存在具有大量可用空间的磁盘上，并且会在快照过旧或其他内容需要空间时自动删除相应的快照。</p></blockquote><p>emmm，这就可以解释问题了。这个自动的快照本来是不应该影响我们下载安装软件的，但可能它有点抽不听系统使唤了。</p><p>我们的解决方案是手动删除了那些快照，当然，读完了 Apple 的文档，我们知道也可以通过设置”取消选择’自动备份‘”来达到同样的效果。<strong>但！是！</strong>，这些快照平时感觉用处并不大，但偶尔或许还真有大用（备份这种东西就像保险一样，希望一辈子都用不到，但该买的还是应该买），所以 Apple 和我们都并不推荐取消这个功能，我们只要在不时之需到来时，懂得如何手动释放一些空间就好了。</p><p>That’s it.😉</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维数约减</title>
      <link href="/2019/11/13/AndrewNgML/AndrewNg-MachineLearning-14-DimensionalityReduction/"/>
      <url>/2019/11/13/AndrewNgML/AndrewNg-MachineLearning-14-DimensionalityReduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-14-Dimensionality-Reduction"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-14-Dimensionality-Reduction" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (14) Dimensionality Reduction"></a>Notes of Andrew Ng’s Machine Learning —— (14) Dimensionality Reduction</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Data-Compression"><a href="#Data-Compression" class="headerlink" title="Data Compression"></a>Data Compression</h3><p><em>Dimensionality reduction</em> is another type of unsupervised learning problem.</p><p>There are a couple of different reasons why one might want to do dimensionality reduction. One is <strong>data compression</strong> which  not only allows us to compress the data and have it therefore use up less computer memory or disk space, but it will also allow us to speed up our learning algorithms.</p><p>What we will do in data compression is reduce data from a high dimensionality to a lower one.</p><p>For example:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pbajmgl3j30mt0byq68.jpg" alt="image-20191107112251112"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8pbaeml8oj30p30brgt7.jpg" alt="屏幕快照 2019-11-07 11.24.44"></p><p>As we see, to make dimensionality reduce, intuitionally , we projects the high-D on a lower-D.</p><p>In the more typical example of dimensionality reduction we might have a thousand dimensional data that we might want to reduce to let’s say a hundred dimensional.</p><p>Generally, suppose we apply <code>dimensionality reduction</code> to a dataset of $m$ examples ${x^{(1)},x^{(2)},\cdots,x^{(m)}}$, where $x^{(i)}\in\R^n$. As a result of this, we will get out a lower dimensional dataset ${z^{(1)},z^{(2)},\cdots,z^{(m)}}$ of $m$ examples where $z^{(i)}\in\R^k$ for some value of $k$ and $k\le n$.</p><h3 id="Data-Visualization"><a href="#Data-Visualization" class="headerlink" title="Data Visualization"></a>Data Visualization</h3><p>We can also utilize dimensionality reduction for data visualization.</p><p>For a lot of machine learning applications, it really helps us to develop effective learning algorithms, if we can understand our data better. And visualizing the data is a useful in this.</p><p>Let’s say we have collected a large data set, which means we have a set of $x^{(i)}\in\R^n$ where $n$ is very large, and we can hardly visualize it because, you know, actually we can only draw a plot in or less than 3 dimension. In this case, what we need to do is dimensionality reduction.</p><p>For example, we’ve collected a large data set of many statistics about different countries. we may have a huge data set like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pd8wo33nj30po0dbn3e.jpg" alt="屏幕快照 2019-11-07 12.32.30"></p><p>To visualize this data, what we can do is reduce the dimensionality from 50-D to 2-D, and then we can plot a 2-D plot to understand our data better.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pdanhskoj30nq0c0did.jpg" alt="屏幕快照 2019-11-07 12.31.49"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pde507hrj30ox0bhdiw.jpg" alt="image-20191107123745407"></p><p>To wrap up, suppose you have a dataset ${x^{(1)},x^{(2)},\cdots,x^{(m)}}$ where $x^{(i)}\in\R^n$. In order to visualize it, we apply dimensionality reduction and get ${z^{(1)},z^{(2)},\cdots,z^{(m)}}$ where $z^{(i)}\in\R^k$. And we usual make $k = 2$ or $k = 3$ (since we can plot 2D or 3D data but don’t have ways to visualize higher dimensional data).</p><h2 id="Principal-Component-Analysis"><a href="#Principal-Component-Analysis" class="headerlink" title="Principal Component Analysis"></a>Principal Component Analysis</h2><p>For the problem of dimensionality reduction, the most commonly used algorithm is something called <em>principal component analysis</em> (PCA).</p><h4 id="PCA-problem-formulation"><a href="#PCA-problem-formulation" class="headerlink" title="PCA problem formulation"></a>PCA problem formulation</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8pksu0z5nj30nu07mn1t.jpg" alt="image-20191107165349198"></p><ul><li><p>Reduce form 2-dimension to 1-dimension: </p><p>Find a direction (a vector $u^{(1)}\in\R^n$) onto which to project the data so as to minimize the projection error.</p></li><li><p>Reduce form n-dimension to k-dimension:</p><p>Find $k$ vectors $u^{(1)},u^{(2)},\cdots,u^{(k)}$ onto which to project the data, so as to minimize the projection error.</p></li></ul><p>Notice that PCA is not linear regression! In the linear regression, we minimize the vertical length  between the data point and our hypothesis line, while in the PCA, we minimize the distance between the data point and its projected point:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8plgct2i6j31iy0oywjp.jpg" alt="image-20191107171638816"></p><h4 id="PCA-Algorithm"><a href="#PCA-Algorithm" class="headerlink" title="PCA Algorithm"></a>PCA Algorithm</h4><h5 id="Data-preprocessing"><a href="#Data-preprocessing" class="headerlink" title="Data preprocessing"></a>Data preprocessing</h5><p>Training set: $x^{(1)},x^{(2)},\cdots,x^{(m)}$</p><p>Preprocessing (feature scaling &amp; mean normalization):</p><ul><li><p>$$<br>\mu_j=\frac{1}{m}\sum_{i=1}^m x_j^{(i)},\qquad s_j=\textrm{standard deviation of feature $j$}<br>$$</p></li><li><p>Replace each $x_j^{(i)}$ with $\frac{x_j-\mu_j}{s_j}$</p></li></ul><h5 id="Reduce-data-from-n-dimensions-to-k-dimensions"><a href="#Reduce-data-from-n-dimensions-to-k-dimensions" class="headerlink" title="Reduce data from $n$-dimensions to $k$-dimensions"></a>Reduce data from $n$-dimensions to $k$-dimensions</h5><ol><li><p>Compute <code>convariance matrix</code> (notated a big Sigma, notice that it’s different from a sum notation):<br>$$<br>\Sigma = \frac{1}{m}\sum_{i=1}^n(x^{(i)})(x^{(i)})^T<br>$$</p></li><li><p>Compute <code>eigenvectors</code> of matrix $\Sigma$:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[U, S, V] &#x3D; svd(Sigma);</span><br></pre></td></tr></table></figure></li><li><p>Get from <code>svd</code>:<br>$$<br>U = \left[\begin{array}{cccc}<br>| &amp; | &amp;  &amp; |\<br>u^{(1)} &amp; u^{(2)} &amp; \cdots &amp; u^{(n)}\<br>| &amp; | &amp;  &amp; |<br>\end{array}\right]<br>\in \R^{n\times n}<br>\Rightarrow<br>U_{reduce}=\left[\begin{array}{cccc}<br>| &amp; | &amp;  &amp; |\<br>u^{(1)} &amp; u^{(2)} &amp; \cdots &amp; u^{(k)}\<br>| &amp; | &amp;  &amp; |<br>\end{array}\right]<br>$$</p></li><li><p>Make $x\in\R^n\to z\in\R^k$:<br>$$<br>z = U_{reduce}^Tx<br>=\left[\begin{array}{ccc}<br>– &amp; (u^{(1)})^T &amp; –\<br> &amp; \vdots &amp; \<br>– &amp; (u^{(k)})^T &amp; –\<br>\end{array}\right]x<br>$$</p></li></ol><p>This does do the right thing of minimizing this square projection error although the  mathematical proof of that is beyond the scope of this course.</p><p>Summary:</p><p>After mean normalization (ensure every feature has zero mean) and optionally feature scaling:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sigma &#x3D; 1&#x2F;m * X&#39; * X;</span><br><span class="line">[U, S, V] &#x3D; svd(Sigma);</span><br><span class="line"></span><br><span class="line">Ureduce &#x3D; U(:, 1:K);</span><br><span class="line">Z &#x3D; X * Ureduce;</span><br></pre></td></tr></table></figure><h2 id="Applying-PCA"><a href="#Applying-PCA" class="headerlink" title="Applying PCA"></a>Applying PCA</h2><h3 id="Reconstruction-from-Compressed-Representation"><a href="#Reconstruction-from-Compressed-Representation" class="headerlink" title="Reconstruction from Compressed Representation"></a>Reconstruction from Compressed Representation</h3><p>With PCA, we compressed data from n-dimension to a lower k-dimension. There should be a way to go back from the compressed representation to an approximation of our original high-dimensional data. We call this way <em>reconstruction</em>.</p><p>Recall that our PCA is working as $z= U_{reduce}^Tx$.</p><p>To reconstruction, what we will do is:<br>$$<br>x_{approx}=U_{reduce}z<br>$$<br>It makes $z\in\R^k \to x_{approx}\in\R^n$. The $x_{approx}$ will be close to $x$, but we can hardly expect $x=x_{approx}$.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ta88gafkj30oz0djaeo.jpg" alt="image-20191110215011122"></p><p>Previously, we said that PCA chooses a direction $u^{(1)},\cdots,u^{(k)}$ onto which to project the data so as to minimize the (squared) projection error. With our new defined $x_{approx}$, another way to say the same is that PCA tries to minimize:<br>$$<br>\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}-x_{approx}^{(i)}||^2<br>$$</p><h3 id="Choosing-the-k-number-of-principal-components"><a href="#Choosing-the-k-number-of-principal-components" class="headerlink" title="Choosing the $k$ (number of principal components)"></a>Choosing the $k$ (number of principal components)</h3><p>About PCA, we can see:</p><ul><li>Average squared projection error: $\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2$</li><li>Total variation in the data: $\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2$</li></ul><p>Typically, choose $k$ to be smallest value so that:<br>$$<br>\frac{\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}\le0.01<br>$$<br>We call it “99% of variance is retained”.</p><p>We can also choose other numbers instead of the usual $0.01$, in practice, $0.01\sim0.05$ is all capable.</p><p>The algorithm utilized for $k$ choosing is that:</p><blockquote><p>Try PCA with $k=1,\cdots,n$:</p><p>Compute $U_{reduce},z^{(1)},\cdots,z^{(m)},x_{approx}^{(1)},\cdots,x_{approx}^{m}$;</p><p>Check if $\frac{\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}\le0.01$?</p></blockquote><p>In octave, we can implement it as:</p><ol><li><p><code>[U, S, V] = svd(Sigma)</code>, after running we can get a <code>S</code> that is useful here:</p></li><li><p>Pick smallest value of $k$ for which (99% of variance retained for example)<br>$$<br>\frac{\sum_{i=1}^k S_{ii}}{\sum_{i=1}^m S_{ii}}\ge0.99<br>$$</p></li></ol><h3 id="Advice-for-Applying-PCA"><a href="#Advice-for-Applying-PCA" class="headerlink" title="Advice for Applying PCA"></a>Advice for Applying PCA</h3><h4 id="Supervised-Learning-speedup"><a href="#Supervised-Learning-speedup" class="headerlink" title="Supervised Learning speedup"></a>Supervised Learning speedup</h4><p>In supervised learning, we have data like this:<br>$$<br>(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\cdots,(x^{(m)},y^{(m)})<br>$$<br>We can <strong>extract inputs</strong> by:</p><ul><li>Unlabled dataset: $x^{(1)},x^{(2)},\cdots,x^{(m)}\in \R^n$</li><li>Applying PCA: $z^{(1)},z^{(2)},\cdots,z^{(m)}\in \R^k$, where $k$ is lower than $n$</li></ul><p>Then we get <strong>new training set</strong>:<br>$$<br>(z^{(1)},y^{(1)}),(z^{(2)},y^{(2)}),\cdots,(z^{(m)},y^{(m)})<br>$$<br>Note: Mapping $x^{(i)}\to z^{(i)}$ should be defined by running PCA only on the <strong>training set</strong> . This mapping can be applied as well to the examples $x_{cv}^{(i)}$ and $x_{test}^{(i)}$ in the cross validation and test sets.</p><h4 id="Application-of-PCA"><a href="#Application-of-PCA" class="headerlink" title="Application of PCA"></a>Application of PCA</h4><ul><li><p>Compression</p><ul><li>Reduce memory/disk needed to store data</li><li>Speed up learning algorithm</li></ul><p>In this case, we should choose $k$ by <code>% of  variance retained</code>.</p></li><li><p>Visualization</p><p>In this case, $k=2$ or $k=3$</p></li></ul><h4 id="Bad-use-of-PCA-To-prevent-overfitting"><a href="#Bad-use-of-PCA-To-prevent-overfitting" class="headerlink" title="Bad use of PCA: To prevent overfitting"></a>Bad use of PCA: To prevent overfitting</h4><blockquote><p>Use $z^{(i)}$ instead of $x^{(i)}$ to reduce the number of features to $k&lt;n$.</p><p>Thus, fewer features, less likely to overfit.</p></blockquote><p>👆 This is a BAD use of PCA.</p><p>This might work OK, but isn’t a good way to address overfitting. Use regularization instead:</p><p>$$<br>\min_\theta\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2<br>$$</p><h4 id="PCA-or-not"><a href="#PCA-or-not" class="headerlink" title="PCA or not"></a>PCA or not</h4><p>PCA is sometimes used where it shouldn’t be, here is an example:</p><p>When designing a ML system, we wrote down this steps:</p><ol><li>Get training set ${(x^{(1)},y^{(1)}),\cdots,(x^{(m)},y^{(m)})}$</li><li>Run PCA to reduce $x^{(i)}$ in dimension to get $z^{i}$</li><li>Train logistic regression on ${(z^{(1)},y^{(1)}),\cdots,(z^{(m)},y^{(m)})}$</li><li>Test on test set: Map $x_{test}^{(i)}$ to $z_{test}^{(i)}$. Run $h_\theta(z)$ on ${(z_{test}^{(1)},y^{(1)}),\cdots,(z_{test}^{(m)},y^{(m)})}$</li></ol><p>But before doing this, we should think: How about the whole thing without using PCA?</p><p>Before implementing PCA, first try running whatever you want to do with the original/raw data $x^{(i)}$. Only if that doesn’t do what you want, then implement PCA and consider using $z^{(i)}$.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无监督学习</title>
      <link href="/2019/11/07/AndrewNgML/AndrewNg-MachineLearning-13-UnsupervisedLearning/"/>
      <url>/2019/11/07/AndrewNgML/AndrewNg-MachineLearning-13-UnsupervisedLearning/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-13-Unsupervised-Learning"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-13-Unsupervised-Learning" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (13) Unsupervised Learning"></a>Notes of Andrew Ng’s Machine Learning —— (13) Unsupervised Learning</h1><h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2><h3 id="Unsupervised-Learning-Introduction"><a href="#Unsupervised-Learning-Introduction" class="headerlink" title="Unsupervised Learning: Introduction"></a>Unsupervised Learning: Introduction</h3><p>In supervised learning, we are given a set of labeled training set ( ($(x,y)$ given)) to fit a hypothesis to it:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n5s7zmffj30lv0ca40u.jpg" alt="image-20191105144318970"></p><p>In contrast, in the unsupervised learning problems, we are given data that does not have any labels associated with it ($x$ only, no $y$):</p><p> <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n62mi54pj30lw0catay.jpg" alt="屏幕快照 2019-11-05 14.49.05"></p><p>The slide above shows that here’s a set of points add in no labels. So, in unsupervised learning what we do is we give this sort of unlabeled training set to an algorithm and we just ask the algorithm find some structure in the data for us. </p><p>Given this data set one type of structure we might have an algorithm find is that it looks like this data set has points grouped into two separate clusters (drawn in green) and so an algorithm that finds <strong>clusters</strong> like the ones I’ve just circled is called a <em>clustering algorithm</em>.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n6ap2y9bj30lq0d7135.jpg" alt="image-20191105150106356"></p><h3 id="K-Means-Algorithm"><a href="#K-Means-Algorithm" class="headerlink" title="K-Means Algorithm"></a>K-Means Algorithm</h3><blockquote><p>In the clustering problem we are given an unlabeled data set and we would like to have an algorithm automatically group the data into coherent subsets or into coherent clusters for us.</p></blockquote><p>The <em>K-Means Algorithm</em> is  by far the most popular and widely used clustering algorithm.</p><p>Given an unlabeled data set to group (cluster) them into K (let’s say two, for example) clusters, what the <code>K-Means Algorithm</code> do is:</p><ol><li>Randomly initialize two points, called the cluster centroids.</li><li>Cluster assignment step: going through each of the examples, for each of data dots depending on which cluster centroid it’s closer to, one point is going to be assigned to one of the K cluster centroids (color them into the same color, illustratingly).</li><li>Move centroid step:  take the K cluster centroids, and we are going to move them to the average of the points colored the same colour.</li></ol><p>We keep on move centroid then redo a cluster assignment. Doing this looply until the cluster centroids not change any further (i.e. the K-Means has converged). And, it’s done a good job finding the clusters in the data.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n8yx2xiwg30hy0cadi8.gif" alt="1572942743912"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n98yihsoj30us0c8go8.jpg" alt="屏幕快照 2019-11-05 16.23.33"></p><h4 id="K-means-algoithm"><a href="#K-means-algoithm" class="headerlink" title="K-means algoithm"></a>K-means algoithm</h4><p>Input: </p><ul><li><p>$K$ (number of clusters)</p></li><li><p>${x^{(1)},x^{(2)},\cdots,x^{(m)}}$ (training set)</p><p>$x^{(i)}\in\R^n$ (drop $x_0=1$ convention)</p></li></ul><p>Output:</p><ul><li>$K$ subsets</li></ul><p>Algorithm:<br>$$<br>\begin{array}{l}</p><p>\textrm{Randomly initialize $K$ cluster centroids $\mu_1, \mu_2,…\mu_k \in \R^n$}\<br>\textrm{Repeat }{\<br>\qquad \textrm{for $i=1$ to $m$:}\qquad\textrm{// Cluster assignment step}\<br>\qquad\qquad c^{(i)} := k \ \textrm{ s.t. } \min_k||x^{(i)}-\mu_k||^2 \<br>\qquad\qquad \textrm{/* set $ c^{(i)}$ the index (from $1$ to $K$) of cluster centroid closest to $x^{(i)}$ */}\<br>\qquad \textrm{for $k=1$ to $K$:}\qquad\textrm{// Move centroid step}\<br>\qquad\qquad \textrm{if cluster centroid $\mu_i$ has 0 points assigned to it}:\<br>\qquad\qquad\qquad \textrm{eliminate that cluster centroid, continue}\<br>\qquad\qquad\qquad \textrm{// end up with $K-1$ clusters}\<br>\qquad\qquad \mu_k:= \textrm{average (mean) of points assigned to cluster $k$}\<br>}\</p><p>\end{array}<br>$$</p><h4 id="K-Means-for-non-separated-clusters"><a href="#K-Means-for-non-separated-clusters" class="headerlink" title="K-Means for non-separated clusters"></a>K-Means for non-separated clusters</h4><p>K-Means can do well in both well-separated cluster and non-separated clusters:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8n930vsnrj30mv09swhe.jpg" alt="image-20191105163643613"></p><h3 id="K-means-Optimization-Objective"><a href="#K-means-Optimization-Objective" class="headerlink" title="K-means Optimization Objective"></a>K-means Optimization Objective</h3><p>Notations:</p><ul><li>$c^{(i)}$ = index of cluster ($1,2,\cdots,K$) to which example $x^{(i)}$ is currently assigned.</li><li>$\mu_k$ = cluster centroid $k$ ($\mu_k\in\R^n$).</li><li>$\mu_{c^{(i)}}$ = cluster centroid of cluster to which example $x^{(i)}$ has been assigned.</li></ul><p>For example, let’s say we have a $x^{(1)}$ that is currently assigned to cluster $5$, so in this case, our $c^{(1)}=5$ and $\mu_{c^{(1)}}=\mu_5$, where cluster centroid of cluster $5$ is notated as $\mu_5$. </p><p>Optimization objective:<br>$$<br>J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)=\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}-\mu_{c^{(i)}}||^2<br>$$</p><p>$$<br>\min_{<br>\begin{array}<br>    {1}c^{(1)},\cdots,c^{(m)},\<br>    \mu_1,\cdots,\mu_K<br>\end{array}}<br>J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)<br>$$</p><p>Our cost function $J$  is also called <strong>distortion</strong>.</p><p>In the K-means algorithm, what it doing in our cluster assignment step is minimize $J$ wit $c^{(1)},\cdots,c^{(m)}$ (holding $\mu_1,\cdots,\mu_k$ fixed), and the move centroid step is minimizing the $J$ wit $\mu_1,…,\mu_k$.</p><h3 id="Random-initialization"><a href="#Random-initialization" class="headerlink" title="Random initialization"></a>Random initialization</h3><p>There is a way to random initialization our $K$ cluster centroids:</p><ol><li>Should have $K&lt;m$</li><li>Randomly pick $K$ training examples.</li><li>Set $\mu_1,\cdots,\mu_k$ equal to these $K$ examples.</li></ol><p>i.e. we pick $k$ distinct random integers $i_1,\cdots,i_k$ from ${1,\cdots,m}$, set $\mu_1=x^{(i_1)},\mu_2=x^{(i_2)},\cdots,\mu_k=x^{(i_k)}$.</p><h4 id="Local-optima"><a href="#Local-optima" class="headerlink" title="Local optima"></a>Local optima</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8oe2i8gz8j30oo0d8tb5.jpg" alt="image-20191106161508966"></p><p>Beacuse of the random initialization, we sometimes get a good cluster (get a <em>global optima</em>, like the one at the right top of the picture) and we may also get a bad one (get a <em>local optima</em>, like the two at the right bottom of the picture).</p><p>To avoid the K-means algorithm stop at a loacal optima, we can try this:<br>$$<br>\begin{array}{l}<br>\textrm{For $i=1$ to $100$ &lt;or 50~1000&gt; {}\<br>\qquad\textrm{Randomly initialize K-means.}\<br>\qquad\textrm{Run K-means. Get $c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_k$}\<br>\qquad\textrm{Compute cost function (distortion):}\<br>\qquad\qquad J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)\<br>\textrm{}}\<br>\textrm{pick clustering that gave lowest $J$.}<br>\end{array}<br>$$</p><h3 id="Choosing-the-Number-of-Clusters"><a href="#Choosing-the-Number-of-Clusters" class="headerlink" title="Choosing the Number of Clusters"></a>Choosing the Number of Clusters</h3><p>The most common way to choose the number of clusters $K$ is actually to choose it by hand.</p><p>Choosing the <em>Elbow</em> number is a capable way to choose the value of $K$:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8oftu824rj30cb0c3407.jpg" alt="image-20191106171612460"></p><p>However the elbow method is not always make sense for a condition like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ofwmrgy0j30bb08fwf9.jpg" alt="image-20191106171906665"></p><p>We can hardly find a elbow of it.</p><p>So, there is another thought to make it:</p><blockquote><p>Sometimes, you are running K-means to get clusters to use for some later/downstream purpose. Elaluate K-means based on a metric for how well it performs for that later purpose.</p></blockquote><p>T-shirt sizing for example:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8og2ak66wj30o709l0wr.jpg" alt="image-20191106172431180"></p><p>In particular, what we can do is, think about this from the perspective of the T-shirt business and ask: “Well if I have five segments, then how well will my T-shirts fit my  customers and so, how many T-shirts can I sell? How happy will my customers be?” What really makes sense, from the perspective of the T-shirt business, in terms of whether, I want to have Goer T-shirt sizes so that my T-shirts fit my customers better. Or do I want to have fewer T-shirt sizes so that I make fewer sizes of T-shirts. And I can sell them to the customers more cheaply. And so, the t-shirt selling business, that might give you a way to decide, between three clusters versus five clusters.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/2019/11/04/AndrewNgML/AndrewNg-MachineLearning-12-SupportVectorMachines/"/>
      <url>/2019/11/04/AndrewNgML/AndrewNg-MachineLearning-12-SupportVectorMachines/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-12-Support-Vector-Machines"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-12-Support-Vector-Machines" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (12) Support Vector Machines"></a>Notes of Andrew Ng’s Machine Learning —— (12) Support Vector Machines</h1><h2 id="Large-Margin-Classification"><a href="#Large-Margin-Classification" class="headerlink" title="Large Margin Classification"></a>Large Margin Classification</h2><h3 id="Optimization-Objective"><a href="#Optimization-Objective" class="headerlink" title="Optimization Objective"></a>Optimization Objective</h3><p>The <em>Support Vector Machine</em> (or <em>SVM</em>) is a powerful algorithm that is widely used in both industry and academia. Compared to both logistic regression and neural networks, the SVM somethimes gives a cleaner and more powerful way of learning complex non-linear functions.</p><p>What the <strong>cost</strong> of example in our logistic regression is as:<br>$$<br>-y\log\Big(\frac{1}{1+e^{-\theta^Tx}}\Big)-(1-y)\log\Big(1-\frac{1}{1+e^{-\theta^Tx}}\Big)<br>$$<br>It looks like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4rfgycnj31lc0mqjsr.jpg" alt="屏幕快照 2019-09-19 23.23.39"></p><p>With SVM, we’d like to make a little change of them so that:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58f0dolj31ao0h6wpq.jpg" alt="image-20191029161946046"></p><p>We set a $\textrm{cost}_1$ instead of $-\log(h)$ and set a $\textrm{cost}_0$ instead of $-\log(1-h)$.</p><p>So, for logistic regression, we are going to:<br>$$<br>\min_\theta\frac{1}{m} \sum_{i=1}^m \large[ -y^{(i)}\ \log (h_\theta (x^{(i)})) - (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2<br>$$<br>And for Support Vector Machine, we change it to:<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tx^{(i)})</p><ul><li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tx^{(i)})\large]</li><li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>We dropped the $\frac{1}{m}$ in both terms, then multiplied a $C=\lambda$ to them. In this case we can promise that we can get the same min $\theta$ with those two operators.</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f5vx0x43j31dm0ni156.jpg" alt="image-20191029164223055"></p><h3 id="Large-Margin-Intuition"><a href="#Large-Margin-Intuition" class="headerlink" title="Large Margin Intuition"></a>Large Margin Intuition</h3><p>Let’s say the SVM decision boundary:<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tx^{(i)})</p><ul><li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tx^{(i)})\large]</li><li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>If we set $C$ a very  large value, $100000$ for example, when this optimization objective , we’re going to be highly motivated to choose a value, so that <strong>the first term is equal to zero</strong>. And our goal become:<br>$$<br>\begin{array}{l}<br>  \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2 \\<br>  s.t. \quad \begin{array}{l}<pre><code>  \theta^Tx^&#123;(i)&#125; \ge 1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=1\\  \theta^Tx^&#123;(i)&#125; \le -1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=0</code></pre>  \end{array}<br>\end{array}<br>$$<br>We will get a very intersting decision boundary. The Support Vector Machines will choose a decision boundary that does a great job of separating the positive and negative examples (the black line below install of others).</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8f6tz8op1j30q60kon78.jpg" alt="image-20191029171503318"></p><p>we see that the black decision boundary has some larger minimum distance from any of my training examples, whereas the magenta and the green lines come awfully close to the training examples.</p><p>And mathematically, what that does is, this black decision boundary has a larger distance (the blue lines).That distance is called the <em>margin</em> of the support vector machine and this gives the SVM a certain robustness, because it tries to separate the data with as a large a margin as possible. So the support vector machine is sometimes also called a large margin classifier.</p><p>If $C$ is very large than the SVM will be sensitive to <strong>outliers</strong>. For example, we a very large $C$, $100000$ maybe, with a outliers at the left bottom, the learning algorithm will get the magenta decision boundary. However, if $C$ is not too large, we are going to get the black one as wanted:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8f7bsn392j30zm0iqwmu.jpg" alt="image-20191029173209265"></p><h3 id="Mathematics-Behind-Large-Margin-Classification"><a href="#Mathematics-Behind-Large-Margin-Classification" class="headerlink" title="Mathematics Behind Large Margin Classification"></a>Mathematics Behind Large Margin Classification</h3><h4 id="Vector-Inner-Product"><a href="#Vector-Inner-Product" class="headerlink" title="Vector Inner Product"></a>Vector Inner Product</h4><p>Let’s say we have two vectors:<br>$$<br>u=\left[\begin{array}{l}u1 \ u2\end{array}\right],\qquad v=\left[\begin{array}{l}v1 \ v2\end{array}\right]<br>$$<br>We define their <em>Vector Inner Product</em> as:<br>$$<br>\textrm{Inner Product} =<br>u^Tv=v^Tu<br>$$<br>And we can also get the inner product by getting:<br>$$<br>\begin{array}{ccl}<br>||u|| &amp;=&amp; \textrm{length of vector } u= \sqrt{u_1^2+u_2^2}\<br>p &amp;=&amp; \textrm{length of projection of } v \textrm{ onto } u \textrm{ (signed)} \ \<br>u^Tv &amp;=&amp; p \cdot ||u||<br>\end{array}<br>$$<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8h7ruhj8kj31em0s0nfd.jpg" alt="image-20191031111759471"></p><h4 id="SVM-Decision-Boundary"><a href="#SVM-Decision-Boundary" class="headerlink" title="SVM Decision Boundary"></a>SVM Decision Boundary</h4><p>When the $C$ is very large, we can get this:<br>$$<br>\begin{array}{l}<br>    \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2<br>    =\frac{1}{2}\Big(\sqrt{\sum_{j=1}^n\theta_j^2}\Big)^2<br>    =\frac{1}{2}||\theta||^2 \\<br>    s.t. \quad \begin{array}{l}<br>        \theta^Tx^{(i)} \ge 1 &amp; \textrm{if } y^{(i)}=1\<br>        \theta^Tx^{(i)} \le -1 &amp; \textrm{if } y^{(i)}=0<br>    \end{array}<br>\end{array}<br>$$<br>If we make a simplification as $\theta_0=0, n=2$, so that $\theta=[\theta_1,\theta_2]^T$, then our $\theta^Tx^{(i)}=p^{(i)}\cdot ||\theta||=\theta_1x_1^{(i)}+\theta_2x_2^{(i)}$.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8h9w173flj309l06t3zr.jpg" alt="image-20191031123156678"></p><p>So, our description can be:<br>$$<br>\begin{array}{l}<br>    \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2<br>    =\frac{1}{2}\Big(\sqrt{\sum_{j=1}^n\theta_j^2}\Big)^2<br>    =\frac{1}{2}||\theta||^2 \\<br>    s.t. \quad \begin{array}{l}<br>        p^{(i)}\cdot ||\theta|| \ge 1 &amp; \textrm{if } y^{(i)}=1\<br>        p^{(i)}\cdot ||\theta|| \le -1 &amp; \textrm{if } y^{(i)}=0<br>    \end{array}\\<br>    \textrm{where $p^{(i)}$ is the projection of $x^{(i)}$ onto the vector $\theta$.}<br>\end{array}<br>$$<br>In the condition of $y=1$, to min the $\theta$, we should promise $||\theta||$ is small as well as make $p^{(i)}\cdot ||\theta|| \ge 1$ as possible. So, we get a large $p^{(i)}$.</p><p>For the negative example, similarly, we will get a $p^{(i)}$ whos absolute value is large.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8harwzv9cj324i0nu4qp.jpg" alt="屏幕快照 2019-10-31 12.58.43"></p><p>As we seen, a large $p^{(i)}$ gives us a large margin.</p><h2 id="kernels"><a href="#kernels" class="headerlink" title="kernels"></a>kernels</h2><h3 id="Kernels-and-Similarity"><a href="#Kernels-and-Similarity" class="headerlink" title="Kernels and Similarity"></a>Kernels and Similarity</h3><p>We can develop complex nonlinear classifiers by adapting support vector machines. The main technique for this is something called <em>kernels</em>.</p><p>Let’s say if we a training set that looks this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jjopayn9j30c5083jui.jpg" alt="image-20191102114127170"></p><p>Recall the past, we will work with lots of polynomial features to hypothesis $y=1$ if $\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1x_2+\theta_4x_1^2+\theta_5x_2^2+\cdots\ge 0$ and predict $0$ otherwise.</p><p>Another way of that is:<br>$$<br>\begin{array}{lcl}<br>\textrm{Predict } y=1 &amp;\textrm{if}&amp;\theta_0+\theta_1f_1+\theta_2f_2+\theta_3f_3+\cdots\ge 0<br>\end{array}<br>$$<br>Where $f_1=x_1,f_2=x_2,f_3=x_1x_2,f_4=x_1^2,…$</p><p>If we have a lot of features, then there will be too many polynomial terms, which can become very computationally expensive. So is there a different or a better choice of the features that we can use to plug into this sort of hypothesis form, or in another words, how to define a set of new $f_1,f_2,f_3$ to avoid  high polynomial calculations?</p><p>Here is one idea:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jljliww8j30o90dmwjt.jpg" alt="image-20191102124615797"></p><p>To simplify the description and make it more intuitional, let’s say we have only $x_0,x_1,x_2$ and we are going to define only three new features ($f_1,f_2,f_3$). </p><p>Leave $x_0$ alone, we manually pick a few points $(x_1^{(i)},x_2^{(i)})$ from a plot of $x_1$-$x_2$, in this example they are notated as $l^{(1)},l^{(2)},l^{(3)}$. We call this points <code>landmarks</code>.</p><p>And then, given a $x$, we can compute new feature depending on proximity to landmarks $l^{(1)},l^{(2)},l^{(3)}$ as follow:<br>$$<br>f_i = \mathop{\textrm{similarity}}(x,l^{(i)}) = \exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{\sum_{j=1}^n(x_j-l_j^{(i)})^2}{2\sigma^2})<br>$$<br>The mathematical term for the simiarity function is <code>kernel function</code>. There are many formula of kernel functions can be chosen. And the specific kernel we’re using here is actually called a <em>Gaussian Kernel</em>.</p><p>Note. $||w||$ means the length of the vector $w$.</p><p>Given  $x$, for each $l^{(i)}$ we can get a $f_i$:</p><ul><li>If x is near $l^{(i)}$:</li></ul><p>$$<br>f_i \approx \lim_{x\to l^{(i)}}\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{0^2}{2\sigma^2}) = 1<br>$$</p><ul><li>If $x$ far from $l^{(i)}$:</li></ul><p>$$<br>f_i \approx \lim_{||x-l^{(i)}||\to +\infin}\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{\infin^2}{2\sigma^2}) = 0<br>$$</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmrwo86pj30ph0dwwm1.jpg" alt="image-20191102132852867"></p><p>We can see that: If sigma squared is large, as we move away from $l^{(1)}$, the value of $f_1$ falls away much more slowly.</p><p>So, given this definition of the features, let’s see what source of hypothesis we can learn:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmzc2qq4j30ot0ditej.jpg" alt="image-20191102133600603"></p><p>We can see that, in this example, only given the $x$ near $l^{(1)}$ or $l^{(2)}$ will it predict “1”, if the $x$ if far from this two landmarks, it will predict “0”.</p><h3 id="SVM-with-Kernels"><a href="#SVM-with-Kernels" class="headerlink" title="SVM with Kernels"></a>SVM with Kernels</h3><p>We have talked about the process of picking a few landmarks. But how to choose our $l^{(i)}$s? Actually we will simply choose the location of our landmarks to be exactly near the locations of our m training examples. Here is what we are going to do:</p><hr><h4 id="The-Support-Vector-Machine-With-Kernels-Algorithm"><a href="#The-Support-Vector-Machine-With-Kernels-Algorithm" class="headerlink" title="The Support Vector Machine With Kernels Algorithm"></a>The Support Vector Machine With Kernels Algorithm</h4><p>Given a set of training data: $(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})$ </p><p>Choose landmarks: $l^{(i)}=x^{(i)} \quad \textrm{for }i=1,2,\cdots,m$</p><p>For example $x$: $f_i=\mathop{\textrm{similarity}}(x,l^{(i)}) \quad \textrm{for }i=1,2,\cdots,m$</p><p>Group $f_i$s into a vector: $f=[f_0,f_1,f_2,\cdots,f_m]^T$, in which the $f_0 \equiv 1$ is a extra feature for convention.</p><p>Hypothesis: </p><ul><li>Given $x$, compute features $f\in\R^{m+1}$</li><li>Predict $y=1$ if $\theta^Tf=\theta_0f_0+\theta_1f_1+\cdots\ge 0$ (where $\theta\in\R^{m+1}$)</li></ul><p>Training:<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tf^{(i)})</p><ul><li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tf^{(i)})\large]</li><li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>Notice: instead of $\theta^Tx^{(i)}$ that we use before, now we use $\theta^Tf^{(i)}$. And here our $n$ is equal to $m$. </li></ul><p>Mathematical tricks in practice: Ignoring the $\theta_0$ (s.t. $\theta=[\theta_1,\cdots,\theta_m]^T$), we can get $\sum_j\theta_j^2=\theta^T\theta$. Moreover, for mathematical convenience when deal with a large training set, we gonna use <strong>$\theta^T M \theta$</strong> instead of $\theta^T\theta$.</p><hr><h4 id="SVM-parameters"><a href="#SVM-parameters" class="headerlink" title="SVM parameters"></a>SVM parameters</h4><p>Here are parameters that we are going to choose when use the algorithm above:</p><ul><li>$C$ (=$\frac{1}{m}$)<ul><li>Large $C$: Lower bias, high variance (small $\lambda$)</li><li>Small $C$: Higher bias, low variance (large $\lambda$)</li></ul></li><li>$\sigma^2$<ul><li>Large $\sigma^2$: Features $f_i$ vary more smoothly. Higher bias, lower variance.<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jukxlnxkj306u04laad.jpg" alt="屏幕快照 2019-11-02 15.51.46"></li><li>Small $\sigma^2$: Features $f_i$ vary less smoothly. Lower bias, higher variance.<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jul1utnaj306i04ezk4.jpg" alt="屏幕快照 2019-11-02 15.51.50"></li></ul></li></ul><p>E.g. Suppose we train an SVM and find it overfits our training data. A reasonable next step is going to decrease $C$ or increase $\sigma^2$.</p><h2 id="SVM-in-Practice"><a href="#SVM-in-Practice" class="headerlink" title="SVM in Practice"></a>SVM in Practice</h2><h3 id="Using-An-SVM"><a href="#Using-An-SVM" class="headerlink" title="Using An SVM"></a>Using An SVM</h3><p>We are not recommended writing our own software to solve for the parameters via a SVM. We should call some library functions to do that.</p><p>When using SVM software package (e.g. <code>liblinear</code>, <code>libsvm</code>) to solve for parameters $\theta$, we need to specify:</p><ul><li>Choice of parameter $C$;</li><li>Choice of kernel (similarity function):<ul><li><strong>No kernel</strong> (“linear kernel”, do our common logistic regression): Predict $y=1$ if $\theta^Tx\ge0$. For large $n$ and small $m$ case (no kernel can avoid overfitting).</li><li><strong>Gaussian kernel</strong>: $f_i=\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})$, where $l^{(i)}=x^{(i)}$.(Need to choose $\sigma^2$). For small $n$ and large $m$ case (Gaussian kernel can fit a more complex nonlinear decision boundary).</li></ul></li></ul><p>If we decide to use a Gaussian kernel, here is what we are going to do:</p><ul><li>Provide a kernel (similarity) function:<br>$$<br>\begin{array}{l}<br>\textrm{function f = kernel(x1, x2)}\<br>\qquad \textrm{f} = \exp(-\frac{||\textrm{x1}-\textrm{x2}||^2}{2\sigma^2})\<br>\textrm{return}<br>\end{array}<br>$$<br>Note: Do perform feature scaling before using the Gaussian kernel.</li></ul><h3 id="Other-choices-of-kernel"><a href="#Other-choices-of-kernel" class="headerlink" title="Other choices of kernel"></a>Other choices of kernel</h3><p>Not all similarity functions $\mathop{\textrm{similarity}}(x,l)$ make valid kernels. (Need to satisfy technical condiction called “Mercer’s Theorem” to make sure SVM packages’ optimizations run correctly, and do not diverge).</p><p>There are many off-the-shelf kernels available, for example:</p><ul><li>Polynomial kernel: $k(x,l)=(X^Tl+constant)^{degree}$, need to choose the $constant$ and $degree$. Usually performs worse than Gaussian kernel. Only for $X$ and $l$ are all strictly non negative.</li><li>More esoteric: String kernel (for input is text string),  chi-square kernel, histogram intersection kernel, …</li></ul><h3 id="Multi-class-classification"><a href="#Multi-class-classification" class="headerlink" title="Multi-class classification"></a>Multi-class classification</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jul8myufj30mv0cz0xu.jpg" alt="image-20191102171432072"></p><h3 id="Logistic-regression-v-s-SVMs"><a href="#Logistic-regression-v-s-SVMs" class="headerlink" title="Logistic regression v.s. SVMs"></a>Logistic regression v.s. SVMs</h3><p>$n$ = number of features ($x\in\R^{n+1}$);</p><p>$m$ = number of training examples;</p><ul><li>If $n$ is large (relative to $m$): ($n\ge m$, e.g. $n=10,000, m=10 \sim 1000$)<ul><li>Use logistic regression, or SVM without a kernel (“linear kernel”) </li></ul></li><li>If $n$ is small, $m$ is intermediate: (e.g. $n=1\sim1000,m=50,000+$)<ul><li>Use SVM with Gaussian kernel</li></ul></li><li>If $n$ is small, $m$ is large:<ul><li>Create/add more features, then use logistic regression or SVM without a kernel</li></ul></li></ul><p>Note: Neural network likely to work well for most of these settings, but may be slower to train.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习系统设计</title>
      <link href="/2019/10/26/AndrewNgML/AndrewNg-MachineLearning-11-MachineLearningSystemDesign/"/>
      <url>/2019/10/26/AndrewNgML/AndrewNg-MachineLearning-11-MachineLearningSystemDesign/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-11-Machine-Learning-System-Design"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-11-Machine-Learning-System-Design" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (11) Machine Learning System Design"></a>Notes of Andrew Ng’s Machine Learning —— (11) Machine Learning System Design</h1><h2 id="Prioritizing-What-to-Work-On"><a href="#Prioritizing-What-to-Work-On" class="headerlink" title="Prioritizing What to Work On"></a>Prioritizing What to Work On</h2><p><strong>System Design Example:</strong></p><p>Given a data set of emails, we could construct a vector for each email. Each entry in this vector represents a word. The vector normally contains 10,000 to 50,000 entries gathered by finding the most frequently used words in our data set. If a word is to be found in the email, we would assign its respective entry a 1, else if it is not found, that entry would be a 0. Once we have all our x vectors ready, we train our algorithm and finally, we could use it to classify if an email is a spam or not.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8bj9rx2urj30ki09mdk2.jpg" alt="img"></p><p>So how could you spend your time to improve the accuracy of this classifier?</p><ul><li>Collect lots of data (for example “honeypot” project but doesn’t always work)</li><li>Develop sophisticated features (for example: using email header data in spam emails)</li><li>Develop algorithms to process your input in different ways (recognizing misspellings in spam).</li></ul><p>It is difficult to tell which of the options will be most helpful.</p><h2 id="Error-Analysis"><a href="#Error-Analysis" class="headerlink" title="Error Analysis"></a>Error Analysis</h2><p>The recommended approach to solving machine learning problems is to:</p><ul><li>Start with a simple algorithm, implement it quickly, and test it early on your cross validation data.</li><li>Plot learning curves to decide if more data, more features, etc. are likely to help.</li><li>Manually examine the errors on examples in the cross validation set and try to spot a trend where most of the errors were made.</li></ul><p>For example, assume that we have 500 emails and our algorithm misclassifies a 100 of them. We could manually analyze the 100 emails and categorize them based on what type of emails they are. We could then try to come up with new cues and features that would help us classify these 100 emails correctly. Hence, if most of our misclassified emails are those which try to steal passwords, then we could find some features that are particular to those emails and add them to our model. We could also see how classifying each word according to its root changes our error rate:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8bl9vwi9lj30jg0a143a.jpg" alt="img"></p><p>It is very important to <strong>get error results as a single, numerical value</strong>. Otherwise it is difficult to assess your algorithm’s performance.</p><p>For example if we use stemming, which is the process of treating the same word with different forms (fail/failing/failed) as one word (fail), and get a 3% error rate instead of 5%, then we should definitely add it to our model. However, if we try to distinguish between upper case and lower case letters and end up getting a 3.2% error rate instead of 3%, then we should avoid using this new feature. </p><p>Hence, we should try new things, get a numerical value for our error rate, and based on our result decide whether we want to keep the new feature or not.</p><h2 id="Handling-Skewed-Data"><a href="#Handling-Skewed-Data" class="headerlink" title="Handling Skewed Data"></a>Handling Skewed Data</h2><h3 id="Error-metrics-for-skewed-classes"><a href="#Error-metrics-for-skewed-classes" class="headerlink" title="Error metrics for skewed classes"></a>Error metrics for skewed classes</h3><p>A <em>skewed class</em> is a case of that the ratio of positive to negative examples is very close to one of two extremes.</p><p>For example, consider the problem of cancer classification, when we say $y = 1$ if the patient has cancer and $y = 0$ if they do not. We have trained the progression classifier and let’s say we test out classifier on a test set and find that we get 1% error. So, we are making 99% correct diagnosis. Seems like a really impressive result. </p><p>But now, we find out that only 0.5% of patients in out training test sets actually have cancer (i.e. only half a percent of the patients that come though our screening process have cancer). This case is actually what we called a skewed class. In this case the 1% error no longert looks so impressive.</p><p>And in particular, here’s a piece of code, which is actually even a non learning code like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function y &#x3D; predictCancer(x)</span><br><span class="line">y &#x3D; 0;% just output 0 for whatever x.</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>It just sets $y=0$, and always predicts nobody has cancer. This algorithm would actually get 0.5% error.So this is even better then the 1% offered by our classifier. </p><p>So, How can we know whether a implement (e.g. using the $y \equiv 0$ instead of our learning algorithm) is actually a improvement for a skewed class?</p><p>One of the evaluatin  metric are what’s called <em>Precision/Recall</em>:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bmwqbebxj30po0dgahc.jpg" alt="image-20191026152903469"></p><p>If a classifier is high precision and high recall, then we can make sure that this algorithm preforms pretty well.</p><h3 id="Trading-Off-Precision-and-Recall"><a href="#Trading-Off-Precision-and-Recall" class="headerlink" title="Trading Off Precision and Recall"></a>Trading Off Precision and Recall</h3><p>After training a logistic regression classifier, we plan to make predictions according to:</p><ul><li>Predict $y=1$ if $h_\theta(x)≥threshold$</li><li>Predict $y=1$ if $h_\theta(x)&lt;threshold$</li></ul><p>For different values of the <code>threshold</code> parameter, we get different values of precision (<code>P</code>) and recall (<code>R</code>).</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8bpe4ywhyj30pr0edgth.jpg" alt="image-20191026165452692"></p><p>So, how to compare precision/recall numbers? We get what called <em>F score</em> (or <em>$F_1$ score</em>) for help:<br>$$<br>F_1 \textrm{ Score} = 2 \frac{PR}{P+R}<br>$$<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8bpu6kdx0j30pm0ec446.jpg" alt="image-20191026171016268"></p><p>In the worst case where our $P=R=0$, we will get $F_1$ score = 0. And in the best case where $P=R=1$, the F score will equals 1. So a $F_1$ Score will be a value between 0 and 1, the higher $F_1$ Score we get, the better implement it is.</p><p>A reasonable way to pick the value to use for the threshold is to measure precision (<code>P</code>) and recall (<code>R</code>) on the   <strong>cross validation set</strong> and choose the value of threshold which maximizes $2\frac{PR}{P+R}$.</p><h2 id="Data-For-Machine-Learning"><a href="#Data-For-Machine-Learning" class="headerlink" title="Data For Machine Learning"></a>Data For Machine Learning</h2><blockquote><p>It’s not who has the best algorithm that wins. It’s who has the most data.</p></blockquote><h3 id="Large-data-rationale"><a href="#Large-data-rationale" class="headerlink" title="Large data rationale"></a>Large data rationale</h3><p>We think a massive  training set will be able to help when we assume feature $x\in\R^{n+1}$ has sufficient information to predict $y$ accurately.</p><p>A useful test for this is: <strong>Given the input $x$, can a human expert confidently predict $y$?</strong></p><p>Example: For breakfast I ate <u>{two, to, too}</u> eggs.</p><p>Counterexample: Predict housing price from only size and no other features.</p><hr><p>To make $J_{\textrm{test}}(\Theta)$ be small, we should:</p><ul><li><p>Using a learning algorithm with many parameters (<em>low bias algorithm</em> e.g. logistic/linear regression regression with many features; neural network with many hidden units)</p><p>-&gt; $J_{\textrm{train}}(\Theta)$ will be small</p></li><li><p>Using a very large training set (unlikely to overfit)</p><p>-&gt; $J_{\textrm{train}}(\Theta) \approx J_{\textrm{test}}(\Theta)$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习的应用建议</title>
      <link href="/2019/10/26/AndrewNgML/AndrewNg-MachineLearning-10-AdviceForApplyingMachineLearning/"/>
      <url>/2019/10/26/AndrewNgML/AndrewNg-MachineLearning-10-AdviceForApplyingMachineLearning/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-10-Advice-for-Applying-Machine-Learning"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-10-Advice-for-Applying-Machine-Learning" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (10) Advice for Applying Machine Learning"></a>Notes of Andrew Ng’s Machine Learning —— (10) Advice for Applying Machine Learning</h1><h2 id="Evaluating-a-Learning-Algorithm"><a href="#Evaluating-a-Learning-Algorithm" class="headerlink" title="Evaluating a Learning Algorithm"></a>Evaluating a Learning Algorithm</h2><h3 id="Machine-learning-diagnostic"><a href="#Machine-learning-diagnostic" class="headerlink" title="Machine learning diagnostic"></a>Machine learning diagnostic</h3><p><code>Diagnostic</code>: A test that you can run to gain insight what is/isn’t working with a learning algorithm, and gain guidance as to how best to improve its performance.</p><p>Diagnostics can take time to implement, but doing so can be a very good use of our time.</p><h3 id="Evaluating-a-Hypothesis"><a href="#Evaluating-a-Hypothesis" class="headerlink" title="Evaluating a Hypothesis"></a>Evaluating a Hypothesis</h3><p>Once we have done some trouble shooting for errors in our predictions by: </p><ul><li>Getting more training examples</li><li>Trying smaller sets of features</li><li>Trying additional features</li><li>Trying polynomial features</li><li>Increasing or decreasing λ</li></ul><p>We can move on to evaluate our new hypothesis. </p><p>A hypothesis may have a low error for the training examples but still be inaccurate (because of overfitting). Thus, to evaluate a hypothesis, given a dataset of training examples, we can split up the data into two sets: a <strong><code>training set</code></strong> and a <strong><code>test set</code></strong>. Typically, the training set consists of <code>70%</code> of your data and the test set is the remaining <code>30%</code>.</p><p>The new procedure using these two sets is then:</p><ol><li><p>Learn $\Theta$ and minimize $J_{\textrm{train}}(\Theta)$ using the training set</p></li><li><p>Compute the test set error $J_{\textrm{test}}(\Theta)$</p></li></ol><h4 id="The-test-set-error"><a href="#The-test-set-error" class="headerlink" title="The test set error"></a>The test set error</h4><ol><li>For linear regression: $J_{test}(\Theta) = \dfrac{1}{2m_{test}} \sum_{i=1}^{m_{test}}(h_\Theta(x^{(i)}<em>{test}) - y^{(i)}</em>{test})^2$</li><li>For classification ~ Misclassification error (aka 0/1 misclassification error):</li></ol><p>$$<br>err(h_\Theta(x),y) = \left{\begin{array}{lll} 1 &amp; \textrm{if } h_\Theta(x) \geq 0.5\ and\ y = 0\ or\ h_\Theta(x) &lt; 0.5\ and\ y = 1\ 0 &amp; \textrm{otherwise} \end{array}\right.<br>$$</p><p>This gives us a binary 0 or 1 error result based on a misclassification. The average test error for the test set is:<br>$$<br>\text{Test Error} = \dfrac{1}{m_{test}} \sum^{m_{test}}<em>{i=1} err(h_\Theta(x^{(i)}_{test}), y^{(i)}</em>{test})<br>$$<br>This gives us the proportion of the test data that was misclassified.</p><h3 id="Model-Selection-and-Train-Validation-Test-Sets"><a href="#Model-Selection-and-Train-Validation-Test-Sets" class="headerlink" title="Model Selection and Train/Validation/Test Sets"></a>Model Selection and Train/Validation/Test Sets</h3><p>Just because a learning algorithm fits a training set well, that does not mean it is a good hypothesis. It could over fit and as a result your predictions on the test set would be poor. The error of your hypothesis as measured on the data set with which you trained the parameters will be lower than the error on any other data set. </p><p>Given many models with different polynomial degrees, we can use a systematic approach to identify the ‘best’ function. In order to choose the model of your hypothesis, you can test each degree of polynomial and look at the error result.</p><p>One way to break down our dataset into the three sets is:</p><ul><li>Training set: 60%</li><li>Cross validation set: 20%</li><li>Test set: 20%</li></ul><p>We can now calculate three separate error values for the three different sets using the following method:</p><ol><li>Optimize the parameters in $\Theta$ using the training set for each polynomial degree.</li><li>Find the polynomial degree d with the least error using the cross validation set.</li><li>Estimate the generalization error using the test set with $J_{test}(\Theta(d))$, ($d$ = theta from polynomial with lower error);</li></ol><p>This way, the degree of the polynomial d has not been trained using the test set.</p><h2 id="Bias-v-s-Variance"><a href="#Bias-v-s-Variance" class="headerlink" title="Bias v.s. Variance"></a>Bias v.s. Variance</h2><h3 id="Diagnosing-Bias-v-s-Variance"><a href="#Diagnosing-Bias-v-s-Variance" class="headerlink" title="Diagnosing Bias v.s. Variance"></a>Diagnosing Bias v.s. Variance</h3><p>We offen need to examine the relationship between the degree of the polynomial $d$ and the <em>underfitting</em> or <em>overfitting</em> of our hypothesis.</p><ul><li>We need to distinguish whether <strong>bias</strong> or <strong>variance</strong> is the problem contributing to bad predictions.</li><li>High bias is underfitting and high variance is overfitting. Ideally, we need to find a golden mean between these two.</li></ul><p>The training error will tend to <strong>decrease</strong> as we increase the degree d of the polynomial.</p><p>At the same time, the cross validation error will tend to <strong>decrease</strong> as we increase d up to a point, and then it will <strong>increase</strong> as $d$ is increased, forming a convex curve.</p><ul><li><strong>High bias (underfitting)</strong>: both $J_{\textrm{train}}(\Theta)$ and $J_{\textrm{CV}}(\Theta)$ will be high. Also, $J_{\textrm{CV}}(\Theta) \approx J_{\textrm{train}}(\Theta)$.</li><li><strong>High variance (overfitting)</strong>: $J_{\textrm{train}}(\Theta)$ will be low and $J_{\textrm{CV}}(\Theta) \gg J_{\textrm{train}}(\Theta)$.</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ajhooasfj308c073q3l.jpg" alt="img"></p><h3 id="Regularization-and-Bias-Variance"><a href="#Regularization-and-Bias-Variance" class="headerlink" title="Regularization and Bias/Variance"></a>Regularization and Bias/Variance</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8al43zgpwj30jj0akq4m.jpg" alt="img"></p><p>In the figure above, we see that as $\lambda$ increases, our fit becomes more rigid. On the other hand, as $\lambda$ approaches $0$, we tend to over overfit the data. So how do we choose our parameter $\lambda$ to get it ‘just right’ ? In order to choose the model and the regularization term $\lambda$,  we need to:</p><ol><li>Create a list of lambdas (i.e. $\lambda∈{0,0.01,0.02,0.04,0.08,0.16,0.32,0.64,1.28,2.56,5.12,10.24}$);</li><li>Create a set of models with different degrees or any other variants.</li><li>Iterate through the$\lambda$s and for each $\lambda$ go through all the models to learn some $\Theta$.</li><li>Compute the cross validation error using the learned $\Theta$ (computed with $\lambda$) on the $J_{\textrm{CV}}(\Theta)$ <strong>without</strong> regularization or $\lambda = 0$.</li><li>Select the best combo that produces the lowest error on the cross validation set.</li><li>Using the best combo $\Theta$ and $\lambda$, apply it on $J_{\textrm{test}}(\Theta)$ to see if it has a good generalization of the problem.</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8antxbcmwj30pu0eiq8l.jpg" alt="image-20191025191458736"></p><h3 id="Learning-Curves"><a href="#Learning-Curves" class="headerlink" title="Learning Curves"></a>Learning Curves</h3><p>Training an algorithm on a very few number of data points (such as 1, 2 or 3) will easily have 0 errors because we can always find a quadratic curve that touches exactly those number of points. Hence:</p><ul><li>As the training set gets larger, the error for a quadratic function increases.</li><li>The error value will plateau out after a certain m, or training set size.</li></ul><p><em>Learning curves</em> is often a very useful thing to plot if either we wanted to sanity check that our algorithm is working correctly, or if we want to improve the performance of the algorithm.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8anv9sdhvj30pq0ef0xi.jpg" alt="image-20191025191643371"></p><h4 id="Experiencing-high-bias"><a href="#Experiencing-high-bias" class="headerlink" title="Experiencing high bias"></a>Experiencing high bias</h4><p><strong>Low training set size</strong>: cases $J_{\textrm{train}}(\Theta)$ to be low and $J_{\textrm{CV}}(\Theta)$ to be high.</p><p><strong>Large training set size</strong>: cases both $J_{\textrm{train}}(\Theta)$ and $J_{\textrm{CV}}(\Theta)$ to be high with $J_{\textrm{train}}(\Theta) \approx J_{\textrm{CV}}(\Theta)$.</p><p>If a learning algorithm is suffering from <strong>high bias</strong>, getting more training data will not <strong>(by itself)</strong> help much.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8annycdk8j308c056q3e.jpg" alt="img"></p><h4 id="Experiencing-high-variance"><a href="#Experiencing-high-variance" class="headerlink" title="Experiencing high variance"></a>Experiencing high variance</h4><p><strong>Low training set size</strong>: $J_{\textrm{train}}(\Theta)$ will be low and $J_{\textrm{CV}}(\Theta)$ will be high.</p><p><strong>Large training set size</strong>: $J_{\textrm{train}}(\Theta)$ increases with training set size and $J_{\textrm{CV}}(\Theta)$ continues to decrease without leveling off. Also, $J_{\textrm{train}}(\Theta) &lt; J_{\textrm{CV}}(\Theta)$ but the difference between them remains significant.</p><p>If a learning algorithm is suffering from <strong>high variance</strong>, getting more training data is likely to help.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8anrlbbfkj308c04rdgb.jpg" alt="img"></p><h3 id="Deciding-What-to-Do-Next-Revisited"><a href="#Deciding-What-to-Do-Next-Revisited" class="headerlink" title="Deciding What to Do Next Revisited"></a>Deciding What to Do Next Revisited</h3><p>Our decision process can be broken down as follows:</p><ul><li><p><strong>Getting more training examples:</strong> Fixes high variance</p></li><li><p><strong>Trying smaller sets of features:</strong> Fixes high variance</p></li><li><p><strong>Adding features:</strong> Fixes high bias</p></li><li><p><strong>Adding polynomial features:</strong> Fixes high bias</p></li><li><p><strong>Decreasing λ:</strong> Fixes high bias</p></li><li><p><strong>Increasing λ:</strong> Fixes high variance.</p></li></ul><h4 id="Diagnosing-Neural-Networks"><a href="#Diagnosing-Neural-Networks" class="headerlink" title="Diagnosing Neural Networks"></a>Diagnosing Neural Networks</h4><ul><li>A neural network with fewer parameters is <strong>prone to underfitting</strong>. It is also <strong>computationally cheaper</strong>.</li><li>A large neural network with more parameters is <strong>prone to overfitting</strong>. It is also <strong>computationally expensive</strong>. In this case you can use regularization (increase λ) to address the overfitting.</li></ul><p>Using a single hidden layer is a good starting default. You can train your neural network on a number of hidden layers using your cross validation set. You can then select the one that performs best.</p><h4 id="Model-Complexity-Effects"><a href="#Model-Complexity-Effects" class="headerlink" title="Model Complexity Effects:"></a>Model Complexity Effects:</h4><ul><li>Lower-order polynomials (low model complexity) have high bias and low variance. In this case, the model fits poorly consistently.</li><li>Higher-order polynomials (high model complexity) fit the training data extremely well and the test data extremely poorly. These have low bias on the training data, but very high variance.</li><li>In reality, we would want to choose a model somewhere in between, that can generalize well but also fits the data reasonably well.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络的拟合</title>
      <link href="/2019/10/21/AndrewNgML/AndrewNg-MachineLearning-9-NeuralNetworksLearning/"/>
      <url>/2019/10/21/AndrewNgML/AndrewNg-MachineLearning-9-NeuralNetworksLearning/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-9-Neural-Networks-Learning"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-9-Neural-Networks-Learning" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (9) Neural Networks: Learning"></a>Notes of Andrew Ng’s Machine Learning —— (9) Neural Networks: Learning</h1><h2 id="Cost-Functon-amp-Backpropagation"><a href="#Cost-Functon-amp-Backpropagation" class="headerlink" title="Cost Functon &amp; Backpropagation"></a>Cost Functon &amp; Backpropagation</h2><h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3><p>Firstly, define some needed variables:</p><table><thead><tr><th>Notation</th><th>Represent</th></tr></thead><tbody><tr><td>$L$</td><td>total number of layers in the network</td></tr><tr><td>$s_l$</td><td>number of units (not counting bias unit) in layer $l$</td></tr><tr><td>$K$</td><td>number of output units/classes</td></tr></tbody></table><p>Recall that in neural networks, we may have many output nodes. </p><p>We denote $H_\Theta(x)_k$ as being a hypothesis that results in the $K^{th}$ output. </p><p>Our cost function for neural networks is going to be a generalization of the one we used for logistic regression. Recall that the cost function for regularized logistic regression was:</p><p>$J(\theta) = - \frac{1}{m} \sum_{i=1}^m \large[ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2$</p><p>For neural networks, it is going to be slightly more complicated:<br>$$<br>J(\Theta)=-\frac{1}{m}\sum_{i=1}^{m}\sum_{k=1}^{K}\Big[<br>y_k^{(i)}log\Big(\big(h_\Theta(x^{(i)})\big)<em>k\Big)+<br>(1-y_k^{(i)})log\Big(1-\big(h_\Theta(x^{(i)})\big)<em>k\Big)<br>\Big]+<br>\frac{\lambda}{2m}\sum</em>{l=1}^{L-1}\sum</em>{i=1}^{s_l}\sum_{j=1}^{s_{l+1}}\Big(\Theta_{j,i}^{(l)}\Big)^2<br>$$<br>We have added a few nested summations to account for our multiple output nodes. In the first part of the equation, before the square brackets, we have an additional nested summation that loops through the number of output nodes.</p><p>In the regularization part, after the square brackets, we must account for multiple theta matrices. The number of columns in our current theta matrix is equal to the number of nodes in our current layer (including the bias unit). The number of rows in our current theta matrix is equal to the number of nodes in the next layer (excluding the bias unit). As before with logistic regression, we square every term.</p><p>Note:</p><ul><li>the double sum simply adds up the logistic regression costs calculated for each cell in the output layer</li><li>the triple sum simply adds up the squares of all the individual Θs in the entire network.</li><li>the i in the triple sum does <strong>not</strong> refer to training example i</li></ul><h3 id="Backpropagation-Algorithm"><a href="#Backpropagation-Algorithm" class="headerlink" title="Backpropagation Algorithm"></a>Backpropagation Algorithm</h3><p><code>Backpropagation</code> is neural-network terminology for minimizing our cost function, just like what we were doing with gradient descent in logistic and linear regression. Our goal is to compute:</p><p>$\mathop{\textrm{min}}_\Theta J(\Theta)$</p><p>That is, we want to minimize our cost function $J$ using an optimal set of parameters in theta. In this section we’ll look at the equations we use to compute the partial derivative of $J(\Theta)$:</p><p>$\frac{\partial}{\partial\Theta_{i,j}^{(l)}}J(\Theta)$</p><p>To do so, we use the following algorithm:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7y3ekmyjmj30om0d9gs6.jpg" alt="img"></p><hr><h4 id="Backpropagation-Algorithm-1"><a href="#Backpropagation-Algorithm-1" class="headerlink" title="Backpropagation Algorithm"></a>Backpropagation Algorithm</h4><p>Given training set ${(x^{(1)},y^{(1)}),…,(x^{(m)},y^{(m)})}$</p><ul><li>Set $\Delta_{i,j}^{(l)}:=0$ for all $l,i,j$, (hence you end up having a matrix full of zeros)</li></ul><p>(👇 Begin For loop: 👇)</p><p><strong>For</strong> training example $t=1\textrm{ to } m$:</p><ol><li>Set $a^{(1)}:=x^{(t)}$</li><li>Preform forward propagation to compute $a^{(l)}$ for $l=2,3,…,L$</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7y3n2yqdkj30d8074q53.jpg" alt="img"></p><ol start="3"><li>Using $y^{(t)}$, compute $\delta^{(L)}=a^{(L)}-y^{(t)}$</li></ol><p>Where $L$ is our total number of layers and $a^{(L)}$ is the vector of outputs of the activation units for the last layer.</p><p>So, our <code>error values</code> for the last layer are simply the differences of our actual results in the last layer and the correct outputs in $y$.</p><p>To get the delta values of the layers before the last layer, we can use an equation that steps us back from right to left:</p><ol start="4"><li>Compute $\delta^{(L-1)},\delta^{(L-2)},…,\delta^{(2)}$ using $\delta^{(l)}=\big((\Theta^{(l)})^T\delta^{(l+1)}\big).<em>a^{(l)}.</em>(1-a^{(l)})$</li></ol><p>【Note】: “$.* $” above are the element-wise multiplications in Octave/MATLAB.</p><p>The delta values of layer $l$ are calculated by multiplying the delta values in the next layer with the theta matrix of layer $l$.</p><p>We then element-wise multiply that with a function called $g’$, or g-prime, which is the derivative of the activation function $g$ evaluated with the input values given by $z^{(l)}$.</p><p>The g-prime derivative terms can also be written out as: $g’(z^{(l)})=a^{(l)}.*(1-a^{(l)})$</p><ol start="5"><li>$\Delta_{i,j}^{(l)}:=\Delta_{i,j}^{l}+a_j^{(l)}\delta^{(l+1)}$ or with vectorization, $\Delta^{(l)}:=\Delta^{(l)}+\delta^{(l+1)}(a^{(l)})^T$</li></ol><p>(👆 End For 👆)</p><p>Hence we update our new $\Delta$ matrix.</p><ul><li><p>$D_{i,j}^{(l)}:=\frac{1}{m}\big(\Delta_{i,j}^{(l)}+\lambda\Theta_{i,j}^{(l)}\big)$, if $j\not=0$;</p></li><li><p>$D_{i,j}^{(l)}:=\frac{1}{m}\Delta_{i,j}^{(l)}$ if $j=0$.</p></li></ul><p>The capital-delta matrix $D$ is used as an <code>accumulator</code> to add up our values as we go along and eventually compute our partial derivate.</p><p>Thus we get $\frac{\partial}{\partial\Theta_{i,j}^{(l)}}J(\Theta)=D_{i,j}^{(l)}$.</p><hr><h4 id="Backpropagation-Intuition"><a href="#Backpropagation-Intuition" class="headerlink" title="Backpropagation Intuition"></a>Backpropagation Intuition</h4><p>Recall that the cost function for a neural network is:<br>$$<br>J(\Theta)=-\frac{1}{m}\sum_{i=1}^{m}\sum_{k=1}^{K}\Big[y_k^{(t)}\log\big(h_\Theta(x^{(t)})\big)<em>k+(1-y_k^{(t)})\log\big(1-h_\Theta(x^{(t)})\big)<em>k\Big]+\frac{\lambda}{m}\sum</em>{l=1}^{L-1}\sum</em>{i=1}^{s_l}\sum_{j=1}^{s_l+1}\Big(\Theta_{j,i}^{(l)}\Big)^2<br>$$<br>If we consider simple non-multiclass classification ($K=1$) and disregard regularization, the cost is copmputed with:<br>$$<br>cost(t) = y^{(t)}\log\big(h_\Theta(x^{(t)})\big)+(1-y^{(t)})\log\big(1-h_\Theta(x^{(t)})\big)<br>$$<br>Intuitively, $\delta_j^{(l)}$ is the “error” for $a_j^{(l)}$ (unit $j$ in layer $l$). More formally, the delta values are actually the derivative of the cost function:<br>$$<br>\delta_j^{(l)}=\frac{\partial}{\partial z_j^{(l)}}cost(t)<br>$$<br>Recall that our derivative is the slope of a line tangent to the cost function, so the steeper the slope the more incorrect we are. Let us consider the following neural network below and see how we could calculate some $\delta_j^{(l)}$:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8072ftfjzj30k00b9wi3.jpg" alt="img"></p><p>In the image above, to calculate $\delta_2^{(2)}$ , we multiply the weights $\Theta_{12}^{(2)}$ and $\Theta_{22}^{(2)}$ by their respective $\delta$ values found to the right of each edge. So we get $\delta_2^{(2)}=\Theta_{12}^{(2)}\times\delta_1^{(3)}+\Theta_{22}^{(2)}\times\delta_2^{(3)}$. To calculate every single possible $\delta_j^{(l)}$, we could start from the right of our diagram. We can think of our edges as our $\Theta_{ij}$. Going from right to left, to calculate the value of $\delta_j^{(l)}$, you can just take the over all sum of each weight times the $\delta$ it is coming from. Hence, another example would be $\delta_2^{(3)}=\Theta_{12}^{(3)}\times\delta_1^{(4)}$.</p><h2 id="Backpropagation-in-Practice"><a href="#Backpropagation-in-Practice" class="headerlink" title="Backpropagation in Practice"></a>Backpropagation in Practice</h2><h3 id="Unrolling-Parameters"><a href="#Unrolling-Parameters" class="headerlink" title="Unrolling Parameters"></a>Unrolling Parameters</h3><p>With neural networks, we are working with sets of matrices:<br>$$<br>\begin{array}{lll} \Theta^{(1)}, \Theta^{(2)}, \Theta^{(3)}, \dots \newline D^{(1)}, D^{(2)}, D^{(3)}, \dots \end{array}<br>$$<br>In order to use optimizing function such as <code>fminunc()</code>, we will want to <em>unroll</em> all the elements and put them into one long vector:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thetaVector &#x3D; [ Theta1(:); Theta2(:); Theta3(:) ];</span><br><span class="line">deltaVector &#x3D; [ D1(:); D2(:); D3(:) ];</span><br></pre></td></tr></table></figure><p>If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11, then we can get back our original matrices from the “unrolled” versions as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Theta1 &#x3D; reshape(thetaVector(1:110),10,11)</span><br><span class="line">Theta2 &#x3D; reshape(thetaVector(111:220),10,11)</span><br><span class="line">Theta3 &#x3D; reshape(thetaVector(221:231),1,11)</span><br></pre></td></tr></table></figure><p>To summarize:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g80ervs2l4j30ey06aq57.jpg" alt="img"></p><h3 id="Gradient-Checking"><a href="#Gradient-Checking" class="headerlink" title="Gradient Checking"></a>Gradient Checking</h3><p>Gradient checking will assure that our backpropagation works as intended. We can approximate the derivative of our cost function with:<br>$$<br>\frac{\partial}{\partial\Theta}J(\Theta) \approx \frac{J(\Theta+\epsilon)-J(\Theta-\epsilon)}{2\epsilon}<br>$$<br>A small value for $\epsilon$ such as $\epsilon=10^{-4}$, guarantees that the math works out properly. If the value for $\epsilon$, we can end up with numerical problems.</p><p>With multiple theta matrices, we can approximate the derivative with respect to $\Theta_j$ (where we get $j$ from 1 to n, for each one) as follows:<br>$$<br>\frac{\partial}{\partial\Theta_j}J(\Theta) \approx \frac{J(\Theta_1,…,\Theta_j+\epsilon,…,\Theta_n)-J(\Theta_1,…,\Theta_j-\epsilon,…,\Theta_n)}{2\epsilon}<br>$$<br>Hence, we are only adding or subtracting epsilon to the $\Theta_j$ matrix.</p><p>In octave we can do it as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">epsilon &#x3D; 1e-4;</span><br><span class="line">for i &#x3D; 1 : n</span><br><span class="line">thetaPlus &#x3D; theta;</span><br><span class="line">thetaPlus(i) +&#x3D; epsilon;</span><br><span class="line">thetaMinus &#x3D; theta;</span><br><span class="line">thetaMinus(i) +&#x3D; epsilon;</span><br><span class="line">gradApprox(i) &#x3D; (J(thetaPlus) - J(thetaMinus)) &#x2F; (2*epsilon);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>We previously saw how to calculate the deltaVector. So once we compute our <code>gradApprox</code> vector, we can check that <code>gradApprox ≈ deltaVector</code>. </p><p>Once we have verified <strong>once</strong> that your backpropagation algorithm is correct, we don’t need to compute gradApprox again. The code to compute gradApprox can be very slow. So we guess it’s better to turn off or disable the codes for gradient checking.</p><h3 id="Randoom-Initialization"><a href="#Randoom-Initialization" class="headerlink" title="Randoom Initialization"></a>Randoom Initialization</h3><p>Initializing all theta weights to zero does not work with neural networks. When we backpropagate, all nodes will update to the same value repeatedly. Instead we can randomly initialize our weights for our $\Theta$  matrices using the following method:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g84m3eabzfj30fb07qjsk.jpg" alt="img"></p><p>Hence, we initialize each $\Theta_{ij}^{(l)}$ to a random value between $[-\epsilon,\epsilon]$.  Using the above formula guarantees that we get the desired bound. The same procedure applies to all the $\Theta$’s. </p><p>Below is some working code implement.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.</span><br><span class="line"></span><br><span class="line">Theta1 &#x3D; rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta2 &#x3D; rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta3 &#x3D; rand(1,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</span><br></pre></td></tr></table></figure><p><code>rand(x,y)</code> is just a function in octave that will initialize a matrix of random real numbers between 0 and 1. </p><p>(Note: the epsilon used above is unrelated to the epsilon from Gradient Checking)</p><h3 id="Putting-It-Together"><a href="#Putting-It-Together" class="headerlink" title="Putting It Together"></a>Putting It Together</h3><p>First, pick a network architecture; choose the layout of your neural network, including how many hidden units in each layer and how many layers in total you want to have.</p><ul><li>Number of input units = dimension of features $x^{(i)}$</li><li>Number of output units = number of classes</li><li>Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units)</li><li>Defaults: 1 hidden layer. If you have more than 1 hidden layer, then it is recommended that you have the same number of units in every hidden layer.</li></ul><p><strong>Training a Neural Network</strong></p><ol><li>Randomly initialize the weights</li><li>Implement forward propagation to get $h_\Theta(x^{(i)})$ for any $x^{(i)}$</li><li>Implement the cost function</li><li>Implement backpropagation to compute partial derivatives</li><li>Use gradient checking to confirm that your backpropagation works. Then disable gradient checking.</li><li>Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta.</li></ol><p>When we perform forward and back propagation, we loop on every training example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1:m,</span><br><span class="line">   Perform forward propagation and backpropagation using example (x(i),y(i))</span><br><span class="line">   (Get activations a(l) and delta terms d(l) for l &#x3D; 2,...,L</span><br></pre></td></tr></table></figure><p>The following image gives us an intuition of what is happening as we are implementing our neural network: </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g84ozcnlokj30eu08aq5g.jpg" alt="img"></p><p>Ideally, we want $h_\Theta(x^{(i)})\approx y^{(i)}$. This will minimize our cost function. However, keep in mind that $J(\Theta)$  is not convex and thus we can end up in a local minimum instead. </p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络的描述</title>
      <link href="/2019/10/13/AndrewNgML/AndrewNg-MachineLearning-8-NeuralNetworksRepresentation/"/>
      <url>/2019/10/13/AndrewNgML/AndrewNg-MachineLearning-8-NeuralNetworksRepresentation/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-8-Neural-Networks-Representation"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-8-Neural-Networks-Representation" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (8) Neural Networks: Representation"></a>Notes of Andrew Ng’s Machine Learning —— (8) Neural Networks: Representation</h1><h2 id="Model-Representation"><a href="#Model-Representation" class="headerlink" title="Model Representation"></a>Model Representation</h2><p>Let’s examine how we will represent a hypothesis function using neural networks.</p><p>At a very simple level, neurons are basically computational units that take inputs (<strong>dendrites</strong>) as electrical inputs (called “spikes”) that are channeled to outputs (<strong>axons</strong>).</p><p>In our model, our dendrites are like the input features $x_1\cdots x_n$, and the output is the result of our hypothesis function.</p><p>In this model our $x_0$ input node is sometimes called the “bias unit.” It is always equal to 1.</p><p>In neural networks, we use the same logistic function as in classification, $\frac{1}{1+e^{-\theta^Tx}}$, yet we sometimes call it a sigmoid (logistic) <strong>activation</strong> function. In this situation, our “theta” parameters are sometimes called “weights”.</p><p>Visually, a simplistic representation looks like:<br>$$<br>\left[\begin{array}{c}<br>x_0\x_1\x_2<br>\end{array}\right]<br>\to [\quad] \to h_\theta(x)<br>$$<br>Our input nodes (layer 1), also known as the “input layer”, go into another node (layer 2), which finally outputs the hypothesis function, known as the “output layer”. We can have intermediate layers of nodes between the input and output layers called the “hidden layers.”</p><p>In this example, we label these intermediate or “hidden” layer nodes $a^2_0 \cdots a^2_n$ and call them “activation units.”</p><ul><li>$a_i^{(j)}$ = “activation” of unit $i$ in layer $j$</li><li>$\Theta^{(j)}$ = matrix of weights controlling function mapping from layer $j$ to layer $j+1$</li></ul><p>If we had one hidden layer, it would look like:<br>$$<br>\left[\begin{array}{c}x_0 \ x_1 \ x_2 \ x_3\end{array}\right]\rightarrow\left[\begin{array}{c}a_1^{(2)} \ a_2^{(2)} \ a_3^{(2)} \ \end{array}\right]\rightarrow h_\theta(x)<br>$$<br>The values for each of the “activation” nodes is obtained as follows:<br>$$<br>\begin{array}{r} a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 + \Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 + \Theta_{13}^{(1)}x_3) \\ a_2^{(2)} = g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 + \Theta_{23}^{(1)}x_3) \\ a_3^{(2)} = g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 + \Theta_{33}^{(1)}x_3) \\ h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} + \Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)}) \\ \end{array}<br>$$<br>To do a vectorized implementation of thew above functions, we’re going to define a new variable $z_k^{(j)}$ that encompasses the parameters inside our $g$ function. In the previous example if we replaced by the vartizble $z$ for all the parameters we would get:<br>$$<br>\begin{array}{l}a_1^{(2)} = g(z_1^{(2)}) \\ a_2^{(2)} = g(z_2^{(2)}) \\ a_3^{(2)} = g(z_3^{(2)}) \\ \end{array}<br>$$<br>In other words, for layer $j=2$ and node $k$, the variable $z$ will be:<br>$$<br>z_k^{(2)} = \Theta_{k,0}^{(1)}x_0 + \Theta_{k,1}^{(1)}x_1 + \cdots + \Theta_{k,n}^{(1)}x_n<br>$$<br>The vector representation of $x$ and $z^{j}$ is:<br>$$<br>x = \begin{bmatrix}x_0 \ x_1 \ \vdots \ x_n\end{bmatrix} \qquad z^{(j)} = \begin{bmatrix}z_1^{(j)} \ z_2^{(j)} \ \vdots \ z_n^{(j)}\end{bmatrix}<br>$$<br>Setting $x = a^{(1)}$, we can rewrite the equation as:<br>$$<br>z^{(j)} = \Theta^{(j-1)}a^{(j-1)}<br>$$<br>We are multiplying our matrix $\Theta^{(j−1)}$ with dimensions $s_j\times (n+1)$ (where $s_j$ is the number of our activation nodes) by our vector $a^{(j-1)}$ with height $(n+1)$. This gives us our vector $z^{(j)}$ with height $s_j$. Now we can get a vector of our activation nodes for layer $j$ as follows:<br>$$<br>a^{(j)} = g(z^{(j)})<br>$$<br>Where our function g can be applied element-wise to our vector $z^{(j)}$.</p><p>We can then add a bias unit (equal to $1$) to layer $j$ after we have computed $a^{(j)}$. This will be element $a_0^{(j)}$ and will be equal to $1$. To compute our final hypothesis, let’s first compute another $z$ vector:<br>$$<br>z^{(j+1)} = \Theta^{(j)}a^{(j)}<br>$$<br>We get this final $z$ vector by multiplying the next theta matrix after $\Theta^{(j−1)}$ with the values of all the activation nodes we just got. This last theta matrix $\Theta^{(j)}$ will have only <strong>one row</strong> which is multiplied by one column $a^{(j)}$ so that our result is a single number. We then get our final result with:<br>$$<br>h_\Theta(x)=a^{(j+1)}=g(z^{(j+1)})<br>$$<br>Notice that in this <strong>last step</strong>, between layer $j$ and layer $j+1$, we are doing <strong>exactly the same thing</strong> as we did in logistic regression. Adding all these intermediate layers in neural networks allows us to more elegantly produce interesting and more complex non-linear hypotheses.</p><h2 id="Examples-and-Intuitions"><a href="#Examples-and-Intuitions" class="headerlink" title="Examples and Intuitions"></a>Examples and Intuitions</h2><p>A simple example of applying neural networks is by predicting $x_1 \and x_2$, which is the logical ‘and’ operator and is only true if both $x_1$ and $x_2$ are $1$. The graph of our functions will look like:<br>$$<br>\begin{array}{c}\begin{bmatrix}x_0 \ x_1 \ x_2\end{bmatrix} \rightarrow\begin{bmatrix}g(z^{(2)})\end{bmatrix} \rightarrow h_\Theta(x)\end{array}<br>$$<br>Remember that $x_0$ is our bias variable and is always $1$. The $g(z)$ is the following:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7qukjiuo1j308h04d0sv.jpg" alt="img"></p><p>Let’s set our first Theta matrix as:<br>$$<br>\Theta^{(1)}=\begin{bmatrix} -30 &amp; 20 &amp; 20 \end{bmatrix}<br>$$<br>This will cause the output of our hypothesis to only be positive if both $x_1$ and $x_2$ are $1$. In other words:<br>$$<br>\begin{array}{ll}&amp; h_\Theta(x) = g(-30 + 20x_1 + 20x_2) \ \ &amp; x_1 = 0 \ \ and \ \ x_2 = 0 \ \ then \ \ g(-30) \approx 0 \ &amp; x_1 = 0 \ \ and \ \ x_2 = 1 \ \ then \ \ g(-10) \approx 0 \ &amp; x_1 = 1 \ \ and \ \ x_2 = 0 \ \ then \ \ g(-10) \approx 0 \ &amp; x_1 = 1 \ \ and \ \ x_2 = 1 \ \ then \ \ g(10) \approx 1\end{array}<br>$$<br>So we have constructed one of the fundamental operations in computers by using a small neural network rather than using an actual AND gate. Neural networks can also be used to simulate all the other logical gates. The following is an example of the logical operator ‘OR’, meaning either $x_1$ is true or $x_2$ is true, or both:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7qukcx6wij30gb07raaw.jpg" alt="f_ueJLGnEea3qApInhZCFg_a5ff8edc62c9a09900eae075e8502e34_Screenshot-2016-11-23-10.03.48"></p><h3 id="A-Neural-Network-for-XNOR"><a href="#A-Neural-Network-for-XNOR" class="headerlink" title="A Neural Network for XNOR"></a>A Neural Network for <code>XNOR</code></h3><p>The $\Theta^{(1)}$ matrices for <code>AND</code>, <code>NOR</code> and <code>OR</code> are:<br>$$<br>\begin{array}{l}AND:\&amp;\Theta^{(1)} &amp;=\begin{bmatrix}-30 &amp; 20 &amp; 20\end{bmatrix} \ NOR:\&amp;\Theta^{(1)} &amp;= \begin{bmatrix}10 &amp; -20 &amp; -20\end{bmatrix} \ OR:\&amp;\Theta^{(1)} &amp;= \begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix} \\end{array}<br>$$</p><p>We can combine these to get the <code>XNOR</code> logical operator (which gives $1$ if $x_1$ and $x_2$ are both $0$ or both $1$):<br>$$<br>\begin{bmatrix}x_0 \ x_1 \ x_2\end{bmatrix} \rightarrow\begin{bmatrix}a_1^{(2)} \ a_2^{(2)} \end{bmatrix} \rightarrow\begin{bmatrix}a^{(3)}\end{bmatrix} \rightarrow h_\Theta(x)<br>$$<br>For the transition between the first and second layer, we’ll use a $\Theta^{(1)}$ matrix that combines the values for AND and NOR:<br>$$<br>\Theta^{(1)} =\begin{bmatrix}-30 &amp; 20 &amp; 20 \ 10 &amp; -20 &amp; -20\end{bmatrix}<br>$$<br>For the transition between the second and third layer, we’ll use a $\Theta^{(2)}$ matrix that uses the value for OR:<br>$$<br>\Theta^{(2)} =\begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix}<br>$$<br>Let’s write out the values for all our nodes:<br>$$<br>\begin{array}{ll}&amp; a^{(2)} = g(\Theta^{(1)} \cdot x) \&amp; a^{(3)} = g(\Theta^{(2)} \cdot a^{(2)}) \&amp; h_\Theta(x) = a^{(3)}\end{array}<br>$$<br>And there we have the XNOR operator using a hidden layer with two nodes! The following summarizes the above algorithm:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7vfhtjp3aj30hb09h40o.jpg" alt="rag_zbGqEeaSmhJaoV5QvA_52c04a987dcb692da8979a2198f3d8d7_Screenshot-2016-11-23-10.28.41"></p><h2 id="Multiclass-Classification"><a href="#Multiclass-Classification" class="headerlink" title="Multiclass Classification"></a>Multiclass Classification</h2><p>To classify data into multiple classes, we let our hypothesis function return a vector of values. Say we wanted to classify our data into one of four categories. We will use the following example to see how this classification is done. This algorithm takes as input an image and classifies it accordingly: </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7vhuzddrnj30h309en0f.jpg" alt="9Aeo6bGtEea4MxKdJPaTxA_4febc7ec9ac9dd0e4309bd1778171d36_Screenshot-2016-11-23-10.49.05"></p><p>We can define our set of resulting classes as y:<br>$$<br>y^{(i)}=\begin{bmatrix}1\0\0\0\end{bmatrix},\begin{bmatrix}0\1\0\0\end{bmatrix},\begin{bmatrix}0\0\1\0\end{bmatrix},\begin{bmatrix}0\0\0\1\end{bmatrix}<br>$$<br>Each $y^{(i)}$ represents a different image corresponding to either a car, pedestrian, truck, or motorcycle. The inner layers, each provide us with some new information which leads to our final hypothesis function. The setup looks like:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7vhzbeut9j308u02w3yn.jpg" alt="VBxpV7GvEeamBAoLccicqA_3e7f67888330b131426ecffd27936f61_Screenshot-2016-11-23-10.59.19"></p><p>Our resulting hypothesis for one set of inputs may look like:<br>$$<br>h_\Theta(x) =\begin{bmatrix}0 \ 0 \ 1 \ 0 \end{bmatrix}<br>$$<br>In which case our resulting class is the third one down, or $h_{\Theta}(x)_3$, which represents the motorcycle. </p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过拟合</title>
      <link href="/2019/09/26/AndrewNgML/AndrewNg-MachineLearning-7-Overfitting/"/>
      <url>/2019/09/26/AndrewNgML/AndrewNg-MachineLearning-7-Overfitting/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-7-Overfitting"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-7-Overfitting" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (7) Overfitting"></a>Notes of Andrew Ng’s Machine Learning —— (7) Overfitting</h1><h2 id="The-Problem-of-Overfitting"><a href="#The-Problem-of-Overfitting" class="headerlink" title="The Problem of Overfitting"></a>The Problem of Overfitting</h2><p>Consider the problem of predicting $y$ from $x \in \R$. The leftmost figure below shows the result of fitting a $y=\theta_0+\theta_1x$ to a dataset. We see that the data doesn’t really lie on straight line, and so the fit is not very good.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aopbltb1j30f0046dg2.jpg" alt="img"></p><p>Instead, if we had added an extra feature $x^2$, and fit $y=\theta_0+\theta_1+\theta_2x^2$, then we obtain a slightly better fit to the data (See middle figure).</p><p>Naively, it might seem that the more features we add, the better. However, there is also a danger in adding too many features: The rightmost figure is the result of fitting a $5^{th}$ order polynomial $y = \sum_{j=0} ^5 \theta_j x^j$. We see that even though the fitted curve passes through the data perfectly, we would not expect this to be a very good predictor for unseen examples.</p><p>The figure on the left shows an instance of <strong>underfitting</strong>—in which the data clearly shows structure not captured by the model</p><blockquote><p><strong><code>Underfitting</code></strong>, or <em>high bias</em>, is when the form of our hypothesis function h maps poorly to the trend of the data. It is usually caused by a function that is too simple or uses too few features.</p></blockquote><p>The figure on the right is an example of <strong>overfitting</strong>.</p><blockquote><p><strong><code>Overfitting</code></strong>, or <em>high variance</em>, is caused by a hypothesis function that makes accurate predictions for examples in the training set, but it does not generalize well to make accurate predictions on new, previously unseen examples. It is usually caused by a complicated function that creates a lot of unnecessary curves and angles unrelated to the data.</p></blockquote><p><code>Overfitting</code> is applied to both linear and logistic regression. There are two main options to address the issue of overfitting:</p><ol><li>Reduce the number of features:</li></ol><ul><li>Manually select which features to keep.</li><li>Use a model selection algorithm (studied later in the course).</li></ul><ol start="2"><li>Regularization</li></ol><ul><li>Keep all the features, but reduce the magnitude of parameters $\theta_j$.</li><li>Regularization works well when we have a lot of slightly useful features.</li></ul><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>If we have overfitting from our hypothesis function, we can reduce the weight that some of the terms in our function carry by increasing their cost.</p><p>Say we wanted to make the following function more quadratic:<br>$$<br>\theta_0 + \theta_1x + \theta_2x^2 + \theta_3x^3 + \theta_4x^4<br>$$</p><p>We’ll want to eliminate the influence of $\theta_3x^3$ and $\theta_4x^4$ . Without actually getting rid of these features or changing the form of our hypothesis, we can instead modify our <strong>cost function</strong>:<br>$$<br>min_\theta\ \dfrac{1}{2m}\sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + 1000\cdot\theta_3^2 + 1000\cdot\theta_4^2<br>$$</p><p>We’ve added two extra terms at the end to inflate the cost of $\theta_3$ and $\theta_4$. Now, in order for the cost function to get close to zero, we will have to reduce the values of $\theta_3$ and $\theta_4$ to near zero. This will in turn greatly reduce the values of $\theta_3x^3$ and $\theta_4x^4$ in our hypothesis function. As a result, we see that the new hypothesis (depicted by the pink curve) looks like a quadratic function but fits the data better due to the extra small terms $\theta_3x^3$ and $\theta_4x^4$.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aq081c3hj30gh091wfl.jpg" alt="img"></p><p>We could also <em>regularize all of our theta parameters</em> in a single summation as:</p><p>$$<br>\mathop{min}\limits_{\theta} \dfrac{1}{2m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum_{j=1}^n \theta_j^2<br>$$</p><p>The $\lambda$, or lambda, is the <strong>regularization parameter</strong>. It determines how much the costs of our theta parameters are inflated.</p><p>Using the above cost function with the extra summation, we can smooth the output of our hypothesis function to reduce overfitting.</p><p>Note. If lambda is chosen to be too large, it may smooth out the function too much and cause underfitting.</p><h2 id="Regularized-Linear-Regression"><a href="#Regularized-Linear-Regression" class="headerlink" title="Regularized Linear Regression"></a>Regularized Linear Regression</h2><p>We can apply regularization to both linear regression and logistic regression. </p><h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>We will modify our gradient descent function to separate out $\theta_0$ from the rest of the parameters because we do not want to penalize $\theta_0$.<br>$$<br>\begin{array}{l}<br>Repeat\quad{\<br>\qquad \theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m\big(h_\theta(x^{(i)})-y^{(i)}\big)x_0^{(i)}\<br>\qquad \theta_j:=\theta_j-\alpha\Big[\Big(\frac{1}{m}\sum_{i=1}^m\big(h_\theta(x^{(i)})-y^{(i)}\big)x_j^{i}\Big)+\frac{\lambda}{m}\theta_j\Big]\qquad j\in{1,2,\cdots,n}\<br>}<br>\end{array}<br>$$<br>The term $\frac{\lambda}{m}\theta_j$ performs our regularization. With some manipulation our update rule can also be represented as:<br>$$<br>\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^{m}\Big(h_\theta(x^{(i)})-y^{(i)}\Big)x_j^{(i)}<br>$$<br>The first term in the above equation, $(1-\alpha\frac{\lambda}{m})$ will always be less than $1$. Intuitively we can see it as reducing the value of $\theta_j$ by some amount on every update. Notice that the second term is now exactly the same as it was before.</p><h3 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h3><p>Now let’s approach regularization using the alternate method of the non-iterative normal equation.</p><p>To add in regularization, the equation is the same as our original, except that we add another term inside the parentheses:<br>$$<br>\begin{array}{l}<br>\theta=(X^TX+\lambda \cdot L)^{-1}X^Ty\<br>\textrm{where}\quad L=\left[\begin{array}{cccc}<br>0\<br>&amp;1\<br>&amp;&amp;1\<br>&amp;&amp;&amp;\ddots\<br>&amp;&amp;&amp;&amp;1<br>\end{array}\right]<br>\end{array}<br>$$<br>$L$ is a matrix with $0$ at the top left and $1$’s down the diagonal, with $0$’s everywhere else. It should have dimension $(n+1)×(n+1)$. Intuitively, this is the identity matrix (though we are not including $x_0$), multiplied with a single real number λ.</p><p>Recall that if $m&lt;n$, then $X^TX$ is non-invertible. However, when we add the term $\lambda\cdot L$, then $X^TX+\lambda\cdot L$ becomes invertible.</p><h2 id="Regularized-Logistic-Regression"><a href="#Regularized-Logistic-Regression" class="headerlink" title="Regularized Logistic Regression"></a>Regularized Logistic Regression</h2><p>We can regularize logistic regression in a similar way that we regularize linear regression. As a result, we can avoid overfitting. The following image shows how the regularized function, displayed by the pink line, is less likely to overfit than the non-regularized function represented by the blue line:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7axj9vr5xj30do07edh2.jpg" alt="img"></p><p>Recall that our cost function for logistic regression was:<br>$$<br>J(\theta) = - \frac{1}{m} \sum_{i=1}^m \Big[ y^{(i)}\ \log \big(h_\theta (x^{(i)})\big) + (1 - y^{(i)})\ \log \big(1 - h_\theta(x^{(i)})\big) \Big]<br>$$</p><p>We can regularize this equation by adding a term to the end:<br>$$<br>J(\theta) = - \frac{1}{m} \sum_{i=1}^m \large[ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2<br>$$</p><p>The second sum, $\sum_{j=1}^n \theta_j^2$ <strong>means to explicitly exclude</strong> the bias term, $\theta_0$. I.e. the $\theta$ vector is indexed from $0$ to $n$ (holding $n+1$ values, $\theta_0$ through $\theta_n$), and this sum explicitly skips $\theta_0$, by running from $1$ to $n$, skipping $0$. Thus, when computing the equation, we should continuously update the two following equations:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7axue4ykpj30de06h75k.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类问题</title>
      <link href="/2019/09/24/AndrewNgML/AndrewNg-MachineLearning-6-Classification/"/>
      <url>/2019/09/24/AndrewNgML/AndrewNg-MachineLearning-6-Classification/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-6-Classification"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-6-Classification" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (6) Classification"></a>Notes of Andrew Ng’s Machine Learning —— (6) Classification</h1><h2 id="Intro-of-Classification"><a href="#Intro-of-Classification" class="headerlink" title="Intro of Classification"></a>Intro of Classification</h2><p>Classification problems are something like giving a patient with a tumor, we have to predict whether the tumor is malignant or benign. It’s expected to output <strong>discrete</strong> values.</p><p>The classification problem is just like the regression problem, except that the values we want to predict take on only a small number of discrete values. For now, we will focus on the <strong>binary classification problem</strong> in which <code>y</code> can take only two values, <code>0</code> and <code>1</code>. </p><p>For instance, if we are trying to build a spam classifier for email, then $x^{(i)}$ may be some features of a piece of email, and $y$ may be <code>1</code> if it is a piece of spam mail, and <code>0</code> otherwise. Hence, $y \in {0,1}$. <code>0</code> is also called the <em>negative class</em>, and <code>1</code> the <em>positive class</em>, and they are sometimes also denoted by the symbols <code>-</code> and <code>+</code>. Given $x^{(i)}$, the corresponding $y^{(i)}$ is also called <em>the label for the training example</em>.</p><p>To attempt classification, one method is to use linear refression and map all predictions greater than <code>0.5</code> as a <code>1</code> and all less than <code>0.5</code> as a <code>0</code>. However, this method doesn’t work because classification is not actually a linear function. So what we actually do to solve classification problems is an algorithm named <strong>logistic regression</strong>. Note that even be called <em>regression</em>, it is actually to do classification.</p><h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><h3 id="Hypothesis-Representation"><a href="#Hypothesis-Representation" class="headerlink" title="Hypothesis Representation"></a>Hypothesis Representation</h3><p>We could approach the classification problem ignoring the fact that <code>y</code> is discrete-valued, and use our old linear regression algorithm to try to predict <code>y</code> given <code>x</code>. However it is easy to construct examples where this method performs very poorly.</p><p>Intuitively, it also doesn’t make sense for $h_\theta(x)$ to take values larger than <code>1</code> or smaller then <code>0</code> when we know that $y\in{0,1}$. To fix this, let’s change our hypotheses $h_\theta(x)$ to satisfy $0 \le h_\theta(x) \le 1$. This accomplished by plugging $\theta^Tx$ into the <strong>Logistic Function</strong>.</p><p>The the <strong>Simoid Function</strong>, also called the <strong>Logistic Function</strong> is this:<br>$$<br>y = \frac{1}{1+e^{-x}}<br>$$<br>It looks like the following image:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g72ld52460j30ur0g8ta7.jpg" alt="image-20190917162504420"></p><p>Our new form uses the Simoid Function:<br>$$<br>\begin{array}{l}h_\theta(x) = g(\theta^Tx)\z = \theta^Tx\g(z) = \frac{1}{1+e^{-z}}\end{array}<br>$$<br>The logistic function $g(z)$ maps any real numbers to the $(0,1)$ interval, making it useful for transforming a arbitrary-valued function into a function better suited for classfication.</p><p>We can also simply write $h_\theta(x)$ like this:<br>$$<br>h_\theta(X) = \frac{1}{1+e^{-\theta^Tx}}<br>$$<br><strong>$h_\theta(x)$ will output the probalility that our output is <code>1</code>.</strong> For example, $h_\theta(x)=0.7$ gives us a probability of $70%$ that our output is $1$ (then the probability that it is 0 is 30%):<br>$$<br>\begin{array}{l}<br>h_\theta(x)=P(y=1 \mid x;\theta)=1-P(y=0 \mid x; \theta)\<br>P(y=0 \mid x;\theta) + P(y=1 \mid x;\theta) = 1<br>\end{array}<br>$$</p><h3 id="Decision-Boundary"><a href="#Decision-Boundary" class="headerlink" title="Decision Boundary"></a>Decision Boundary</h3><p>In order to get our discrete <code>0</code> or <code>1</code> classification, we can translate the output of the hyporithesis function as follows:<br>$$<br>\begin{array}{rcl}<br>h_\theta(x) \ge 0.5 &amp;\Rightarrow&amp; y=1\<br>h_\theta(x) &lt; 0.5 &amp;\Rightarrow&amp; y=0<br>\end{array}<br>$$<br>The way our logistic function $g$ behaves is that when its input is $\ge 0$, its output is $\ge 0.5$:<br>$$<br>g(z) \ge 0.5 \quad when \quad z \ge 0<br>$$<br>In fact, we know that:<br>$$<br>\begin{array}{lclcl}<br>z \to -\infin &amp;,&amp; e^{\infin} \to \infin &amp; \Rightarrow &amp; g(z) \to 0\<br>z \to 0 &amp;,&amp; e^{0} \to 1 &amp; \Rightarrow &amp; g(z) \to 0.5\<br>z \to +\infin &amp;,&amp; e^{-\infin} \to 0 &amp; \Rightarrow &amp; g(z) \to 1<br>\end{array}<br>$$<br>So if our input to $g$ is $\theta^TX$, then that means:<br>$$<br>h_\theta(X) = g(\theta^TX) \ge 0.5 \quad when \quad \theta^TX \ge 0<br>$$<br>From these statements we can now say:<br>$$<br>\begin{array}{rcl}<br>\theta^TX \ge 0 &amp;\Rightarrow&amp; y=1\<br>\theta^TX \le 0 &amp;\Rightarrow&amp; y=0\<br>\end{array}<br>$$<br>The <strong>decision boundary</strong> is the line that separates the area where $y=0$ and where $y=1$. It is created by our hypothesis function.</p><p>Example:<br>$$<br>\theta=\left[ \begin{array}{c}<br>5\<br>-1\<br>0<br>\end{array} \right]<br>$$<br>In this case, $y=1$ if $5+(-1)x_1+0x_2 \ge 0$ , i.e. $x_1 \le 5$. Our boundary is a straight vertical line placed on the graph where $x_1=5$, and everything to the left of that denotes $y=1$, while everything to the right denotes $y=0$:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g72ng9ovwsj306e04u74d.jpg" alt="image-20190917173722734"></p><p>Another example:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g72niix9vaj30m20cin2i.jpg" alt="image-20190917173931467"></p><p>Non-linear decision boundaries:</p><p>The input to the sigmoid function g(z) (e.g. $\theta^TX$) doesn’t need to be linear, and could be a function that describes a circle (e.g. $z=\theta_0+\theta_1x_1^2+\theta_2x_2^2$) or any shape to fit our data.</p><p>Example:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g72nku2lrxj30mv08xtcy.jpg" alt="image-20190917174144868"></p><h3 id="Logistic-Regression-Model"><a href="#Logistic-Regression-Model" class="headerlink" title="Logistic Regression Model"></a>Logistic Regression Model</h3><p>In this part, we will implement the logistic regression model.<br>$$<br>\begin{array}{rcl}<br>\textrm{Training set} &amp;:&amp; {(x^{(1)},y^{(1)}), (x^{(2)},y^{(2)}), \ldots, (x^{(m)},y^{(m)})}\<br>\<br>\textrm{m examples} &amp;:&amp;<br>x \in \left[\begin{array}{c}<br>x_0\x_1\ \vdots \ x_n<br>\end{array}\right] \textrm{where }(x_0=1)<br>,\quad y \in {0,1}\<br>\<br>\textrm{Hypothesis} &amp;:&amp; h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}<br>\end{array}<br>$$</p><h4 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h4><p>If we use the same cost function that we use for <em>linear regression</em> ($J(\theta)=\frac{1}{m}\sum_{i=1}^m\frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2$) for logistic regression, it will be <strong>non-convex</strong> (that looks wavy), which is causing many local optima and hard to find the global minimum.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g757sf5lm8j30f504w3zi.jpg" alt="屏幕快照 2019-09-19 22.49.53"></p><p>So, what we actually need is our new <strong>Logistic Regression Cost Function</strong>, which guarantees that $J(\theta)$ is convex for logistic regression.<br>$$<br>\begin{array}{l}<br>J(\theta)=\frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)},y^{(i)}))\<br>\<br>Cost(h_\theta(x),y)=\left{\begin{array}{rl}<br>-log(h_\theta(x)) &amp; \textrm{ if}\quad y=1\<br>-log(1-h_\theta(x)) &amp; \textrm{ if}\quad y=0<br>\end{array}\right.<br>\end{array}<br>$$<br>The “$J(\theta)$-$h_\theta(x)$” plots is like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g758q7xincj31lc0mq76b.jpg" alt="屏幕快照 2019-09-19 23.23.39"></p><p>Let’s take a look at the $Cost(h_\theta(x),y)$ :<br>$$<br>\begin{array}{lcl}Cost(h_\theta(x),y) = 0 &amp;\textrm{if}&amp; h_\theta(x)=y\Cost(h_\theta(x),y) \to \infin &amp;\textrm{if}&amp; y=0 \quad&amp;\quad h_\theta(x) \to 1\Cost(h_\theta(x),y) \to \infin &amp;\textrm{if}&amp; y=1 \quad&amp;\quad h_\theta(x) \to 0\\end{array}<br>$$</p><blockquote><p> If our correct answer ‘y’ is 0, then the cost function will be 0 if our hypothesis function also outputs 0. If our hypothesis approaches 1, then the cost function will approach infinity.</p><p>If our correct answer ‘y’ is 1, then the cost function will be 0 if our hypothesis function outputs 1. If our hypothesis approaches 0, then the cost function will approach infinity.</p></blockquote><h4 id="Simplified-Cost-Function"><a href="#Simplified-Cost-Function" class="headerlink" title="Simplified Cost Function"></a>Simplified Cost Function</h4><p>We can simplify the $Cost$ function by compressing the two conditional cases into one case:<br>$$<br>Cost(h_\theta(x),y)=-y \cdot log(h_\theta(x))-(1-y) \cdot log(1-h_\theta(x))<br>$$<br>In this definition, when $y=0$, the term $-(1-y) \cdot log(1-h_\theta(x))$ will be $0$; when $y=0$, the term $-y \cdot log(h_\theta(x))$ will be $0$. Obviously, this is equal to the previous one but more easy to implement.</p><p>Now, we can fully write out our entire cost function as follow:<br>$$<br>J(\theta)=-\frac{1}{m}\sum_{i=1}^m\Bigg[y^{(i)}log\Big(h_\theta(x)\Big)+(1-y^{(i)})log\Big(1-h_\theta(x^{(i)})\Big)\Bigg]<br>$$<br>And a <strong>vectorized</strong> implementation is:<br>$$<br>\begin{array}{l}<br>h=g(X\theta)\<br>J(\theta)=\frac{1}{m}\cdot\big(-y^T log(h) -(1-y)^T log(1-h)\big)<br>\end{array}<br>$$</p><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><p>The general form of gradient descent is:<br>$$<br>\begin{array}{l}<br>Repeat \quad {\<br>\qquad \theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\<br>}<br>\end{array}<br>$$<br>Work out the derivative part using calculus to get:<br>$$<br>\begin{array}{l}<br>Repeat \quad {\<br>\qquad \theta_j:=\theta_j-\frac{\alpha}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})\cdot x_j^{(i)}\<br>}<br>\end{array}<br>$$<br>Actually, this algorithm is identical to the one we used in linear regression. And notice that we still have to simultaneously update all values in theta.</p><p><strong>Vectorized implementation</strong>:<br>$$<br>\theta:=\theta-\frac{\alpha}{m}X^T(g(X\theta)-\overrightarrow{y})<br>$$</p><h2 id="Advanced-Optimization"><a href="#Advanced-Optimization" class="headerlink" title="Advanced Optimization"></a>Advanced Optimization</h2><p>There are many more sophisticated, faster ways to optimize $\theta$ that can be used instead of gradient descent, such as “<em>Conjugate gradient</em>“, “<em>BFGS</em>“ and “<em>L-BFGS</em>“.</p><p>We are not suggest to write these more sophisticated algorithms ourself but use the libraries instead, as they’re already tested and highly optimized. Octave provides them.</p><p>We can use octave’s <code>fminunc()</code> optimization algorithm to do that.</p><p>To use this advanced optimization, we first need to provide a function that evaluates the following two functions for a given inpuit value $\theta$:<br>$$<br>J(\theta), \qquad \frac{\partial}{\partial\theta_j}J(\theta)<br>$$<br>We can write a single function that retunrs both of these:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function [jVal, gradient] &#x3D; costFunction(theta)</span><br><span class="line">jVal &#x3D; &lt;code to compute J(theta)&gt;</span><br><span class="line">gradient &#x3D; &lt;code to compute derivative of J(theta)&gt;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Then we are going to set a <code>optimset</code> and a initial theta as well, then send them to <code>fminunc()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options &#x3D; optimset(&#39;GradObj&#39;, &#39;on&#39;, &#39;MaxIter&#39;, 100);</span><br><span class="line">initialTheta &#x3D; zeros(2, 1);</span><br><span class="line"></span><br><span class="line">[optTheta, functionVal, exitFlag] &#x3D; fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure><h2 id="Multiclass-Classification"><a href="#Multiclass-Classification" class="headerlink" title="Multiclass Classification"></a>Multiclass Classification</h2><p>Now we will approach the classification of data when we have more than two categories. Instead of $y={0,1}$ we will expand our definition so that $y={0,1…n}$.</p><p>Since $y={0,1…n}$, we divide our problem into $n+1$ ($+1$ because the index starts at $0$) binary classification problems; in each one, we predict the probability that ‘$y$’ is a member of one of our classes.<br>$$<br>\begin{array}{l}<br>y \in {0,1,\cdots,n}\\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\<br>\vdots\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\\<br>prediction = \mathop{max}\limits_{\theta}\big(h_\theta^{(i)}(x)\big)<br>\end{array}<br>$$<br>We are basically choosing one class and then lumping all the others into a single second class. We do this repeatedly, applying binary logistic regression to each case, and then use the hypothesis that returned the highest value as our prediction.</p><p>The following image shows how one could classify 3 classes:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78nj8fvy4j30d507agmp.jpg" alt="img"></p><p><strong>To summarize:</strong></p><p>Train a logistic regression classifier $h_\theta(x)$ for each class￼ to predict the probability that ￼ ￼$y=i$￼ ￼. To make a prediction on a new $x$, pick the class ￼that maximizes $h_\theta(x)$.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Python 做数学建模</title>
      <link href="/2019/09/17/blog/MathematicalModelingWithPython/"/>
      <url>/2019/09/17/blog/MathematicalModelingWithPython/</url>
      
        <content type="html"><![CDATA[<h1 id="用-Python-做数学建模"><a href="#用-Python-做数学建模" class="headerlink" title="用 Python 做数学建模"></a>用 Python 做数学建模</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><blockquote><p>第三方依赖库：<code>scipy</code>。</p></blockquote><p>用 <code>scipy.optimize.linprog</code> 可以解线性规划问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linprog(c, A_ub=<span class="literal">None</span>, b_ub=<span class="literal">None</span>, A_eq=<span class="literal">None</span>, b_eq=<span class="literal">None</span>, bounds=<span class="literal">None</span>, method=<span class="string">&#x27;simplex&#x27;</span>, callback=<span class="literal">None</span>, options=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>其规定的问题标准型式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Minimize:     c^T * x</span><br><span class="line">    </span><br><span class="line">Subject to:   A_ub * x &lt;&#x3D; b_ub</span><br><span class="line">              A_eq * x &#x3D;&#x3D; b_eq</span><br></pre></td></tr></table></figure><p>e.g. 求接下列线性规划问题：<br>$$<br>\textrm{max } z=2x_1+3x_2-5x_3,\<br>\textrm{s.t. } \left { \begin{array}{ll}<br>x_1+x_2+x_3=7\<br>2x_1-5x_2+x_3\ge10\<br>x_1+3x_2+x_3\le12\<br>x_1,x_2,x_3\ge0<br>\end{array}\right.<br>$$<br><strong>解</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = [-<span class="number">2</span>, -<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">a = [[-<span class="number">2</span>, <span class="number">5</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]]</span><br><span class="line">b = [-<span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">aeq = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">beq = [<span class="number">7</span>]</span><br><span class="line">bounds = [[<span class="number">0</span>, <span class="literal">None</span>], [<span class="number">0</span>, <span class="literal">None</span>], [<span class="number">0</span>, <span class="literal">None</span>]]<span class="comment"># (0, None) means non-negative, this is a default value</span></span><br><span class="line">result = optimize.linprog(c, a, b, aeq, beq, bounds)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><blockquote><p>⚠️【注意】这里题目是求max，标准型是min，所以在写<code>c</code>矩阵的时候把值都写成了题目中的负；类似地， <code>&gt;=</code> 的项对应的a、b中值要取之负。然后最终结果也要取<code>fun</code>的负。</p></blockquote><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    fun: -14.571428571428571</span><br><span class="line">message: &#39;Optimization terminated successfully.&#39;</span><br><span class="line">    nit: 2</span><br><span class="line">  slack: array([3.85714286, 0.        ])</span><br><span class="line"> status: 0</span><br><span class="line">success: True</span><br><span class="line">      x: array([6.42857143, 0.57142857, 0.        ])</span><br></pre></td></tr></table></figure><p>最优解为$x_1=6.42857143, x_2=0.57142857, x_3=0$, 对应的最优值$z=14.571428571428571$.</p><p>若要取 fun、x的值，可以直接用 <code>result.fun</code> 和 <code>result.x</code>。</p><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><p>线性整数规划问题可以转换为线性规划问题求解。</p><p>对于非线性的整数规划，在穷举不可为时，在一定计算量下可以考虑用 <em>蒙特卡洛法</em> 得到一个满意解。</p><h3 id="蒙特卡洛法（随机取样法）"><a href="#蒙特卡洛法（随机取样法）" class="headerlink" title="蒙特卡洛法（随机取样法）"></a>蒙特卡洛法（随机取样法）</h3><p>e.g. $y=x^2$、$y=12-x$ 与 $x$ 轴 在第一象限围成一个曲边三角形。设计一个随机试验，求该图像面积的近似值。</p><p><strong>解</strong>：    设计的随机试验思想如下：在矩形区域 <code>[0, 12] * [0, 9]</code> 上产生服从均匀分布的 <code>10^7</code> 个随机点，统计随机点落在曲边三角形的频数，则曲边三角形的面积近似为上述矩形面积乘于频率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [random.random() * <span class="number">12</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000000</span>)]</span><br><span class="line">y = [random.random() * <span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000000</span>)]</span><br><span class="line"></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt;= <span class="number">3</span> <span class="keyword">and</span> y[i] &lt; x[i] ** <span class="number">2</span>:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x[i] &gt; <span class="number">3</span> <span class="keyword">and</span> y[i] &lt; <span class="number">12</span> - x[i]:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">area_appr = <span class="number">12</span> * <span class="number">9</span> * p / <span class="number">10</span> ** <span class="number">7</span></span><br><span class="line">print(area_appr)</span><br></pre></td></tr></table></figure><p>结果在 <code>49.5</code> 附近。</p><p>e.g. 已知非线性整数规划为：<br>$$<br>\textrm{max } z=x_1^2+x_2^2+3x_3^2+4x_4^2+2x_5^2-8x_1-2x_2-3x_3-x_4-2x_5\<br>\textrm{s.t. } \left { \begin{array}{ll}<br>0 \le x_i \le 99, i=1,…,5,\<br>x_1+x_2+x_3+x_4+x_5 \le 400\<br>x_1+2x_2+2x_3+x_4+6x_5 \le 800\<br>2x_1+x_2+6x_3 \le 200\<br>x_3+x_4+5x_5 \le 200<br>\end{array}\right.<br>$$<br>如果用枚举法，要计算 <code>100^5 = 10^10</code> 个点，计算量太大。所以考虑用蒙特卡洛法去随机计算  <code>10^6</code> 个点，得到比较满意的点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">list</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span> + <span class="number">3</span> * x[<span class="number">2</span>] ** <span class="number">2</span> + <span class="number">4</span> * x[<span class="number">3</span>] ** <span class="number">2</span> + <span class="number">2</span> * x[<span class="number">4</span>] ** <span class="number">2</span> - <span class="number">8</span> * x[<span class="number">0</span>] - <span class="number">2</span> * x[<span class="number">1</span>] - <span class="number">3</span> * x[<span class="number">2</span>] - x[<span class="number">3</span>] -<span class="number">2</span> * x[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 约束向量函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">x: <span class="built_in">list</span></span>) -&gt; list:</span></span><br><span class="line">    res = []</span><br><span class="line">    res.append(<span class="built_in">sum</span>(x) - <span class="number">400</span>)</span><br><span class="line">    res.append(x[<span class="number">0</span>] + <span class="number">2</span> * x[<span class="number">1</span>] + <span class="number">2</span> * x[<span class="number">2</span>] + x[<span class="number">3</span>] + <span class="number">6</span> * x[<span class="number">4</span>] - <span class="number">800</span>)</span><br><span class="line">    res.append(<span class="number">2</span> * x[<span class="number">0</span>] + x[<span class="number">1</span>] + <span class="number">6</span> * x[<span class="number">2</span>] - <span class="number">200</span>)</span><br><span class="line">    res.append(x[<span class="number">2</span>] + x[<span class="number">3</span>] + <span class="number">5</span> * x[<span class="number">4</span>] - <span class="number">200</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">random.seed(time.time)</span><br><span class="line"></span><br><span class="line">pb = <span class="number">0</span></span><br><span class="line">xb = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span> ** <span class="number">6</span>):</span><br><span class="line">    x = [random.randint(<span class="number">0</span>, <span class="number">99</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]<span class="comment"># 产生一行五列的区间[0, 99] 上的随机整数</span></span><br><span class="line">    rf = f(x)</span><br><span class="line">    rg = g(x)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>((a &lt; <span class="number">0</span> <span class="keyword">for</span> a <span class="keyword">in</span> rg)):<span class="comment"># 若 rg 中所有元素都小于 0</span></span><br><span class="line">        <span class="keyword">if</span> pb &lt; rf:</span><br><span class="line">            xb = x</span><br><span class="line">            pb = rf</span><br><span class="line">            </span><br><span class="line">print(xb, pb)</span><br></pre></td></tr></table></figure><h3 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h3><blockquote><p>第三方依赖库：<code>numpy</code> , <code>scipy</code>。</p></blockquote><p>用 <code>scipy.optimize.linear_sum_assignment</code> 可以解指派问题(the linear sum assignment problem)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear_sum_assignment(cost_matrix)</span><br></pre></td></tr></table></figure><p>注意指派矩阵 <code>cost_matrix</code> 里的元素 <code>C[i, j]</code> 的 <code>i</code> 为 <em>worker</em>，<code>j</code> 为 <em>job</em>.</p><blockquote><p>Formally, let X be a boolean matrix where $X[i,j] = 1$ iff row i is assigned to column j. Then the optimal assignment has cost<br>$$<br>\min \sum_i \sum_j C_{i,j} X_{i,j}<br>$$<br>s.t. each row is assignment to at most one column, and each column to at most one row.</p></blockquote><p>e.g. 求解下列指派问题，已知指派矩阵为<br>$$<br>\left[ \begin{array}{cc}<br>3 &amp; 8 &amp; 2 &amp; 10 &amp; 3\<br>8 &amp; 7 &amp; 2 &amp; 9 &amp; 7\<br>6 &amp; 4 &amp; 2 &amp; 7 &amp; 5\<br>8 &amp; 4 &amp; 2 &amp; 3 &amp; 5\<br>9 &amp; 10 &amp; 6 &amp; 9 &amp; 10\<br>\end{array} \right].<br>$$<br><strong>解</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [[<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">3</span>], [<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>], [<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>], [<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array(c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>optimize.linear_sum_assignment(c)</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]), array([<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>]))<span class="comment"># 对应 x15、x23、x32、x44、x51</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>]].<span class="built_in">sum</span>()<span class="comment"># 结果代入 cost_matrix，求得最优值</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><h3 id="非线性规划模型"><a href="#非线性规划模型" class="headerlink" title="非线性规划模型"></a>非线性规划模型</h3><blockquote><p>第三方依赖库：<code>numpy</code> , <code>scipy</code>。</p></blockquote><p>我们之前多次使用的 <code>scipy.optimize</code> 中集成了一系列用来求规划的函数，其中当然不乏解决非线性规划的方法。例如用其中的 <code>minimize</code> 函数就可以解决很多在 Matlab 中用 <code>fmincon</code> 解的非线性规划问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minimize(fun, x0, args&#x3D;(), method&#x3D;None, jac&#x3D;None, hess&#x3D;None, hessp&#x3D;None, bounds&#x3D;None, constraints&#x3D;(), tol&#x3D;None, callback&#x3D;None, options&#x3D;None)</span><br></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><code>fun</code>:：待求 <em>最小值</em> 的目标函数，<code>fun(x, *args) -&gt; float</code>， x 是 <code>shape (n,)</code>的 1-D array  </li><li><code>x0</code>：初始猜测值， <code>shape (n,)</code>的 1-D array </li><li><code>bounds</code>：设置参数范围/约束条件，tuple，形如 <code>((0, None), (0, None))</code></li><li><code>constraints</code>：<em>约束条件</em>，放一系列 dict 的 tuple，<code>(&#123;&#39;type&#39;: TYPE, &#39;fun&#39;: FUN&#125;, ...)</code><ul><li><code>TYPE</code>：<code>&#39;eq&#39;</code>表示 函数结果等于0 ； <code>&#39;ineq&#39;</code> 表示 表达式大于等于0</li><li><code>FUN</code>： 约束函数</li></ul></li></ul><p>e.g. 求下列非线性规划：<br>$$<br>\textrm{min } f(x)=x_1^2+x_2^2+x_3^2+8,\<br>\textrm{s.t. } \left { \begin{array}{ll}<br>x_1^2+x_2^2+x_3^2 \ge 0,\<br>x_1+x_2^2+x_3^2 \le 20,\<br>-x_1-x_2^2+2=0,\<br>x_2+2x_3^2=3,\<br>x_1,x_2,x_3 \ge 0.<br>\end{array}\right.<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] **<span class="number">2</span> + x[<span class="number">2</span>] ** <span class="number">2</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Notice：eq ==; ineq &gt;=</span></span><br><span class="line">cons = (&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: <span class="keyword">lambda</span> x: x[<span class="number">0</span>]**<span class="number">2</span> - x[<span class="number">1</span>] + x[<span class="number">2</span>]**<span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: <span class="keyword">lambda</span> x: -x[<span class="number">0</span>] - x[<span class="number">1</span>] - x[<span class="number">2</span>]**<span class="number">3</span> + <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;eq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: <span class="keyword">lambda</span> x: -x[<span class="number">0</span>] - x[<span class="number">1</span>]**<span class="number">2</span> + <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;eq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: <span class="keyword">lambda</span> x: x[<span class="number">1</span>] + <span class="number">2</span> * x[<span class="number">2</span>]**<span class="number">2</span> - <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">res = optimize.minimize(f, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), constraints=cons)</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    fun: 10.651091840572583</span><br><span class="line">    jac: array([1.10433471, 2.40651834, 1.89564812])</span><br><span class="line">message: &#39;Optimization terminated successfully.&#39;</span><br><span class="line">   nfev: 86</span><br><span class="line">    nit: 15</span><br><span class="line">   njev: 15</span><br><span class="line"> status: 0</span><br><span class="line">success: True</span><br><span class="line">      x: array([0.55216734, 1.20325918, 0.94782404])</span><br></pre></td></tr></table></figure><p>即，求得当 $(x_1,x_2,x_3)=(0.55216734, 1.20325918, 0.94782404)$ 时，最小值$y=10.651091840572583$.</p><h3 id="无约束问题的-Python-解法"><a href="#无约束问题的-Python-解法" class="headerlink" title="无约束问题的 Python 解法"></a>无约束问题的 Python 解法</h3><h4 id="符号解"><a href="#符号解" class="headerlink" title="符号解"></a>符号解</h4><blockquote><p>第三方依赖库：<code>sympy</code>。</p></blockquote><p>e.g. 求多元函数 $f(x，y) = x^3 - y^3 + 3x^2 + 3y^2 - 9x$ 的极值</p><p>思路：求驻点，代入Hessian矩阵，正定则为极小值，负定极大，不定不是极值点。</p><p><strong>解</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">f, x, y = sympy.symbols(<span class="string">&quot;f x y&quot;</span>)</span><br><span class="line"></span><br><span class="line">f = x**<span class="number">3</span> - y**<span class="number">3</span> + <span class="number">3</span> * x**<span class="number">2</span> + <span class="number">3</span> * y**<span class="number">2</span> - <span class="number">9</span> * x</span><br><span class="line">funs = sympy.Matrix([f])</span><br><span class="line">args = sympy.Matrix([x, y])</span><br><span class="line"></span><br><span class="line">df = funs.jacobian(args)        <span class="comment"># 一阶偏导</span></span><br><span class="line">d2f = df.jacobian(args)         <span class="comment"># Hessian 矩阵</span></span><br><span class="line"></span><br><span class="line">stationaryPoints = sympy.solve(df)      <span class="comment"># 驻点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> stationaryPoints:</span><br><span class="line">    a = d2f.subs(x, i[x]).subs(y, i[y])<span class="comment"># 驻点处的Hessian</span></span><br><span class="line">    b = a.eigenvals(multiple=<span class="literal">True</span>)      <span class="comment"># 求Hessian矩阵的特征值</span></span><br><span class="line">    fv = f.subs(x, i[x]).subs(y, i[y])<span class="comment"># 驻点处的函数值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>((j &gt; <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> b)):</span><br><span class="line">        print(<span class="string">&#x27;点(&#123;x&#125;, &#123;y&#125;)是极小值点，对应的极小值为: f(&#123;x&#125;, &#123;y&#125;) = &#123;f&#125;&#x27;</span>.<span class="built_in">format</span>(x=i[x], y=i[y], f=fv))</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">all</span>((j &lt; <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> b)):</span><br><span class="line">        print(<span class="string">&#x27;点(&#123;x&#125;, &#123;y&#125;)是极大值点，对应的极大值为: f(&#123;x&#125;, &#123;y&#125;) = &#123;f&#125;&#x27;</span>.<span class="built_in">format</span>(x=i[x], y=i[y], f=fv))</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">any</span>((j &lt; <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> b)) <span class="keyword">and</span> <span class="built_in">any</span>((j &gt; <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> b)):</span><br><span class="line">        print(<span class="string">&#x27;点(&#123;x&#125;, &#123;y&#125;)不是极值点&#x27;</span>.<span class="built_in">format</span>(x=i[x], y=i[y]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;无法判断点(&#123;x&#125;, &#123;y&#125;)是否为极值点&#x27;</span>.<span class="built_in">format</span>(x=i[x], y=i[y]))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">点(-3, 0)不是极值点</span><br><span class="line">点(-3, 2)是极大值点，对应的极大值为: f(-3, 2) &#x3D; 31</span><br><span class="line">点(1, 0)是极小值点，对应的极小值为: f(1, 0) &#x3D; -5</span><br><span class="line">点(1, 2)不是极值点</span><br></pre></td></tr></table></figure><h4 id="数值解"><a href="#数值解" class="headerlink" title="数值解"></a>数值解</h4><blockquote><p>第三方依赖库：<code>numpy</code> , <code>scipy</code>。</p></blockquote><p>利用 Python 求无约束极值的数值解与我们在非线性规划模型中的操作类似，我们依然使用 <code>minimize</code> 函数求解，不过这次连 constraints 都不用了。</p><p>e.g. 求多元函数 $f(x，y) = x^3 - y^3 + 3x^2 + 3y^2 - 9x$ 的最值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy import optimize</span><br><span class="line"></span><br><span class="line">f &#x3D; lambda x: x[0]**3 - x[1]**3 + 3 * x[0]**2 + 3 * x[1]**2 - 9 * x[0]</span><br><span class="line"></span><br><span class="line">resMin &#x3D; optimize.minimize(f, (0, 0))# 求最小值</span><br><span class="line">resMax &#x3D; optimize.minimize(lambda x: -f(x), (0, 0))# 求最大值</span><br><span class="line"></span><br><span class="line">print(&quot;最小值：\n&quot;)</span><br><span class="line">print(resMin)</span><br><span class="line">print(&quot;最大值：\n&quot;)</span><br><span class="line">print(resMax)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">极小值：</span><br><span class="line"></span><br><span class="line">      fun: -5.0</span><br><span class="line"> hess_inv: array([[8.34028325e-02, 3.27721596e-09],</span><br><span class="line">       [3.27721596e-09, 1.00000000e+00]])</span><br><span class="line">      jac: array([1.1920929e-07, 0.0000000e+00])</span><br><span class="line">  message: &#39;Optimization terminated successfully.&#39;</span><br><span class="line">     nfev: 20</span><br><span class="line">      nit: 4</span><br><span class="line">     njev: 5</span><br><span class="line">   status: 0</span><br><span class="line">  success: True</span><br><span class="line">        x: array([ 1.00000000e+00, -5.40966234e-09])</span><br><span class="line">极大值：</span><br><span class="line"></span><br><span class="line">      fun: -30.99999999999847</span><br><span class="line"> hess_inv: array([[0.08280865, 0.00036445],</span><br><span class="line">       [0.00036445, 0.16672048]])</span><br><span class="line">      jac: array([ 9.53674316e-07, -4.29153442e-06])</span><br><span class="line">  message: &#39;Optimization terminated successfully.&#39;</span><br><span class="line">     nfev: 172</span><br><span class="line">      nit: 11</span><br><span class="line">     njev: 43</span><br><span class="line">   status: 0</span><br><span class="line">  success: True</span><br><span class="line">        x: array([-2.99999994,  1.99999929])</span><br></pre></td></tr></table></figure><h4 id="求函数的零点和方程组的解"><a href="#求函数的零点和方程组的解" class="headerlink" title="求函数的零点和方程组的解"></a>求函数的零点和方程组的解</h4><blockquote><p>第三方依赖库：<code>sympy</code>。</p></blockquote><p>使用 <code>sympy.solve</code> 函数可以求出方程/方程组的符号解，得到的每个根可以调用其 <code>evalf</code> 方法转化为近似的数值。</p><ol><li>求多项式 $f(x)=x^3-x^2+2x-3$ 的零点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sympy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = sympy.Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = sympy.solve(x**<span class="number">3</span> - x**<span class="number">2</span> + <span class="number">2</span> * x -<span class="number">3</span>)<span class="comment"># 求符号解</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">1</span>/<span class="number">3</span> + (-<span class="number">1</span>/<span class="number">2</span> - sqrt(<span class="number">3</span>)*I/<span class="number">2</span>)*(<span class="number">65</span>/<span class="number">54</span> + <span class="number">5</span>*sqrt(<span class="number">21</span>)/<span class="number">18</span>)**(<span class="number">1</span>/<span class="number">3</span>) - <span class="number">5</span>/(<span class="number">9</span>*(-<span class="number">1</span>/<span class="number">2</span> - sqrt(<span class="number">3</span>)*I/<span class="number">2</span>)*(<span class="number">65</span>/<span class="number">54</span> + <span class="number">5</span>*sqrt(<span class="number">21</span>)/<span class="number">18</span>)**(<span class="number">1</span>/<span class="number">3</span>)), <span class="number">1</span>/<span class="number">3</span> - <span class="number">5</span>/(<span class="number">9</span>*(-<span class="number">1</span>/<span class="number">2</span> + sqrt(<span class="number">3</span>)*I/<span class="number">2</span>)*(<span class="number">65</span>/<span class="number">54</span> + <span class="number">5</span>*sqrt(<span class="number">21</span>)/<span class="number">18</span>)**(<span class="number">1</span>/<span class="number">3</span>)) + (-<span class="number">1</span>/<span class="number">2</span> + sqrt(<span class="number">3</span>)*I/<span class="number">2</span>)*(<span class="number">65</span>/<span class="number">54</span> + <span class="number">5</span>*sqrt(<span class="number">21</span>)/<span class="number">18</span>)**(<span class="number">1</span>/<span class="number">3</span>), -<span class="number">5</span>/(<span class="number">9</span>*(<span class="number">65</span>/<span class="number">54</span> + <span class="number">5</span>*sqrt(<span class="number">21</span>)/<span class="number">18</span>)**(<span class="number">1</span>/<span class="number">3</span>)) + <span class="number">1</span>/<span class="number">3</span> + (<span class="number">65</span>/<span class="number">54</span> + <span class="number">5</span>*sqrt(<span class="number">21</span>)/<span class="number">18</span>)**(<span class="number">1</span>/<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    print(i.evalf())<span class="comment"># 近似数值</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">-<span class="number">0.137841101825493</span> - <span class="number">1.52731225088663</span>*I</span><br><span class="line">-<span class="number">0.137841101825493</span> + <span class="number">1.52731225088663</span>*I</span><br><span class="line"><span class="number">1.27568220365098</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>求如下方程组的解</li></ol><p>$$<br>\left{\begin{array}{l}<br>x^2+y-6=0\<br>y^2+x-6=0\<br>\end{array}\right.<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sympy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = sympy.symbols(<span class="string">&#x27;x y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = sympy.solve((x**<span class="number">2</span>+y-<span class="number">6</span>, y**<span class="number">2</span>+x-<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[&#123;x: -<span class="number">3</span>, y: -<span class="number">3</span>&#125;, &#123;x: <span class="number">2</span>, y: <span class="number">2</span>&#125;, &#123;x: <span class="number">6</span> - (<span class="number">1</span>/<span class="number">2</span> - sqrt(<span class="number">21</span>)/<span class="number">2</span>)**<span class="number">2</span>, y: <span class="number">1</span>/<span class="number">2</span> - sqrt(<span class="number">21</span>)/<span class="number">2</span>&#125;, &#123;x: <span class="number">6</span> - (<span class="number">1</span>/<span class="number">2</span> + sqrt(<span class="number">21</span>)/<span class="number">2</span>)**<span class="number">2</span>, y: <span class="number">1</span>/<span class="number">2</span> + sqrt(<span class="number">21</span>)/<span class="number">2</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;(&#123;x&#125;, &#123;y&#125;)&#x27;</span>.<span class="built_in">format</span>(x=i[x].evalf(), y=i[y].evalf()))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">(-<span class="number">3.00000000000000</span>, -<span class="number">3.00000000000000</span>)</span><br><span class="line">(<span class="number">2.00000000000000</span>, <span class="number">2.00000000000000</span>)</span><br><span class="line">(<span class="number">2.79128784747792</span>, -<span class="number">1.79128784747792</span>)</span><br><span class="line">(-<span class="number">1.79128784747792</span>, <span class="number">2.79128784747792</span>)</span><br></pre></td></tr></table></figure><h3 id="约束极值问题"><a href="#约束极值问题" class="headerlink" title="约束极值问题"></a>约束极值问题</h3><p>参考上文 “无约束问题的 Python 解法”。</p><p>……</p><p><strong>未完但不用待续了，应该没有后续了，我对用 python 做数学建模以及数学建模都失去兴趣了。</strong></p><h2 id="附：numpy"><a href="#附：numpy" class="headerlink" title="附：numpy"></a>附：numpy</h2><p>推荐一份质量比较高的 numpy 中文文档：<a href="https://www.numpy.org.cn/index.html">https://www.numpy.org.cn/index.html</a>.</p><h3 id="创建-向量-矩阵"><a href="#创建-向量-矩阵" class="headerlink" title="创建 向量/矩阵"></a>创建 向量/矩阵</h3><p>用 <code>np.array()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure><h3 id="矩阵的拼接"><a href="#矩阵的拼接" class="headerlink" title="矩阵的拼接"></a>矩阵的拼接</h3><ul><li>列合并/扩展：<code>np.column_stack()</code></li><li>行合并/扩展：<code>np.row_stack()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">1</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">array([[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.column_stack((A, B))<span class="comment"># 行</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.row_stack((A, B))<span class="comment"># 列</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure><h3 id="对角线元素赋值"><a href="#对角线元素赋值" class="headerlink" title="对角线元素赋值"></a>对角线元素赋值</h3><p>比如说我们有一个 <code>np.array X</code>，我想对角线的所有值设置为0，可以用 <code>np.fill_diagonal(X, [0, 0, 0, ...])</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; D &#x3D; np.zeros([3, 3])</span><br><span class="line">&gt;&gt;&gt; np.fill_diagonal(D, [1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; D</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 2., 0.],</span><br><span class="line">       [0., 0., 3.]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Octave 入门</title>
      <link href="/2019/09/10/AndrewNgML/AndrewNg-MachineLearning-5-OctaveTutorial/"/>
      <url>/2019/09/10/AndrewNgML/AndrewNg-MachineLearning-5-OctaveTutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-5-Octave-Tutorial"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-5-Octave-Tutorial" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (5) Octave Tutorial"></a>Notes of Andrew Ng’s Machine Learning —— (5) Octave Tutorial</h1><h2 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h2><h3 id="Elementary-Operations"><a href="#Elementary-Operations" class="headerlink" title="Elementary Operations"></a>Elementary Operations</h3><p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 5 + 6</span><br><span class="line">ans &#x3D;  11</span><br><span class="line">&gt;&gt; 20 - 1</span><br><span class="line">ans &#x3D;  19</span><br><span class="line">&gt;&gt; 3 * 4</span><br><span class="line">ans &#x3D;  12</span><br><span class="line">&gt;&gt; 8 &#x2F; 2</span><br><span class="line">ans &#x3D;  4</span><br><span class="line">&gt;&gt; 2 ^ 8</span><br><span class="line">ans &#x3D;  256</span><br></pre></td></tr></table></figure><h3 id="Logical-Operations"><a href="#Logical-Operations" class="headerlink" title="Logical Operations"></a>Logical Operations</h3><p><code>==</code>, <code>~=</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>xor()</code>.</p><p>Note that a <strong>not equal sign</strong> is <strong><code>~=</code></strong>, and not <code>!=</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 1 &#x3D;&#x3D; 0</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">&gt;&gt; 1 ~&#x3D; 0</span><br><span class="line">ans &#x3D; 1</span><br><span class="line">&gt;&gt; 1 &amp;&amp; 0</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">&gt;&gt; 1 || 0</span><br><span class="line">ans &#x3D; 1</span><br><span class="line">&gt;&gt; xor(1, 0)</span><br><span class="line">ans &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="Change-the-Prompt"><a href="#Change-the-Prompt" class="headerlink" title="Change the Prompt"></a>Change the Prompt</h3><p>We can change the prompt via <code>PS1()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; PS1(&quot;octave: &gt; &quot;)</span><br><span class="line">octave: &gt; PS1(&quot;&gt;&gt; &quot;)</span><br><span class="line">&gt;&gt; PS1(&quot;octave: &gt; &quot;)</span><br><span class="line">octave: &gt; PS1(&quot;SOMETHING &gt; &quot;)</span><br><span class="line">SOMETHING &gt; PS1(&quot;&gt;&gt; &quot;)</span><br><span class="line">&gt;&gt; % Prompt changed</span><br></pre></td></tr></table></figure><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; 3</span><br><span class="line">a &#x3D;  3</span><br><span class="line">&gt;&gt; a &#x3D; 3;    % semicolon supressing output</span><br><span class="line">&gt;&gt; c &#x3D; (3 &gt;&#x3D; 1);</span><br><span class="line">&gt;&gt; c</span><br><span class="line">c &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="Display-variables"><a href="#Display-variables" class="headerlink" title="Display variables"></a>Display variables</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; pi;</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.1416</span><br><span class="line">&gt;&gt; disp(a)</span><br><span class="line"> 3.1416</span><br><span class="line">&gt;&gt; disp(sprintf(&#39;2 decimals: %0.2f&#39;, a))</span><br><span class="line">2 decimals: 3.14</span><br></pre></td></tr></table></figure><p>We can also set the default length of decimal places by entering <code>format short/long</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.1416</span><br><span class="line">&gt;&gt; format long</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.141592653589793</span><br><span class="line">&gt;&gt; format short</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.1416</span><br></pre></td></tr></table></figure><h3 id="Create-Matrices"><a href="#Create-Matrices" class="headerlink" title="Create Matrices"></a>Create Matrices</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2, 3; 4, 5, 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B &#x3D; [1 3 5; 7 9 11]</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">    1    3    5</span><br><span class="line">    7    9   11</span><br><span class="line"></span><br><span class="line">&gt;&gt; B &#x3D; [1, 2, 3;</span><br><span class="line">&gt; 4, 5, 6;</span><br><span class="line">&gt; 7, 8, 9]</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">   7   8   9</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; [1, 2, 4, 8]</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   4   8</span><br><span class="line"></span><br><span class="line">&gt;&gt; D &#x3D; [1; 2; 3; 4]</span><br><span class="line">D &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line">   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>There are some useful methods to generate matrices:</p><ul><li>Generate vector of a range</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; 1:10    % start:end</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    1    2    3    4    5    6    7    8    9   10</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; 1:0.1:2    % start:step:end</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line"> Columns 1 through 8:</span><br><span class="line"></span><br><span class="line">    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000</span><br><span class="line"></span><br><span class="line"> Columns 9 through 11:</span><br><span class="line"></span><br><span class="line">    1.8000    1.9000 </span><br></pre></td></tr></table></figure><ul><li>Generate matrices of all ones/zeros</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ones(2, 3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1</span><br><span class="line">   1   1   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; zeros(3, 2)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0   0</span><br><span class="line">   0   0</span><br><span class="line">   0   0</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; 2 * ones(4, 5)</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Generate identity matrices</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; eye(3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0</span><br><span class="line">   0   1   0</span><br><span class="line">   0   0   1</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Generate matrices of random values</li></ul><p>Uniform distribution between 0 and 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; D &#x3D; rand(1, 3)</span><br><span class="line">D &#x3D;</span><br><span class="line"></span><br><span class="line">   0.14117   0.81424   0.83745</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Gaussian random:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; D &#x3D; randn(1, 3)</span><br><span class="line">D &#x3D;</span><br><span class="line"></span><br><span class="line">   0.22133  -2.00002   1.61025</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We can generate a gaussian random vector with 10000 elements, and plot a histogram:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; randn(1, 10000);</span><br><span class="line">&gt;&gt; hist(w)</span><br></pre></td></tr></table></figure><p>Output figure:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6rc9xza9dj30ff0blt8s.jpg" alt="image-20190907224934733"></p><p>We can also plot a histogram with more buckets, 50 bins for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; hist(w, 50)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6rc9cow1gj30fh0bjjri.jpg" alt="image-20190907224859815"></p><h3 id="Get-Help"><a href="#Get-Help" class="headerlink" title="Get Help"></a>Get Help</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help</span><br><span class="line"></span><br><span class="line">  For help with individual commands and functions type</span><br><span class="line"></span><br><span class="line">    help NAME</span><br><span class="line">    </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&gt;&gt; help eye</span><br><span class="line">&#39;eye&#39; is a built-in function from the file libinterp&#x2F;corefcn&#x2F;data.cc</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&gt;&gt; help help</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Moving-Data-Around"><a href="#Moving-Data-Around" class="headerlink" title="Moving Data Around"></a>Moving Data Around</h2><h3 id="Size-of-matrix"><a href="#Size-of-matrix" class="headerlink" title="Size of matrix"></a>Size of matrix</h3><p><code>size()</code>: get the size of a matrix, return <code>[rows, columns]</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(A)    % get the size of A</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; sz &#x3D; size(A);    % actually, size return a 1x2 matrix</span><br><span class="line">&gt;&gt; size(sz)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(A, 1)    % get the first dimension of A (i.e. the number of rows)</span><br><span class="line">ans &#x3D;  3</span><br><span class="line">&gt;&gt; size(A, 2)    % the number of columns</span><br><span class="line">ans &#x3D;  2</span><br></pre></td></tr></table></figure><p><code>length()</code>: return the size of the longest dimension.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; length(A)    % get the size of the longest dimension. Confusing, not recommend</span><br><span class="line">ans &#x3D;  3</span><br><span class="line">&gt;&gt; v &#x3D; [1, 2, 3, 4];</span><br><span class="line">&gt;&gt; length(v)    % We often length() to get the length of a vector</span><br><span class="line">ans &#x3D;  4</span><br></pre></td></tr></table></figure><h3 id="Load-data"><a href="#Load-data" class="headerlink" title="Load data"></a>Load data</h3><p>We can use basic shell commands to find data that we want.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; pwd</span><br><span class="line">ans &#x3D; &#x2F;Users&#x2F;c</span><br><span class="line">&gt;&gt; cd MyProg&#x2F;octave&#x2F;</span><br><span class="line">&gt;&gt; pwd</span><br><span class="line">ans &#x3D; &#x2F;Users&#x2F;c&#x2F;MyProg&#x2F;octave</span><br><span class="line">&gt;&gt; ls</span><br><span class="line">featureX.dat featureY.dat</span><br><span class="line">&gt;&gt; ls -l</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 c  staff  188 Sep  8 10:00 featureX.dat</span><br><span class="line">-rw-r--r--  1 c  staff  135 Sep  8 10:00 featureY.dat</span><br></pre></td></tr></table></figure><p><code>load</code> command can load data from a file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; load featureX.dat</span><br><span class="line">&gt;&gt; load(&#39;featureY.dat&#39;)</span><br></pre></td></tr></table></figure><p>The data from file is now comed into matrices after load</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; featureX</span><br><span class="line">featureX &#x3D;</span><br><span class="line"></span><br><span class="line">   2104      3</span><br><span class="line">   1600      3</span><br><span class="line">   2400      3</span><br><span class="line">   1416      2</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(featureX)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   27    2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Show-variables"><a href="#Show-variables" class="headerlink" title="Show variables"></a>Show variables</h3><p><code>who/whos</code>: show variables in memory currently.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; who</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">A         ans       featureX  featureY  sz        v         w</span><br><span class="line"></span><br><span class="line">&gt;&gt; whos    % for more details</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name          Size                     Bytes  Class</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;          &#x3D;&#x3D;&#x3D;&#x3D;                     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">        A             3x2                         48  double</span><br><span class="line">        ans           1x2                         16  double</span><br><span class="line">        featureX     27x2                        432  double</span><br><span class="line">        featureY     27x1                        216  double</span><br><span class="line">        sz            1x2                         16  double</span><br><span class="line">        v             1x4                         32  double</span><br><span class="line">        w             1x10000                  80000  double</span><br><span class="line"></span><br><span class="line">Total is 10095 elements using 80760 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Clear-variables"><a href="#Clear-variables" class="headerlink" title="Clear variables"></a>Clear variables</h3><p><code>clear</code> command can help us to clear variables that are no longer useful.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; who</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">A         ans       featureX  featureY  sz        v         w</span><br><span class="line"></span><br><span class="line">&gt;&gt; clear A    % clear a variable</span><br><span class="line">&gt;&gt; clear sz v w    % clear variables</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name          Size                     Bytes  Class</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;          &#x3D;&#x3D;&#x3D;&#x3D;                     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">        ans           1x2                         16  double</span><br><span class="line">        featureX     27x2                        432  double</span><br><span class="line">        featureY     27x1                        216  double</span><br><span class="line"></span><br><span class="line">Total is 83 elements using 664 bytes</span><br><span class="line">&gt;&gt; clear    % clear all variables</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure><h3 id="Save-data"><a href="#Save-data" class="headerlink" title="Save data"></a>Save data</h3><p>Take a part of a vector.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; featureY(1:5)</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   3999</span><br><span class="line">   3299</span><br><span class="line">   3690</span><br><span class="line">   2320</span><br><span class="line">   5399</span><br><span class="line">   </span><br><span class="line">&gt;&gt; whos</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name          Size                     Bytes  Class</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;          &#x3D;&#x3D;&#x3D;&#x3D;                     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">        featureX     27x2                        432  double</span><br><span class="line">        featureY     27x1                        216  double</span><br><span class="line">        v             5x1                         40  double</span><br><span class="line"></span><br><span class="line">Total is 86 elements using 688 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Save data to disk: <code>save file_name variable [-ascii]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; save hello.mat v    % save as a binary format</span><br><span class="line">&gt;&gt; ls</span><br><span class="line">featureX.dat featureY.dat hello.mat</span><br><span class="line">&gt;&gt; save hello.txt v -ascii;    % save as a ascii txt</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure><p>Then we can clear it from memory and load v back from disk:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clear v</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name          Size                     Bytes  Class</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;          &#x3D;&#x3D;&#x3D;&#x3D;                     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">        featureX     27x2                        432  double</span><br><span class="line">        featureY     27x1                        216  double</span><br><span class="line"></span><br><span class="line">Total is 81 elements using 648 bytes</span><br><span class="line"></span><br><span class="line">&gt;&gt; load hello.mat </span><br><span class="line">&gt;&gt; whos</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name          Size                     Bytes  Class</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;          &#x3D;&#x3D;&#x3D;&#x3D;                     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">        featureX     27x2                        432  double</span><br><span class="line">        featureY     27x1                        216  double</span><br><span class="line">        v             5x1                         40  double</span><br><span class="line"></span><br><span class="line">Total is 86 elements using 688 bytes</span><br><span class="line"></span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure><h3 id="Manipulate-data"><a href="#Manipulate-data" class="headerlink" title="Manipulate data"></a>Manipulate data</h3><p>Get element from a matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(3, 2)    % get a element of matrix</span><br><span class="line">ans &#x3D;  6</span><br><span class="line">&gt;&gt; A(2, :)    % &quot;:&quot; means every element along that row&#x2F;column</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   4</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:, 1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   3</span><br><span class="line">   5</span><br><span class="line"></span><br><span class="line">&gt;&gt; A([1, 3], :)    % get the elements along row 1 &amp; 3</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   5   6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Change the elements of a matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:, 2) &#x3D; [10, 11, 12]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">    1   10</span><br><span class="line">    3   11</span><br><span class="line">    5   12</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(1, 1) &#x3D; 0</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">    0   10</span><br><span class="line">    3   11</span><br><span class="line">    5   12</span><br><span class="line"></span><br><span class="line">&gt;&gt; A &#x3D; [A, [100; 101; 102]]    % append another column vector to right</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">     0    10   100</span><br><span class="line">     3    11   101</span><br><span class="line">     5    12   102</span><br><span class="line"></span><br><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B &#x3D; A + 10</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   11   12</span><br><span class="line">   13   14</span><br><span class="line">   15   16</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; [A, B]</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">    1    2   11   12</span><br><span class="line">    3    4   13   14</span><br><span class="line">    5    6   15   16</span><br><span class="line"></span><br><span class="line">&gt;&gt; D &#x3D; [A; B];</span><br><span class="line">&gt;&gt; size(D)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   6   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Put all elements of a matrix into a single column vector:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">     0    10   100</span><br><span class="line">     3    11   101</span><br><span class="line">     5    12   102</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:)    % put all elements of A into a single vector</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     0</span><br><span class="line">     3</span><br><span class="line">     5</span><br><span class="line">    10</span><br><span class="line">    11</span><br><span class="line">    12</span><br><span class="line">   100</span><br><span class="line">   101</span><br><span class="line">   102</span><br></pre></td></tr></table></figure><h2 id="Computing-on-Data"><a href="#Computing-on-Data" class="headerlink" title="Computing on Data"></a>Computing on Data</h2><h3 id="Element-wise-operations"><a href="#Element-wise-operations" class="headerlink" title="Element-wise operations"></a>Element-wise operations</h3><p>Use <code>.&lt;operator&gt;</code> instead of <code>&lt;operator&gt;</code> for element-wise operations (i.e. operations between elements).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6];</span><br><span class="line">&gt;&gt; B &#x3D; [11, 12; 13, 14; 15, 16];</span><br><span class="line">&gt;&gt; C &#x3D; [1 1; 2 2];</span><br><span class="line">&gt;&gt; v &#x3D; [1, 2, 3];</span><br><span class="line">&gt;&gt; A .* B    % element-wise multiplication (ans &#x3D; [A(1,1)*B(1,1), A(1,2)*B(1,2); ...])</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   11   24</span><br><span class="line">   39   56</span><br><span class="line">   75   96</span><br><span class="line"></span><br><span class="line">&gt;&gt; A .^ 2    % squaring each element of A</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1    4</span><br><span class="line">    9   16</span><br><span class="line">   25   36</span><br><span class="line"></span><br><span class="line">&gt;&gt; 1 .&#x2F; A</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.00000   0.50000</span><br><span class="line">   0.33333   0.25000</span><br><span class="line">   0.20000   0.16667</span><br><span class="line"></span><br><span class="line">&gt;&gt; v .+ 1    % equals to &#96;v + 1&#96; &amp; &#96;v + ones(1, length(v))&#96;</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2   3   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Element-wise comparison:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; a &lt; 3</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  1  0  1  1</span><br><span class="line">  </span><br><span class="line">&gt;&gt; find(a &lt; 3)    % to find the elements that are less then 3 in a, return their indices</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   3   4</span><br><span class="line">   </span><br><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; [r, c] &#x3D; find(A &lt; 3)</span><br><span class="line">r &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line"></span><br><span class="line">c &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Functions are element-wise:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; [1, 2, 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; log(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.00000   0.69315   1.09861</span><br><span class="line"></span><br><span class="line">&gt;&gt; exp(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    2.7183    7.3891   20.0855</span><br><span class="line"></span><br><span class="line">&gt;&gt; abs([-1, 2, -3, 4])</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3   4</span><br><span class="line"></span><br><span class="line">&gt;&gt; -v    % -1 * v</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  -1  -2  -3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Floor and Ceil of elements:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; floor(a)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   15    2    0</span><br><span class="line"></span><br><span class="line">&gt;&gt; ceil(a)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   15    2    1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Matrix-operations"><a href="#Matrix-operations" class="headerlink" title="Matrix operations"></a>Matrix operations</h3><p>Matrix multiplication:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6];</span><br><span class="line">&gt;&gt; C &#x3D; [1 1; 2 2];</span><br><span class="line">&gt;&gt; A * C    % matrix multiplication</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    5    5</span><br><span class="line">   11   11</span><br><span class="line">   17   17</span><br></pre></td></tr></table></figure><p>Transpose:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6];</span><br><span class="line">&gt;&gt; A&#39;    % transposed</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   3   5</span><br><span class="line">   2   4   6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Get the max element of a vector | matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; [1 15 2 0.5];</span><br><span class="line">&gt;&gt; A &#x3D; [1, 2; 3, 4; 5, 6];</span><br><span class="line">&gt;&gt; max_val &#x3D; max(a)</span><br><span class="line">max_val &#x3D;  15</span><br><span class="line">&gt;&gt; [val, index] &#x3D; max(a)</span><br><span class="line">val &#x3D;  15</span><br><span class="line">index &#x3D;  2</span><br><span class="line">&gt;&gt; max(A)    % &#96;max(&lt;Matrix&gt;)&#96; does a column-wise maximum</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   5   6</span><br><span class="line">&gt;&gt; max(A, [], 1)    % max per column</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A, [], 2)    % max per row</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   4</span><br><span class="line">   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(max(A))    % the max element of whole matrix</span><br><span class="line">ans &#x3D;  6</span><br><span class="line">&gt;&gt; max(A(:))</span><br><span class="line">ans &#x3D;  6</span><br></pre></td></tr></table></figure><p>Sum &amp; prod of vector:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line">    </span><br><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(a)</span><br><span class="line">ans &#x3D;  18.500</span><br><span class="line">&gt;&gt; sum(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    9   12</span><br><span class="line">    </span><br><span class="line">&gt;&gt; sum(A, 1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    9   12</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A, 2)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">    7</span><br><span class="line">   11</span><br><span class="line"></span><br><span class="line">&gt;&gt; prod(a)</span><br><span class="line">ans &#x3D;  15</span><br><span class="line">&gt;&gt; prod(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   15   48</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Get the diagonal elements:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(4)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   16    2    3   13</span><br><span class="line">    5   11   10    8</span><br><span class="line">    9    7    6   12</span><br><span class="line">    4   14   15    1</span><br><span class="line"></span><br><span class="line">&gt;&gt; A .* eye(4)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   16    0    0    0</span><br><span class="line">    0   11    0    0</span><br><span class="line">    0    0    6    0</span><br><span class="line">    0    0    0    1</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A .* eye(4))</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   16   11    6    1</span><br><span class="line"></span><br><span class="line">&gt;&gt; flipud(eye(4))    % flip up down</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">Permutation Matrix</span><br><span class="line"></span><br><span class="line">   0   0   0   1</span><br><span class="line">   0   0   1   0</span><br><span class="line">   0   1   0   0</span><br><span class="line">   1   0   0   0</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A .* flipud(eye(4)))</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    4    7   10   13</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Inverse:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(3)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.147222  -0.144444   0.063889</span><br><span class="line">  -0.061111   0.022222   0.105556</span><br><span class="line">  -0.019444   0.188889  -0.102778</span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(A) * A    % get identity matrix</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.0000e+00   2.0817e-16  -3.1641e-15</span><br><span class="line">  -6.1062e-15   1.0000e+00   6.2450e-15</span><br><span class="line">   3.0531e-15   4.1633e-17   1.0000e+00</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Plotting-Data"><a href="#Plotting-Data" class="headerlink" title="Plotting Data"></a>Plotting Data</h2><h3 id="Plotting-a-function"><a href="#Plotting-a-function" class="headerlink" title="Plotting a function"></a>Plotting a function</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clear</span><br><span class="line">&gt;&gt; t &#x3D; [0:0.01:0.98];</span><br><span class="line">&gt;&gt; size(t)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   99</span><br><span class="line"></span><br><span class="line">&gt;&gt; y1 &#x3D; sin(2*pi*4*t);</span><br><span class="line">&gt;&gt; plot(t, y1);</span><br></pre></td></tr></table></figure><p>It will show you a figure like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6s5bn03vsj30dj0ao3yt.jpg" alt="image-20190908153422239"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; y2 &#x3D; cos(2*pi*4*t);</span><br><span class="line">&gt;&gt; plot(t, y2);</span><br></pre></td></tr></table></figure><p>👆 This will replace the sin figure with a new cos figure.</p><p>If we want to have both the sin and cos plots, the <code>hold on</code> command will help:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; plot(t, y1);</span><br><span class="line">&gt;&gt; hold on;</span><br><span class="line">&gt;&gt; plot(t, y2, &#39;r&#39;);</span><br></pre></td></tr></table></figure><p>We can set some text on thw figure:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; xlabel(&quot;time&quot;);</span><br><span class="line">&gt;&gt; ylabel(&quot;value&quot;);</span><br><span class="line">&gt;&gt; legend(&#39;sin&#39;, &#39;cos&#39;);    % Show what the 2 lines are</span><br><span class="line">&gt;&gt; title(&#39;my plot&#39;);</span><br></pre></td></tr></table></figure><p>Now, we get this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6s5m92rbyj30dc0a0jsq.jpg" alt="myPlot"></p><p>Then, we save it and close the plotting window:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; print -dpng &#39;myPlot.png&#39;    % save it to $(pwd)</span><br><span class="line">&gt;&gt; close</span><br></pre></td></tr></table></figure><p>We can show two figures at the same time:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; figure(1); plot(t, y1);</span><br><span class="line">&gt;&gt; figure(2); plot(t, y2);</span><br></pre></td></tr></table></figure><p>Then, we can also generate figures like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6s5u82kobj30e20avwf2.jpg" alt="image-20190908155218094"></p><p>What we need to do is using a <code>subplot</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; subplot(1, 2, 1);    % Divides plot a 1x2 grid, access first element</span><br><span class="line">&gt;&gt; plot(t, y1);</span><br><span class="line">&gt;&gt; subplot(1, 2, 2);</span><br><span class="line">&gt;&gt; plot(t, y2);</span><br><span class="line">&gt;&gt; axis([0.5, 1, -1, 1])    % change the range of axis</span><br></pre></td></tr></table></figure><p>Use <code>clf</code> to clear a figure:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clf;</span><br></pre></td></tr></table></figure><h3 id="Showing-a-matrix"><a href="#Showing-a-matrix" class="headerlink" title="Showing a matrix"></a>Showing a matrix</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(5)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   17   24    1    8   15</span><br><span class="line">   23    5    7   14   16</span><br><span class="line">    4    6   13   20   22</span><br><span class="line">   10   12   19   21    3</span><br><span class="line">   11   18   25    2    9</span><br><span class="line"></span><br><span class="line">&gt;&gt; imagesc(A), colorbar</span><br></pre></td></tr></table></figure><p>It gives us a figure like this:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6s62mn3gwj30d60afwej.jpg" alt="image-20190908160029068"></p><p>The different colors correspond to the different values.</p><p>Another example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; B &#x3D; magic(10);</span><br><span class="line">&gt;&gt; imagesc(B), colorbar, colormap gray;</span><br></pre></td></tr></table></figure><p>Output:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6s680rvexj30dd0aidfw.jpg" alt="image-20190908160540485"></p><h2 id="Contriol-Statements"><a href="#Contriol-Statements" class="headerlink" title="Contriol Statements"></a>Contriol Statements</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; zeros(10, 1)</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line"></span><br><span class="line">&gt;&gt; for i &#x3D; 1: 10,</span><br><span class="line">&gt;     v(i) &#x3D; 2^i;</span><br><span class="line">&gt; end;</span><br><span class="line">&gt;&gt; v&#39;</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">      2      4      8     16     32     64    128    256    512   1024</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a><code>while</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; i &#x3D; 1;</span><br><span class="line">&gt;&gt; while i &lt;&#x3D; 5,</span><br><span class="line">&gt;     v(i) &#x3D; 100;</span><br><span class="line">&gt;     i &#x3D; i + 1;</span><br><span class="line">&gt; end;</span><br><span class="line">&gt;&gt; v&#39;</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    100    100    100    100    100     64    128    256    512   1024</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; for i &#x3D; 1: 10,</span><br><span class="line">&gt;     if v(i) &gt; 100,</span><br><span class="line">&gt;         disp(v(i));</span><br><span class="line">&gt;     end;</span><br><span class="line">&gt; end;</span><br><span class="line"> 128</span><br><span class="line"> 256</span><br><span class="line"> 512</span><br><span class="line"> 1024</span><br></pre></td></tr></table></figure><p>Or, we can program like this,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1;</span><br><span class="line">if (x &#x3D;&#x3D; 1)</span><br><span class="line">    disp (&quot;one&quot;);</span><br><span class="line">elseif (x &#x3D;&#x3D; 2)</span><br><span class="line">    disp (&quot;two&quot;);</span><br><span class="line">else</span><br><span class="line">    disp (&quot;not one or two&quot;);</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a><code>break</code> &amp; <code>continue</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1;</span><br><span class="line">while true,</span><br><span class="line">    v(i) &#x3D; 999;</span><br><span class="line">    i &#x3D; i + 1;</span><br><span class="line">    if i &#x3D;&#x3D; 6,</span><br><span class="line">        break;</span><br><span class="line">    end;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">     64</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="Create-a-Function"><a href="#Create-a-Function" class="headerlink" title="Create a Function"></a>Create a Function</h3><p>To create a function, type the function code in a text editor (e.g. gedit or notepad), and save the file as <code>functionName.m</code></p><p>Example function:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function y &#x3D; squareThisNumber(x)</span><br><span class="line"></span><br><span class="line">y &#x3D; x^2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>To call this function in Octave, do either:</p><ol><li><code>cd</code> to the directory of the functionName.m file and call the function:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% Navigate to directory:</span><br><span class="line">cd &#x2F;path&#x2F;to&#x2F;function</span><br><span class="line"></span><br><span class="line">% Call the function:</span><br><span class="line">functionName(args)</span><br></pre></td></tr></table></figure><ol start="2"><li>Add the directory of the function file to the load path:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% To add the path for the current session of Octave:</span><br><span class="line">addpath(&#39;&#x2F;path&#x2F;to&#x2F;function&#x2F;&#39;)</span><br><span class="line"></span><br><span class="line">% To remember the path for future sessions of Octave, after executing addpath above, also do:</span><br><span class="line">    savepath</span><br></pre></td></tr></table></figure><h3 id="Function-with-multiple-return-values"><a href="#Function-with-multiple-return-values" class="headerlink" title="Function with multiple return values"></a>Function with multiple return values</h3><p>Octave’s functions can return more than one value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function [square, cube] &#x3D; squareAndCubeThisNumber(x)</span><br><span class="line"></span><br><span class="line">square &#x3D; x^2;</span><br><span class="line">cube &#x3D; x^3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; [s, c] &#x3D; squareAndCubeThisNumber(5)</span><br><span class="line">s &#x3D;  25</span><br><span class="line">c &#x3D;  125</span><br></pre></td></tr></table></figure><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><p>Let’s say I have a data set that looks like this, with data points at <code>(1, 1)</code>,<code> (2, 2)</code>, <code>(3, 3)</code>. And what I’d like to do is to define an octave function to compute the cost function J of theta for different values of theta.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6s7xhva3yj30em08baar.jpg" alt="image-20190908170150862"></p><p>First, put the data into octave:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X &#x3D; [1, 1; 1, 2; 1, 3]    % Design matrix</span><br><span class="line">y &#x3D; [1; 2; 3]</span><br><span class="line">theta &#x3D; [0; 1]</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">X &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   1   2</span><br><span class="line">   1   3</span><br><span class="line"></span><br><span class="line">y &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">theta &#x3D;</span><br><span class="line"></span><br><span class="line">   0</span><br><span class="line">   1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Then define the cost function:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% costFunctionJ.m</span><br><span class="line"></span><br><span class="line">function J &#x3D; costFunctionJ(X, y, theta)</span><br><span class="line"></span><br><span class="line">% X is the *design matrix* containing our training examples.</span><br><span class="line">% y is the class labels</span><br><span class="line"></span><br><span class="line">m &#x3D; size(X, 1);    % number of training examples</span><br><span class="line">predictions &#x3D; X * theta;    % predictions of hypothesis on all m examples</span><br><span class="line">sqrErrors &#x3D; (predictions - y) .^ 2;    % squared erroes</span><br><span class="line"></span><br><span class="line">J &#x3D; 1 &#x2F; (2*m) * sum(sqrErrors);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Now, use the costFunctionJ:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; j &#x3D; costFunctionJ(X, y, theta)</span><br><span class="line">j &#x3D; 0</span><br></pre></td></tr></table></figure><p>Got <code>j = 0</code> because we set theta as <code>[0; 1]</code> which is fitting our data set perfectly.</p><h2 id="Vectorization"><a href="#Vectorization" class="headerlink" title="Vectorization"></a>Vectorization</h2><p>Vectorization is the process of taking code that relies on <strong>loops</strong> and converting it into <strong>matrix operations</strong>. It is more efficient, more elegant, and more concise.</p><p>As an example, let’s compute our prediction from a hypothesis. Theta is the vector of fields for the hypothesis and x is a vector of variables.</p><p>With loops:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prediction &#x3D; 0.0;</span><br><span class="line">for j &#x3D; 1:n+1,</span><br><span class="line">  prediction +&#x3D; theta(j) * x(j);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>With vectorization:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prediction &#x3D; theta&#39; * x;</span><br></pre></td></tr></table></figure><p>If you recall the definition multiplying vectors, you’ll see that this one operation does the element-wise multiplication and overall sum in a very concise notation.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正规方程</title>
      <link href="/2019/09/07/AndrewNgML/AndrewNg-MachineLearning-4-NormalEquation/"/>
      <url>/2019/09/07/AndrewNgML/AndrewNg-MachineLearning-4-NormalEquation/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-4-Normal-Equation"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-4-Normal-Equation" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (4) Normal Equation"></a>Notes of Andrew Ng’s Machine Learning —— (4) Normal Equation</h1><h2 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h2><p>Gradient dedcent gives one way of minimizing our cost function $J$. Let’s discuss a second way of doing so – <strong><code>Normal Equation</code></strong>.</p><p>Normal Equation minimize $J$ by explicitly taking its derivatives with resspect to the $\theta_j$s, and setting them to zero. This alllows us to find the optimum theta without resorting to an iteration.</p><p>The normal equation formula is given below:<br>$$<br>\theta = (X^TX)^{-1}X^Ty<br>$$</p><p>There is no need to do feature scaling with the normal equation.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6oul2lb93j30gq09dgn1.jpg" alt="img"></p><h3 id="Normal-Equation-V-S-Gradient-Descent"><a href="#Normal-Equation-V-S-Gradient-Descent" class="headerlink" title="Normal Equation V.S. Gradient Descent"></a>Normal Equation V.S. Gradient Descent</h3><table><thead><tr><th>Gradient Descent</th><th>Normal Equation</th></tr></thead><tbody><tr><td>Need to choose alpha</td><td>No need to choose alpha</td></tr><tr><td>Needs many iterations</td><td>No need to iterate</td></tr><tr><td>Time cost: $O(kn^2)$</td><td>Need to calculate inverse of $X^TX$, which costs $O(n^3)$</td></tr><tr><td>Works well when n is large</td><td>Slow if n is very large</td></tr></tbody></table><p>In practice, when $n &gt; 10,000$, we are tend to use gradient descent, otherwise, normal equation will perform better.</p><h2 id="Normal-Equation-Noninvertibility"><a href="#Normal-Equation-Noninvertibility" class="headerlink" title="Normal Equation Noninvertibility"></a>Normal Equation Noninvertibility</h2><p>When implementing the normal equation in octave we want to usr the ** <code>pinv</code>** function rather than <code>inv</code>. The <code>pinv</code> will give you a value of $\theta$ even if $X^TX$ is not invertible.</p><p>if $X^TX$ is <strong>non-invertible</strong>, the common causes might be having:</p><ul><li><strong>Redundant features</strong>, where two features are linearly dependent. (e.g. there are the size of house in feet^2 and the size of house in meter^2, where we know that 1 meter = 3.28 feet)</li><li><strong>Too many features ($m \le n$)</strong>. In this case, delete some features or use “regularization”.</li></ul><p>Solutions to the above problems include deleting a feature that is linearly dependent with another or deleting one or more features when there are too many features.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多变量线性回归</title>
      <link href="/2019/09/05/AndrewNgML/AndrewNg-MachineLearning-3-MultivariateLinearRegression/"/>
      <url>/2019/09/05/AndrewNgML/AndrewNg-MachineLearning-3-MultivariateLinearRegression/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-3-Multivariate-Linear-Regression"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-3-Multivariate-Linear-Regression" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (3) Multivariate Linear Regression"></a>Notes of Andrew Ng’s Machine Learning —— (3) Multivariate Linear Regression</h1><h2 id="Multiple-Features"><a href="#Multiple-Features" class="headerlink" title="Multiple Features"></a>Multiple Features</h2><p>Linear regression with multiple variables is alse known as “<strong>multivariate linear regression</strong>“.</p><h3 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h3><p>We now introduce notation for equations where we can have any number of input variables (Multiple Features, i.e. Multivariate):</p><ul><li>$m$: the number of training examples.</li><li>$n$: the number of features.</li><li>$x^{(i)}$: the input (features) of the $i^{th}$ training example, a n-dimensional vector.</li><li>$x^{(i)}_j$: the value of feature $j$ in the $i^{th}$ training example.  </li></ul><h3 id="Hypothesis"><a href="#Hypothesis" class="headerlink" title="Hypothesis"></a>Hypothesis</h3><p>The multivariable form of the hypothesis function accommodating these multiple features is as follows:<br>$$<br>h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_3+ … + \theta_nx_n<br>$$</p><blockquote><p>In order to develop intuition about this function, we can think about $\theta_0$ as the basic price of a house, $\theta_1$ as the price per square meter, $\theta_2$ as the price per floor, etc. $x_1$ will be the number of square meters in the house, $x_2$ the number of floors, etc.</p></blockquote><p>Using the definition of matrix muyltiplication, our multivariable hypothesis function can be concisely represented as:<br>$$<br>h_\theta(x)=<br>\left[\begin{array}{c}\theta_0 &amp; \theta_1 &amp; \ldots &amp; \theta_n\end{array}\right]<br>\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]<br>=<br>\theta^Tx<br>$$<br>This is a vectorization of our hypothesis function for one training example.</p><p>Remark: Note that for convenience reasons, we assume <strong>$x^{(i)}_0=1 \quad \textrm{for(}i \in 1, …,m \textrm{)}$</strong>. This allows us to do matrix operations with $\theta$ and $x$. Hence making two vector $\theta$ and $x^{(i)}$ match each other element-wise (that is, have the same number of elements: n+1).</p><h2 id="Gradient-Descent-For-Multiple-Variables"><a href="#Gradient-Descent-For-Multiple-Variables" class="headerlink" title="Gradient Descent For Multiple Variables"></a>Gradient Descent For Multiple Variables</h2><p>Let’s say the condition about the multiple variables:</p><blockquote><p>Hypothesis: $h_\theta(x)=\sum_{i=0}^m \theta_ix_i$.</p><p>Parameters: $\theta_0, \theta_1, …,\theta_n$.</p><p>Cost Function: $J(\theta_0, \theta_1, …, \theta_n)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2$.</p></blockquote><p>Or vectorizedly:</p><blockquote><p>Hypothesis: $h_\theta(x)=\theta^Tx$.</p><p>Parameters: $\theta$.</p><p>Cost Function: $J(\theta)=\frac{1}{2m}\sum_{i=1}^m(\theta^Tx^{(i)}-y^{(i)})^2$.</p></blockquote><p>The Gradient Descent will be like this:</p><blockquote><p>repeat until convergence {</p><p>$\qquad \theta_j := \theta_j - \alpha \frac{1}{m} \sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}] \cdot x_j^{(i)}\qquad \textrm{for }j:=0, …, n$</p><p>}</p></blockquote><p>The following image compares gradient descent with one variable to gradient descent with multiple variables:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ljh8xnnuj30g508ttam.jpg" alt="img"></p><h2 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h2><p>We can speed up gradient descent by <strong>having each of our input values in roughly the same range</strong>. This is because $\theta$ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.</p><p>The way to prevent this is to <strong>modify the ranges of our input variables</strong> so that they are all roughly the same. Ideally:<br>$$<br>\begin{array}{c}<br>-1 \le x_{i} \le 1\<br>\textrm{or}\<br>-0.5 \le x_{i} \le 0.5<br>\end{array}<br>$$<br>These aren’t exact requirements; we are only trying to speed things up. The goal is to get all input variables into roughly one of these ranges, give or take a few.</p><p>In practice, we offen think it’s ok for variables in range $[-3,-\frac{1}{3}) \cup (+\frac{1}{3}, +3]$.</p><p>Two techniques to help with this are <code>feature scaling</code> and <code>mean normalization</code>.</p><h3 id="Feature-scaling"><a href="#Feature-scaling" class="headerlink" title="Feature scaling"></a>Feature scaling</h3><p>Feature scaling involves <strong>dividing the input values by <em>the range</em></strong> (i.e. the maximum value minus the minimum value) of input variable, resulting in a new range of just 1.<br>$$<br>\begin{array}{rl}<br>\textrm{Range:} &amp; s_i = max(x_i)-min(x_i)\<br>\textrm{Scaling:} &amp; x_i:=\frac{x_i}{s_i}<br>\end{array}<br>$$</p><h3 id="Mean-normalization"><a href="#Mean-normalization" class="headerlink" title="Mean normalization"></a>Mean normalization</h3><p>Mean normalization involves subtracting the average value for an input variable from the values for that input variable resulting in a new average value for the input variable of just zero.<br>$$<br>\begin{array}{rl}<br>\textrm{Average:} &amp; \mu_i = \frac{sum(x_i)}{m}\<br>\textrm{Mean normalizing:} &amp; x_i:=x_i-\mu_i<br>\end{array}<br>$$</p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>We always implement both of these techniques via adjusting our input values as shown in this formula:<br>$$<br>x_i:=\frac{x_i-\mu_i}{s_i}<br>$$</p><ul><li><strong>$\mu_i$</strong> is the <strong>average of all the values for feature (i)</strong></li><li><strong>$s_i$</strong> is the <strong>range of values (<code>max - min</code>)</strong>, or $s_i$ could also be the <strong>standard deviation</strong>.</li></ul><p>For example, if $x_i$ represents housing prices with a range of 100 to 2000 and a mean value of 1000, then, $x_i := \dfrac{price-1000}{1900}$.</p><h4 id="In-octave"><a href="#In-octave" class="headerlink" title="In octave"></a>In octave</h4><p>In octave, the function <code>mean</code> can offer us the avaerage of values for feature (i), when the function <code>std</code> gives us the standard deviation of values for feature (i). So we can program like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function [X_norm, mu, sigma] &#x3D; featureNormalize(X)</span><br><span class="line">%FEATURENORMALIZE Normalizes the features in X </span><br><span class="line">%   FEATURENORMALIZE(X) returns a normalized version of X where</span><br><span class="line">%   the mean value of each feature is 0 and the standard deviation</span><br><span class="line">%   is 1. This is often a good preprocessing step to do when</span><br><span class="line">%   working with learning algorithms.</span><br><span class="line"></span><br><span class="line">X_norm &#x3D; X;</span><br><span class="line">mu &#x3D; zeros(1, size(X, 2));</span><br><span class="line">sigma &#x3D; zeros(1, size(X, 2));</span><br><span class="line"></span><br><span class="line">% Instructions: First, for each feature dimension, compute the mean</span><br><span class="line">%               of the feature and subtract it from the dataset,</span><br><span class="line">%               storing the mean value in mu. Next, compute the </span><br><span class="line">%               standard deviation of each feature and divide</span><br><span class="line">%               each feature by it&#39;s standard deviation, storing</span><br><span class="line">%               the standard deviation in sigma. </span><br><span class="line">%</span><br><span class="line">%               Note that X is a matrix where each column is a </span><br><span class="line">%               feature and each row is an example. You need </span><br><span class="line">%               to perform the normalization separately for </span><br><span class="line">%               each feature. </span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">mu &#x3D; mean(X);</span><br><span class="line">sigma &#x3D; std(X);</span><br><span class="line">X_norm &#x3D; (X - mu) .&#x2F; sigma;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Learning-Rate"><a href="#Learning-Rate" class="headerlink" title="Learning Rate"></a>Learning Rate</h2><h3 id="Debugging-gradient-descent"><a href="#Debugging-gradient-descent" class="headerlink" title="Debugging gradient descent"></a>Debugging gradient descent</h3><p>Make a plot with <em>number of iterations</em> on the x-axis. Now plot the cost functiong $J(\theta)$ over the number of iterations of  gradient descent. If $J(\theta)$ ever increases, then you probably need to decrease learning rate $\alpha$.</p><h3 id="Automatic-convergence-test"><a href="#Automatic-convergence-test" class="headerlink" title="Automatic convergence test"></a>Automatic convergence test</h3><p>Declare convergence if $J(\theta)$ decreases by less than $\epsilon$, where $\epsilon$ is some small value such as $10^{-3}$. However in practice it’s difficult to choose this threshold value.</p><h3 id="Making-sure-gradient-descent-is-working-correctly"><a href="#Making-sure-gradient-descent-is-working-correctly" class="headerlink" title="Making sure gradient descent is working correctly"></a>Making sure gradient descent is working correctly</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6mi7c257sj30eg07wt9v.jpg" alt="img"></p><p>It has been proven that if learning rate α is sufficiently small, then J(θ) will decrease on every iteration.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6mi84pb5bj30e807pjsd.jpg" alt="img"></p><p>To summarize:</p><blockquote><p>If $\alpha$ is too small: slow convergence.</p><p>If $\alpha$ is too large: ￼may not decrease on every iteration and thus may not converge.</p></blockquote><h3 id="Implement-1"><a href="#Implement-1" class="headerlink" title="Implement"></a>Implement</h3><p>We should try different $\alpha$ to find a fit one by drawing #iterations-J(θ) plots.</p><p>E.g. To choose $\alpha$, try:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... , 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1, ...</span><br></pre></td></tr></table></figure><h2 id="Features-and-Polynomial-Regression"><a href="#Features-and-Polynomial-Regression" class="headerlink" title="Features and Polynomial Regression"></a>Features and Polynomial Regression</h2><h3 id="Combine-Features"><a href="#Combine-Features" class="headerlink" title="Combine Features"></a>Combine Features</h3><p>We can improve our features and the form of our hypothesis function in a couple different ways.</p><p>For example, we can <strong>combine</strong> multiple features into one, Such as combining $x_1$ and $x_2$ into a new feature $x_3$ by taking $x_1 \cdot x_2$.</p><h3 id="Polynomial-Regression"><a href="#Polynomial-Regression" class="headerlink" title="Polynomial Regression"></a>Polynomial Regression</h3><p>To fit the data well, our hypothesis function may need to be non-linear. So we can <strong>change the behavior or curve</strong> of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).</p><p>For example, if our hypothesis function is $h_\theta(x)=\theta_0+\theta_1x_1$ then we can create additional features based on $x_1$, to get the quadratic function $h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_1^2$ or the cubic function $h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_1^2+\theta_3x_1^3$, to make it a square root function, we could do: $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 \sqrt{x_1}$.</p><p>In the cubic version, we can create new features $x_2$, $x_3$ where $x_2=x_1^2$ and $x_3=x_1^3$, then we can get a set of thetas via gradient descent for multiple variables.</p><p>⚠️Note. if you choose your features this way then <strong>feature scaling</strong> becomes very important.</p><p>e.g. if x has range 1 ~ 1000:</p><p>Then range of x^2 becomes 1 ~ 1000000;</p><p>And range of x^3 becomes 1 ~ 1000000000;</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数复习</title>
      <link href="/2019/09/02/AndrewNgML/AndrewNg-MachineLearning-2-LinearAlgebraReview/"/>
      <url>/2019/09/02/AndrewNgML/AndrewNg-MachineLearning-2-LinearAlgebraReview/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-2-Linear-Algebra-Review"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-2-Linear-Algebra-Review" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (2) Linear Algebra Review"></a>Notes of Andrew Ng’s Machine Learning —— (2) Linear Algebra Review</h1><h2 id="Matrices-and-Vectors"><a href="#Matrices-and-Vectors" class="headerlink" title="Matrices and Vectors"></a>Matrices and Vectors</h2><ul><li><strong>Matrices</strong> are 2-dimensional arrays:</li></ul><p>$$<br>\left[\begin{array}{ccc}<br>a &amp; b &amp; c \<br>d &amp; e &amp; f \<br>g &amp; h &amp; i \<br>j &amp; k &amp; l \<br>\end{array}\right]<br>$$</p><p>The above matrix has four rows and three columns, so it is a <code>4 x 3 matrix</code>.</p><ul><li><strong>Vector</strong> are matrices with one column and many rows:</li></ul><p>$$<br>\left[\begin{array}{c}<br>w \<br>x \<br>y \<br>z \<br>\end{array}\right]<br>$$</p><p>The above vector is a <code>4 x 1 matrix</code>.</p><h3 id="Notation-and-terms"><a href="#Notation-and-terms" class="headerlink" title="Notation and terms"></a>Notation and terms</h3><ul><li>$A_{ij}$ refers to the element in the <em>ith row</em> and <em>jth column</em> of matrix A.</li><li>A vector with ‘n’ rows is referred to as a <code>&#39;n&#39;-dimensional vector</code>.</li><li>$v_i$ refers to the element in the <em>ith row</em> of the vector.</li><li>In general, all our vectors and matrices will be <code>1-indexed</code>, which refers that it’s beginning from <code>1</code>. Note that this is different to lots of programming languages.</li><li>Matrices are usualy denoted by uppercase names while vectors are lowercase.</li><li><code>Scalar</code> means that an object is a single value, not a vector or matrix.</li><li>$\R$ referss to the set of scalar real numbers.</li><li>$R^n$ refers to the set of n-dimensional vectors of real numbers.</li></ul><h3 id="in-Octave-Matlab"><a href="#in-Octave-Matlab" class="headerlink" title="in Octave/Matlab"></a>in Octave/Matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% The ; denotes we are going back to a new row.</span><br><span class="line">A &#x3D; [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12]</span><br><span class="line"></span><br><span class="line">% Initialize a vector </span><br><span class="line">v &#x3D; [1;2;3] </span><br><span class="line"></span><br><span class="line">% Get the dimension of the matrix A where m &#x3D; rows and n &#x3D; columns</span><br><span class="line">[m,n] &#x3D; size(A)</span><br><span class="line"></span><br><span class="line">% You could also store it this way</span><br><span class="line">dim_A &#x3D; size(A)</span><br><span class="line"></span><br><span class="line">% Get the dimension of the vector v </span><br><span class="line">dim_v &#x3D; size(v)</span><br><span class="line"></span><br><span class="line">% Now let&#39;s index into the 2nd row 3rd column of matrix A</span><br><span class="line">A_23 &#x3D; A(2,3)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">    1    2    3</span><br><span class="line">    4    5    6</span><br><span class="line">    7    8    9</span><br><span class="line">   10   11   12</span><br><span class="line"></span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">m &#x3D;  4</span><br><span class="line">n &#x3D;  3</span><br><span class="line">dim_A &#x3D;</span><br><span class="line"></span><br><span class="line">   4   3</span><br><span class="line"></span><br><span class="line">dim_v &#x3D;</span><br><span class="line"></span><br><span class="line">   3   1</span><br><span class="line"></span><br><span class="line">A_23 &#x3D;  6</span><br></pre></td></tr></table></figure><h2 id="Addition-and-Scalar-Multiplication"><a href="#Addition-and-Scalar-Multiplication" class="headerlink" title="Addition and Scalar Multiplication"></a>Addition and Scalar Multiplication</h2><h3 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h3><p><strong>Addition</strong> and <strong>subtraction</strong> are element-wise, so you simply add or subtract each corresponding element:<br>$$<br>\left[\begin{array}{cc}<br>a &amp; b \<br>c &amp; d \<br>\end{array}\right]<br>+<br>\left[\begin{array}{cc}<br>w &amp; x\<br>y &amp; z\<br>\end{array}\right]<br>=<br>\left[\begin{array}{cc}<br>a+w &amp; b+x \<br>c+y &amp; d+z \<br>\end{array}\right]<br>$$<br>To add or subtract two matrices, their <em>dimensions</em> must be <strong>the same</strong>.</p><h3 id="Scalar-multiplication"><a href="#Scalar-multiplication" class="headerlink" title="Scalar multiplication"></a>Scalar multiplication</h3><p>In <strong>scalar multiplication</strong>, we simply multiply every element by the scalar value:<br>$$<br>\left[\begin{array}{cc}<br>a &amp; b \<br>c &amp; d \<br>\end{array}\right]<br>*x<br>=<br>\left[\begin{array}{cc}<br>ax &amp; bx \<br>cx &amp; dx \<br>\end{array}\right]<br>$$</p><h3 id="in-Octave-Matlab-1"><a href="#in-Octave-Matlab-1" class="headerlink" title="in Octave/Matlab"></a>in Octave/Matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">% Initialize matrix A and B </span><br><span class="line">A &#x3D; [1, 2, 4; 5, 3, 2]</span><br><span class="line">B &#x3D; [1, 3, 4; 1, 1, 1]</span><br><span class="line"></span><br><span class="line">% Initialize constant s </span><br><span class="line">s &#x3D; 2</span><br><span class="line"></span><br><span class="line">% See how element-wise addition works</span><br><span class="line">add_AB &#x3D; A + B </span><br><span class="line"></span><br><span class="line">% See how element-wise subtraction works</span><br><span class="line">sub_AB &#x3D; A - B</span><br><span class="line"></span><br><span class="line">% See how scalar multiplication works</span><br><span class="line">mult_As &#x3D; A * s</span><br><span class="line"></span><br><span class="line">% Divide A by s</span><br><span class="line">div_As &#x3D; A &#x2F; s</span><br><span class="line"></span><br><span class="line">% A Matrix + scalar will get Matrix + a new matrix that each element equals the scalar </span><br><span class="line">add_As &#x3D; A + s</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   4</span><br><span class="line">   5   3   2</span><br><span class="line"></span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   1   3   4</span><br><span class="line">   1   1   1</span><br><span class="line"></span><br><span class="line">s &#x3D;  2</span><br><span class="line">add_AB &#x3D;</span><br><span class="line"></span><br><span class="line">   2   5   8</span><br><span class="line">   6   4   3</span><br><span class="line"></span><br><span class="line">sub_AB &#x3D;</span><br><span class="line"></span><br><span class="line">   0  -1   0</span><br><span class="line">   4   2   1</span><br><span class="line"></span><br><span class="line">mult_As &#x3D;</span><br><span class="line"></span><br><span class="line">    2    4    8</span><br><span class="line">   10    6    4</span><br><span class="line"></span><br><span class="line">div_As &#x3D;</span><br><span class="line"></span><br><span class="line">   0.50000   1.00000   2.00000</span><br><span class="line">   2.50000   1.50000   1.00000</span><br><span class="line"></span><br><span class="line">add_As &#x3D;</span><br><span class="line"></span><br><span class="line">   3   4   6</span><br><span class="line">   7   5   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Matrix-Vector-Multiplication"><a href="#Matrix-Vector-Multiplication" class="headerlink" title="Matrix-Vector Multiplication"></a>Matrix-Vector Multiplication</h2><p>We map the column of the vector onto each row of the matrix, multiplying each element and summing the result.<br>$$<br>\left[\begin{array}{cc}<br>a &amp; b\<br>c &amp; d\<br>e &amp; f\<br>\end{array}\right]<br>*<br>\left[\begin{array}{c}<br>x\<br>y<br>\end{array}\right]<br>=<br>\left[\begin{array}{cc}<br>ax &amp; by\<br>cx &amp; dy\<br>ex &amp; fy\<br>\end{array}\right]<br>$$<br>The result is a <strong>vector</strong>. The number of <strong>columns</strong> of the matrix must equal the number of <strong>rows</strong> of the vector.</p><p>An <code>m x n matrix</code> multiplied by an <code>n x 1 vector</code> results in an <code>m x 1 vector</code>.</p><h3 id="in-Octave-Matlab-2"><a href="#in-Octave-Matlab-2" class="headerlink" title="in Octave/Matlab"></a>in Octave/Matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% Initialize matrix A </span><br><span class="line">A &#x3D; [1, 2, 3; 4, 5, 6;7, 8, 9] </span><br><span class="line"></span><br><span class="line">% Initialize vector v </span><br><span class="line">v &#x3D; [1; 1; 1] </span><br><span class="line"></span><br><span class="line">% Multiply A * v</span><br><span class="line">Av &#x3D; A * v</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">   7   8   9</span><br><span class="line"></span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line"></span><br><span class="line">Av &#x3D;</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line">   15</span><br><span class="line">   24</span><br></pre></td></tr></table></figure><h3 id="Neat-Trick"><a href="#Neat-Trick" class="headerlink" title="Neat Trick"></a>Neat Trick</h3><p>Say, we have a set of four sizes of houses, and we have a hypotheses for predictiong what the price of a house. We are going to compute $h(x)$ of each of our 4 houses:</p><blockquote><p>House sizes:<br>$$<br>\begin{array}{c}<br>2104\<br>1416\<br>1534\<br>852\<br>\end{array}<br>$$<br>Hypothesis:<br>$$<br>h_\theta(x)=-40+0.25x<br>$$</p></blockquote><p>It turns out there’s neat way of posing this, applying this hypothesis to all of my houses at the same time via a Matrix-Vector multiplication.</p><ul><li>Construct a <code>DataMatrix</code>:</li></ul><p>$$<br>\textrm{DataMatrix}=<br>\left[\begin{array}{cc}<br>1 &amp; 2104\<br>1 &amp; 1416\<br>1 &amp; 1534\<br>1 &amp; 852\<br>\end{array}\right]<br>$$</p><ul><li>Put <code>Parameters</code> to a vector:</li></ul><p>$$<br>\textrm{Parameters}=<br>\left[\begin{array}{c}<br>-40\<br>0.25\<br>\end{array}\right]<br>$$</p><ul><li>Then, the <code>Predictions</code> will be clear by calculate a Matrix-Vector Multiplication:</li></ul><p>$$<br>\begin{array}{ccccc}<br>\textrm{Predictions} &amp; = &amp; \textrm{DataMatrix} &amp; * &amp; \textrm{Parameters}\<br> &amp; = &amp; \left[\begin{array}{cc}<br>1 &amp; 2104\<br>1 &amp; 1416\<br>1 &amp; 1534\<br>1 &amp; 852<br>\end{array}\right] &amp; * &amp; \left[\begin{array}{c}<br>-40\<br>0.25<br>\end{array}\right]<br>\end{array}<br>$$</p><p>The reuslt will be something like this:<br>$$<br>\textrm{Predictions}=<br>\left[\begin{array}{c}<br>-40 \times 1 + 0.25 \times 2104\<br>-40 \times 1 + 0.25 \times 1416\<br>\vdots<br>\end{array}\right]<br>$$<br>Obviously, it’s equal to the codes below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i &#x3D; 0; i &lt; X.size(); i++) &#123;</span><br><span class="line">Predictions[i] &#x3D; h(X[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, our new trick simplifies the code, makes it more readable as well as driving it faster to be solved in most programming languages, we just construct two matrices and do a multiplication:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataMatrix &#x3D; [...]</span><br><span class="line">Parameters &#x3D; [...]</span><br><span class="line">Predictions &#x3D; DataMatrix * Parameters</span><br></pre></td></tr></table></figure><h2 id="Matrix-Matrix-Multiplication"><a href="#Matrix-Matrix-Multiplication" class="headerlink" title="Matrix-Matrix Multiplication"></a>Matrix-Matrix Multiplication</h2><p>We multiply two matrices by breaking it into serveral vector multiplications and concatenating the result.<br>$$<br>\left[\begin{array}{cc}<br>a &amp; b\<br>c &amp; d\<br>e &amp; f\<br>\end{array}\right]<br>*<br>\left[\begin{array}{cc}<br>w &amp; x\<br>y &amp; z\<br>\end{array}\right]<br>=<br>\left[\begin{array}{cc}<br>aw+by &amp; ax+bz\<br>cw+dy &amp; cx+dz\<br>ew+fy &amp; ex+fz\<br>\end{array}\right]<br>$$<br>An <code>m x n matrix</code> multiplied by an <code>n x o matrix</code> result in an <code>m x o</code> matrix ($[m \times n]*[n \times o]=[m \times o]$). In the above example, a 3 x 2 matrix times a 2 x 2 matrix resulted in a 3 x 2 matrix.</p><p>To multiply two matrices, the number of <strong>columns</strong> of the first matrix must equal the number of <strong>rows</strong> of the second matrix.</p><h3 id="in-Octave-Matlab-3"><a href="#in-Octave-Matlab-3" class="headerlink" title="in Octave/Matlab"></a>in Octave/Matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1, 2; 3, 4; 5, 6]</span><br><span class="line">B &#x3D; [7, 8; 9, 10]</span><br><span class="line">A*B</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">    7    8</span><br><span class="line">    9   10</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    25    28</span><br><span class="line">    57    64</span><br><span class="line">    89   100</span><br></pre></td></tr></table></figure><h3 id="Neat-Trick-1"><a href="#Neat-Trick-1" class="headerlink" title="Neat Trick"></a>Neat Trick</h3><p>Let’s say, as befor, that we have four houses, and we want to predict their prices. Ony now, we have three competing hypotheses. We want to apply all three competing hypotheses to all four Xs. It turns out we can do that very efficiently using a matrix-matrix multiplication.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6k2f8f6tyj30hw09f40y.jpg" alt="image-20190901154936492"></p><h2 id="Matrix-Multiplication-Properties"><a href="#Matrix-Multiplication-Properties" class="headerlink" title="Matrix Multiplication Properties"></a>Matrix Multiplication Properties</h2><h3 id="Non-commutative"><a href="#Non-commutative" class="headerlink" title="Non-commutative"></a>Non-commutative</h3><p>Matrices are not commutative:<br>$$<br>A \times B \neq B \times A<br>$$</p><h3 id="Associative"><a href="#Associative" class="headerlink" title="Associative"></a>Associative</h3><p>Matrices are associative:<br>$$<br>(A \times B) \times C = A \times (B \times C)<br>$$</p><h3 id="Identity-matrix"><a href="#Identity-matrix" class="headerlink" title="Identity matrix"></a>Identity matrix</h3><p><code>Identity matrix</code>: a matrix that simply has <code>1</code>‘s on the diagonal (upper left to lower right diagonal) and <code>0</code>‘s elsewhere.<br>$$<br>I=\left[\begin{array}{ccc}<br>1 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 1\<br>\end{array}\right]<br>$$<br>The identity matrix, when multiplied by any matrix of the same dimensions, results in the original matrix. It’s just like multiplying numbers by 1.<br>$$<br>A \times I = I \times A = A<br>$$<br>Notice that when doing <code>A*I</code>, the <code>I</code> should match the matrix’s columns and when doing <code>I*A</code>, the <code>I</code> should match the matrix’s rows:<br>$$<br>A_{m \times n} \times I_{n \times n}=I_{m \times m} \times A_{m \times n} = A_{m \times n}<br>$$</p><h3 id="in-Octave-Matlab-4"><a href="#in-Octave-Matlab-4" class="headerlink" title="in Octave/Matlab"></a>in Octave/Matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">% Initialize random matrices A and B </span><br><span class="line">A &#x3D; [1,2;4,5]</span><br><span class="line">B &#x3D; [1,1;0,2]</span><br><span class="line"></span><br><span class="line">% Initialize a 2 by 2 identity matrix</span><br><span class="line">I &#x3D; eye(2)</span><br><span class="line"></span><br><span class="line">% The above notation is the same as I &#x3D; [1,0;0,1]</span><br><span class="line"></span><br><span class="line">% What happens when we multiply I*A ? </span><br><span class="line">IA &#x3D; I*A </span><br><span class="line"></span><br><span class="line">% How about A*I ? </span><br><span class="line">AI &#x3D; A*I </span><br><span class="line"></span><br><span class="line">% Compute A*B </span><br><span class="line">AB &#x3D; A*B </span><br><span class="line"></span><br><span class="line">% Is it equal to B*A? </span><br><span class="line">BA &#x3D; B*A </span><br><span class="line"></span><br><span class="line">% Note that IA &#x3D; AI but AB !&#x3D; BA</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   4   5</span><br><span class="line"></span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   0   2</span><br><span class="line"></span><br><span class="line">I &#x3D;</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0</span><br><span class="line">   0   1</span><br><span class="line"></span><br><span class="line">IA &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   4   5</span><br><span class="line"></span><br><span class="line">AI &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   4   5</span><br><span class="line"></span><br><span class="line">AB &#x3D;</span><br><span class="line"></span><br><span class="line">    1    5</span><br><span class="line">    4   14</span><br><span class="line"></span><br><span class="line">BA &#x3D;</span><br><span class="line"></span><br><span class="line">    5    7</span><br><span class="line">    8   10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Inverse-and-Transpose"><a href="#Inverse-and-Transpose" class="headerlink" title="Inverse and Transpose"></a>Inverse and Transpose</h2><h3 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h3><p>The inverse of a matrix $A$ is denoted $A^{-1}$. Multiplying by the inverse results in the identity matrix:<br>$$<br>A_{m \times m} \times A^{-1}<em>{m \times m}=A^{-1}</em>{m \times m} \times A_{m \times m} = I_{m \times m}<br>$$<br>A non square matrix does not have an inverse matrix. We can compute inverses of matrices in octave with the <code>pinv(A)</code> function and in Matlab with the <code>inv(A)</code> function. Matrices that don’t have an inverse are <em>singular</em> or <em>degenerate</em>.</p><p>In practice, when we are using normal equation with Octave, there are two functions to inverse a Matrix – pinv and inv. For some mathematically reason, The <code>pinv(A)</code> will always offer us the value of data that we want, even if A is non-invertible.</p><h3 id="Transpose"><a href="#Transpose" class="headerlink" title="Transpose"></a>Transpose</h3><p>The transposition of a matrix is like rotating the matrix 90º in clockwise direction and then reversing it.</p><p>In other words: Let $A$ be an $m \times n$ matrix, and let $B=A^T$. Then  $B$ is an $n \times m$ matrix, and $B_{ij}=A_{ji}$.<br>$$<br>A=<br>\left[\begin{array}{cc}<br>a &amp; b\<br>c &amp; d\<br>e &amp; f\<br>\end{array}\right]<br>\qquad<br>A^T=<br>\left[\begin{array}{ccc}<br>a &amp; c &amp; e\<br>b &amp; d &amp; f\<br>\end{array}\right]<br>$$<br>We can compute transposition of matrices in matlab with the <code>transpose(A)</code> function or <code>A&#39;</code></p><h3 id="in-Octave-Matlab-5"><a href="#in-Octave-Matlab-5" class="headerlink" title="in Octave/Matlab"></a>in Octave/Matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% Initialize matrix A </span><br><span class="line">A &#x3D; [1,2,0;0,5,6;7,0,9]</span><br><span class="line"></span><br><span class="line">% Transpose A </span><br><span class="line">A_trans &#x3D; A&#39; </span><br><span class="line"></span><br><span class="line">% Take the inverse of A </span><br><span class="line">A_inv &#x3D; inv(A)</span><br><span class="line"></span><br><span class="line">% What is A^(-1)*A? </span><br><span class="line">A_invA &#x3D; inv(A)*A</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   0</span><br><span class="line">   0   5   6</span><br><span class="line">   7   0   9</span><br><span class="line"></span><br><span class="line">A_trans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   0   7</span><br><span class="line">   2   5   0</span><br><span class="line">   0   6   9</span><br><span class="line"></span><br><span class="line">A_inv &#x3D;</span><br><span class="line"></span><br><span class="line">   0.348837  -0.139535   0.093023</span><br><span class="line">   0.325581   0.069767  -0.046512</span><br><span class="line">  -0.271318   0.108527   0.038760</span><br><span class="line"></span><br><span class="line">A_invA &#x3D;</span><br><span class="line"></span><br><span class="line">   1.00000  -0.00000   0.00000</span><br><span class="line">   0.00000   1.00000  -0.00000</span><br><span class="line">  -0.00000   0.00000   1.00000</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-更多类型：指针、struct、slice和映射</title>
      <link href="/2019/08/31/Golang/go-3-MoreTypes/"/>
      <url>/2019/08/31/Golang/go-3-MoreTypes/</url>
      
        <content type="html"><![CDATA[<h2 id="更多类型：指针、struct、slice-和映射"><a href="#更多类型：指针、struct、slice-和映射" class="headerlink" title="更多类型：指针、struct、slice 和映射"></a>更多类型：指针、struct、slice 和映射</h2><h3 id="§-指针"><a href="#§-指针" class="headerlink" title="§ 指针"></a>§ <a href="https://tour.golang.org/moretypes/1">指针</a></h3><p>Go 拥有指针。指针保存了值的内存地址。</p><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><p><code>*</code> 操作符表示指针指向的底层值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure><p>这也就是通常所说的“间接引用”或“重定向”。</p><p>与 C 不同，Go 没有指针运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">p := &amp;i</span><br><span class="line">fmt.Println(p)</span><br><span class="line">fmt.Println(*p)</span><br><span class="line">*p = <span class="number">21</span></span><br><span class="line">fmt.Println(*p)</span><br><span class="line"></span><br><span class="line">p = &amp;j</span><br><span class="line">*p /= <span class="number">37</span></span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xc00008e000</span><br><span class="line">42</span><br><span class="line">21</span><br><span class="line">73</span><br></pre></td></tr></table></figure><h3 id="§-结构体"><a href="#§-结构体" class="headerlink" title="§ 结构体"></a>§ <a href="https://tour.golang.org/moretypes/2">结构体</a></h3><p>一个结构体（<code>struct</code>）就是一组字段（field）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1 2&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体字段"><a href="#结构体字段" class="headerlink" title="结构体字段"></a><a href="https://tour.golang.org/moretypes/3">结构体字段</a></h4><p>结构体字段使用点号来访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v.X = <span class="number">4</span></span><br><span class="line">fmt.Println(v.X)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a><a href="https://tour.golang.org/moretypes/4">结构体指针</a></h4><p>结构体字段可以通过结构体指针来访问。</p><p>如果我们有一个指向结构体的指针 p，那么可以通过 <code>(*p).X</code> 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1000000000 2&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体文法-Struct-Literals"><a href="#结构体文法-Struct-Literals" class="headerlink" title="结构体文法(Struct Literals)"></a><a href="https://tour.golang.org/moretypes/5">结构体文法(Struct Literals)</a></h4><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p><p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p><p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;</span><br><span class="line">v3 = Vertex&#123;&#125;</span><br><span class="line">p0 = &amp;Vertex&#123;Y: <span class="number">1</span>, X: <span class="number">2</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v1, v2, v3, *p0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; &#123;2 1&#125;</span><br></pre></td></tr></table></figure><h3 id="§-数组"><a href="#§-数组" class="headerlink" title="§ 数组"></a>§ <a href="https://tour.golang.org/moretypes/6">数组</a></h3><p>类型 <code>[n]T</code> 表示拥有 n 个 T 类型的值的数组。</p><p>表达式</p><p><code>var a [10]int</code></p><p>会将变量 a 声明为拥有 10 个整数的数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">[Hello World]</span><br><span class="line">[2 3 5 7 11 13]</span><br></pre></td></tr></table></figure><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p><h3 id="§-切片"><a href="#§-切片" class="headerlink" title="§ 切片"></a>§ 切片</h3><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型 <code>[]T</code> 表示一个元素类型为 T 的切片。（不写元素个数的数组）</p><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><p><code>a[low : high]</code></p><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p><p>以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素：</p><p><code>a[1:4]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3 5 7]</span><br></pre></td></tr></table></figure><h4 id="切片就像数组的引用"><a href="#切片就像数组的引用" class="headerlink" title="切片就像数组的引用"></a><a href="https://tour.golang.org/moretypes/8">切片就像数组的引用</a></h4><p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p><p>更改切片的元素会修改其底层数组中对应的元素。</p><p>与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">names := [<span class="number">4</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;B&quot;</span>,</span><br><span class="line"><span class="string">&quot;C&quot;</span>,</span><br><span class="line"><span class="string">&quot;D&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line">a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[A B C D]</span><br><span class="line">[A B] [B C]</span><br><span class="line">[A XXX] [XXX C]</span><br><span class="line">[A XXX C D]</span><br></pre></td></tr></table></figure><h4 id="切片文法-Slice-literals"><a href="#切片文法-Slice-literals" class="headerlink" title="切片文法(Slice literals)"></a><a href="https://tour.golang.org/moretypes/9">切片文法(Slice literals)</a></h4><p>切片文法类似于没有长度的数组文法。</p><p>这是一个数组文法：</p><p><code>[3]bool&#123;true, true, false&#125;</code></p><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><p><code>[]bool&#123;true, true, false&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2 3 5 7 11 13]</span><br><span class="line">[true false true false]</span><br><span class="line">[&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125;]</span><br></pre></td></tr></table></figure><h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a><a href="https://tour.golang.org/moretypes/10">切片的默认行为</a></h4><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p><p>切片下界的默认值为 0，上界则是该切片的长度。</p><p>对于数组</p><p><code>var a [10]int</code></p><p>来说，以下切片是等价的：</p><p><code>a[0:10]</code></p><p><code>a[:10]</code></p><p><code>a[0:]</code></p><p><code>a[:]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[3 5 7]</span><br><span class="line">[3 5]</span><br><span class="line">[5]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a><a href="https://tour.golang.org/moretypes/11">切片的长度与容量</a></h4><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p><ul><li><p>切片的 长度 就是它所包含的元素个数。</p></li><li><p>切片的 容量 是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p></li></ul><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p><p>你可以通过重新切片来改变一个切片的长度(You can extend a slice’s length by re-slicing it, provided it has sufficient capacity. )。</p><p>如果长度开得超出了容量(to extend it beyond its capacity)，会有 runtime error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外扩展它的容量</span></span><br><span class="line">s = s[<span class="number">2</span>:<span class="number">10</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d\tcap=%d\t %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">len&#x3D;6cap&#x3D;6 [2 3 5 7 11 13]</span><br><span class="line">len&#x3D;0cap&#x3D;6 []</span><br><span class="line">len&#x3D;4cap&#x3D;6 [2 3 5 7]</span><br><span class="line">len&#x3D;2cap&#x3D;4 [5 7]</span><br><span class="line">panic: runtime error: slice bounds out of range</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">&#x2F;Users&#x2F;example&#x2F;go&#x2F;tour&#x2F;slice-len-cap&#x2F;src.go:22 +0x483</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a><a href="https://tour.golang.org/moretypes/12">nil 切片</a></h4><p>切片的零值是 <code>nil</code>。</p><p><code>nil</code> 切片的长度和容量为 <code>0</code> 且没有底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] 0 0</span><br><span class="line">nil!</span><br></pre></td></tr></table></figure><h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a><a href="https://tour.golang.org/moretypes/13">用 make 创建切片</a></h4><p>切片可以用内建函数 <code>make</code> 来创建，这也是创建动态数组的方式。</p><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><p><code>a := make([]int, 5)  // len(a)=5</code></p><p>要指定它的容量(cap)，需向 make 传入第三个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">printSlice(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(<span class="string">&quot;d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: len=%d cap=%d %v\n&quot;</span>, s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: len&#x3D;5 cap&#x3D;5 [0 0 0 0 0]</span><br><span class="line">b: len&#x3D;0 cap&#x3D;5 []</span><br><span class="line">c: len&#x3D;2 cap&#x3D;5 [0 0]</span><br><span class="line">d: len&#x3D;3 cap&#x3D;3 [0 0 0]</span><br></pre></td></tr></table></figure><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a><a href="https://tour.golang.org/moretypes/14">切片的切片</a></h4><p>切片可包含任何类型，甚至包括其它的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个井字板（井字棋游戏）</span></span><br><span class="line">board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="string">&quot;  &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X  _  X</span><br><span class="line">O  _  X</span><br><span class="line">_  _  O</span><br></pre></td></tr></table></figure><h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a><a href="https://tour.golang.org/moretypes/15">向切片追加元素</a></h4><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的<a href="https://golang.org/pkg/builtin/#append">文档</a>对此函数有详细的介绍。</p><p><code>func append(s []T, vs ...T) []T</code></p><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len&#x3D;0 cap&#x3D;0 []</span><br><span class="line">len&#x3D;1 cap&#x3D;1 [0]</span><br><span class="line">len&#x3D;2 cap&#x3D;2 [0 1]</span><br><span class="line">len&#x3D;5 cap&#x3D;6 [0 1 2 3 4]</span><br></pre></td></tr></table></figure><p>（要了解关于切片的更多内容，请阅读文章 <a href="https://blog.golang.org/go-slices-usage-and-internals">Go 切片：用法和本质</a>。）</p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a><a href="https://tour.golang.org/moretypes/16">Range</a></h3><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2**0 &#x3D; 1</span><br><span class="line">2**1 &#x3D; 2</span><br><span class="line">2**2 &#x3D; 4</span><br><span class="line">2**3 &#x3D; 8</span><br><span class="line">2**4 &#x3D; 16</span><br><span class="line">2**5 &#x3D; 32</span><br><span class="line">2**6 &#x3D; 64</span><br><span class="line">2**7 &#x3D; 128</span><br></pre></td></tr></table></figure><h4 id="range（续）"><a href="#range（续）" class="headerlink" title="range（续）"></a><a href="https://tour.golang.org/moretypes/17">range（续）</a></h4><p>可以将 下标 或 值 赋予 _ 来忽略它。</p><p><code>for i, _ := range pow</code><br><code>for _, value := range pow</code></p><p>若你只需要索引，忽略第二个变量即可:</p><p><code>for i := range pow</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pow := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">pow[i] = <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(i) <span class="comment">// == 2 ** i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">256</span><br><span class="line">512</span><br></pre></td></tr></table></figure><h3 id="Maps-映射"><a href="#Maps-映射" class="headerlink" title="Maps(映射)"></a><a href="https://tour.golang.org/moretypes/19">Maps(映射)</a></h3><p>映射将键映射到值。</p><p>映射的零值为 <code>nil</code> 。</p><p><code>nil</code> 映射既没有键，也不能添加键。</p><p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line"><span class="comment">// m[&quot;A&quot;] = Vertex&#123;1.2, 3.4&#125;    // 不可这样用</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;B&quot;</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.05</span>, <span class="number">-71.0</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">&quot;B&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[]</span><br><span class="line">&#123;40.05 -71&#125;</span><br></pre></td></tr></table></figure><h4 id="映射的文法"><a href="#映射的文法" class="headerlink" title="映射的文法"></a><a href="https://tour.golang.org/moretypes/20">映射的文法</a></h4><p>映射的文法与结构体相似，不过必须有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;B&quot;</span> : Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line"><span class="string">&quot;C&quot;</span> : Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[B:&#123;1 2&#125; C:&#123;3 4&#125;]</span><br></pre></td></tr></table></figure><h4 id="映射的文法（续）"><a href="#映射的文法（续）" class="headerlink" title="映射的文法（续）"></a><a href="https://tour.golang.org/moretypes/21">映射的文法（续）</a></h4><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;B&quot;</span>: &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line"><span class="string">&quot;C&quot;</span>: &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[B:&#123;1 2&#125; C:&#123;3 4&#125;]</span><br></pre></td></tr></table></figure><h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a><a href="https://tour.golang.org/moretypes/22">修改映射</a></h4><p>在映射 <code>m</code> 中插入或修改元素：</p><p><code>m[key] = elem</code></p><p>获取元素：</p><p><code>elem = m[key]</code></p><p>删除元素：</p><p><code>delete(m, key)</code></p><p>通过双赋值检测某个键是否存在：</p><p><code>elem, ok = m[key]</code></p><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p><p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p><p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p><p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，可以使用短变量声明：</p><p><code>elem, ok := m[key]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The value: 42</span><br><span class="line">The value: 48</span><br><span class="line">The value: 0</span><br><span class="line">The value: 0 Present? false</span><br></pre></td></tr></table></figure><h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a><a href="https://tour.golang.org/moretypes/24">函数值</a></h3><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(compute(hypot))</span><br><span class="line">fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">5</span><br><span class="line">81</span><br></pre></td></tr></table></figure><h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a><a href="https://tour.golang.org/moretypes/25">函数的闭包</a></h3><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 -2</span><br><span class="line">3 -6</span><br><span class="line">6 -12</span><br><span class="line">10 -20</span><br><span class="line">15 -30</span><br><span class="line">21 -42</span><br><span class="line">28 -56</span><br><span class="line">36 -72</span><br><span class="line">45 -90</span><br></pre></td></tr></table></figure><p>👆函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上。</p><p>实例：<a href="https://tour.golang.org/moretypes/26"><em>斐波纳契闭包</em></a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fibonacci is a function that returns</span></span><br><span class="line"><span class="comment">// a function that returns an int.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i, j = j, i + j</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-流程控制语句：for、if、else、switch 和 defer</title>
      <link href="/2019/08/31/Golang/go-2-ControlStatements/"/>
      <url>/2019/08/31/Golang/go-2-ControlStatements/</url>
      
        <content type="html"><![CDATA[<h2 id="流程控制语句：for、if、else、switch-和-defer"><a href="#流程控制语句：for、if、else、switch-和-defer" class="headerlink" title="流程控制语句：for、if、else、switch 和 defer"></a>流程控制语句：for、if、else、switch 和 defer</h2><h3 id="§-for"><a href="#§-for" class="headerlink" title="§ for"></a>§ <a href="https://tour.golang.org/flowcontrol/1">for</a></h3><p>Go 只有一种循环结构：<code>for</code> 循环。</p><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式，则前后的<code>;</code>会被去掉，若有：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p><p>注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号 <code>( )</code>， 而大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure><p>初始化语句和后置语句是可选的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">100</span></span><br><span class="line">c := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i != j &#123;    <span class="comment">// for ;i != j; &#123; 自动格式化后的结果，go 中的&quot;while&quot;</span></span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">c += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;i: %v, j: %v, c: %v\n&quot;</span>, i, j, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i: 50, j: 50, c: 50</span><br></pre></td></tr></table></figure><p>如果只有条件表达式，则前后的 <code>;</code> 会被 <code>go fmt</code> 去掉，成为 go 中的”while”。若有初始化语句、条件表达式、后置语句中的两个，则不会被省略。</p><h4 id="for-也是-go-的-“while”"><a href="#for-也是-go-的-“while”" class="headerlink" title="for 也是 go 的 “while”"></a><a href="https://tour.golang.org/flowcontrol/3">for 也是 go 的 “while”</a></h4><p>可以去掉分号，在 <code>for</code>  与 <code>&#123;</code> 只写条件语句。<br>C 的 while 在 Go 中也叫做 <code>for</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> s &lt;= <span class="number">1000</span> &#123;</span><br><span class="line">s += s</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1024</span><br></pre></td></tr></table></figure><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a><a href="https://tour.golang.org/flowcontrol/4">无限循环</a></h4><p>如果省略循环条件，<code>for</code> 与 <code>&#123;</code> 间什么都不写，该循环就不会结束，因此无限循环可以写得很紧凑。<br>（没有条件的 for 同 for true 一样。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)  <span class="comment">// 暂停100毫米</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">...     &#x2F;&#x2F; 省去部分输出</span><br><span class="line">^Csignal: interrupt     &#x2F;&#x2F; 键入了 control+C，以终止程序</span><br></pre></td></tr></table></figure><h3 id="§-if"><a href="#§-if" class="headerlink" title="§ if"></a>§ <a href="https://tour.golang.org/flowcontrol/5">if</a></h3><p>Go 的 if 语句与 for 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.4142135623730951 2i</span><br></pre></td></tr></table></figure><h4 id="if-的简短语句"><a href="#if-的简短语句" class="headerlink" title="if 的简短语句"></a><a href="https://tour.golang.org/flowcontrol/6">if 的简短语句</a></h4><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p><p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p><p>（在最后的 <code>return</code> 语句处使用 <code>v</code> 看看。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 20</span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><a href="https://tour.golang.org/flowcontrol/7">if-else</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里开始就不能使用 v 了</span></span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">27 &gt;&#x3D; 20</span><br><span class="line">9 20</span><br></pre></td></tr></table></figure><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p><p>（在 <code>main</code> 的 <code>fmt.Println</code> 调用开始前，两次对 <code>pow</code> 的调用均已执行并返回其各自的结果。）</p><h3 id="§-switch"><a href="#§-switch" class="headerlink" title="§ switch"></a>§ <a href="https://tour.golang.org/flowcontrol/9">switch</a></h3><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p><p>Go 的 <code>switch</code> 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 <code>case</code>，而非之后所有的 <code>case</code>。 实际上，Go 自动提供了在这些语言中每个 <code>case</code> 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 <code>switch</code> 的 <code>case</code> 无需为常量，且取值不必为整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go runs on OS X.</span><br></pre></td></tr></table></figure><h4 id="switch-的求值顺序"><a href="#switch-的求值顺序" class="headerlink" title="switch 的求值顺序"></a><a href="https://tour.golang.org/flowcontrol/10">switch 的求值顺序</a></h4><p><code>switch</code> 的 <code>case</code> 语句从上到下顺次执行，直到匹配成功时停止。</p><p>（例如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> f():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 i==0 时 f 不会被调用。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;When&#x27;s Saturday?&quot;</span>)</span><br><span class="line">today := time.Now().Weekday()</span><br><span class="line"><span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Today.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tomorrow.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;In two days.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Too far away.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When&#39;s Saturday?</span><br><span class="line">Tomorrow.</span><br></pre></td></tr></table></figure><h4 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a><a href="https://tour.golang.org/flowcontrol/11">没有条件的 switch</a></h4><p>没有条件的 <code>switch</code> 同 <code>switch true</code> 一样。</p><p>这种形式能将一长串 <code>if-then-else</code> 写得更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Good evening.</span><br></pre></td></tr></table></figure><h3 id="§-defer"><a href="#§-defer" class="headerlink" title="§ defer"></a>§ <a href="https://tour.golang.org/flowcontrol/12">defer</a></h3><p><code>defer</code> 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值（闭包?🤔️），但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a><a href="https://tour.golang.org/flowcontrol/13">defer 栈</a></h4><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照<strong>后进先出</strong>的顺序调用。</p><p>更多关于 <code>defer</code> 语句的信息，<a href="https://blog.golang.org/defer-panic-and-recover">参考阅读此文</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">counting...</span><br><span class="line">done.</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-包、变量和函数</title>
      <link href="/2019/08/31/Golang/go-1-PackageVarFunc/"/>
      <url>/2019/08/31/Golang/go-1-PackageVarFunc/</url>
      
        <content type="html"><![CDATA[<h2 id="包、变量和函数"><a href="#包、变量和函数" class="headerlink" title="包、变量和函数"></a>包、变量和函数</h2><h3 id="§-包"><a href="#§-包" class="headerlink" title="§ 包"></a>§ <a href="https://tour.golang.org/basics/1">包</a></h3><p>每个 Go 程序都是由包构成的。</p><p>一般程序从 <code>main</code> 包的 <code>main</code> 函数开始运行，除非有 <code>init</code> 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;This is a rand int:&quot;</span>, rand.Intn(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a rand int: 1</span><br></pre></td></tr></table></figure><p>本程序通过导入路径 <code>&quot;fmt&quot;</code> 和 <code>&quot;math/rand&quot;</code> 来使用这两个包。</p><p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code> 包中的源码均以 <code>package rand</code> 语句开始。</p><p><em>注意：</em> 若此程序的运行环境是固定的，<code>rand.Intn</code> 将总是会返回相同的数字。</p><p>（要得到不同的数字，需为生成器提供不同的种子数（使用 <a href="https://golang.org/pkg/math/rand/#Seed"><code>rand.Seed</code></a>）。 常用时间的值作为种子数。）</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a><a href="https://tour.golang.org/basics/2">导入</a></h4><p>正如我们在之前的代码中看见的，我们使用 <code>import</code> 语句来导入包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;8&#x27;s sqrt is %g.\n&quot;</span>, math.Sqrt(<span class="number">8</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a rand int: 1</span><br></pre></td></tr></table></figure><p>此代码用圆括号组合了导入，这是“分组”形式的导入语句。</p><p>当然你也可以编写多个导入语句，例如：</p><p><code>import &quot;fmt&quot;</code><br><code>import &quot;math&quot;</code></p><p>不过使用分组导入语句是更好的形式。</p><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a><a href="https://tour.golang.org/basics/3">导出名</a></h4><p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，<code>Pizza</code> 就是个已导出名，<code>Pi</code> 也同样，它导出自 <code>math</code> 包。</p><p>pizza 和 pi 并未以大写字母开头，所以它们是未导出的。</p><p>在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码，可以观察到错误输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.&#x2F;src.go:9:14: cannot refer to unexported name math.pi</span><br><span class="line">.&#x2F;src.go:9:14: undefined: math.pi</span><br></pre></td></tr></table></figure><p>然后将 <code>math.pi</code> 改名为 <code>math.Pi</code> 再试着执行一次，就可以得到预想的输出了：</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure><h3 id="§-函数"><a href="#§-函数" class="headerlink" title="§ 函数"></a>§ <a href="https://tour.golang.org/basics/4">函数</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">12</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><p>函数可以没有参数或接受多个参数。</p><p>在本例中，<code>add</code> 接受两个 <code>int</code> 类型的参数。</p><p>注意类型在变量名<strong>之后</strong>。</p><p>（参考 <a href="http://blog.golang.org/gos-declaration-syntax">这篇关于 Go 语法声明的文章</a> 了解这种类型声明形式出现的原因。）</p><h4 id="函数（续）"><a href="#函数（续）" class="headerlink" title="函数（续）"></a><a href="https://tour.golang.org/basics/5">函数（续）</a></h4><p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>在本例中，</p><p><code>x int, y int</code></p><p>被缩写为</p><p><code>x, y int</code></p><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a><a href="https://tour.golang.org/basics/6">多值返回</a></h4><p>函数可以返回<strong>任意数量</strong>的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := swap(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World Hello</span><br></pre></td></tr></table></figure><p>swap 函数返回了两个字符串。</p><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a><a href="https://tour.golang.org/basics/7">命名返回值</a></h4><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p><p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p><p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 直接 返回。</p><p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 10</span><br></pre></td></tr></table></figure><h3 id="§-变量"><a href="#§-变量" class="headerlink" title="§ 变量"></a>§ <a href="https://tour.golang.org/basics/8">变量</a></h3><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> y, n <span class="keyword">bool</span></span><br><span class="line">fmt.Println(i, j, y, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 false false</span><br></pre></td></tr></table></figure><p>就像在这个例子中看到的一样，<code>var</code> 语句可以出现在包或函数级别。</p><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a><a href="https://tour.golang.org/basics/9">变量的初始化</a></h4><p>变量声明可以包含初始值，每个变量对应一个。</p><p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> y, n, a, b = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span></span><br><span class="line">fmt.Println(i, j, y, n, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 true false Hello 3.14</span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a><a href="https://tour.golang.org/basics/10">短变量声明</a></h4><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p><p>函数外的每个语句都必须以关键字开始（var, func 等等），因此 <code>:=</code> 结构不能在函数外使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">100</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a><a href="https://tour.golang.org/basics/11">基本类型</a></h4><p>Go 的基本类型有:</p><table><thead><tr><th>类型</th><th>描述</th><th>说明</th><th>衍生</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔型</td><td><code>true</code> or <code>false</code></td><td></td></tr><tr><td><code>string</code></td><td>字符串</td><td>一串固定长度的字符连接起来的字符序列，使用 UTF-8 编码标识 Unicode 文本。</td><td></td></tr><tr><td><code>int</code></td><td>整型</td><td>32位机上为32位，64位机上是64位</td><td>指定大小的整型: int8  <code>int16</code>  <code>int32</code>  <code>int64</code></td></tr><tr><td><code>uint</code></td><td>无符号整型</td><td></td><td><code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code></td></tr><tr><td><code>float32</code>、<code>float64</code></td><td>浮点型</td><td></td><td></td></tr><tr><td><code>complex64</code>、<code>complex128</code></td><td>复数</td><td>复数的字面值常量写作<code>1+2i</code></td><td></td></tr><tr><td><code>byte</code></td><td></td><td>uint8 的别名</td><td></td></tr><tr><td><code>rune</code></td><td>表示一个 Unicode 码点</td><td>int32 的别名</td><td></td></tr></tbody></table><p>下例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/cmplx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T\t\tValue: %v\n&quot;</span>, ToBe, ToBe)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T\t\tValue: %v\n&quot;</span>, MaxInt, MaxInt)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T\tValus: %v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type: boolValue: false</span><br><span class="line">Type: uint64Value: 18446744073709551615</span><br><span class="line">Type: complex128Valus: (2+3i)</span><br></pre></td></tr></table></figure><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a><a href="https://tour.golang.org/basics/12">零值</a></h4><p>没有明确初始值的变量声明会被赋予它们的 <em>零值</em>。</p><p>零值是：</p><p>数值类型为 <code>0</code>，<br>布尔类型为 <code>false</code>，<br>字符串为 <code>&quot;&quot;</code>（空字符串）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">complex128</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v %v %v %q\n&quot;</span>, i, f, c, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 (0+0i) false &quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><a href="https://tour.golang.org/basics/13">类型转换</a></h4><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><p>一些关于数值的转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>或者，更加简单的形式(在函数中)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)</span><br><span class="line">u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换，否则会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = math.Sqrt(<span class="keyword">float64</span>(x*x + y*y))</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line">fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 5</span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a><a href="https://tour.golang.org/basics/14">类型推导</a></h4><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">j := <span class="number">1.1</span></span><br><span class="line">k := <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%T\t%T\n%v\t%v\t%v\n&quot;</span>, i, j, k, i, j, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intfloat64complex128</span><br><span class="line">11.1(1+2i)</span><br></pre></td></tr></table></figure><p>当右值声明了类型时，新变量的类型与其相同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j := i <span class="comment">// j 也是一个 int</span></span><br></pre></td></tr></table></figure><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>           <span class="comment">// int</span></span><br><span class="line">f := <span class="number">3.142</span>        <span class="comment">// float64</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a><a href="https://tour.golang.org/basics/15">常量</a></h4><p>常量的声明与变量类似，只不过是使用 <strong><code>const</code></strong> 关键字替换 <code>var</code>。</p><p>常量可以是字符、字符串、布尔值或数值。</p><p>常量不能用 <code>:=</code> 语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> NAME = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello,&quot;</span>, NAME)</span><br><span class="line">fmt.Println(PI)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a><a href="https://tour.golang.org/basics/16">数值常量</a></h4><p>数值常量是高精度的<strong>值</strong>。</p><p>一个未指定类型的常量由上下文来决定其类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(needInt(Small))</span><br><span class="line">fmt.Println(needFloat(Small))</span><br><span class="line">fmt.Println(needFloat(Big))</span><br><span class="line"><span class="comment">// fmt.Println(needInt(Big))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">21</span><br><span class="line">0.2</span><br><span class="line">1.2676506002282295e+29</span><br></pre></td></tr></table></figure><p>尝试一下输出 <code>needInt(Big)</code> 将会报错（溢出）。</p><p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-Go语言基础</title>
      <link href="/2019/08/31/Golang/go-0-begining/"/>
      <url>/2019/08/31/Golang/go-0-begining/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-语言基础"><a href="#Go-语言基础" class="headerlink" title="Go 语言基础"></a>Go 语言基础</h1><h2 id="Go-语言简介（无用的废话-）"><a href="#Go-语言简介（无用的废话-）" class="headerlink" title="Go 语言简介（无用的废话 =_=）"></a>Go 语言简介（无用的废话 =_=）</h2><blockquote><p>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</p></blockquote><p>我使用 Go 的几个原因：</p><ul><li>快速</li><li>简洁</li><li>严格规范</li><li>方便的网络编程</li><li>方便的多线程</li><li>完备的文档</li><li>开源</li><li><del>大多数朋友都不会呀</del></li></ul><p>使用 Go 已经有一段时间了，它给我的几个感觉就是：</p><ul><li>要求严格（不能声明不使用的变量，变量类型必须显示转化等）</li><li>超方便的多线程！</li><li>高效（时间、空间消耗都不大哦）</li></ul><p>借用一句前辈的话，Golang 就是互联网时代的 C！由于本人幼年时期对 C 十分热爱（后来生活所迫更多是在用OO的语言），所以对 Go 的印象也很好。</p><h2 id="编译、运行Go程序"><a href="#编译、运行Go程序" class="headerlink" title="编译、运行Go程序"></a>编译、运行Go程序</h2><ol><li><strong>创建目录</strong>：<br>新建一个目录，这个目录的名称应与需要建立的Go项目名称相同（最后生成的可执行文件将以这个“项目根目录”为文件名）； </li><li><strong>创建源文件</strong>：<br>进入该目录，创建名为 <code>*.go</code> 的Go源文件，并写入代码；</li><li><strong>格式化代码</strong>：<br>工作目录不变，执行命令 <code>go fmt</code>，可以自动格式化代码；</li><li><strong>编译运行</strong>：<br><code>go run &lt;src.go&gt;</code>命令会将编译参数中的命令源码文件，并把编译后的可执行文件存放到临时工作目录中，然后运行该临时可执行文件；</li><li><strong>编译</strong>：<br>工作目录不变，执行命令：<code>go bulid</code>，若编译通过，目录中将出现一个与目录同名的可执行文件；</li><li><strong>运行</strong>：<br>执行生成的可执行文件即可。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir test_go</span><br><span class="line">$ cd test_go&#x2F;</span><br><span class="line">$ vim test.go</span><br><span class="line">$ go run test.go</span><br><span class="line">Hello, world!</span><br><span class="line">$ go build</span><br><span class="line">$ ls</span><br><span class="line">test.go test_go</span><br><span class="line">$ .&#x2F;test_go </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>这里的 test.go 中我们写了一个经典的 <code>Hello World</code> 程序，它的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hello, world!\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单变量线性回归</title>
      <link href="/2019/08/18/AndrewNgML/AndrewNg-MachineLearning-1-LinearRegressionWithOneVariable/"/>
      <url>/2019/08/18/AndrewNgML/AndrewNg-MachineLearning-1-LinearRegressionWithOneVariable/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-1-Linear-Regression-with-One-Variable"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-1-Linear-Regression-with-One-Variable" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (1) Linear Regression with One Variable"></a>Notes of Andrew Ng’s Machine Learning —— (1) Linear Regression with One Variable</h1><h2 id="Model-Representation"><a href="#Model-Representation" class="headerlink" title="Model Representation"></a>Model Representation</h2><h3 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h3><ul><li><a href="http://clownote.github.io/about/index.html#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">$x^{(i)}$</a> denote the <em>input</em> variables, called <strong>input features</strong></li><li>$y^{(i)}$ denote the <em>output</em> variables, called <strong>target variable</strong></li><li>$(x^{(i)}, y^{(i)})$ is called a <strong>training example</strong></li><li>$(x^{(i)}, y^{(i)}); i=1, …, m$ —— is called a <strong>training set</strong></li></ul><p>⚠️【Note】The superscript “$^{(i)}$” in the notations is simply an <strong>index</strong> into the train set.</p><ul><li>$X$ denote the <strong>space</strong> of <em>input values</em></li><li>$Y$ denote the <strong>space</strong> of <em>output values</em></li></ul><p>In many examples, $X = Y =\R$.</p><h3 id="A-more-formal-description-of-supervised-learning"><a href="#A-more-formal-description-of-supervised-learning" class="headerlink" title="A more formal description of supervised learning"></a>A more formal description of supervised learning</h3><p>Given a training set, to learn a <strong>function</strong> $h: X \to Y$ so that $h(x)$ is a “good” predictor for the corresponding value of $y$.</p><p>For historical reasons, this function $h$ is called a <strong><code>hypothesis</code></strong>.</p><p>Pictorially:</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g652fmlvx6j30az078glq.jpg" alt="page1image20344816.png"> </p><p>With our new notations, the categories of supervised learning problems can be this:</p><ul><li><code>regression problem</code>: when the <strong>target variable</strong> is continuous.</li><li><code>classification problem</code>: $y$ can take on only a small number of discrete values</li></ul><h3 id="Hypothesis-amp-Model-Regression"><a href="#Hypothesis-amp-Model-Regression" class="headerlink" title="Hypothesis &amp; Model Regression"></a>Hypothesis &amp; Model Regression</h3><p>To represent the hypothesis $h$, for example, if we want to fit a data set like this:</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g65bp99j97j307o05gq2z.jpg" alt="image-20190819214710193"></p><p>Simply, we may make the $h_\theta(x)=\theta_0+\theta_1x$. This is means that we are going to predict that $y$ is a linear function of $x$. </p><p>Plotting this in the picture, it will be something like this:</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g65byqwhjxj307o05gwee.jpg" alt="006tNc79gy1g65bp99j97j307o05gq2z"></p><p>And what this function is doing is predicting that $y$ is some straight line function of $x$.</p><p>In this case, this <strong>model</strong> is called <strong><code>linear regression with one variable</code></strong>(or <code>Univariate linear regression</code>).</p><p>P.S. we can also fit a more complicated (perhaps non-linear) functions, but this linear case is the simplest.</p><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>Well, now we have got this:</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g65cm1aucyj30js0a60v0.jpg" alt="image-20190819221840291"></p><p>To get a “good” hypothesis function, we need to choose $\theta_0$, $\theta_1$ so that $h_\theta(x)$ is close to $y$ for our training exmaples $(x, y)$.  A cost function is of great help with this goal.</p><h3 id="Cost-function"><a href="#Cost-function" class="headerlink" title="Cost function"></a>Cost function</h3><p>A <strong><code>cost function</code></strong> can help us to measure the accuracy of our hypothesis function.</p><p>This takes an <strong>average difference</strong> of all the results of the hypothesis with inputs from x’s and the actual output y’s:<br>$$<br>J(\theta_0, \theta_1) = \frac{1}{2m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]^2 \tag{1}<br>$$<br>The function $(1)$ is our <em>cost function</em> exactly. Take a look at it:</p><ul><li><p>$h_\theta(x^{(i)})-y^{(i)}$ shows the difference between the predicted value and the actual value.</p></li><li><p>$\frac{1}{m}\sum^{m}_{i=1}…$ offers the mean of the squares of $h_\theta(x^{(i)})-y^{(i)}$</p></li><li><p>The mean is halved ($\frac{1}{2}$) as a convenience for the computati::on of the <strong>gradient descent</strong>, as the $\frac{1}{2}f^2 = f$.</p></li></ul><p>P.S. This function is otherwise called the “<em>Squared error function</em>“, or “<em>Mean squared error</em>“.</p><h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><p>To make $h_\theta(x)$ closing to $y$, we are just expected to minimize our cost function by adjusting the value of $\theta_0$, $\theta_1$.</p><p>We describe this <strong>goal</strong> like this:<br>$$<br>\mathop{minimize}\limits_{\theta_0, \theta_1} J(\theta_0, \theta_1) \tag{2}<br>$$<br>Or, more directly:<br>$$<br>\mathop{minimize}\limits_{\theta_0, \theta_1}<br>\frac{1}{2m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]^2<br>\tag{3}<br>$$</p><p>And if we are working with a linear regression with one variable, the $h_\theta(x)=\theta_0+\theta_1x$.</p><p>⚠️【Note】Hypothesis Function &amp; Cost Function</p><ul><li>$h_\theta(x)$ for fixed $\theta_i$, is a function of $x$.</li><li>$J(\theta_0, \theta_1)$ is a function of the parameter $\theta_i$ .</li></ul><h2 id="Cost-Function-Intuition-I"><a href="#Cost-Function-Intuition-I" class="headerlink" title="Cost Function - Intuition I"></a>Cost Function - Intuition I</h2><p>Let’s draw some pictures for better understanding of what the values of the cost function.</p><p>To getting start, we are going to work with a simplified hypothesis function:</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g65ddr26d9j30ja0a4778.jpg" alt="屏幕快照 2019-08-19 22.44.10"></p><p>Our training data set is scattered on the x-y plane. We are trying to make a straight line (defined by $h_\theta(x)$) which passes through these scattered data points.</p><p>Our objective is to get the best possible line. The best possible line will be such:</p><blockquote><p>So that the <em>average squared vertical distances of the scattered points from the line</em> ($\frac{1}{m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]^2$) will be the least.</p></blockquote><p>Ideally, the line should pass through all the points of our training data set. In such a case, the value of cost function $J(\theta_0, \theta_1)$ will be <code>0</code>. </p><p>E.g. A ideal situation where $J=0$:</p><p>Let this be our training set: Only three points <code>(1, 1)</code>, <code>(2, 2)</code> &amp; <code>(3, 3)</code></p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g65dnu9hj7j309606iwen.jpg" alt="屏幕快照 2019-08-19 22.54.07"></p><p>Now, we try setting $\theta_1$ to different values: <code>-0.5</code>,  <code>0</code>, <code>0.5</code>, <code>1</code>, <code>1.5</code>……</p><p>When $\theta_1=1$, we get a slope of 1 which goes through every single data point in our model. Conversely, when $\theta_1=0.5$, we see the vertical distance from our fit to the data points increase:</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g65ejfyhsbj30rs08cmzd.jpg" alt="新建项目"></p><p>By doing this, we got a series of graph of $h_\theta(x)$ in x-y plane as well as yield to the following $\theta_1$-$J(\theta_1)$ graph:</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g65dzrkce0j30b209ydh6.jpg" alt="image-20190819230628708"></p><p>Thus as a goal, we should try to <strong>minimize the cost function</strong>. In this case, $\theta_1=1$ is our global minimum.</p><h2 id="Cost-Function-Intuition-II"><a href="#Cost-Function-Intuition-II" class="headerlink" title="Cost Function - Intuition II"></a>Cost Function - Intuition II</h2><p>Unlike before, this time, we won’t continue with the simplified hypothesis, we are going to keep both of parameters $\theta_0$ and $\theta_1$. So the hypithesis function will be $h_\theta(x)=\theta_0+\theta_1x$.</p><p>Here’s our problem formulation as usual:<br>$$<br>\begin{array}{rl}<br> \textrm{Hypothesis: } &amp; h_\theta(x)=\theta_0+\theta_1x\<br>  &amp; \<br> \textrm{Parameters: } &amp; \theta_0, \theta_1\<br>   &amp; \<br> \textrm{Cost Function: } &amp; J(\theta_0, \theta_1) = \frac{1}{2m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]^2\<br>   &amp; \<br> \textrm{Goal: } &amp; \mathop{minimize}\limits_{\theta_0, \theta_1} J(\theta_0, \theta_1)<br>\end{array}<br>$$<br>Same as last time, we want to unserstand the hypothesis $h$ and the cost function $J$ via a series of graph. However, we’d like to use a <em><code>contour plot</code></em> to describe our $J(\theta_0, \theta_1)$.</p><blockquote><p>A <em>contour plot</em> is a graph that contains many contour lines.</p><p>A <em>contour line</em> of a two variable function has a constant value at all points of the same line. </p></blockquote><p>An example:</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g673ule5evj30p40cqafx.jpg" alt="屏幕快照 2019-08-21 09.29.48"></p><p>Taking any color and going along the ‘circle’, one would expect to get the same value of the cost function. </p><p>To touch our optimization objective, we can try to setting the parameters $\theta_i$ to different values.</p><p>When $\theta_0 = 360$ and $\theta_1 = 0$, the value of $J(\theta_0, \theta_1)$ in the contour plot <strong>gets closer to the center thus reducing the cost function error</strong>. Now we get a result in a better fit of the data:</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g673vbnti4j30o20bggqp.jpg" alt="屏幕快照 2019-08-21 09.29.58"></p><p>Minimizing the cost function as much as possible and consequently, the result of $\theta_1$ and $\theta_0$ tend to be around 0.12 and 250 respectively. Plotting those values on our graph to the right seems to put our point in the center of the inner most ‘circle’.</p><p>Obviously, we dislike to write a software to just plot out a contour plot and then try to manually read off the numbers to reach our goal. We want <strong>an efficient algorithm for automatically finding the value of $\theta_0$ and $\theta_1$ that minimizes the cost function $J$</strong>. Actually, the <em>gradient descent</em> algorithm that we will talk about works great on this question.</p><h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h2><p>There is a algorithm called <strong>gradient descent</strong> for <strong>minimizing the cost function $J$</strong>. And we can use it not only in linear regression as it’s actually used all over the place in machine learning.</p><p>Let’s talk about gradient descent for minimizing some arbitrary function $J$. So here’s the problem setup:</p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g67fcs8k0mj30gs09gjsz.jpg" alt="image-20190821172439919"></p><p>We put $\theta_0$ on the <code>x</code> axis and $\theta_1$ on the <code>y</code> axis, with the <strong>cost function</strong> on the vertical <code>z</code> axis. The points on our graph will be the result of the cost function using our hypothesis with those specific theta parameters. The graph below depicts such a setup:</p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g67l1ajh02j30no0con68.jpg" alt="image-20190821204112216"></p><p>We will know that we have succeeded when our cost function is at the very bottom of the pits in our graph, i.e. when its value is the minimum. The red arrows show the minimum points in the graph.</p><p>Image that we are physically standing at a point on a hill, in gradient descent, what we’re going to do is to spin 360 degrees around and just look all around us, and ask, “If I were to take a little step in some direction, and I want to go down the hill as quickly as possible, what direction should I take?” then you take a step in that direction. Repeat doing this until you converge to a local minimum. Like the black line in the picture above shows.</p><p>Notice that if we choose different points to grandient descent, we may reach different local optimums.</p><p>Mathematically, this is the definition of the gradient descent algorithm:</p><blockquote><p><strong>Gradient Descent Algorithm</strong></p><p>repeat until convergence {</p><p>$\qquad\theta_j := \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_0, \theta_1)\qquad \textrm{(for } j=0 \textrm{ and } j=1 \textrm{)}$</p><p>}</p></blockquote><p>The $\alpha$ is a number that is called the <strong><code>learning rate</code></strong>. It basically controls how big a step we take downhill with gradient descent.</p><p>At each iteration $j$, one should simultaneously update the parameters θ1,θ2,…,θn. Updating a specific parameter prior to calculating another one on the <code>j(th)</code> iteration would yield to a wrong implementation:</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67magihpyj30wo0hu7iy.jpg" alt="屏幕快照 2019-08-21 21.24.15"></p><h2 id="Gradient-Descent-Intuition"><a href="#Gradient-Descent-Intuition" class="headerlink" title="Gradient Descent Intuition"></a>Gradient Descent Intuition</h2><p>Let’s explore the scenario where we used **one parameter $\theta_1$ ** and plotted its cost function to implement a gradient descent. Our formula for a single parameter was : Repeat until convergence:<br>$$<br>\theta_1:=\alpha\frac{d}{d\theta_1}J(\theta_1)<br>$$</p><p>Regardless of the slope’s sign for $\frac{d}{d\theta_1}J(\theta_1)$ eventually converges to its minimum value. </p><p>The following graph shows that when the slope is negative, the value of $\theta_1$ increases and when it is positive, the value of $\theta_1$ decreases:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6de48b49qj30i50af0ui.jpg" alt="image-20190826211520863"></p><p>On a side note, we should adjust our parameter $\alpha$ to ensure that the gradient descent algorithm converges in a reasonable time. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6de6eemuhj30im0astb9.jpg" alt="image-20190826211727240"></p><p>How does gradient descent converge with a fixed step size $\alpha$?<br>The intuition behind the convergence is that $\frac{d}{d\theta_1}J(\theta_1)$ approaches 0 as we approach the bottom of our convex function. At the minimum, the derivative will always be 0 and thus we get:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6de8nmhaoj30ia0a4why.jpg" alt="image-20190826211936126"></p><h2 id="Gradient-Descent-for-Linear-Regression"><a href="#Gradient-Descent-for-Linear-Regression" class="headerlink" title="Gradient Descent for Linear Regression"></a>Gradient Descent for Linear Regression</h2><p>Now, we have learnt the gradient descent, the linear regression model and the squared error cost function as well. This time, we are going to put together gradient descent with our cost function that will give us an algorithm for linear regression for fitting a straight line to our data.</p><p>This is what we worked out:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6dedxiq58j30ej052aay.jpg" alt="image-20190826212442071"></p><p>We are going to apply gradient descent algorithm to minimize our squared error cost function.</p><p>The key term is the derivative term:</p><p>$$<br>\frac{\partial}{\partial\theta_j}J(\theta_0, \theta_1) = \frac{\partial}{\partial\theta_j}\frac{1}{2m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]^2<br>=<br>\frac{\partial}{\partial\theta_j}\frac{1}{2m}\sum^m_{i=1}[\theta_0+\theta_1x^{(i)}-y^{(i)}]^2<br>$$</p><p>$$<br>\begin{array}{rl}<br>j=0: &amp; \frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)=\frac{1}{m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]\<br> &amp; \<br>j=1: &amp; \frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)=\frac{1}{m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}] \cdot x^{(i)}<br>\end{array}<br>$$</p><p>Plug them back into our gradient descent algorithm:</p><blockquote><p>repeat until convergence {</p><p>$\qquad\theta_0 := \theta_0 - \alpha\frac{1}{m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}]$</p><p>$\qquad\theta_1 := \theta_1 - \alpha\frac{1}{m}\sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}] \cdot x^{(i)}$</p><p>}</p></blockquote><p>Notice: update $\theta_0$ and $\theta_1$ simultaneously.</p><p>The point of all this is that if we start with a guess for our hypothesis and then repeatedly apply these gradient descent equations, our hypothesis will become more and more accurate. So, this is simply gradient descent on the original cost function J. </p><p>This method looks at every example in the entire training set on every step, and is called <strong>batch gradient descent</strong>. </p><p>Note that, while gradient descent can be susceptible to local minima in general, the optimization problem we have     posed here for linear regression has only one global, and no other local,optima; thus gradient descent always converges (assuming the learning rate α is not too large) to the global minimum. Indeed, J is a convex quadratic function. Here is an example of gradient descent as it is run to minimize a quadratic function.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6dhmaf0chj308q06qgml.jpg" alt="image-20190826231632514"></p><p>The ellipses shown above are the contours of a quadratic function. Also shown is the trajectory taken by gradient descent, which was initialized at (48,30). The x’s in the figure (joined by straight lines) mark the successive values of θ that gradient descent went through as itconverged to its minimum.</p><hr><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>A Wild Implement of Linear Regression with One Variable via Gradient Descent in Python Made by Myself:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># linregress.py</span></span><br><span class="line"><span class="comment"># Linear Regression with one variable via a Batch Gradient Descent</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Created by CDFMLR on 2019/8/28.</span></span><br><span class="line"><span class="comment"># Copyright © CDFMLR. All right reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegressionWithOneVariable</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # Linear regression with one variable</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt; Given a training set, to find a set of parameters (theta_0, theta_1) of hypothesis function `h(x) = theta_0 + theta_1 * x` via gradient descent so that h(x) is a &quot;good&quot; predictor for the corresponding value of y.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Properties</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        - `training_set`</span></span><br><span class="line"><span class="string">        - `theta`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Methods</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        - `regress`: to find a set of thetas to make hypothesis a &quot;good&quot; predictor</span></span><br><span class="line"><span class="string">        - `hypothesis`: to get a predicted value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ``python</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; model = LinearRegressionWithOneVariable([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; model.regress(verbose=True, epsilon=0.0001)</span></span><br><span class="line"><span class="string">    theta_0:        0.025486336182825836</span></span><br><span class="line"><span class="string">    theta_1:        0.9940305813471573</span></span><br><span class="line"><span class="string">    cost:           9.99815680487604e-05</span></span><br><span class="line"><span class="string">    hypothesis:     h(x) = 0.025486336182825836 + 0.9940305813471573*x</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; model.hypothesis(10)</span></span><br><span class="line"><span class="string">    9.9657921496544</span></span><br><span class="line"><span class="string">``</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, training_set</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        training_set: training set</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.training_set = training_set    <span class="comment"># [(x: int, y: int), ...]</span></span><br><span class="line">        self.theta = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hypothesis</span>(<span class="params">self, x, theta</span>):</span></span><br><span class="line">        <span class="keyword">return</span> theta[<span class="number">0</span>] + theta[<span class="number">1</span>] * x</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cost</span>(<span class="params">self, dataset, theta</span>):</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dataset:</span><br><span class="line">            s += (self._hypothesis(i[<span class="number">0</span>], theta) - i[<span class="number">1</span>]) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s / (<span class="number">2</span> * <span class="built_in">len</span>(dataset))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_gradient_descent</span>(<span class="params">self, dataset, starting_theta, learning_rate, epsilon, max_count=<span class="number">4294967296</span></span>):</span></span><br><span class="line">        theta = <span class="built_in">list</span>.copy(starting_theta)</span><br><span class="line">        last_theta = <span class="built_in">list</span>.copy(starting_theta)</span><br><span class="line">        cost = self._cost(dataset, theta)</span><br><span class="line">        last_cost = cost * <span class="number">2</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        epsilon = <span class="built_in">abs</span>(epsilon)</span><br><span class="line">        diff = epsilon + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (diff &gt; epsilon):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= max_count:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Failed in gradient descent: cannot convergence after &#123;mc&#125; iterations.&quot;</span>.<span class="built_in">format</span>(mc=max_count))</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                t_sum= <span class="built_in">sum</span>((self._hypothesis(i[<span class="number">0</span>], theta) - i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> dataset))</span><br><span class="line">                theta[<span class="number">0</span>] = theta[<span class="number">0</span>] - learning_rate * t_sum / <span class="built_in">len</span>(dataset)</span><br><span class="line">    </span><br><span class="line">                t_sum = <span class="built_in">sum</span>(</span><br><span class="line">                    ((self._hypothesis(i[<span class="number">0</span>], theta) - i[<span class="number">1</span>]) * i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> dataset)</span><br><span class="line">                    )</span><br><span class="line">                theta[<span class="number">1</span>] = theta[<span class="number">1</span>] - learning_rate * t_sum / <span class="built_in">len</span>(dataset)</span><br><span class="line">    </span><br><span class="line">                last_cost = cost</span><br><span class="line">                cost = self._cost(dataset, theta)</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>((math.isnan(x) <span class="keyword">or</span> math.isinf(x) <span class="keyword">for</span> x <span class="keyword">in</span> theta)) <span class="keyword">and</span> <span class="built_in">abs</span>(cost) &lt;= <span class="built_in">abs</span>(last_cost):</span><br><span class="line">                    diff = <span class="built_in">max</span>((<span class="built_in">abs</span>(last_theta[i] - theta[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theta))))</span><br><span class="line">                    last_theta = <span class="built_in">list</span>.copy(theta)</span><br><span class="line">                    learning_rate += learning_rate * <span class="number">4</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    theta = <span class="built_in">list</span>.copy(last_theta)</span><br><span class="line">                    learning_rate /= <span class="number">10</span></span><br><span class="line">                    <span class="keyword">if</span> (learning_rate == <span class="number">0</span>):</span><br><span class="line">                        learning_rate = self._get_learning_rate(self.training_set)</span><br><span class="line">    </span><br><span class="line">                <span class="comment"># print(&#x27;[DEBUG] (%s) theta: %s, diff=%s, learning_rate=%s, cost=%s&#x27; % (count, theta, diff, learning_rate, cost))</span></span><br><span class="line">            <span class="keyword">except</span> OverflowError:</span><br><span class="line">                theta = <span class="built_in">list</span>.copy(last_theta)</span><br><span class="line">                learning_rate /= <span class="number">10</span></span><br><span class="line">                <span class="keyword">if</span> (learning_rate == <span class="number">0</span>):</span><br><span class="line">                    learning_rate = self._get_learning_rate(self.training_set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theta, count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_learning_rate</span>(<span class="params">self, dataset</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / <span class="built_in">max</span>((i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> dataset))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regress</span>(<span class="params">self, epsilon=<span class="number">1</span>, learning_rate=<span class="number">0</span>, verbose=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        To find a set of thetas to make hypothesis a &quot;good&quot; predictor</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        Parms:</span></span><br><span class="line"><span class="string">            - epsilon: when the difference between new theta and last theta less then epsilon, finish regressing</span></span><br><span class="line"><span class="string">            - learning_rate: about the &quot;step length&quot; of gtadient descent. Too small will take a long time to regress, and too big will raise a Overflow error. `0` to allow the algorithm to select an appropriate value automatically.</span></span><br><span class="line"><span class="string">            - verbose: true to print the result of regression</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        init_theta = [random.random(), random.random()]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> learning_rate == <span class="number">0</span>:</span><br><span class="line">            learning_rate = self._get_learning_rate(self.training_set)</span><br><span class="line">        </span><br><span class="line">        self.theta, count = self._gradient_descent(self.training_set, init_theta, learning_rate, epsilon)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            print(<span class="string">&#x27;Gradient descent finished after &#123;count&#125; iterations:\ntheta_0:\t&#123;t0&#125;\ntheta_1:\t&#123;t1&#125;\ncost:\t\t&#123;cost&#125;\nhypothesis:\th(x) = &#123;t0&#125; + &#123;t1&#125;*x&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    count=count, t0=self.theta[<span class="number">0</span>], t1=self.theta[<span class="number">1</span>], cost=self._cost(self.training_set, self.theta)))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hypothesis</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        To get a predicted y value of giving x</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parms:</span></span><br><span class="line"><span class="string">            - x: x value of the point you want to predict</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self._hypothesis(x, self.theta)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    model = LinearRegressionWithOneVariable([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">5</span>), (<span class="number">6</span>, <span class="number">6</span>)])</span><br><span class="line">    model.regress(verbose=<span class="literal">True</span>, epsilon=<span class="number">0.0000000001</span>)</span><br><span class="line">    model.hypothesis(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习引入</title>
      <link href="/2019/08/18/AndrewNgML/AndrewNg-MachineLearning-0-Introduction/"/>
      <url>/2019/08/18/AndrewNgML/AndrewNg-MachineLearning-0-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Andrew-Ng’s-Machine-Learning-——-0-Introduction"><a href="#Notes-of-Andrew-Ng’s-Machine-Learning-——-0-Introduction" class="headerlink" title="Notes of Andrew Ng’s Machine Learning —— (0) Introduction"></a>Notes of Andrew Ng’s Machine Learning —— (0) Introduction</h1><h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h2><p>Machine Learning </p><ul><li>Grew out of work in AI</li><li>New capability for computers</li></ul><p>Examples:</p><ul><li><p>Database mining<br>Large datasets from growth of automation / web.<br>  E.g. Web click data, medical records, biology, engineering</p></li><li><p>Applications can’t program by hand.<br>  E.g. Autonomous helicopter, handwriting recognition, most of Natural Language Progressing (NLP), Computer Vision.</p></li><li><p>Self-customizing programs<br>  E.g. Amazon, Netflix product recommendations</p></li><li><p>Understanding human learning (brain, real AI)</p></li></ul><h2 id="What-is-machine-learning"><a href="#What-is-machine-learning" class="headerlink" title="What is machine learning"></a>What is machine learning</h2><h3 id="Machine-Learning-definition"><a href="#Machine-Learning-definition" class="headerlink" title="Machine Learning definition"></a>Machine Learning definition</h3><ul><li><em>Arthur Samuel (1959)</em> : Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.</li><li><em>Tom Mitchell (1998)</em>, <em>a more modern definition</em> : Well-posed Learning Problem: A computer program is said to learn from experience <code>E</code> with respect to some task <code>T</code> and some prformance measure <code>P</code>, if its performance on T, as measured by P, improves with experience E.</li></ul><p>Example:</p><ul><li><p>Playing checkers.</p><p><code>E</code> = the experience of playing many games of checkers<br><code>T</code> = the task of playing checkers.<br><code>P</code> = the probability that the program will win the next game.</p></li><li><p>Spam Filter</p><p><code>E</code> = Watching you label emails as spam or not spam<br><code>T</code> = Classifying emails as spam or not spam<br><code>P</code> = The number (or fraction) of emails correctly classified as spam / not spam.</p></li></ul><h3 id="Machine-Learning-algorithms"><a href="#Machine-Learning-algorithms" class="headerlink" title="Machine Learning algorithms"></a>Machine Learning algorithms</h3><ul><li>Supervised learning</li><li>Unsupervised learning</li></ul><p>Others: Reinforcement learning, recommender system</p><h2 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h2><p>In supervised learning, we are:</p><ul><li>given a data set</li><li>given “right answers” (already know what our correct output should look like)</li><li>having the idea that there is a relationship between the input and the output.</li></ul><h4 id="Categories-of-supervised-learning-problems"><a href="#Categories-of-supervised-learning-problems" class="headerlink" title="Categories of supervised learning problems"></a>Categories of supervised learning problems</h4><ol><li><p><code>Regression</code>: Predict continuous valued output</p><p>Trying to map input variables to some continuous function.</p><p><em>[To predict how much]</em></p><p>E.g.</p><ul><li>You have a large inventory of identical items. You want to predict how many of these items will sell over the next 3 months.</li><li>Given a picture of a person, we have to predict their age on the basis of the given picture</li></ul></li><li><p><code>Classification</code>: Discrete valued output (0/1 or 0/1/2/3…)</p><p>Trying to map input variables into discrete categories.</p><p><em>[To predict whether/which]</em></p><p>E.g.</p><ul><li>Given a patient with a tumor, we have to predict whether the tumor is malignant or benign.</li><li>You’d like software to examine individual customer accounts, and for each accout decide if it has been hacked/compromised.</li></ul></li></ol><h2 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h2><p>In unsupervised learning we can:</p><ul><li>approach problems with little or no idea what our results should look like</li><li>derive structure from data where we don’t necessarily know the effect of the variables.</li><li>derive this structure by <strong>clustering the data</strong> based on relationships among the variables in the data.</li></ul><p>With unsupervised learning there is <strong>no feedback based on the prediction results</strong>.</p><p>E.g.</p><ol><li><p><code>Clustering</code>: </p><ul><li><p>Google news looks for tens of thousands of news stories and automatically cluster them together. So, the news stories that are all about the same topic get displayed together.</p></li><li><p>Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.</p></li></ul></li><li><p><code>Non-clustering</code>:</p><p>The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party).</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> AndrewNg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub加Hexo打造个人博客</title>
      <link href="/2019/08/15/blog/GitHub%E5%8A%A0Hexo%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/08/15/blog/GitHub%E5%8A%A0Hexo%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Hexo-gt-个人博客"><a href="#GitHub-Hexo-gt-个人博客" class="headerlink" title="GitHub + Hexo =&gt; 个人博客"></a>GitHub + Hexo =&gt; 个人博客</h1><blockquote><p>打造一个个人博客其实很简单，我们不需要拥有一台服务器、甚至可以对 Web 开发不甚了解。</p></blockquote><p>这篇文章记录我如何在 Mac 上通过 <a href="https://github.com/">GitHub</a>、<a href="https://hexo.io/">Hexo</a> 打造一个<em>个人博客</em> —— <strong><a href="https://clownote.github.io/">clownote</a></strong></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我一直不喜欢 CSDN 和博客园等博客平台，但确实有写东西的习惯。写了东西就要发表，所以在之前，我把我学习计算机知识的笔记都放到了一个自己初学 Web 开发时搞的一个超级简陋的静态网站上。</p><p>但它实在是太简陋了导致使用起来<strong>巨</strong>麻烦，发布文章要手动把 markdown 写的文章用自己写的一个转换器渲染成 HTML，然后调用一个可以及时渲染代码颜色的 js 进去，然后 FTP 上传到服务器上，再到手动修改 <code>index.html</code>，加入这篇新文章的链接……</p><p>这完全不是正常人应该用的操作！</p><p>我一直在考虑写一个功能完整的、更方便的博客。计划是用 Flask 写后端，Vue 做前端，Git 来管理内容，然后再写一些 Apple Script、Bash Script 让这个博客系统方便在 Mac 中使用 。但最近一直忙其他项目，没时间来实现。现在我的服务器到期了，百度云的，感觉不太好用（主要是受对这家公司的某些其他产品的不良印象的影响），不续费了。</p><p>笔记急需迁出！写之前想的博客系统是来不及了，突然想起来很多人用一个叫 <code>Hexo</code> 的东西做博客，于是一番 Google、Bing。最终，我觉定用 <code>GitHub</code> + <code>Hexo</code> 快速（Less than One Day）打造一个<strong>不用服务器</strong>、<strong>不用写代码</strong>的博客。</p><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p><del>废话不多说，代码赶快写起来</del>，，，（哦，错了，咱们今天不用写代码！只是几个简单的命令 + 配置就好了😂）</p><p>废话不多说，建站走起！</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h4><p>首先，我们需要注册一个 <code>GitHub</code> 账户，我相信绝大多数的读者已经完成了这一步，所以不再赘述；如果您幸运的属于少数人，请打开 <a href="https://github.com/">GitHub</a>，即可按照感觉轻松完成。</p><h4 id="创建-GitHub-Pages"><a href="#创建-GitHub-Pages" class="headerlink" title="创建 GitHub Pages"></a>创建 GitHub Pages</h4><p>在您的 GitHub 中，<code>New</code> 一个 <code>Repository</code>，名字为 <code>&lt;userName&gt;.github.io</code>，其中的 <code>&lt;userName&gt;</code> 与您的 GitHub 用户名相同。</p><p>注意，在这个新建的 Repository 的 <code>Settings</code> 中，您应该可以找到，有关 <code>GitHub Pages</code> 的设置里写了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your site is published at https:&#x2F;&#x2F;&lt;userName&gt;.github.io</span><br></pre></td></tr></table></figure><p>这样就成了，否则请检查之前的步骤是否正确。</p><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>在安装 <code>Hexo</code> 前，需要确定电脑中是否已安装了：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (版本至少为 nodejs 6.9)</li><li><a href="http://git-scm.com/">Git</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node --version</span><br></pre></td></tr></table></figure><p>如果没有，要先安装他们。接下来只需要使用 <code>npm</code> 即可完成 Hexo 的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建您的博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>然后，可以看到指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>目录中的 <code>_config.yml</code> 是网站的配置信息，我们需要在此配置一些参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat _config.yml</span><br><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>需要配置的项目有：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言</td></tr><tr><td align="left"><code>url</code></td><td align="left">网址</td></tr><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr></tbody></table><p>需要说明的是，<code>deploy</code> 项的配置就可以把Hexo与GitHub关联起来，即将我们的博客<strong>推送</strong>到 GitHub，打开站点的配置文件_config.yml，<code>deploy</code> 项配置为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/&lt;userName&gt;/&lt;userName&gt;.github.io</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后，我们需要让 Hexo 连接上我们的 GitHub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>每一条命令的作用都很直观。操作完之后你就会发现你的博客已经上线了，可以在网络上被访问了！</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>如果你像我一样，觉得 <code>Hexo</code> 自带的 <code>landscape</code> 主题不太好看，我们可以跟换一个主题。</p><p>我们可以在 Hexo 官网上找到很丰富的 <a href="https://hexo.io/themes/">主题资源</a>，具体的使用方法主题项目的 README 里会写明，照着做就行。</p><p>这里以配置一个叫做 <a href="https://github.com/probberechts/hexo-theme-cactus"><code>cactus</code></a> 的主题为例：</p><ol><li>下载、安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;# hexo init 的目录</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;probberechts&#x2F;hexo-theme-cactus.git themes&#x2F;cactus# 拷贝一份主题</span><br></pre></td></tr></table></figure><ol start="2"><li>修改Hexo主题：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim .&#x2F;config.yml</span><br></pre></td></tr></table></figure><p>修改其中的 <code>theme</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># theme: landscape</span><br><span class="line">theme: cactus</span><br></pre></td></tr></table></figure><ol start="3"><li>主题配置</li></ol><p>在 <code>themes/cactus/_config.yml</code> 中按照自己的需要对主题进行配置。</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>其实到这里，我们的博客就已经构建完成了。接下来我们就可以用新建的博客系统写作了😊。</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p>可选的布局有：</p><table><thead><tr><th><code>layout</code></th><th>储存路径</th><th>功能</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td><td>存放要发布的博客文章</td></tr><tr><td><code>page</code></td><td><code>source</code></td><td>网站中的一些固定页面，比如说”关于”</td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td><td>草稿</td></tr></tbody></table><p><code>hexo new</code> 成功后，Hexo 会告诉你新建的文件路径，利用 markdown 编辑器打开它，就可以开始书写了，在我的 Mac 里，默认的 markdown 编辑器是 <code>Typora</code>，可以直接用 <code>open</code> 命令来用默认程序打开并编辑文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open ~&#x2F;&lt;blogFolder&gt;&#x2F;source&#x2F;_drafts&lt;title&gt;.md</span><br></pre></td></tr></table></figure><h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><p>我们在写文章时，可以先写草稿(draft)。草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><p>文章写好后，通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，在里面写 YAML 配置，用于指定个别文件的变量，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>以下是一些常用的参数：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left"></td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>keywords</code></td><td align="left">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td><td align="left"></td></tr></tbody></table><h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>对于大多数人来讲，对一篇文章分类和标签的设置是必不可少的。</p><p>分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：<strong>分类(<code>categories</code>)</strong> 具有<em>顺序性</em>和<em>层次性</em>，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而 <strong>标签(<code>tags</code>)</strong> 没有顺序和层次。</p><p>在 <code>Front-matter</code> 中，分类和标签的设置方法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure><p>在使用 <code>categories</code> 时，请注意：</p><p>Hexo不支持指定多个同级分类！下面的指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure><p>会使分类 <code>Life</code> 成为 <code>Diary</code> 的子分类，而不是 <em>并列分类</em>。因此，有必要为您的文章选择尽可能准确的分类。</p><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>在完成写作后，我们先保存编辑好的 markdown 文件，然后执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish post &lt;title&gt;.md# 如果新建时 layout 为 draft</span><br><span class="line"></span><br><span class="line">$ hexo deploy --generate# 生成文件完成后部署</span><br><span class="line"># 可以简写为 &#96;$ hexo d -g&#96;</span><br></pre></td></tr></table></figure><h4 id="操作总结"><a href="#操作总结" class="headerlink" title="操作总结"></a>操作总结</h4><p>现在，回顾一下我们用 Hexo 写作的过程:</p><ol><li><code>$ hexo new draft &lt;title&gt;</code></li><li><code>$ open ~/&lt;blogFolder&gt;/source/_drafts/&lt;title&gt;.md</code></li><li><code>在编辑器中填写Front-matter，并完成内容写作</code></li><li><code>$ hexo publish post &lt;title&gt;</code></li><li><code>$ hexo deploy --generate</code></li></ol><p>如果有能力，我们还可以写一个简单的小脚本来简化这些操作。很容易实现，在这里就不介绍了。</p><h3 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h3><p>现在，我们已经完成了博客系统的安装、建站并且学会了在其中写作。</p><p>当我们打开自己的博客网站时，会发现，我们的 <code>Cactus</code> 主题已经提供了诸如分享、导航的功能。</p><p>但或许我们还是觉得它有些太简陋了，我们可能还想让它有一些让用户体验更好的特性，比如，搜索、评论功能，现在我们尝试来实现它们。</p><p>其实，我们使用的 <code>Cactus</code> 主题中，已经包含了对搜索、评论的支持，直接使用即可。</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>安装 hexo 的搜索插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>创建一个新页面，用来承载搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page search</span><br></pre></td></tr></table></figure><p>在 Front-matter 里加上 <code>type: search</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Search</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">search</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>在 <code>themes/cactus/_config.yml</code> 里配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">/search/</span></span><br></pre></td></tr></table></figure><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p> <code>Cactus</code> 主题为我们提供的评论工具是 <code>Disqus</code>，这是一个各方面都很好的评论系统，但有一点问题是，这个评论系统<strong>在国内无法使用</strong>，所以我们只是简单翻译一下官方的介绍：</p><p>首先，在 Disqus 注册我们的站点: <a href="http://disqus.com/admin/create/">https://disqus.com/admin/create/</a>.</p><p>然后, 修改 <code>themes/cactus/_config.yml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enabled: true</span><br><span class="line">  shortname: SITENAME</span><br></pre></td></tr></table></figure><p>这里的 <code>SITENAME</code> 是在注册 Disqus 时，你给你的站点填写的名字。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，我们的博客网站建好了。由于我最迫切的需求就是快速的完成博客建站，所以多余的东西我都没有研究，但其实 Hexo 还可以有很多拓展，GitHub Pages 也还有一些东西可以配置，这些都需要大家自己去研究。</p><p>后期我还会持续优化这个网站，比如我计划修改一下源码，把 Cactus 中的 <code>Disqus</code> 评论换成墙内能用的如 <code>livere</code> 之类的东西 ，如果可以，我会另外发文记录。</p><p>其实，这篇文章中的绝大多数内容都来源于咱们使用的各个工具的官网，我只是粗糙地把他们按照一定的逻辑顺序排列到一起。如果需要更详细的说明，大家可以看下面列出的这些参考文档：</p><ul><li>GitHub的注册与使用：<a href="https://help.github.com/cn">https://help.github.com/cn</a></li><li>Hexo的安装及使用：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li><li>Cactus主题的配置：<a href="https://github.com/probberechts/hexo-theme-cactus">https://github.com/probberechts/hexo-theme-cactus</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构「图」的基础</title>
      <link href="/2019/05/07/Algorithm/Graph/"/>
      <url>/2019/05/07/Algorithm/Graph/</url>
      
        <content type="html"><![CDATA[<p>这（可能）是你能找到的最简单的讲图的文章。</p><blockquote><p>这篇文章是我以前学习「图」数据结构的时候写的。今天上课讲图，我翻了好久才翻到这个😂</p><p>注：文中代码均为伪代码，其语法比较类似于 Python + BASIC，你可以用你喜欢的任何语言去做具体实现。在最后，我会附上我的 Python 实现源码。</p></blockquote><h2 id="网络的表示"><a href="#网络的表示" class="headerlink" title="网络的表示"></a>网络的表示</h2><ol start="0"><li><p>邻接矩阵</p><p>（略，这个是数学，我不懂）</p></li><li><p>把链路作为引用储存在类里（连带其他数据）：</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Node</span><br><span class="line">String: name</span><br><span class="line">List&lt;Node&gt;: neighbors</span><br><span class="line">List&lt;Integer&gt;: costs</span><br><span class="line">End Node</span><br></pre></td></tr></table></figure><ol start="2"><li>链路和节点单独（更常用）：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Node:</span><br><span class="line">String: name</span><br><span class="line">List&lt;Link&gt;: links</span><br><span class="line">End Node</span><br><span class="line"></span><br><span class="line">Class Link:</span><br><span class="line">Integer: cost</span><br><span class="line">Node: nodes[2]// 无向</span><br><span class="line">/* Node: toNode// 有向 */</span><br><span class="line">ENd Link</span><br></pre></td></tr></table></figure><p>无向，链路包含两个 Node，顺序任意。</p><p>有向，只包含一个 Node，指向目标节点，也可以用两个，一个指向来源，另一个指向目标。</p><h2 id="网络的遍历"><a href="#网络的遍历" class="headerlink" title="网络的遍历"></a>网络的遍历</h2><h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><blockquote><p>在一次深度优先遍历中，算法首先访问一些离初始节点很远的节点，之后才是离初始节点较近的节点。</p></blockquote><p>直接像树一样遍历，在图中是不行的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">badTraverse():</span><br><span class="line">&lt;处理节点&gt;</span><br><span class="line">For Each link In links:</span><br><span class="line">link.nodes[1].Traverse()</span><br><span class="line">Next link</span><br><span class="line">End badTraverse</span><br></pre></td></tr></table></figure><p>如果图包含了回路，这个算法会死循环。</p><p>解决的方法是让算法知道自己访问过的节点，可以给类中加一个 <code>visited</code> 属性来纪录自己有没有被访问：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slowTraverse():</span><br><span class="line">&lt;处理节点&gt;</span><br><span class="line">Self.visited = True</span><br><span class="line"></span><br><span class="line">For Each link In links:</span><br><span class="line">If Not link.nodes[1].visited:</span><br><span class="line">link.nodes[1].Traverse()</span><br><span class="line">End If</span><br><span class="line">Next link</span><br><span class="line">End slowTraverse</span><br></pre></td></tr></table></figure><p>这个算法理论上可行，但消耗太大，容易爆栈。</p><p>要解决这个问题，可以用栈来替换递归：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">depthFirstTraverse(Node: startNode):</span><br><span class="line">// 访问当前节点</span><br><span class="line">startNode.visited = True</span><br><span class="line"></span><br><span class="line">// 创建栈，把初始节点压入栈</span><br><span class="line">Stack&lt;Node&gt;: stack</span><br><span class="line">stack.push(stareNode)</span><br><span class="line"></span><br><span class="line">// 循环处理直到栈为空</span><br><span class="line">While Not stack.isEmpty():</span><br><span class="line">Node node = stack.pop()// 从栈中获取下一节点</span><br><span class="line">// 循环处理节点中的链路</span><br><span class="line">For Each link In node.links:</span><br><span class="line">If Not link.nodes[1].visited:</span><br><span class="line">link.nodes[1].visited = True</span><br><span class="line">stack.push(link.node[1])</span><br><span class="line">End If</span><br><span class="line">Next link</span><br><span class="line">Loop// 继续处理直到栈为空</span><br><span class="line">End depthFirstTraverse</span><br></pre></td></tr></table></figure><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><blockquote><p>在一次广度优先遍历中，离初始节点较近的节点首先被访问，然后才是离初始节点较远的节点。</p></blockquote><p>在<strong>深度优先遍历</strong>中，由于使用<em>后进先出</em>的栈来存放节点，所以遍历了一些离初始节点较远的节点然后才遍历较近的节点。</p><p>如果使用<strong>队列</strong>（<em>Queues</em>，FIFO）代替<strong>栈</strong>（<em>Stacks</em>，FILO），则节点会按先进先出的顺序被处理，离初始节点较近的节点就首先被处理了，即<strong>广度优先遍历</strong>。</p><h3 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h3><h4 id="无向图连通性测试"><a href="#无向图连通性测试" class="headerlink" title="无向图连通性测试"></a>无向图连通性测试</h4><p>对于一个无向图，如果连通，一个遍历算法从初识节点出发，可达所有节点。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boolean: isConnected(Node: startNode):</span><br><span class="line">// 从初识节点开始遍历网络</span><br><span class="line">Traverse(start_node)</span><br><span class="line"></span><br><span class="line">// 查看有无没被访问的</span><br><span class="line">For Each node In &lt;所有节点&gt;</span><br><span class="line">If Not node.visited: Return False</span><br><span class="line">Next node</span><br><span class="line"></span><br><span class="line">// 所有节点都访问过了，连通</span><br><span class="line">Return True</span><br><span class="line">End isConnected</span><br></pre></td></tr></table></figure><h4 id="寻找所有连通分量"><a href="#寻找所有连通分量" class="headerlink" title="寻找所有连通分量"></a>寻找所有连通分量</h4><p>利用深度遍历，一直遍历直到所有连通的节点都已经访问过，就找到了所有连通分量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Node&gt;&gt;: getConnectedComponents:</span><br><span class="line">// 跟踪记录已经访问过的节点数</span><br><span class="line">Integer: numVisited = 0</span><br><span class="line">// 创建连通分量列表</span><br><span class="line">List&lt;Lidt&lt;Node&gt;&gt;: components</span><br><span class="line"></span><br><span class="line">// 循环直到所有节点都在连通分量中</span><br><span class="line">While numVisited &lt; 节点个数:</span><br><span class="line">// 查找一个还未访问过的节点</span><br><span class="line">Node: startNode = 第一个未访问过的节点</span><br><span class="line"></span><br><span class="line">// 将初始值压入栈</span><br><span class="line">Stack&lt;Node&gt;: stack</span><br><span class="line">stack.push(startNode)</span><br><span class="line">startNode.Visited = True</span><br><span class="line">numVisited += 1</span><br><span class="line"></span><br><span class="line">// 将节点添加到一个新的连通分量中</span><br><span class="line">List&lt;Node&gt;: component</span><br><span class="line">component.add(startNode)</span><br><span class="line">components.add(component)</span><br><span class="line"></span><br><span class="line">// 不断处理，直到它为空</span><br><span class="line">While Not stack.isEmpty():</span><br><span class="line">// 从栈中获取下一个节点</span><br><span class="line">Node: node = stack.pop()</span><br><span class="line"></span><br><span class="line">// 依次处理该节点所有对应的链路</span><br><span class="line">For Each link In node.links:</span><br><span class="line">If Not link.nodes[1].visited:</span><br><span class="line">link.nodes[1].visited = True</span><br><span class="line">component.add(link.nodes[1])</span><br><span class="line">stack.push(link.nodes[1])</span><br><span class="line">// 将链路标记为树的一部分，生成树</span><br><span class="line">link.visited = True</span><br><span class="line">numVisited += 1</span><br><span class="line">End If</span><br><span class="line">Next link</span><br><span class="line">Loop// Not stack.isEmpty()</span><br><span class="line">Loop// numVisited &lt; 节点个数</span><br><span class="line"></span><br><span class="line">Return components</span><br><span class="line">End getConnectedComponents</span><br></pre></td></tr></table></figure><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><p>如果一个无向图是连通的，就可以以一节点为根建立一棵树，表示根节点到网络中其他节点到路径。这颗树称为<strong>生成树</strong>。</p><p>要实现这一点，在前面的程序里标记新节点被访问后，将链路标记为树的一部分，就行了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link.visited = True</span><br></pre></td></tr></table></figure><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>具有最少可能代价的生成树称为<strong>最小生成树</strong>。</p><p>要得到一颗生成树，可以用如下贪心策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 添加根节点R以初始化生成树</span><br><span class="line">2. 对每个节点重复直到得到生成树：</span><br><span class="line">a. 发现在生成树中节点到未在树中节点到最小代价链接</span><br><span class="line">b. 将该链接到目标节点添加到生成树</span><br></pre></td></tr></table></figure><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>文中涉及的代码还是比较多的，我写了其中一些的 Python 实现，放到了 GitHub：</p><ul><li><a href="https://github.com/cdfmlr/Graph_Python">https://github.com/cdfmlr/Graph_Python</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO</title>
      <link href="/2019/04/25/Java_intro/Day14_Java_IO/"/>
      <url>/2019/04/25/Java_intro/Day14_Java_IO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><h2 id="处理外部数据"><a href="#处理外部数据" class="headerlink" title="处理外部数据"></a>处理外部数据</h2><p>在 Java 程序中使用的数据通常来自外部数据来源，比如数据库、通过套接字直接传输的字节或文件存储。大部分收集和处理外部数据的 Java 工具都包含在 <code>java.io</code> 包中。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在所有可用于 Java 应用程序的数据来源中，文件是最常见的，通常也是最方便的。如果想在 Java 应用程序中读取某个文件，必须使用将它的传入字节解析为 Java 语言类型的<em>流</em>。</p><p><code>java.io.File</code> 是一个在文件系统上定义资源并以某种抽象方式表示该资源的类。创建 <code>File</code> 对象很容易：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;temp.txt&quot;</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">&quot;/home/steve/testFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>File</code> 构造方法接受它创建的文件的路径。</p><p>可以将任何 <code>String</code> 传递到 <code>File</code> 的构造方法，只要它是操作系统中的有效路径，无论它引用的文件是否存在。</p><p>通常，我们都需要向新创建的 <code>File</code> 对象询问该文件是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">&quot;/home/steve/testFile.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (f2.exists()) &#123;</span><br><span class="line">  <span class="comment">// File exists. Process it...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// File doesn&#x27;t exist. Create it...</span></span><br><span class="line">  f2.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>利用 <code>java.io.File</code>，通过 File 对象，我们可以操作文件：</p><ul><li>文件是否存在：<code>FileObject.exists()</code></li><li>创建文件：<code>FileObject.createNewFile()</code></li><li>删除文件：<code>FileObject.delete</code></li></ul><p>还有很多操作，详见 <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/io/File.html">JDK 文档</a>。</p><h2 id="在-Java-I-O-中使用流"><a href="#在-Java-I-O-中使用流" class="headerlink" title="在 Java I/O 中使用流"></a>在 Java I/O 中使用流</h2><p>我们可以使用流来访问文件系统上的文件。</p><p>流允许程序从来源接收字节或将输出发送到目标。</p><p>在 <code>java.io</code> 包中包含多种风格的流，一些流可以处理所有类型的 16 位字符（<code>Reader</code> 和 <code>Writer</code> 类型）。其他流仅能处理 8 位字节（<code>InputStream</code> 和 <code>OutputStream</code> 类型）。</p><h3 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h3><p><img src="http://ww4.sinaimg.cn/large/006y8mN6gy1g673prk0haj30j30l7t9y.jpg" alt="iostream2xx"></p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><strong>字节流</strong>读（<code>InputStream</code> 和子类）和写（<code>OutputStream</code> 和子类）8 位字节。换句话说，可以将字节流视为一种更加原始的流类型。下面总结了两种常见的字节流和它们的用法：</p><ul><li><code>FileInputStream</code> / <code>FileOutputStream</code>：从文件读取字节，将字节写入文件 </li><li><code>ByteArrayInputStream</code> / <code>ByteArrayOutputStream</code>：从内存型中的数组读取字节，将字节写入内存中的数组</li></ul><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><strong>字符流</strong>读（<code>Reader</code> 和它的子类）和写（<code>Writer</code> 和它的子类）16 位字符。下面挑选了一些字符流和它们的用法：</p><ul><li><code>StringReader</code> / <code>StringWriter</code>：在内存中的 <code>String</code> 中读取和写入字符。 </li><li><code>InputStreamReader</code> / <code>InputStreamWriter</code>（和子类<code>FileReader</code> / <code>FileWriter</code>）：充当字节流和字符流之间的桥梁。<code>Reader</code> 从字节流读取字节并转换为字符。<code>Writer</code> 将字符转换为字节，以便将它们放在字节流上。 </li><li><code>BufferedReader</code> / <code>BufferedWriter</code>：在读取或写入另一个流时缓冲数据，使读写操作更高效。</li></ul><h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>Java 的控制台输入由 <code>System.in</code> 完成。</p><p>为了获得一个绑定到控制台的字符流，我们把 <code>System.in</code> 包装在一个 <code>BufferedReader</code> 对象中来创建一个字符流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </span><br><span class="line">                     InputStreamReader(System.in));</span><br></pre></td></tr></table></figure><p>BufferedReader 对象创建后，我们便可以使用 <code>read()</code> 方法从控制台读取一个字符，或者用 <code>readLine()</code> 方法读取一个字符串：</p><ul><li><code>int read() throws IOException</code> ：调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</li><li><code>String readLine() throws IOException</code> ：与 read() 类型，但读取一个字符串。</li></ul><p>实例（读取字符）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chrRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 用 System.in 创建 BufferedReader</span></span><br><span class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">  System.out.println(<span class="string">&quot;输入字符，到&#x27;q&#x27;退出：&quot;</span>);</span><br><span class="line">  <span class="comment">// 读取字符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> character = <span class="string">&#x27;\0&#x27;</span>; character != <span class="string">&#x27;q&#x27;</span>; ) &#123;</span><br><span class="line">    character = (<span class="keyword">char</span>) br.read();</span><br><span class="line">    System.out.println(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>😂有意思的是，</del>这对代码的作用和下面这 <strong>一行</strong>Python代码是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;\n&#x27;</span>.join([c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">input</span>(<span class="string">&quot;输入字符，到\&#x27;q\&#x27;退出：\n&quot;</span>).split(<span class="string">&#x27;q&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;q&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>实例（读取字符串）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">  System.out.println(<span class="string">&quot;Please enter lines of text, &#x27;end&#x27; to quit: &quot;</span>);</span><br><span class="line">  <span class="comment">// 读取字符串</span></span><br><span class="line">  <span class="keyword">for</span> (String line = <span class="string">&quot;\0&quot;</span>; !line.equals(<span class="string">&quot;end&quot;</span>); ) &#123;</span><br><span class="line">    line = (String) br.readLine();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scanner"><a href="#scanner" class="headerlink" title="scanner"></a>scanner</h4><p>其实，更容易地，我们也可以通过 <code>java.util.Scanner</code> 类来获取用户的输入。</p><h5 id="创建-scanner"><a href="#创建-scanner" class="headerlink" title="创建 scanner"></a>创建 scanner</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><h5 id="使用-scanner"><a href="#使用-scanner" class="headerlink" title="使用 scanner"></a>使用 scanner</h5><p>通过使用 <code>Scanner</code> 类的 <code>next()</code> 与 <code>nextLine()</code> 方法获取输入的字符串，在读取前我们一般需要 使用 <code>hasNext</code> 与 <code>hasNextLine</code> 判断是否还有输入的数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mine.java.tour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryScanner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println(&quot;Please enter something:&quot;);</span></span><br><span class="line"><span class="comment">for (String read = &quot;\0&quot;; scan.hasNext(); ) &#123;</span></span><br><span class="line"><span class="comment">read = scan.next();</span></span><br><span class="line"><span class="comment">System.out.println(read);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;Please enter some lines:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String read = <span class="string">&quot;\0&quot;</span>; scan.hasNextLine(); ) &#123;</span><br><span class="line">read = scan.nextLine();</span><br><span class="line">System.out.println(read);</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h6><ul><li><p><code>next()</code>:</p><ol><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 </li><li>next() 不能得到带有空格的字符串。</li></ol></li><li><p><code>nextLine()</code>： </p><ol><li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 </li><li>可以获得空白。</li></ol></li></ul><p>另外，如果要输入 <code>int</code> 或 <code>float</code> 类型的数据，在 <code>Scanner</code> 类中也有支持，但是在输入之前最好先使用 <code>hasNextXxx()</code> 方法进行验证，再使用 <code>nextXxx()</code> 来读取。</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p><code>FileInputStream</code> 用于从文件读取数据。</p><p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/home/steve/testFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>也可以使用一个文件对象来创建一个输入流对象来读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;/home/steve/testFile.txt&quot;</span>);</span><br><span class="line">InputStream out = <span class="keyword">new</span> FileInputStream(f);</span><br></pre></td></tr></table></figure><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public void close() throws IOException</code></td><td>关闭此文件输入流并释放与此流有关的所有系统资源。</td></tr><tr><td><code>protected void finalize()throws IOException</code></td><td>这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。</td></tr><tr><td><code>public int read(int r)throws IOException</code></td><td>从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td></tr><tr><td><code>public int read(byte[] r) throws IOException</code></td><td>从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td></tr><tr><td><code>public int available() throws IOException</code></td><td>返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td></tr></tbody></table><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>同样可以用路径字符串和文件对象来构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/home/steve/testFile.txt&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;/home/steve/testFile.txt&quot;</span>);</span><br><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</span><br></pre></td></tr></table></figure><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public void close() throws IOException</code></td><td>关闭此文件输入流并释放与此流有关的所有系统资源。</td></tr><tr><td><code>protected void finalize()throws IOException</code></td><td>这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。</td></tr><tr><td><code>public void write(int w)throws IOException</code></td><td>把指定的字节写到输出流中。</td></tr><tr><td><code>public void write(byte[] w)</code></td><td>把指定数组中w.length长度的字节写到OutputStream中。</td></tr></tbody></table><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mine.java.tour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStream</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger l = Logger.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 byte 以二进制的形式读写文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ioByByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">l.info(<span class="string">&quot;通过 byte 以二进制的形式读写文件:&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">OutputStream ostream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">InputStream istream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">byte</span> toBeWritten[] = &#123;<span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x46</span>, <span class="number">0x4d</span>, <span class="number">0x4c</span>, <span class="number">0x52</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : toBeWritten) &#123;</span><br><span class="line">ostream.write(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从文件中读取</span></span><br><span class="line"><span class="keyword">int</span> fileSize = istream.available();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileSize; i++) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>)istream.read());</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">l.severe(<span class="string">&quot;IOException: &quot;</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读写中文(Unicode)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ioUnicode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">l.info(<span class="string">&quot;读写中文(Unicode):&quot;</span>);</span><br><span class="line">File fileForIO = <span class="keyword">new</span> File(<span class="string">&quot;测试.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!fileForIO.exists()) &#123;</span><br><span class="line">fileForIO.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line">OutputStream ostream = <span class="keyword">new</span> FileOutputStream(fileForIO);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(ostream, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.append(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">writer.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">writer.append(<span class="string">&quot;English&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">l.severe(<span class="string">&quot;Fail to write: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (writer != <span class="keyword">null</span>) writer.close();</span><br><span class="line"><span class="keyword">if</span> (ostream != <span class="keyword">null</span>) ostream.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line">InputStream istream = <span class="keyword">new</span> FileInputStream(fileForIO);</span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(istream, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">sb.append((<span class="keyword">char</span>)reader.read());</span><br><span class="line">&#125;</span><br><span class="line">String result = sb.toString();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">l.severe(<span class="string">&quot;Fail to read: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (reader != <span class="keyword">null</span>) reader.close();</span><br><span class="line"><span class="keyword">if</span> (istream != <span class="keyword">null</span>) istream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ioByByte();</span><br><span class="line">ioUnicode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5月 03, 2019 8:31:07 下午 mine.java.tour.FileStream ioByByte</span><br><span class="line">信息: 通过 byte 以二进制的形式读写文件:</span><br><span class="line">CDFMLR</span><br><span class="line">5月 03, 2019 8:31:08 下午 mine.java.tour.FileStream ioUnicode</span><br><span class="line">信息: 读写中文(Unicode):</span><br><span class="line">中文</span><br><span class="line">English</span><br></pre></td></tr></table></figure><p><del>😂讽刺的是，</del>它的作用和下面这段 Python 代码差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;CDFMLR&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;测试.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;中文\nEnglish&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;测试.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><hr><p>相关代码：</p><p><a href="./src/SystemIn.java">SystemIn.java</a></p><p><a href="./src/FileStream.java">FileStream.java</a></p><p><a href="./src/TryScanner.java">TryScanner.java</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-接口</title>
      <link href="/2019/04/24/Java_intro/Day13_Java_Interface/"/>
      <url>/2019/04/24/Java_intro/Day13_Java_Interface/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>根据设计，抽象方法指定一个<em>契约</em>（通过方法名、参数和返回类型）但未提供可重用的代码。当在抽象类的一个子类中实现行为的方式与另一个子类中不同时，抽象方法（在抽象类上定义）就会很有用。</p><p>当在应用程序中需要一组可分组到一起的常见行为（例如 <code>java.util.List</code>），但它们存在两个或多个实现时，可以考虑使用<em>接口</em> 定义该行为。</p><p><strong>接口</strong> 像是<strong>仅</strong>包含抽象方法的抽象类；它们<strong>仅</strong>定义契约，而不定义实现。</p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>接口声明看起来像类声明，但使用了 <code>interface</code> 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line">    <span class="function">returnType <span class="title">methodName</span><span class="params">(argumentList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中定义的方法没有方法主体。接口的实现者负责提供方法主体（与抽象方法一样）。</p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>要在类上定义一个接口，则需要<em>实现</em> 该接口，这意味着提供一个方法主体来进一步提供履行接口契约的行为。</p><p>可以使用 <code>implements</code> 关键字实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">BonusEligible</span>, <span class="title">StockOptionRecipient</span> </span>&#123;</span><br><span class="line">  <span class="comment">// And so on</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>implements</code> 操作类似 继承用的 extends，接口是使用 <code>implements</code> 关键字，二者不同的是，接口可以有好多个，但继承只能有一个。</p><p>然后，我们要在 implements 了接口的类里实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">StockOptionRecipient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processStockOptions</span> <span class="params">(<span class="keyword">int</span> numberOfOptions, BigDecimal price)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;I can&#x27;t believe I got &quot;</span> + number + <span class="string">&quot; options at $&quot;</span> +</span><br><span class="line">    price.toPlainString() + <span class="string">&quot;!&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现该接口时，需要提供该接口上的一个或多个方法的行为。注意实现的方法必须与接口中的匹配（名称、参数、返回值），还需要添加 <code>public</code> 访问修饰符。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-异常</title>
      <link href="/2019/04/23/Java_intro/Day12_Java_Exception/"/>
      <url>/2019/04/23/Java_intro/Day12_Java_Exception/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><blockquote><p>没有程序能够始终正常运行，Java 语言的设计者也知道这一点。Java 平台提供了内置机制来处理代码未准确地按计划运行的情形。</p></blockquote><p><strong>异常</strong> 是在程序执行期间发生的破坏正常的程序指令流的事件。</p><p><strong>异常处理</strong> 可以使用 <code>try</code> 和 <code>catch</code> 代码块（以及 <code>finally</code>）捕获错误。</p><h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><p>在 Java 中，异常的层次结构图如下：</p><p><img src="http://ww1.sinaimg.cn/large/006y8mN6gy1g673rbxe34j30i50b4dk9.jpg" alt="4970765-1437c4660dd95f3e"></p><ul><li><code>Throwable</code><ul><li><code>Error</code>    : 运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</li><li><code>Exception</code>    : 程序本身可以处理的异常<ul><li><code>IOException</code></li><li><code>RuntimeException</code><h3 id="异常分层结构"><a href="#异常分层结构" class="headerlink" title="异常分层结构"></a>异常分层结构</h3></li></ul></li></ul></li></ul><p>Java 语言包含一个完整的异常分层结构，它由许多类型的异常组成，这些异常划分为两大主要类别：</p><ul><li>**已检查的异常(<em>checked exceptions</em>)**：已由编译器检查（表示编译器确定它们已在您代码中的某处处理过）。一般而言，这些异常是 <code>java.lang.Exception</code> 的直接子类。</li><li><strong>未检查的异常</strong>（也称为<em>运行时异常</em>，<em>unchecked / runtime exceptions</em>）：未由编译器检查。这些是 <code>java.lang.RuntimeException</code> 的子类。</li></ul><h2 id="使用-try、catch-和-finally"><a href="#使用-try、catch-和-finally" class="headerlink" title="使用 try、catch 和 finally"></a>使用 <code>try</code>、<code>catch</code> 和 <code>finally</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Try to execute</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">  <span class="comment">// Catch exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Always executes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️【注意】<code>ExceptionType</code> 要换成具体的错误类型：如 <code>RuntimeException</code>、<code>IOException</code> 。</p><p><code>try</code>、<code>catch</code> 和 <code>finally</code> 代码块共同形成了一张捕获异常的网: </p><ul><li>首先，<code>try</code> 语句限定可能抛出异常的代码;</li><li>捕获的异常会放到 <code>catch</code> 代码块（或称 <em>异常处理函数</em>） 中。捕获到异常时，可以尝试优雅地进行恢复，也可以退出程序（或方法）;</li><li>在所有尝试和捕获都完成后，会继续执行 <code>finally</code> 代码块，无论是否发生了异常;</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mine.java.tour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Try-Catch-Finally&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Integer foo = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;foo: &quot;</span> + foo.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">l.severe(<span class="string">&quot;Caught exception: &quot;</span> + e);</span><br><span class="line">System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行这个程序会得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5月 02, 2019 11:57:04 上午 mine.java.tour.Exception main</span><br><span class="line">严重: Caught exception: java.lang.NullPointerException</span><br><span class="line">catch</span><br><span class="line">finally</span><br></pre></td></tr></table></figure><h3 id="多个-catch-代码块"><a href="#多个-catch-代码块" class="headerlink" title="多个 catch 代码块"></a>多个 <code>catch</code> 代码块</h3><p>可以拥有多个 <code>catch</code>代码块，但必须采用某种特定方式来搭建它们。</p><p>如果所有异常都是其他异常的子类，那么子类会按照 <code>catch</code> 代码块的顺序放在父类前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;IndexOutOfBoundsException: &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Caught IOException: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用一个-catch-捕获多个类型的错误"><a href="#用一个-catch-捕获多个类型的错误" class="headerlink" title="用一个 catch 捕获多个类型的错误"></a>用一个 <code>catch</code> 捕获多个类型的错误</h3><p>在 Java SE 7 以后，一个 <code>catch</code> 语句可以处理不止一个类型的异常。这个特性可以让我们避免一直写重复的代码，也让我们没有理由去catch一个过度宽泛的错误类型（例如，我们本来应该逐一处理各种不同的问题，但为了避免麻烦，直接 <code>catch(RuntimeException e)</code>）。</p><p>我们可以把 catch 的小括号里的单个 ExceptionType 替换为逐个列出需要这个语句块处理的错误类型，每个类型之间用 竖线（ <code>|</code> ）分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException|SQLException ex) &#123;</span><br><span class="line">    logger.log(ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注】在用一个 catch 捕获多个错误的时候，这个 catch 的参数会隐含地带上 <code>final</code> 属性。例如在上面的例子中，catch 的参数 ex 是一个 <code>final</code> 的变量，因此，不能在 catch 语句块里给它赋值！</p><h2 id="throws-和-throw"><a href="#throws-和-throw" class="headerlink" title="throws 和 throw"></a><code>throws</code> 和 <code>throw</code></h2><ul><li><code>throws</code> : 方法可能抛出异常的声明(用在声明方法时，表示该方法可能要抛出异常)。</li></ul><p>Checked exception 通过在声明一个方法时使用 <code>throws</code> 关键字加上一个可能的异常列表 来向编译器声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception1, Exception1, ... </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>throws Exception1, Exception1, ...</code>  只是告诉编译器这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些可能异常是该函数体产生的。</p><ul><li><code>throw</code> 是具体向外抛异常的动作，它抛出一个异常实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-with-resources-代码块"><a href="#try-with-resources-代码块" class="headerlink" title="try-with-resources 代码块"></a><code>try-with-resources</code> 代码块</h2><p>当我们在 try 中使用一些资源时，不论出错与否我们都应该在最后关闭它，所以可以在finally 中完成这个关闭操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLineFromFileWithFinallyBlock</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function">                                                     <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java SE 7 开始，还有一种更简单办法来解决问题，Java 可以自动关闭资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLineFromFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br =</span><br><span class="line">                   <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 try 后面加小括号，里面声明需要的资源，在结束异常检测后（在 try 代码块超出范围时），Java 将自动处理这个资源的关闭问题。</p><p>注意，这种自动关闭的资源必须实现 java.lang.AutoCloseable 接口；如果尝试在一个没有实现该接口的资源类上实现此语法，会出错。</p><hr><p>相关代码：</p><p><a href="./src/Exception.java">Exception.java</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-集合</title>
      <link href="/2019/04/22/Java_intro/Day11_Java_Collections/"/>
      <url>/2019/04/22/Java_intro/Day11_Java_Collections/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><blockquote><p>大多数真实应用程序都会处理像文件、变量、来自文件的记录或数据库结果集这样的集合。</p></blockquote><p>最常见的集合就是数组，我们之前已经单独讨论过它，现在我们主要研究其他的集合类型。</p><h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 <code>List</code></h2><p><code>List</code> 是一种有序集合，也称为<em>序列</em>。</p><p><code>List</code> 集合只能包含对象（不能包含像 <code>int</code> 这样的原语类型）。</p><p>要使用 List，我们需要先把它 import 到程序中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br></pre></td></tr></table></figure><p><code>List</code> 是一个接口，所以不能直接实例化它（即，不可以 <code>new List&lt;E&gt;</code> ！），要声明一个 <code>List</code> ，使用如下语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listOfStrings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listOfStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这样，我们声明了一个种比较常用的 List —— <code>ArrayList</code>。</p><blockquote><p>【注】</p><ol><li>要使用上面的代码，首先要 ：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure></li><li>我们将 <code>ArrayList</code> 对象赋给了一个 <code>List</code> 类型的变量。在 Java 编程中，可以将某种类型的变量赋给另一种类型，只要被赋值的变量是赋值变量所实现的超类或接口。</li></ol></blockquote><h3 id="正式类型"><a href="#正式类型" class="headerlink" title="正式类型"></a>正式类型</h3><p>前面的代码段中尖括号（ <code>&lt;&gt;</code>） 中的类型被称为<em>正式类型（formal type）</em>，即这个 List 是一个包含何种类型的集合。</p><p>如前例中正式类型为 <code>String</code>，这个<code>List</code> 仅能包含 <code>String</code> 实例。</p><p>如果把正式类型写为<code>&lt;Object&gt;</code>，就意味着可将任何实体放在该 <code>List</code> 中。</p><h3 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h3><ul><li>将实体放入  <code>List</code>  中<ul><li><code>add(E element)</code> 方法将元素 element 添加到 <code>List</code> 的末尾处。</li><li><code>add(int index, E e </code> 方法将元素 element 添加到 <code>List</code> 的索引为 <code>index</code> 处（<code>index &lt;= List.size()</code>）。</li></ul></li><li>询问  <code>List</code> 目前有多大<ul><li>要询问 <code>List</code> 有多大，可调用 <code>size()</code></li></ul></li><li>从  <code>List</code> 中获取实体<ul><li>要从 <code>List</code> 中<strong>检索</strong>某一项，可调用 <code>get()</code> 并向它传递想要的项的索引</li></ul></li><li>从  <code>List</code> 中删除实体<ul><li>要从 <code>List</code> 中<strong>删除</strong>某一项，可调用 <code>remove()</code> 并向它传递想要的项的索引</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="comment">// 声明 List</span></span><br><span class="line">List&lt;Integer&gt; listOfIntegers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">listOfIntegers.add(Integer.valueOf(<span class="number">238</span>));</span><br><span class="line">listOfIntegers.add(<span class="number">0</span>, Integer.valueOf(<span class="number">987</span>));</span><br><span class="line"><span class="comment">// 查看大小</span></span><br><span class="line">l.info(<span class="string">&quot;Current List size: &quot;</span> + listOfIntegers.size());</span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line">l.info(<span class="string">&quot;Item at index 0 is: &quot;</span> listOfIntegers.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">listOfIntegers.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>相关代码: <a href="./src/UsrList.java">UsrList.java</a></p><p>关于 List 的更多说明，详见 <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/List.html">JDK文档</a>。</p><h2 id="迭代变量-Iterable"><a href="#迭代变量-Iterable" class="headerlink" title="迭代变量 Iterable"></a>迭代变量 <code>Iterable</code></h2><p>如果一个集合实现了 <code>java.lang.Iterable</code>，那么该集合被称为<em>迭代变量集合</em>。</p><p> <code>Iterable</code> 可从一端开始，逐项地处理集合，直到处理完所有项。</p><p>它的使用形式就是在 循环 中提及过的 for-echo 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (objectType varName : collectionReference) &#123;</span><br><span class="line">    <span class="comment">// Start using objectType (via varName) right away...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>List</code> 扩展了 <code>java.util.Collection</code>（它实现 <code>Iterable</code>），所以可以使用简写语法来迭代任何 <code>List</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; listOfIntegers = obtainSomehow();</span><br><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : listOfIntegers) &#123;</span><br><span class="line">    l.info(<span class="string">&quot;Integer value is : &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现的效果和如下的 for 循环处理等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; listOfIntegers = obtainSomehow();</span><br><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> aa = <span class="number">0</span>; aa &lt; listOfIntegers.size(); aa++) &#123;</span><br><span class="line">    Integer I = listOfIntegers.get(aa);</span><br><span class="line">    l.info(<span class="string">&quot;Integer value is : &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集-Set"><a href="#集-Set" class="headerlink" title="集 Set"></a>集 <code>Set</code></h2><p><code>Set</code> 是一种没有重复元素的集合结构。它可保证其元素中的唯一性，但不关心元素的顺序。</p><p><code>List</code> 可包含同一个对象数百次，而 <code>Set</code> 仅可包含某个特定实例一次。</p><p><code>Set</code> 也仅可包含对象，不能直接包含内置类型。</p><p>与 <code>List</code> 一样，不能直接实例化 <code>Set</code> (不能 <code>new Set&lt;E&gt;()</code>) ，但可以用继承自 <code>Set</code> 的 <code>HashSet</code> 等来实现。</p><h4 id="操作-Set"><a href="#操作-Set" class="headerlink" title="操作 Set"></a>操作 <code>Set</code></h4><ul><li>增<ul><li><code>add(E e)</code></li></ul></li><li>删<ul><li><code>remove(Object o)</code></li></ul></li><li>获取大小<ul><li><code>size()</code></li></ul></li><li>获取实体<ul><li>使用在 “迭代变量 (<code>Iterable</code>)” 中介绍的 for-each 循环可以把元素从 <code>Set</code> 中取出来。但注意对象可能按照不同于添加它们的顺序打印被取出来。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrySet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Tset&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; setOfIntegers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">setOfIntegers.add(Integer.valueOf(<span class="number">12</span>));</span><br><span class="line">setOfIntegers.add(Integer.valueOf(<span class="number">20</span>));</span><br><span class="line">setOfIntegers.add(Integer.valueOf(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">setOfIntegers.add(Integer.valueOf(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">l.info(setOfIntegers.toString());</span><br><span class="line"></span><br><span class="line">setOfIntegers.remove(Integer.valueOf(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">l.info(<span class="string">&quot;&quot;</span> + setOfIntegers.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer i : setOfIntegers) &#123;</span><br><span class="line">i += <span class="number">100</span>;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">l.info(setOfIntegers.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">... TrySet main</span><br><span class="line">信息: [20, 5, 12]</span><br><span class="line">... TrySet main</span><br><span class="line">信息: 2</span><br><span class="line">105</span><br><span class="line">112</span><br><span class="line">... TrySet main</span><br><span class="line">信息: [5, 12]</span><br></pre></td></tr></table></figure><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 <code>Map</code></h2><p><code>Map</code> 是一种方便的集合构造，可以使用它将一个对象（<em>键</em>）与另一个对象（<em>值</em>）相关联。</p><p><code>Map</code> 的键必须是唯一的，而且可在以后用于检索值。</p><p>和 List、Set 一样，<code>Map</code> 集合仅可包含对象，且 <code>Map</code> 是一个接口，所以不能直接实例化它，我们常用 <code>HashMap</code> 来实现一个 <code>Map</code>。</p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li>添加元素：<code>put(K key, V value)</code></li><li>取出元素：<code>get(Object key)</code></li><li>删除元素：<code>remove (Object key, [Object value])</code></li><li>获取大小：<code>size()</code></li><li>获取一个 Key 的 <code>Set</code>：<code>keySet()</code>，可以利用这个方法，结合使用 Set 和 Map，实现遍历 <code>Map</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">Map&lt;String, Integer&gt; mapOfIntegers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">mapOfIntegers.put(<span class="string">&quot;168&quot;</span>, Integer.valueOf(<span class="number">168</span>));</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">Integer oneHundred68 = mapOfIntegers.get(<span class="string">&quot;168&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keys = mapOfIntegers.keySet();</span><br><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">    Integer  value = mapOfIntegers.get(key);</span><br><span class="line">    l.info(<span class="string">&quot;Value keyed by &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; is &#x27;&quot;</span> + value + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关代码：<a href="./src/TryMap.java">TryMap.java</a></p><hr><p>相关代码：</p><p><a href="./src/UsrList.java">TryList.java</a></p><p><a href="./src/TrySet.java">TrySet.java</a></p><p><a href="./src/TryMap.java">TryMap.java</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-数组</title>
      <link href="/2019/04/21/Java_intro/Day10_Java_Array/"/>
      <url>/2019/04/21/Java_intro/Day10_Java_Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>Java 语言中提供的数组是用来存储<strong>固定大小</strong>的<strong>同类型元素</strong>的。</p><h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>欲使用数组，首先必须声明数组变量，用来存放数组对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法，这种风格来自 C/C++，只是为了让 C/C++ 程序员能够快速理解java语言</span></span><br></pre></td></tr></table></figure><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>与其他类型相似，我们可以用 <code>new</code> 创建一个数组对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure><p>与 C 不同的是，arraySize 可以是一个变量，而不必使用字面值常量。</p><p>或者，如果我们预先知道了数组的内容，可以像 C 一样用 数组的字面值常量 (<code>&#123;...&#125;</code>) 来创建一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] names;</span><br><span class="line">names = &#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lacy&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>正如其他类型的变量，我们常把声明和创建写在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure><h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><h3 id="数组大小"><a href="#数组大小" class="headerlink" title="数组大小"></a>数组大小</h3><p>对于一个数组 <code>arrayRefVar</code> ，我们可以使用 <code>arrayRefVar.length</code> 来获取其长度。</p><h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>数组的元素是通过索引访问的。数组索引从 <code>0</code> 开始 到 <code>arrayRefVar.length-1</code>。</p><p>例如，我们用一个长度为 n 的数组来表示出 <em>斐波那契数列</em> 的前 n 项，然后把它们输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填装数列</span></span><br><span class="line">fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">fib[i] = fib[i-<span class="number">1</span>] + fib[i-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">System.out.println(fib[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h3><p>正如上面的程序，我们常用循环来处理一个数组，我们可以使用传统的 for 或者是 for-each 循环来迭代一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for-each</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element: arr) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组与函数"><a href="#数组与函数" class="headerlink" title="数组与函数"></a>数组与函数</h3><p>我们可以把一个数组看成是和其他任何实例一样的对象，所以我们当然也可以把它当作参数传递给函数，或作为函数的返回值返回。</p><h4 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] returnArray(<span class="keyword">int</span> base) &#123;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">result[i] = base &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i: arr) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，我们常用到的 <code>main</code> 函数，就是使用数组作为函数的参数的良好例子。</p><p><code>main</code> 是这样的：<code>public static void main(String[] args) &#123; ... &#125;</code>, 它接收一个 String 的数组作为参数，这个数组的元素就是在运行 java 程序时给出的命令行参数。<br>例如 <code>java Example.java Arg1 Arg2</code>，对应的args将是：<code>&#123;&quot;Arg1&quot;, &quot;Arg2&quot;&#125;</code>。</p><p>参考示例代码 <a href="./src/ArrayAndFunction.java">ArrayAndFunction.java</a>。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>我们可以声明一个元素是数组的数组，即多维数组。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这将生成一个有两个元素的数组，这两个元素又分别是包含 3 个 int 的数组。</p><p>我们可以这样使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultArr</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">a[i][j] = i*<span class="number">10</span> + j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i[]: a) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j: i) &#123;</span><br><span class="line">System.out.println(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p><code>Arrays</code> 类（<code>java.util.Arrays</code>）是 Java 提供的一个处理数组的类，它包含了一系列常用的数组操作，可以对内建类型的数组方便地操作。</p><p>要使用 <code>Arrays</code> 类，首先要导入它，即在代码开头使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure><p>然后，就可以调用它的这些主要的方法：</p><ul><li><code>Arrays.fill(ArrayObject, [begin, end,] Num)</code></li></ul><p>把 <code>Num</code> 赋值给 <code>ArrayObject</code> 中下标属于 <code>[begin, end)</code> (可选，缺省为整个数组) 的元素。</p><ul><li><code>Arrays.sort(ArrayObject, [begin, end])</code></li></ul><p>对 <code>ArrayObject</code> 中下标属于 <code>[begin, end)</code> (可选，缺省为整个数组) 的元素排序。</p><ul><li><code>Arrays.equals(Arr1, Arr2)</code></li></ul><p>判断数组 <code>Arr1</code> 和 <code>Arr2</code> 是否相同。</p><ul><li><code>Arrays.binarySearch(ArrayObject, Key)</code></li></ul><p>在 数组 <code>ArrayObject</code> 中用 <strong>二分搜索</strong>（注意要排序后的才有意义）搜索值Key，<br>找到会返回首个对应的索引，<br>找不到会返回负值。</p><ul><li><code>Arrays.toString(ArrayObject)</code></li></ul><p>用字符串来表示一个数组（如 <code>&#123;1, 2, 3&#125;</code> 表示为 <code>&quot;[1, 2, 3]&quot;</code>），<br><strong>返回</strong>得到的字符串。</p><p>用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseArrays</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill</span></span><br><span class="line">Arrays.fill(a, <span class="number">6</span>);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">Arrays.fill(a, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort</span></span><br><span class="line">Arrays.sort(b, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">Arrays.sort(b);</span><br><span class="line">System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line">System.out.println(</span><br><span class="line">Arrays.equals(a, a)</span><br><span class="line">);</span><br><span class="line">System.out.println(</span><br><span class="line">Arrays.equals(a, b)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// binarySearch</span></span><br><span class="line">System.out.println(</span><br><span class="line">Arrays.binarySearch(b, <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line">System.out.println(</span><br><span class="line">Arrays.binarySearch(b, <span class="number">99</span>)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 0, 0, 0]</span><br><span class="line">[9, 2, 1, 3, 7]</span><br><span class="line">[6, 6, 6, 6, 6]</span><br><span class="line">[6, 6, 8, 8, 6]</span><br><span class="line">[9, 1, 2, 3, 7]</span><br><span class="line">[1, 2, 3, 7, 9]</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">2</span><br><span class="line">-6</span><br></pre></td></tr></table></figure><p>Arrays 类还有很多方法，可以参考 <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Arrays.html">官方文档</a></p><hr><p>相关代码:</p><ul><li><a href="./src/FibonacciArray.java">FibonacciArray.java</a></li><li><a href="./src/ArrayAndFunction.java">ArrayAndFunction.java</a></li><li><a href="./src/MultArr.java">MultArr.java</a></li><li><a href="./src/UseArrays.java">UseArrays.java</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-条件</title>
      <link href="/2019/04/20/Java_intro/Day9_Java_Condition/"/>
      <url>/2019/04/20/Java_intro/Day9_Java_Condition/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-条件语句"><a href="#Java-条件语句" class="headerlink" title="Java 条件语句"></a>Java 条件语句</h1><h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h2><p>Java 的 <code>if</code> 条件语句和 C 完全一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression_0) &#123;</span><br><span class="line">    <span class="comment">// statements</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expression_1) &#123;</span><br><span class="line">    <span class="comment">// statements</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>无需解释</del></p><h2 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch-case 语句"></a>switch-case 语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value_0 :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>;   <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value_1 :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>;   <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> :   <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的 <code>switch</code> 大体上和 C 的相同，但也有不同的地方。值得一提的是如下几点：</p><ul><li>同 C 一样，<ul><li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>同时需要注意 <code>case</code> 后一直执行到 <code>break</code> 才会停止（或者执行到全部结束），不会在一个 case 结束后自动停止！</li></ul></li><li>与 C 不同的是，<ul><li>Java 中 <code>switch</code> 后面的 expression 可以是 <code>byte</code>、<code>short</code>、<code>int</code> 或者 <code>char</code>。从 Java SE 7 开始，switch 支持字符串 <code>String</code> 类型了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-循环</title>
      <link href="/2019/04/19/Java_intro/Day8_Java_Loop/"/>
      <url>/2019/04/19/Java_intro/Day8_Java_Loop/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-循环"><a href="#Java-循环" class="headerlink" title="Java 循环"></a>Java 循环</h1><p>Java中有三种主要的循环结构：</p><ul><li><code>while</code> 循环</li><li><code>do...while</code> 循环</li><li><code>for</code> 循环</li></ul><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while( 布尔表达式 ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do...while 循环"></a><code>do...while</code> 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环内容</span><br><span class="line">&#125; while( 布尔表达式 );</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h2><p>和 C++ 11 一样，Java有两种 for 循环，一种是类似与 C 的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for( 初始化; 布尔表达式; 更新 ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 代码语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种用于数组迭代的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(type element: array)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。<br>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      String [] names = &#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lacy&quot;</span>&#125;;</span><br><span class="line">      <span class="keyword">for</span>( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p><code>break</code>、<code>continue</code> 在 Java 中也同样有效。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基本运算</title>
      <link href="/2019/04/18/Java_intro/Day7_Java_Operators/"/>
      <url>/2019/04/18/Java_intro/Day7_Java_Operators/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><p>Java 中的运算符与 C 中基本一致。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法 : 相加运算符两侧的值</td><td><code>A + B</code> 等于 30</td></tr><tr><td><code>-</code></td><td>减法 : 左操作数减去右操作数</td><td><code>A – B</code> 等于 -10</td></tr><tr><td><code>*</code></td><td>乘法 : 相乘操作符两侧的值</td><td><code>A * B</code> 等于200</td></tr><tr><td><code>/</code></td><td>除法 : 左操作数除以右操作数</td><td><code>B / A</code> 等于2</td></tr><tr><td><code>++</code></td><td>自增: 操作数的值增加1</td><td><code>B++</code> 或 <code>++B</code> 等于 21</td></tr><tr><td><code>--</code></td><td>自减: 操作数的值减少1</td><td><code>B--</code> 或 <code>--B</code> 等于 19</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>==</code></td><td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td><code>(A == B)</code>为假。</td></tr><tr><td><code>!=</code></td><td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td><code>(A != B)</code> 为真。</td></tr><tr><td><code>&gt;</code></td><td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td><code>(A &gt; B)</code>为假。</td></tr><tr><td><code>&lt;</code></td><td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td><code>(A &lt; B)</code>为真。</td></tr><tr><td><code>&gt;=</code></td><td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td><code>(A &gt;= B)</code>为假。</td></tr><tr><td><code>&lt;=</code></td><td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td><code>(A &lt;= B)</code>为真。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td><code>(A &amp;&amp; B)</code> 为假。</td></tr><tr><td>`</td><td></td><td>`</td></tr><tr><td><code>!</code></td><td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td><code>!(A &amp;&amp; B)</code> 为真。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>＆</code></td><td>如果相对应位都是1，则结果为1，否则为0</td><td><code>(A＆B)</code>，得到12，即0000 1100</td></tr><tr><td>`</td><td>`</td><td>如果相对应位都是0，则结果为0，否则为1</td></tr><tr><td><code>^</code></td><td>如果相对应位值相同，则结果为0，否则为1</td><td><code>(A ^ B)</code>得到49，即 0011 0001</td></tr><tr><td><code>~</code></td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td><code>(〜A)</code>得到-61，即1100 0011</td></tr><tr><td><code>&lt;&lt;</code></td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td><code>A &lt;&lt; 2</code> 得到240，即 1111 0000</td></tr><tr><td><code>&gt;&gt;</code></td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td><code>A &gt;&gt; 2</code> 得到15即 1111</td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td><code>A&gt;&gt;&gt;2</code> 得到15即0000 1111</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>=</code></td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td><code>C = A + B</code> 将把A + B得到的值赋给C</td></tr><tr><td><code>+=</code></td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td><code>C += A</code> 等价于C = C + A</td></tr></tbody></table><p>类似 <code>+=</code> ，其他的<em>算数运算符</em>、<em>位运算符</em>、<em>逻辑运算符</em>都可以加在 <code>=</code> 前面。</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable x = (expression) ? value_if_true : value_if_false;</span><br></pre></td></tr></table></figure><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a><code>instanceof</code> 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable <span class="keyword">instanceof</span> class_or_interface_type_name;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; &quot;James&quot;;</span><br><span class="line">boolean result &#x3D; name instanceof String; &#x2F;&#x2F; 由于 name 是 String 类型，所以返回真</span><br></pre></td></tr></table></figure><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>详见<a href="http://www.runoob.com/java/java-operators.html">参考</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-修饰符</title>
      <link href="/2019/04/17/Java_intro/Day6_Java_Modifier/"/>
      <url>/2019/04/17/Java_intro/Day6_Java_Modifier/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h1><blockquote><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p></blockquote><p>Java 中的<strong>修饰符</strong>主要分为两类：</p><ul><li>访问修饰符：Java 通过访问控制符来保护对类、变量、方法和构造方法的访问；</li><li>非访问修饰符：Java 为了实现一些其他的功能而设定的修饰符；</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><code>default</code> (缺省值）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><code>private</code> : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li><code>public</code> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><code>protected</code> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<ul><li>子类与基类在同一包中：被声明为 <code>protected</code> 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 <code>protected</code> 方法，而不能访问基类实例的 <code>protected</code> 方法。</li></ul></li></ul><table><thead><tr><th>修饰符</th><th>当前类</th><th>同一包内</th><th>子孙类(同一包)</th><th>子孙类(不同包)</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>Y/N</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>⚠️【注意】</p><ol><li>在不写任何修饰符的情况下（如 <code>int a = 1;</code>），<strong>接口</strong> 里的变量都隐式声明为 <code>public static final</code>,而接口里的方法默认情况下访问权限为 <code>public</code>。</li><li><code>protected</code> 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。接口及接口的成员变量和成员方法不能声明为 <code>protected</code>。详见<a href="http://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html">参考</a> 。</li></ol><h4 id="访问控制符的继承"><a href="#访问控制符的继承" class="headerlink" title="访问控制符的继承"></a>访问控制符的继承</h4><ul><li>父类中声明为 <code>public</code> 的方法在子类中也必须为 <code>public</code> 。</li><li>父类中声明为 <code>protected</code> 的方法在子类中要么声明为 <code>protected</code> ，要么声明为 <code>public</code> ，不能声明为 <code>private</code> 。</li><li>父类中声明为 <code>private</code> 的方法，不能够被继承。</li></ul><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a><code>static</code> 修饰符</h4><ul><li><p>静态变量：<br><code>static</code> 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 <code>static</code> 变量。</p></li><li><p>静态方法：<br><code>static</code> 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul><p>对类变量和方法的访问可以直接使用 <code>classname.variablename</code> 和 <code>classname.methodname</code> 的方式访问。</p><h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a><code>final</code> 修饰符</h4><ul><li><code>final</code> 变量:<br>常量，一旦赋值后，不能被重新赋值。</li><li><code>final</code> 类:<br>不能被继承，没有类能够继承 <code>final</code> 类的任何特性。</li><li><code>final</code> 方法:<br>类中的 final 方法可以被子类继承，但是不能被子类修改。<br>声明 final 方法的主要目的是防止该方法的内容被修改。</li></ul><p><code>final</code> 修饰符通常和 static 修饰符一起使用来创建类常量。</p><h4 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a><code>abstract</code> 修饰符</h4><ul><li>抽象类：<br>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</li></ul><p>一个类不能同时被 abstract 和 final 修饰。</p><p>抽象类可以包含抽象方法和非抽象方法。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><ul><li>抽象方法：<br>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</li></ul><p>抽象方法不能被声明成 final 和 static。</p><p>⚠️【注意】如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a><code>synchronized</code> 修饰符</h4><p><code>synchronized</code> 关键字声明的方法同一时间只能被一个线程访问。</p><h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a><code>transient</code> 修饰符</h4><p>详见 <a href="http://www.runoob.com/java/java-modifier-types.html">参考</a>。</p><h4 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a><code>volatile</code> 修饰符</h4><p>详见 <a href="http://www.runoob.com/java/java-modifier-types.html">参考</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-变量</title>
      <link href="/2019/04/16/Java_intro/Day5_Java_Variable/"/>
      <url>/2019/04/16/Java_intro/Day5_Java_Variable/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中的变量类型"><a href="#Java-中的变量类型" class="headerlink" title="Java 中的变量类型"></a>Java 中的变量类型</h1><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h2><blockquote><p>在<em>方法</em>或<em>语句块</em>中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p></blockquote><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h2 id="成员变量-实例变量"><a href="#成员变量-实例变量" class="headerlink" title="成员变量(实例变量)"></a><strong>成员变量(实例变量)</strong></h2><blockquote><p>成员变量是定义在类中，<em>方法体之外</em>的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</p></blockquote><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是<code>0</code>，布尔型变量的默认值是<code>false</code>，引用类型变量的默认值是<code>null</code>。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：<code>ObejectReference.VariableName</code>。</li></ul><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a><strong>类变量</strong></h2><blockquote><p>类变量也声明在类中，方法体之外，但必须声明为 <code>static</code> 类型。</p></blockquote><ul><li>类变量也称为静态变量，在类中以 <code>static</code> 关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为 <code>public</code> / <code>private</code>, <code>final</code> 和 <code>static</code> 类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 <code>static</code> 声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 <code>public</code> 类型。</li><li>默认值和实例变量相似。数值型变量默认值是 <code>0</code>，布尔型默认值是 <code>false</code>，引用类型默认值是 <code>null</code>。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<code>ClassName.VariableName</code> 的方式访问。</li><li>类变量被声明为 <code>public static final</code> 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 <code>public</code> 和 <code>final</code> 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><h4 id="关于-类变量-的说明："><a href="#关于-类变量-的说明：" class="headerlink" title="关于 类变量 的说明："></a>关于 <strong>类变量</strong> 的说明：</h4><blockquote><p>The static keyword in Java is used for memory management mainly. We can apply java static keyword with variables, methods, blocks and nested class. The static keyword belongs to the class than an instance of the class. The static can be: Variable (also known as a class variable) Method (also known as a class method) Block.</p></blockquote><p>（部分翻译）</p><blockquote><p>Java 中的 <code>static</code> 关键字主要用于 <em>memory management</em>（谷歌翻译给出的翻译是“内存管理”, 但我对这个词的理解是：安排出一个内存空间来，供类的实例之间共享某个量）。我们可以将 java 的 <code>static</code> 关键字施用于变量、方法、语句块和嵌套类。<code>static</code> 定义的对象是属于整个类的, 而不是某个类的实例。</p></blockquote><p>普通的变量属于类的某一个特定的实例，但用 <code>static</code> 关键字修饰的变量将属于一个类。也就是说，我们通过类的某一个实例去修改一个一般的变量值，将只有这个实例中的值被修改，其他实例不受影响；而若是修改一个 <code>static</code> 关键字修饰的<strong>类变量</strong>，这个类的所有实例的这个值都会被修改。</p><p>说起来比较麻烦，可以看一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Example foo = <span class="keyword">new</span> Example();</span><br><span class="line">Example bar = <span class="keyword">new</span> Example();</span><br><span class="line"></span><br><span class="line">foo.staticVar = foo.normalVar = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(foo.staticVar + <span class="string">&quot;\t&quot;</span> + foo.normalVar);</span><br><span class="line">System.out.println(bar.staticVar + <span class="string">&quot;\t&quot;</span> + bar.normalVar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String staticVar = <span class="string">&quot;Example&quot;</span>;</span><br><span class="line">String normalVar = <span class="string">&quot;Example&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobarfoobar</span><br><span class="line">foobarExample</span><br></pre></td></tr></table></figure><p>可以看到，我们只改变了 <code>foo</code> 实例的值，但由 <code>static</code> 修饰的类变量 <code>staticVar</code> 的改变在 <code>bar</code> 中也出现了，而普通的成员变量则不然。</p><p>利用这种特性，我们可以实现一种可以统计自己的实例个数的类，详见 <a href="src/CountingClass.java"><code>CountingClass.java</code></a></p><hr><p>相关代码：</p><p><a href="src/Static.java"><code>Static.java</code></a><br><a href="src/CountingClass.java"><code>CountingClass.java</code></a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基本数据类型</title>
      <link href="/2019/04/15/Java_intro/Day4_Java_Types/"/>
      <url>/2019/04/15/Java_intro/Day4_Java_Types/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>Java 的两大数据类型:</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>对于每一种 数据类型 都有一个 <strong>包装类</strong>，如：<code>void</code>类型的包装类是 <code>java.lang.Void</code>。</p><p>对于数值类型的包装类，我们都可以从中获取对应类型的二进制位数、取值范围。</p><table><thead><tr><th>原语</th><th>对应的 JDK 类</th></tr></thead><tbody><tr><td>boolean</td><td>java.lang.Boolean</td></tr><tr><td>byte</td><td>java.lang.Byte</td></tr><tr><td>char</td><td>java.lang.Character</td></tr><tr><td>short</td><td>java.lang.Short</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>long</td><td>java.lang.Long</td></tr><tr><td>float</td><td>java.lang.Float</td></tr><tr><td>double</td><td>java.lang.Double</td></tr></tbody></table><p>具体的例子，见 <a href="./src/PrimitiveTypes.java"><code>PrimitiveTypes.java</code></a></p><p>下面，分类介绍 Java 中的内置数据类型：</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>代表空的值的类型。</p><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><table><thead><tr><th>类型</th><th>说明</th><th>范围</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8位, 有符号, 以二进制补码表示的整数</td><td><code>-128</code>~`127`</td><td><code>0</code></td><td>用在大型数组中节约空间</td></tr><tr><td><code>short</code></td><td>16位, 有符号, 以二进制补码表示的整数</td><td><code>-32768</code>~`32767`</td><td><code>0</code></td><td></td></tr><tr><td><code>int</code></td><td>32位, 有符号, 以二进制补码表示的整数</td><td><code>-2147483648</code>~`2147483647`</td><td><code>0</code></td><td>一般地整型变量默认为 int 类型</td></tr><tr><td><code>long</code></td><td>64位, 有符号, 以二进制补码表示的整数</td><td><code>-2^63</code>~`2^63-1`</td><td><code>0L</code></td><td>字面值常量是数后面加”L”(“L”理论上不分大小写，但小写不易分辩，最好大写)</td></tr></tbody></table><p>整型字面值常量都可以用十(正常书写)、八(以<code>0</code>开头)、十六(以<code>0x</code>开头)进制表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int decimal &#x3D; 100;</span><br><span class="line">int octal &#x3D; 0114;</span><br><span class="line">int hexadecimal &#x3D; 0x64;</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><blockquote><p>浮点数不能用来表示精确的值。</p></blockquote><table><thead><tr><th>类型</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td><code>float</code></td><td>单精度、32位、符合 IEEE 754 标准的浮点数</td><td><code>0.0f</code></td><td>float 在储存大型浮点数组的时候可节省内存空间</td></tr><tr><td><code>double</code></td><td>双精度、64 位、符合IEEE 754标准的浮点数</td><td><code>0.0d</code></td><td>浮点数的默认类型为double类型</td></tr></tbody></table><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><table><thead><tr><th>类型</th><th>说明</th><th>范围</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td><code>char</code></td><td>char类型是一个单一的 16 位 Unicode 字符</td><td><code>\u0000</code>~`\uffff`</td><td>字面值常量是单引号里字符(如：<code>&#39;A&#39;</code>)</td><td></td></tr></tbody></table><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><table><thead><tr><th>类型</th><th>说明</th><th>取值</th><th>默认值</th></tr></thead><tbody><tr><td><code>boolean</code></td><td>表示一位的信息</td><td><code>true</code> 和 <code>false</code></td><td><code>false</code></td></tr></tbody></table><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><blockquote><p>引用类型指向一个对象，指向对象的变量是引用变量。</p></blockquote><p>对象、数组都是引用数据类型。</p><p>所有引用类型的默认值都是 <code>null</code>。</p><p>引用变量一旦声明后，类型就不能被改变了，但一个引用变量可以用来引用任何与之兼容的类型。</p><h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><p>声明一个变量，需要使用如下的格式的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type varName;</span><br></pre></td></tr></table></figure><p>也可以在声明的同时，对它初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type varName &#x3D; initialValue;</span><br></pre></td></tr></table></figure><p>【注】初始化一个对象时，使用：<code>ClassName instanceName = new ClassName();</code></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量在程序运行时是不能被修改的。</p><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><p>字面值常量，就是直接在程序里写一个值，比如 <code>100</code>, <code>-100.0</code>, <code>&#39;A&#39;</code>…<br>这个东西很好理解，特殊的已经在上面的内置类型表格中有说明了。</p><p>字面值常量可以赋给任何内置类型的变量。</p><h4 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h4><p>我们也可以像声明变量一样声明一个常量。</p><p>在 Java 中，使用 <code>final</code> 关键字来修饰常量，声明方式和变量类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI &#x3D; 3.1415927;</span><br></pre></td></tr></table></figure><p>按照惯例，常量名应该用<strong>全部大写</strong>的名称表示。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列，其中可以使用转义字符，也可以含有Unicode字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello World&quot;</span><br><span class="line">&quot;two\nlines&quot;</span><br><span class="line">&quot;\&quot;This is in quotes\&quot;&quot;</span><br><span class="line">&quot;\u0001&quot;</span><br></pre></td></tr></table></figure><p>常用的转义字符如下：</p><table><thead><tr><th>符号</th><th>字符含义</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行 (0x0a)</td></tr><tr><td><code>\r</code></td><td>回车 (0x0d)</td></tr><tr><td><code>\f</code></td><td>换页符(0x0c)</td></tr><tr><td><code>\b</code></td><td>退格 (0x08)</td></tr><tr><td><code>\0</code></td><td>空字符 (0x20)</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td><code>\ddd</code></td><td>八进制字符 (ddd)</td></tr><tr><td><code>\uxxxx</code></td><td>16进制Unicode字符 (xxxx)</td></tr></tbody></table><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Java 中类型的转换有以下规则：</p><ol><li>不能对boolean类型进行类型转换。</li><li>不能把对象类型转换成不相关类的对象。</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li><li>转换过程中可能导致溢出或损失精度。</li><li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。</li></ol><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>在自动类型转换中，类型总是从<strong>低级</strong>到<strong>高级</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">低  ----------------------------------------&gt;  高</span><br><span class="line"></span><br><span class="line">byte, short, char —&gt; int —&gt; long —&gt; float —&gt; double </span><br></pre></td></tr></table></figure><p>⚠️【注意】在进行整数运算时，如果是两个比int类型小的类型做运算，java在编译的时候就会将它们统一强转成int类型。当有比int类型大的类型运算时，会自动转换成它们中最大类型那个。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>通过下面这种语句可以强制类型转化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type)value</span><br></pre></td></tr></table></figure><p>⚠️【注意】转换的数据类型必须是兼容的。</p><h4 id="数据类型转换的补充"><a href="#数据类型转换的补充" class="headerlink" title="数据类型转换的补充"></a>数据类型转换的补充</h4><h5 id="1、包装类过渡类型转换"><a href="#1、包装类过渡类型转换" class="headerlink" title="1、包装类过渡类型转换"></a>1、包装类过渡类型转换</h5><p>一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。</p><p>例如：</p><p>当希望把float型转换为double型时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">100.00f</span>;</span><br><span class="line">Float F1 = <span class="keyword">new</span> Float(f1);</span><br><span class="line"><span class="keyword">double</span> d1 = F1.doubleValue();     <span class="comment">//F1.doubleValue()为Float类的返回double值型的方法</span></span><br></pre></td></tr></table></figure><p>简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。<br>即：<code>Boolean(boolean value)、Character(char value)</code>、<code>Integer(int value)</code>、<code>Long(long value)</code>、<code>Float(float value)</code>、<code>Double(double value)</code>。</p><p>而在各个包装类中，总有形为 <code>××Value()</code> 的方法，来得到其对应的简单类型数据。<br>利用这种方法，也可以实现不同数值型变量间的转换。<br>例如，对于一个双精度实型类，<code>intValue()</code> 可以得到其对应的整型变量，而 <code>doubleValue()</code> 可以得到其对应的双精度实型变量。</p><h5 id="2、字符串与其它类型间的转换"><a href="#2、字符串与其它类型间的转换" class="headerlink" title="2、字符串与其它类型间的转换"></a>2、字符串与其它类型间的转换</h5><h6 id="其它类型向字符串的转换"><a href="#其它类型向字符串的转换" class="headerlink" title="其它类型向字符串的转换"></a>其它类型向字符串的转换</h6><ol><li>调用类的串转换方法: <code>X.toString();</code></li><li>自动转换: <code>X+&quot;&quot;;</code></li><li>使用String的方法: <code>String.valueOf(X);</code></li></ol><p>⚠️【注意】在使用 <code>2</code> 时需要注意：<strong>任何字符类型与字符串相加，结果都是拼接。</strong><br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line">s += <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s);  <span class="comment">// 输出 nullhello</span></span><br></pre></td></tr></table></figure><h6 id="字符串作为值-向其它类型的转换"><a href="#字符串作为值-向其它类型的转换" class="headerlink" title="字符串作为值,向其它类型的转换"></a>字符串作为值,向其它类型的转换</h6><ol><li>先转换成相应的封装器实例,再调用对应的方法转换成其它类型</li></ol><p>例如，字符串 <code>&quot;32.1&quot;</code> 转换 <code>double</code> 型的值的格式为: <code>new Float(&quot;32.1&quot;).doubleValue()</code></p><p>也可以用: <code>Double.valueOf(&quot;32.1&quot;).doubleValue()</code></p><ol start="2"><li>静态parseXXX方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span> b = Byte.parseByte( s );</span><br><span class="line"><span class="keyword">short</span> t = Short.parseShort( s );</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt( s );</span><br><span class="line"><span class="keyword">long</span> l = Long.parseLong( s );</span><br><span class="line">Float f = Float.parseFloat( s );</span><br><span class="line">Double d = Double.parseDouble( s );</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>只有 boolean 不参与数据类型的转换</li><li>自动类型的转换：<ul><li>常数在表数范围内是能够自动类型转换的</li><li>数据范围小的能够自动数据类型大的转换</li><li>由浮点类型转换成整数类型不会自动转换的，不然将会丢失精度。</li><li>引用类型能够自动转换为父类的</li><li>基本类型和它们包装类型是能够互相转换的</li></ul></li><li>强制类型转换：用圆括号括起来目标类型，置于变量前</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-类和对象</title>
      <link href="/2019/04/14/Java_intro/Day3_Java_Class/"/>
      <url>/2019/04/14/Java_intro/Day3_Java_Class/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中的类和对象"><a href="#Java-中的类和对象" class="headerlink" title="Java 中的类和对象"></a>Java 中的类和对象</h1><blockquote><p>类可以看成是创建Java对象的模板</p></blockquote><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类中变量的类型"><a href="#类中变量的类型" class="headerlink" title="类中变量的类型"></a>类中变量的类型</h2><ul><li><p><strong>局部变量</strong>：在<em>方法</em>或<em>语句块</em>中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p></li><li><p>*<em>成员变量(实例变量)**：成员变量是定义在类中，</em>方法体之外*的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</p></li><li><p><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 <code>static</code> 类型。</p></li></ul><blockquote><p>这里只是简单介绍，详见 <a href="./Day5_Java_Variable.md">Day5_Java_Variable.md</a></p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。<br>如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造Dog&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h2><p>创建两个具有相同名称和不同参数列表（即不同的参数数量或类型）的方法时，就拥有了一个<em>重载</em> 方法。</p><p>在运行时，JRE 基于传递给它的参数来决定调用您的重载方法的哪个变体。</p><p>我们甚至可以在一个方法中调用另一个同名的重载方法。</p><p>但要注意：在使用重载方法时，</p><ul><li>不能仅通过更改一个方法的返回类型来重载它。</li><li>不能拥有两个具有相同名称和相同参数列表的方法。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>要表示一个类继承自某一个超类，我们可以在声明类时，在 className 后加上 <code>extends</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">// Employee 继承自 Person</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> height, <span class="keyword">int</span> weight,</span></span></span><br><span class="line"><span class="function"><span class="params">  String eyeColor, String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age, height, weight, eyeColor, gender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中，调用 <code>super([args])</code> 来初始化父类。</p><h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>如果一个子类提供其父类中定义的方法的自有实现，这被称为<em>方法重写</em>。</p><p>重写的形式类似于重载，但需要加上一个 <code>@Override</code>。例如，当父类中有一个 <code>foo()</code> 方法时，我们可以在子类中这样重写它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注】这段代码是使用 Eclipse 自动生成的，它只是调用了父类中的方法（<code>super.foo()</code>），没有任何改变，但实际中我们不会这么使用。</p><p>重写后，<strong>在类中</strong>直接使用 <code>method()</code>调用重写后的函数，但我们任然可以通过 <code>super.method()</code> 调用父类中的（重写前的）方法。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>对象是根据类创建的。<br>创建对象需要以下三步：</p><ul><li>声明：声明一个对象，包括对象名称和对象类型。</li><li>实例化：使用关键字 <code>new</code> 来创建一个对象。</li><li>初始化：使用 <code>new</code> 创建对象时，会调用构造方法初始化对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Dog Dog0 = <span class="keyword">new</span> Dog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h2><ul><li>访问实例的变量：<code>实例名.变量名</code></li><li>调用实例的方法：<code>实例名.方法名()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">&quot; is eating &quot;</span> + food + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name = <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;构造()：&quot;</span>);</span><br><span class="line">System.out.println(name + <span class="string">&quot;\t&quot;</span> + age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String dogName, <span class="keyword">int</span> dogAge)</span> </span>&#123;</span><br><span class="line">name = dogName;</span><br><span class="line">age = dogAge;</span><br><span class="line">System.out.println(<span class="string">&quot;构造(name, age)：&quot;</span>);</span><br><span class="line">System.out.println(name + <span class="string">&quot;\t&quot;</span> + age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Dog Dog0 = <span class="keyword">new</span> Dog();</span><br><span class="line">Dog Dog1 = <span class="keyword">new</span> Dog(<span class="string">&quot;FooBar&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问变量 </span></span><br><span class="line">Dog0.name = <span class="string">&quot;Ana&quot;</span>;</span><br><span class="line">System.out.println(Dog0.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问方法</span></span><br><span class="line">Dog1.eat(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行👆上面代码将输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造()：</span><br><span class="line">Dog0</span><br><span class="line">构造(name, age)：</span><br><span class="line">FooBar3</span><br><span class="line">Ana</span><br><span class="line">FooBar is eating cat.</span><br></pre></td></tr></table></figure><h2 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h2><p>Java 语言提供了两种比较对象的方法：</p><ul><li><code>==</code> 运算符 </li><li><code>equals()</code> 方法</li></ul><h3 id="使用-比较对象"><a href="#使用-比较对象" class="headerlink" title="使用 == 比较对象"></a>使用 <code>==</code> 比较对象</h3><p><code>==</code> 语法比较对象是否相等，只有在 <code>a</code> 和 <code>b</code> 相等时，<code>a == b</code> 才返回 <code>true</code>。</p><p>对于内置基本类型，需要<em>它们的值相等</em>。</p><p>对于对象，需要两个对象引用<em>同一个对象实例</em>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equals</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Logger l = Logger.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>,</span><br><span class="line">j = <span class="number">12</span>,</span><br><span class="line">k = <span class="number">99</span>;</span><br><span class="line">        </span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">Integer b = a;</span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">l.info(<span class="string">&quot;i == j: &quot;</span> + (i == j));</span><br><span class="line">l.info(<span class="string">&quot;i == k: &quot;</span> + (i == k));</span><br><span class="line"></span><br><span class="line">l.info(<span class="string">&quot;a == b: &quot;</span> + (a == b));</span><br><span class="line">l.info(<span class="string">&quot;a == c: &quot;</span> + (a == c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码将得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D;&#x3D; j: true</span><br><span class="line">i &#x3D;&#x3D; k: false</span><br><span class="line">a &#x3D;&#x3D; b: true</span><br><span class="line">a &#x3D;&#x3D; c: false</span><br></pre></td></tr></table></figure><p>⚠️【注】若使用 <code>a = Integer.valueOf(12);</code> 与 <code>c = Integer.valueOf(12);</code> 分别得到 a 和 c，则 <code>a == c</code> 将是 <code>true</code> ！</p><h3 id="使用-equals-比较对象"><a href="#使用-equals-比较对象" class="headerlink" title="使用 equals() 比较对象"></a>使用 <code>equals()</code> 比较对象</h3><blockquote><p><code>equals()</code> 是每种 Java 语言对象都可以自由使用的方法，因为它被定义为 <code>java.lang.Object</code> 的一个实例方法（每个 Java 对象都继承该对象）。</p></blockquote><p>调用 <code>equals()</code> 的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.equals(b);</span><br></pre></td></tr></table></figure><p>此语句调用对象 <code>a</code> 的 <code>equals()</code> 方法，向它传递对象 <code>b</code> 的引用。</p><p>默认情况下，Java 程序使用 <code>==</code> 语法检查两个对象是否相同。但是因为 <code>equals()</code> 是一种方法，所以它可以被重写。这样，对于任何对象，我们都可定义适合的 <code>equals()</code> 的含义。</p><p>【注】在重写 <code>equals()</code> 时，我们可以利用 <code>object.hashCode()</code>（ to return a hash code value for the object.）</p><hr><p>相关代码：</p><p><a href="./src/Dog.java"><code>Dog.java</code></a></p><p>参考：</p><p><a href="https://www.runoob.com/java/java-object-classes.html">菜鸟教程 | Java 对象和类</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-perry-next-steps-with-objects/index.html">Java 编程入门 |  第 13 单元：对象的后续处理 </a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-面向对象</title>
      <link href="/2019/04/13/Java_intro/Day2_OOP/"/>
      <url>/2019/04/13/Java_intro/Day2_OOP/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着计算机技术的发展，我们想用计算机来解决越来越复杂的问题。问题越复杂，解决问题需要的抽象层往往越高。</p><p>编程语言的的发展，也顺应着这样的趋势。一开始的汇编语言只是对计算机硬件的简单抽象，C语言又对其进行了进一步的抽象，使其更加贴近问题而不是硬件；到了 Java，面向对象编程(OOP)的思想已近很成熟了，这是一种更加抽象的语言，对计算机硬件的表达更少，而对问题的描述更多。</p><h2 id="认识面向对象"><a href="#认识面向对象" class="headerlink" title="认识面向对象"></a>认识面向对象</h2><ul><li>什么是<em>对象</em>？</li></ul><p>对象就是一个存在的东西！</p><p>在面向过程的编程中，我们需要把一个问题转换成一系列的数据和操作数据的算法，同时我们还需要考虑这些数据和算法如何用计算机可以理解的方式表达出来，即遵照基础机器的表达方式。</p><p>对象的概念可为我们带来极大的便利。它在概念上允许我们将各式各样数据和功能封装到一起。这样便可恰当表达“问题空间”的概念，不用刻意遵照基础机器的表达方式。</p><ul><li>什么是<em>面向对象的程序设计</em>？</li></ul><p>面向对象编程，就是把一切问题的部分抽象成对象，用那些通用的特征和行为来描述他们，然后再处理这些对象之间的沟通，得到完整的问题描述，并通过给这些对象一些，信息让他们最终给出一个解。</p><ul><li><p>“纯粹”的面向对象程序设计方法是什么样的？</p><ol><li>所有东西都是对象。可将对象想象成一种新型变量；</li><li>程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。</li><li>每个对象都有自己的存储空间，可容纳其他对象。</li><li>每个对象都有一种类型。</li><li>同一类所有对象都能接收相同的消息。</li></ol></li></ul><h2 id="对象的接口"><a href="#对象的接口" class="headerlink" title="对象的接口"></a>对象的接口</h2><p>所有对象，尽管各有特色，都属于某一系列对象的一部分，这些对象具有通用的特征和行为。</p><p>“接口”（Interface）就是把一种类型的对象的共同特征抽象出来，并将其表示。（大多数语言中我们使用关键字 <code>class</code> 来描述）</p><p>“类型”决定了接口，而“类”是那个接口的一种特殊实现方式。</p><p>接口建立的同时，也规定了可对一个特定的对象发出哪些请求。所以建好一个类后，可根据情况生成许多对象。随后，可将那些对象作为要解决问题中存在的元素进行处理。</p><h2 id="实现方案的隐藏"><a href="#实现方案的隐藏" class="headerlink" title="实现方案的隐藏"></a>实现方案的隐藏</h2><p>在面向对象的程序设计的过程中，我们时常需要<em>控制对成员的访问</em>。</p><p>一方面，防止调用类的程序员接触到内部数据类型的设计思想。<br>另一方面，允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。</p><p>在我们的接口中，要实现这样的访问控制，把一部分设计细节隐藏起来，便需要一种机制来实现对访问的控制，在 Java 中这种控制用关键字 <code>public</code>，<code>private</code>，<code>protected</code> 以及暗示性的 <code>friendly</code>来实现：</p><ul><li>“public”（公共）意味着后续的定义任何人均可使用。</li><li>“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。</li><li>“protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。继承的问题不久就要谈到。</li><li>“friendly”（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。</li></ul><h2 id="方案的重复使用"><a href="#方案的重复使用" class="headerlink" title="方案的重复使用"></a>方案的重复使用</h2><p>创建并测试好一个类后，它应（从理想的角度）代表一类事物，是可以重复在很多地方使用的。</p><p>为重复使用一个类，最简单的办法是仅直接使用那个类的对象。同时也能将那个类的一个对象置入一个新类，这种类中置入类的方法成为“组织”或“包含”，比如“一辆车包含了一个变速箱”。</p><h2 id="继承：重新使用接口"><a href="#继承：重新使用接口" class="headerlink" title="继承：重新使用接口"></a>继承：重新使用接口</h2><p>我们费尽心思做出一种数据类型后，假如不得不又新建一种类型，令其实现大致相同的功能，那会是一件非常令人灰心的事情。<br>但若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。</p><blockquote><p>在 Java 语言中，继承是通过 <code>extends</code> 关键字实现的。</p></blockquote><p>使用继承时，相当于创建了一个新的类，不过这个“克隆”类（正式名称叫作继承类或者子类）中一开始就包含了原始类（正式名称叫作基础类、超类或父类）中的所有成员（<code>private</code>会被隐藏起来，禁止访问）与接口。</p><p>于此同时，在继承过程中，若<strong>父类</strong>发生了变化，<strong>子类</strong>也会反映出这种变化。</p><p>在完成继承后，可向<strong>父类</strong>的对象发送的所有消息亦可原样发给<strong>子类</strong>的对象。如果不对<strong>子类</strong>做任何修改，<strong>子类对象</strong>接收到一条特定的消息后，也总有一个<strong>父类</strong>提供的“方法”能够执行。这意味着<strong>子类</strong>具有与<strong>父类</strong>相同的类型和行为！</p><p>然而，在绝大多数情况下，我们希望子类和父类有所区别（不然为什么要建立一个子类呢？），实现这个效果，我们有一下方法可用：</p><ul><li>为衍生类添加新函数（功能）</li></ul><p>如果需要子类拥有父类没有的功能，只需要给子类增加新的方法（函数）就行了。</p><ul><li>改变（”改善”）基础类一个现有函数的行为（重载）</li></ul><p>为改善一个函数，只需为衍生类的函数建立一个新定义即可。我们的目标是：“尽管使用的函数接口未变，但它的新版本具有不同的表现”。</p><h2 id="多形对象的互换使用"><a href="#多形对象的互换使用" class="headerlink" title="多形对象的互换使用"></a>多形对象的互换使用</h2><p><img src="https://java.quanke.name/1-2.gif" alt="1-2.gif"></p><p>举个例子，我们构建一个 <code>Shape</code> 类，<code>Shape</code> 类拥有 <code>draw()</code>, <code>erase()</code>, <code>move()</code> 等方法；<br>然后我们在构建几个 <code>Shape</code> 的子类（继承自 <code>Shape</code>）的类：<code>Circle</code>, <code>Line</code>, <code>Triangle</code>；<br>对每个子类，我们都会根据实际情况重载对应的方法。</p><p>这时，如果我们构建一个 doStuff 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void doStuff(Shape s) &#123;</span><br><span class="line">    s.erase();</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    s.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以接收任何 Shape 包括其子类进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle c &#x3D; new Circle();</span><br><span class="line">Triangle t &#x3D; new Triangle();</span><br><span class="line">Line  l &#x3D; new Line();</span><br><span class="line">doStuff(c);</span><br><span class="line">doStuff(t);</span><br><span class="line">doStuff(l);</span><br></pre></td></tr></table></figure><p>在这里，我们把 Shape 的子类，当作 Shape 使用，这称为“<strong>上溯造型</strong>”，这样做常常可以避免检查一个对象到底是何种具体类型。</p><p>值得注意的是，即使 Circle、Line、Triangle 用不同的 erase、draw 的具体实现方式，doStuff 还是可以很好得完成工作。我们可以理解为 doStuff 只是在告诉 Shape ：“你是一种几何形状，我知道你能将自己删掉，即erase()；请自己采取那个行动，并自己去控制所有的细节吧”，而不是对 Circle 做某种操作，对 Triangle 做某种操作…</p><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>我们在使用上述代码时，不论我们传给 doStuff 的是那种具体类型，它总能调用我们想要的函数。</p><p>像这样将一条消息发给对象时，如果不知道对方对具体类型是什么，但采取的行动同样是正确的，这种情况称作“<strong>多形性</strong>”，实现“多形性”的办法叫做“<strong>动态绑定</strong>”。</p><p>对于动态绑定，编译器会自己处理细节，我们只需要知道会发生什么。</p><p>在 Java 中，我们无需使用关键字来实现 动态绑定，它将是自动的。</p><h4 id="抽象的基础类和接口"><a href="#抽象的基础类和接口" class="headerlink" title="抽象的基础类和接口"></a>抽象的基础类和接口</h4><p><strong>基础类</strong> 只是为自己的衍生类提供一个接口的类（上溯造型成它），我们不希望实际创建这种类的实例对象。<br>这时，我们就可以把这个类声明成“抽象的”。</p><blockquote><p>在 Java 中，我们使用 关键字 <code>abstract</code> 来说明一个类是抽象的。编译器将阻止创建<strong>抽象类</strong>的实例。</p></blockquote><p><strong><code>interface</code> 关键字</strong> 将抽象类的概念延伸，它完全禁止所有函数的定义。</p><hr><p>【注】这篇文章，是学习《Thinking in Java》的笔记与摘录整理而成的。</p><p>由于找到的这本书太老，加上一些翻译上的问题，所以有些地方的表述可能和现在的主流方式不同（如书中对“重载”、“多态”等词的表述😂）。</p><p>这部分主要学习那种思想，就不纠结这些遣词造句是的细节了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础语法</title>
      <link href="/2019/04/12/Java_intro/Day1_Java_Basic/"/>
      <url>/2019/04/12/Java_intro/Day1_Java_Basic/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><p><code>Java</code>  是一门<strong>面向对象</strong>的<strong>解释型</strong>编程语言。</p><p><strong>面向对象</strong> 意味着我们应该把一个 Java 程序看作一系列对象的集合，我们的工作就是构建这些对象，并通过调用彼此的方法来让各种对象协同工作，解决实际的问题。</p><p><strong>解释型</strong> 意味着：</p><p>Java编译程序生成字节码（<em>byte-code</em>），而不是通常的机器码。<br>相同的代码设计成可有效地传送程序到多个平台。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>Java 大小写敏感</li><li>Java 源文件名必须和类名相同（如果文件名和类名不相同则会导致编译错误）</li><li>Java 程序由 <code>public static void main(String []args) </code>方法开始执行。</li></ul><h2 id="标识符（合法的变量名）"><a href="#标识符（合法的变量名）" class="headerlink" title="标识符（合法的变量名）"></a>标识符（合法的变量名）</h2><ul><li>Java 标识符可以包含以下字符：<ul><li><em>字母</em>：<code>A</code>-<code>Z</code>、<code>a</code>-<code>z</code></li><li><em>数字</em>：<code>0</code>-<code>9</code></li><li><em>符号</em>：<code>$</code>、<code>_</code></li></ul></li><li>首字符不能是<em>数字</em></li><li>Java 标识符大小写敏感</li><li>关键字不能用作标识符</li></ul><h2 id="关键字（保留字）"><a href="#关键字（保留字）" class="headerlink" title="关键字（保留字）"></a>关键字（保留字）</h2><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr><tr><td>assert</td><td>断言，用来进行程序调试</td></tr><tr><td>boolean</td><td>基本数据类型之一，声明布尔类型的关键字</td></tr><tr><td>break</td><td>提前跳出一个块</td></tr><tr><td>byte</td><td>基本数据类型之一，字节类型</td></tr><tr><td>case</td><td>用在switch语句之中，表示其中的一个分支</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>char</td><td>基本数据类型之一，字符类型</td></tr><tr><td>class</td><td>声明一个类</td></tr><tr><td>const</td><td>保留关键字，没有具体含义</td></tr><tr><td>continue</td><td>回到一个块的开始处</td></tr><tr><td>default</td><td>默认，例如，用在switch语句中，表明一个默认的分支</td></tr><tr><td>do</td><td>用在do-while循环结构中</td></tr><tr><td>double</td><td>基本数据类型之一，双精度浮点数类型</td></tr><tr><td>else</td><td>用在条件语句中，表明当条件不成立时的分支</td></tr><tr><td>enum</td><td>枚举</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</td></tr><tr><td>final</td><td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td></tr><tr><td>finally</td><td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td></tr><tr><td>float</td><td>基本数据类型之一，单精度浮点数类型</td></tr><tr><td>for</td><td>一种循环结构的引导词</td></tr><tr><td>goto</td><td>保留关键字，没有具体含义</td></tr><tr><td>if</td><td>条件语句的引导词</td></tr><tr><td>implements</td><td>表明一个类实现了给定的接口</td></tr><tr><td>import</td><td>表明要访问指定的类或包</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr><tr><td>int</td><td>基本数据类型之一，整数类型</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>long</td><td>基本数据类型之一，长整数类型</td></tr><tr><td>native</td><td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td></tr><tr><td>new</td><td>用来创建新实例对象</td></tr><tr><td>package</td><td>包</td></tr><tr><td>private</td><td>一种访问控制方式：私用模式</td></tr><tr><td>protected</td><td>一种访问控制方式：保护模式</td></tr><tr><td>public</td><td>一种访问控制方式：共用模式</td></tr><tr><td>return</td><td>从成员方法中返回数据</td></tr><tr><td>short</td><td>基本数据类型之一,短整数类型</td></tr><tr><td>static</td><td>表明具有静态属性</td></tr><tr><td>strictfp</td><td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范[1]</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>switch</td><td>分支语句结构的引导词</td></tr><tr><td>synchronized</td><td>表明一段代码需要同步执行</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>throw</td><td>抛出一个异常</td></tr><tr><td>throws</td><td>声明在当前定义的成员方法中所有需要抛出的异常</td></tr><tr><td>transient</td><td>声明不用序列化的成员域</td></tr><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>void</td><td>声明当前成员方法没有返回值</td></tr><tr><td>volatile</td><td>表明两个或者多个变量必须同步地发生变化</td></tr><tr><td>while</td><td>用在循环结构中</td></tr></tbody></table><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Java 中的注释和 C 语言相同，有<code>/* ... */</code> 和 <code>// ...</code> 两种。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 行中注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行尾注释</span></span><br></pre></td></tr></table></figure><h2 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h2><p>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><h3 id="package-语句"><a href="#package-语句" class="headerlink" title="package 语句"></a><code>package</code> 语句</h3><p><code>package</code> 指定的信息直接将生成的 <code>class</code> 文件生成到对应目录下。如 <code>package aaa.bbb.ccc</code> 编译器就将该 <code>.java</code> 文件下的各个类生成到 <code>./aaa/bbb/ccc/</code> 这个目录。</p><h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a><code>import</code> 语句</h3><p><code>import</code> 是为了简化使用 <code>package</code> 之后的实例化的代码。假设 <code>./aaa/bbb/ccc/</code> 下的 <code>A</code> 类:</p><p>假如没有 <code>import</code>，实例化A类为：<code>new aaa.bbb.ccc.A()</code>;</p><p>使用 <code>import aaa.bbb.ccc.A</code> 后，就可以直接使用 <code>new A()</code> 了;<br>也就是编译器匹配并扩展了 <code>aaa.bbb.ccc.</code> 这串字符串。</p><p>例如，下面的命令行将会命令编译器载入 <code>java_installation/java/io</code> 路径下的所有类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br></pre></td></tr></table></figure><h2 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h2><ul><li>一个源文件中只能有一个 <code>public</code> 类（非 <code>public</code> 的不限）</li><li>源文件的名称应该和 <code>public</code> 类的类名保持一致。（源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java）</li><li>如果一个类定义在某个包中，那么 <code>package</code> 语句应该在源文件的首行。</li><li>如果源文件包含import语句，那么应该放在 <code>package</code> 语句和 <code>类定义</code> 之间。如果没有package语句，那么import语句应该在源文件中最前面。</li><li><code>import</code> 语句和 <code>package</code> 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-起步</title>
      <link href="/2019/04/11/Java_intro/Day0_Java_Begining/"/>
      <url>/2019/04/11/Java_intro/Day0_Java_Begining/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-起步"><a href="#Java-起步" class="headerlink" title="Java 起步"></a>Java 起步</h1><h2 id="Java-简介（废话）"><a href="#Java-简介（废话）" class="headerlink" title="Java 简介（废话）"></a>Java 简介（废话）</h2><p>Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言（现属于Oracle）。<br>Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。 </p><h2 id="Java-开发环境配置"><a href="#Java-开发环境配置" class="headerlink" title="Java 开发环境配置"></a>Java 开发环境配置</h2><h3 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK (Java Development Kit)"></a>JDK (Java Development Kit)</h3><blockquote><p>Java 是一种跨平台的编程语言，想要让你的计算机能够运行 Java 程序那么就需要安装 JRE，而想要开发 Java 程序，那么就需要安装 JDK。   </p></blockquote><ul><li><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">官网下载JDK</a> </li><li>安装 </li><li>配置（<a href="https://docs.oracle.com/en/java/javase/12/install/installation-jdk-microsoft-windows-platforms.html">Windows 下需要配置几个环境变量</a>） </li></ul><h3 id="Eclipse-IDE"><a href="#Eclipse-IDE" class="headerlink" title="Eclipse (IDE)"></a>Eclipse (IDE)</h3><blockquote><p>Eclipse 是一个很好的 Java 开发环境。   </p></blockquote><ul><li><a href="https://www.eclipse.org/">官网</a>下载 </li><li>安装 (不再推荐使用 Eclipse，要安装的话方法自寻)</li></ul><p>（Update 2020.02.19👆对 Eclipse 的推荐时很长很长时间前写的了，那时候我还没有接触过 IDEA。时至今日，我不否为 Eclipse 仍然还是强大的 IDE，但我现在更喜欢更加现代化、人性化、更加优雅强大的IDEA）</p><h3 id="IntelliJ-IDEA-（推荐）"><a href="#IntelliJ-IDEA-（推荐）" class="headerlink" title="IntelliJ IDEA （推荐）"></a>IntelliJ IDEA （推荐）</h3><p><a href="https://www.jetbrains.com/">JetBrains</a> 出品的强大现代化 IDE。</p><ul><li><a href="https://www.jetbrains.com/idea/">官网</a></li></ul><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim HelloWorld.java </span><br><span class="line">$ javac hello.java </span><br><span class="line">$ java HelloWorld </span><br></pre></td></tr></table></figure><p><strong><code>javac</code></strong> 后面跟着的是java文件的文件名，例如 <code>HelloWorld.java</code>。 该命令用于将 java 源文件编译为 class 字节码文件，如： <code>javac HelloWorld.java</code>。<br>运行javac命令后，如果成功编译没有错误的话，会出现一个 <code>HelloWorld.class</code> 的文件。</p><p><strong><code>java</code></strong> 后面跟着的是java文件中的类名(后面不加<code>.class</code>)，如: <code>java HelloWorld</code>。 </p><p>⚠️【注意】文件名必须和类名一致！否则会出现如下错误：<br><code>错误: 类 HelloWorld 是公共的, 应在名为 HelloWorld.java 的文件中声明</code> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax数据爬取</title>
      <link href="/2019/02/22/PythonAndCrawler/crawler-13-ajax/"/>
      <url>/2019/02/22/PythonAndCrawler/crawler-13-ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax-数据爬取"><a href="#Ajax-数据爬取" class="headerlink" title="Ajax 数据爬取"></a>Ajax 数据爬取</h1><blockquote><p>本节主要介绍如何爬取 Ajax 渲染的网页。</p></blockquote><h2 id="Ajax-简介"><a href="#Ajax-简介" class="headerlink" title="Ajax 简介"></a>Ajax 简介</h2><blockquote><p>Ajax，全称为 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML。</p></blockquote><p>Ajax 是一种利用 JavaScript 在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p><p>发送 Ajax 请求到网页更新的这个过程可以简单分为三步：</p><ul><li>发送请求</li><li>解析内容</li><li>渲染网页</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/ajax/&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>JavaScript 对 Ajax 最底层的实现，<br>实际上就是新建了 XMLHttpRequest 对象，<br>然后调用了onreadystatechange 属性设置了监听，<br>然后调用 open() 和 send() 方法向某个链接也就是服务器发送了一个请求，<br>当服务器返回响应时，onreadystatechange 对应的方法便会被触发，<br>然后在这个方法里面解析响应内容。</p><h4 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a>解析内容</h4><p>得到响应之后，onreadystatechange 属性对应的方法便会被触发，此时利用 xmlhttp 的 responseText 属性便可以取到响应的内容。</p><p>返回内容可能是 HTML，可能是 Json，接下来只需要在方法中用 JavaScript 进一步处理即可。比如如果是 Json 的话，可以进行解析和转化。</p><h4 id="渲染网页"><a href="#渲染网页" class="headerlink" title="渲染网页"></a>渲染网页</h4><p> DOM 操作，即对 Document网页文档进行操作，如更改、删除等。</p><h2 id="Ajax-分析方法"><a href="#Ajax-分析方法" class="headerlink" title="Ajax 分析方法"></a>Ajax 分析方法</h2><p>在浏览器开发者工具的Network中，Ajax的请求类型是 <code>xhr</code>。</p><p>在Request Headers中有一项 <code>X-Requested-With: XMLHttpRequest</code> 标记了该请求为 Ajax。</p><p>在 Preview 中可以看到响应的内容。</p><p>有了Request URL、Request Headers、Response Headers、Response Body等内容，就可以模拟发送Ajax请求了。</p><h2 id="Python-模拟-Ajax-请求"><a href="#Python-模拟-Ajax-请求" class="headerlink" title="Python 模拟 Ajax 请求"></a>Python 模拟 Ajax 请求</h2><p>爬取【人民日报】的微博：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url_base = <span class="string">&#x27;https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=2803301701&amp;containerid=1076032803301701&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;MWeibo-Pwa&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span>(<span class="params">basicUrl, headers, page</span>):</span></span><br><span class="line">    url = basicUrl + <span class="string">&#x27;&amp;page=%s&#x27;</span> % page</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()      <span class="comment"># Would return a dict</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Response Status Code != 200&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;Get Page False:&#x27;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_html</span>(<span class="params">html</span>):</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> soup.get_text()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content</span>(<span class="params">data</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">and</span> data.get(<span class="string">&#x27;data&#x27;</span>).get(<span class="string">&#x27;cards&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data.get(<span class="string">&#x27;data&#x27;</span>).get(<span class="string">&#x27;cards&#x27;</span>):</span><br><span class="line">            useful = &#123;&#125;</span><br><span class="line">            useful[<span class="string">&#x27;source&#x27;</span>] = item.get(<span class="string">&#x27;mblog&#x27;</span>).get(<span class="string">&#x27;source&#x27;</span>)</span><br><span class="line">            useful[<span class="string">&#x27;text&#x27;</span>] = parse_html(item.get(<span class="string">&#x27;mblog&#x27;</span>).get(<span class="string">&#x27;text&#x27;</span>))</span><br><span class="line"></span><br><span class="line">            result.append(useful)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span>    <span class="comment"># 这里不保存了，只是把它打印出来</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):    <span class="comment"># 记得调整需要的页数。</span></span><br><span class="line">        r = get_page(url_base, headers, page)</span><br><span class="line">        d = get_content(r)</span><br><span class="line">        save_data(d)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Redis</title>
      <link href="/2019/02/21/PythonAndCrawler/crawler-12-redis/"/>
      <url>/2019/02/21/PythonAndCrawler/crawler-12-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫储存库的使用之Redis"><a href="#Python爬虫储存库的使用之Redis" class="headerlink" title="Python爬虫储存库的使用之Redis"></a>Python爬虫储存库的使用之Redis</h1><blockquote><p>本文主要介绍 Python 下 Redis 的使用（RedisPy库）。</p></blockquote><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><blockquote><p>Redis 是一个<strong>基于内存</strong>的高效的键值型非关系型数据库，存取效率极高，而且支持多种存储数据结构。</p></blockquote><p>RedisPy 库提供两个类 Redis 和 StrictRedis 用于实现Redis 的命令操作。<br>推荐使用的是 StrictRedis，它实现了绝大部分Redis的命令，参数也一一对应。<br>Redis 主要用来兼容旧版本。</p><h2 id="连接-Redis"><a href="#连接-Redis" class="headerlink" title="连接 Redis"></a>连接 Redis</h2><p>首先需要确定正确在本地安装了Redis，并开启了服务。</p><h4 id="使用-StrictRedis-连接"><a href="#使用-StrictRedis-连接" class="headerlink" title="使用 StrictRedis 连接"></a>使用 StrictRedis 连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 这里使用的这几个参数和默认值是等效的，即可以直接使用 `StrictRedis()` 来代替。</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Foo&#x27;</span>)    <span class="comment"># 设置了一个键值对</span></span><br><span class="line">print(redis.get(<span class="string">&#x27;name&#x27;</span>))    <span class="comment"># 获取一个数据</span></span><br></pre></td></tr></table></figure><h4 id="使用-ConnectionPool-连接"><a href="#使用-ConnectionPool-连接" class="headerlink" title="使用 ConnectionPool 连接"></a>使用 ConnectionPool 连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"></span><br><span class="line">pool = ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="literal">None</span>)</span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">print(redis.get(<span class="string">&#x27;age&#x27;</span>))</span><br></pre></td></tr></table></figure><p>使用 ConnectionPool 还可以用 URL 来构建：</p><p>有三种可用的 URL 格式：</p><ul><li>Redis TCP 连接：<code>redis://[:password]@host:port/db</code></li><li>Redis TCP+SSL 连接：<code>rediss://[:password]@host:port/db</code></li><li>Redis Unix Socket连接：<code>unix://[:password]@/path/to/socket.sock?db=db</code></li></ul><p>使用的姿势如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"><span class="comment"># 注意多导入了一个ConnectionPool。</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;redis://@localhost:6379/0&#x27;</span></span><br><span class="line">pool = ConnectionPool.from_url(url)</span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">r = redis.get(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">print(<span class="built_in">type</span>(r), r, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Key-操作"><a href="#Key-操作" class="headerlink" title="Key 操作"></a>Key 操作</h2><p>这是一些常用的对 key 的操作，通过使用如 <code>redis.exists(&#39;neme&#39;)</code> 这样的语句来使用他们：</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>exists(name)</td><td>判断一个key是否存在</td><td>name: key名</td><td>redis.exists(‘name’)</td><td>是否存在name这个key</td><td>1</td></tr><tr><td>delete(name)</td><td>删除一个key</td><td>name: key名</td><td>redis.delete(‘name’)</td><td>删除name这个key</td><td>1</td></tr><tr><td>type(name)</td><td>判断key类型</td><td>name: key名</td><td>redis.type(‘name’)</td><td>判断name这个key类型</td><td>b’string’</td></tr><tr><td>keys(pattern)</td><td>获取所有符合规则的key</td><td>pattern: 匹配规则</td><td>redis.keys(‘n*’)</td><td>获取所有以n开头的key</td><td>[b’name’]</td></tr><tr><td>randomkey()</td><td>获取随机的一个key</td><td></td><td>randomkey()</td><td>获取随机的一个key</td><td>b’name’</td></tr><tr><td>rename(src, dst)</td><td>将key重命名</td><td>src: 原key名 dst: 新key名</td><td>redis.rename(‘name’, ‘nickname’)</td><td>将name重命名为nickname</td><td>True</td></tr><tr><td>dbsize()</td><td>获取当前数据库中key的数目</td><td></td><td>dbsize()</td><td>获取当前数据库中key的数目</td><td>100</td></tr><tr><td>expire(name, time)</td><td>设定key的过期时间，单位秒</td><td>name: key名 time: 秒数</td><td>redis.expire(‘name’, 2)</td><td>将name这key的过期时间设置2秒</td><td>True</td></tr><tr><td>ttl(name)</td><td>获取key的过期时间，单位秒，-1为永久不过期</td><td>name: key名</td><td>redis.ttl(‘name’)</td><td>获取name这key的过期时间</td><td>-1</td></tr><tr><td>move(name, db)</td><td>将key移动到其他数据库</td><td>name: key名 db: 数据库代号</td><td>move(‘name’, 2)</td><td>将name移动到2号数据库</td><td>True</td></tr><tr><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td></td><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td>True</td></tr><tr><td>flushall()</td><td>删除所有数据库中的所有key</td><td></td><td>flushall()</td><td>删除所有数据库中的所有key</td><td>True</td></tr></tbody></table><h2 id="String-操作"><a href="#String-操作" class="headerlink" title="String 操作"></a>String 操作</h2><p>String 是 Redis 中最基本的Value储存方式，他的操作如下，</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>set(name, value)</td><td>给数据库中key为name的string赋予值value</td><td>name: key名 value: 值</td><td>redis.set(‘name’, ‘Bob’)</td><td>给name这个key的value赋值为Bob</td><td>True</td></tr><tr><td>get(name)</td><td>返回数据库中key为name的string的value</td><td>name: key名</td><td>redis.get(‘name’)</td><td>返回name这个key的value</td><td>b’Bob’</td></tr><tr><td>getset(name, value)</td><td>给数据库中key为name的string赋予值value并返回上次的value</td><td>name: key名 value: 新值</td><td>redis.getset(‘name’, ‘Mike’)</td><td>赋值name为Mike并得到上次的value</td><td>b’Bob’</td></tr><tr><td>mget(keys, *args)</td><td>返回多个key对应的value</td><td>keys: key的列表</td><td>redis.mget([‘name’, ‘nickname’])</td><td>返回name和nickname的value</td><td>[b’Mike’, b’Miker’]</td></tr><tr><td>setnx(name, value)</td><td>如果key不存在才设置value</td><td>name: key名</td><td>redis.setnx(‘newname’, ‘James’)</td><td>如果newname这key不存在则设置值为James</td><td>第一次运行True，第二次False</td></tr><tr><td>setex(name, time, value)</td><td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td><td>name: key名 time: 有效期 value: 值</td><td>redis.setex(‘name’, 1, ‘James’)</td><td>将name这key的值设为James，有效期1秒</td><td>True</td></tr><tr><td>setrange(name, offset, value)</td><td>设置指定key的value值的子字符串</td><td>name: key名 offset: 偏移量 value: 值</td><td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td><td>设置name为Hello字符串，并在index为6的位置补World</td><td>11，修改后的字符串长度</td></tr><tr><td>mset(mapping)</td><td>批量赋值</td><td>mapping: 字典</td><td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td><td>将name1设为Durant，name2设为James</td><td>True</td></tr><tr><td>msetnx(mapping)</td><td>key均不存在时才批量赋值</td><td>mapping: 字典</td><td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td><td>在name3和name4均不存在的情况下才设置二者值</td><td>True</td></tr><tr><td>incr(name, amount=1)</td><td>key为name的value增值操作，默认1，key不存在则被创建并设为amount</td><td>name: key名 amount:增长的值</td><td>redis.incr(‘age’, 1)</td><td>age对应的值增1，若不存在则会创建并设置为1</td><td>1，即修改后的值</td></tr><tr><td>decr(name, amount=1)</td><td>key为name的value减值操作，默认1，key不存在则被创建并设置为-amount</td><td>name: key名 amount:减少的值</td><td>redis.decr(‘age’, 1)</td><td>age对应的值减1，若不存在则会创建并设置为-1</td><td>-1，即修改后的值</td></tr><tr><td>append(key, value)</td><td>key为name的string的值附加value</td><td>key: key名</td><td>redis.append(‘nickname’, ‘OK’)</td><td>向key为nickname的值后追加OK</td><td>13，即修改后的字符串长度</td></tr><tr><td>substr(name, start, end=-1)</td><td>返回key为name的string的value的子串</td><td>name: key名 start: 起始索引 end: 终止索引，默认-1截取到末尾</td><td>redis.substr(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr><tr><td>getrange(key, start, end)</td><td>获取key的value值从start到end的子字符串</td><td>key: key名 start: 起始索引 end: 终止索引</td><td>redis.getrange(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr></tbody></table><h2 id="List-操作"><a href="#List-操作" class="headerlink" title="List 操作"></a>List 操作</h2><p>List 是 Redis 中 value 为列表的一种数据。</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>rpush(name, *values)</td><td>在key为name的list尾添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.rpush(‘list’, 1, 2, 3)</td><td>给list这个key的list尾添加1、2、3</td><td>3，list大小</td></tr><tr><td>lpush(name, *values)</td><td>在key为name的list头添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.lpush(‘list’, 0)</td><td>给list这个key的list头添加0</td><td>4，list大小</td></tr><tr><td>llen(name)</td><td>返回key为name的list的长度</td><td>name: key名</td><td>redis.llen(‘list’)</td><td>返回key为list的列表的长度</td><td>4</td></tr><tr><td>lrange(name, start, end)</td><td>返回key为name的list中start至end之间的元素</td><td>name: key名 start: 起始索引 end: 终止索引</td><td>redis.lrange(‘list’, 1, 3)</td><td>返回起始为1终止为3的索引范围对应的list</td><td>[b’3’, b’2’, b’1’]</td></tr><tr><td>ltrim(name, start, end)</td><td>截取key为name的list，保留索引为start到end的内容</td><td>name:key名 start: 起始索引 end: 终止索引</td><td>ltrim(‘list’, 1, 3)</td><td>保留key为list的索引为1到3的元素</td><td>True</td></tr><tr><td>lindex(name, index)</td><td>返回key为name的list中index位置的元素</td><td>name: key名 index: 索引</td><td>redis.lindex(‘list’, 1)</td><td>返回key为list的列表index为1的元素</td><td>b’2’</td></tr><tr><td>lset(name, index, value)</td><td>给key为name的list中index位置的元素赋值，越界则报错</td><td>name: key名 index: 索引位置 value: 值</td><td>redis.lset(‘list’, 1, 5)</td><td>将key为list的list索引1位置赋值为5</td><td>True</td></tr><tr><td>lrem(name, count, value)</td><td>删除count个key的list中值为value的元素</td><td>name: key名 count: 删除个数 value: 值</td><td>redis.lrem(‘list’, 2, 3)</td><td>将key为list的列表删除2个3</td><td>1，即删除的个数</td></tr><tr><td>lpop(name)</td><td>返回并删除key为name的list中的首元素</td><td>name: key名</td><td>redis.lpop(‘list’)</td><td>返回并删除名为list的list第一个元素</td><td>b’5’</td></tr><tr><td>rpop(name)</td><td>返回并删除key为name的list中的尾元素</td><td>name: key名</td><td>redis.rpop(‘list’)</td><td>返回并删除名为list的list最后一个元素</td><td>b’2’</td></tr><tr><td>blpop(keys, timeout=0)</td><td>返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.blpop(‘list’)</td><td>返回并删除名为list的list的第一个元素</td><td>[b’5’]</td></tr><tr><td>brpop(keys, timeout=0)</td><td>返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.brpop(‘list’)</td><td>返回并删除名为list的list的最后一个元素</td><td>[b’2’]</td></tr><tr><td>rpoplpush(src, dst)</td><td>返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部</td><td>src: 源list的key dst: 目标list的key</td><td>redis.rpoplpush(‘list’, ‘list2’)</td><td>将key为list的list尾元素删除并返回并将其添加到key为list2的list头部</td><td>b’2’</td></tr></tbody></table><h2 id="Set-、Sorted-Set操作"><a href="#Set-、Sorted-Set操作" class="headerlink" title="Set 、Sorted Set操作"></a>Set 、Sorted Set操作</h2><p>详见 <a href="https://germey.gitbooks.io/python3webspider/content/5.3.2-Redis%E5%AD%98%E5%82%A8.html">Redis教程</a>。</p><h2 id="Hash-操作"><a href="#Hash-操作" class="headerlink" title="Hash 操作"></a>Hash 操作</h2><p>Redis 中可以用name指定一个哈希表的名称，然后表内存储了各个键值对。</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>hset(name, key, value)</td><td>向key为name的hash中添加映射</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hset(‘price’, ‘cake’, 5)</td><td>向key为price的hash中添加映射关系，cake的值为5</td><td>1，即添加的映射个数</td></tr><tr><td>hsetnx(name, key, value)</td><td>向key为name的hash中添加映射，如果映射键名不存在</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hsetnx(‘price’, ‘book’, 6)</td><td>向key为price的hash中添加映射关系，book的值为6</td><td>1，即添加的映射个数</td></tr><tr><td>hget(name, key)</td><td>返回key为name的hash中field对应的value</td><td>name: key名 key: 映射键名</td><td>redis.hget(‘price’, ‘cake’)</td><td>获取key为price的hash中键名为cake的value</td><td>5</td></tr><tr><td>hmget(name, keys, *args)</td><td>返回key为name的hash中各个键对应的value</td><td>name: key名 keys: 映射键名列表</td><td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td><td>获取key为price的hash中apple和orange的值</td><td>[b’3’, b’7’]</td></tr><tr><td>hmset(name, mapping)</td><td>向key为name的hash中批量添加映射</td><td>name: key名 mapping: 映射字典</td><td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td><td>向key为price的hash中批量添加映射</td><td>True</td></tr><tr><td>hincrby(name, key, amount=1)</td><td>将key为name的hash中映射的value增加amount</td><td>name: key名 key: 映射键名 amount: 增长量</td><td>redis.hincrby(‘price’, ‘apple’, 3)</td><td>key为price的hash中apple的值增加3</td><td>6，修改后的值</td></tr><tr><td>hexists(name, key)</td><td>key为namehash中是否存在键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hexists(‘price’, ‘banana’)</td><td>key为price的hash中banana的值是否存在</td><td>True</td></tr><tr><td>hdel(name, *keys)</td><td>key为namehash中删除键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hdel(‘price’, ‘banana’)</td><td>从key为price的hash中删除键名为banana的映射</td><td>True</td></tr><tr><td>hlen(name)</td><td>从key为name的hash中获取映射个数</td><td>name: key名</td><td>redis.hlen(‘price’)</td><td>从key为price的hash中获取映射个数</td><td>6</td></tr><tr><td>hkeys(name)</td><td>从key为name的hash中获取所有映射键名</td><td>name: key名</td><td>redis.hkeys(‘price’)</td><td>从key为price的hash中获取所有映射键名</td><td>[b’cake’, b’book’, b’banana’, b’pear’]</td></tr><tr><td>hvals(name)</td><td>从key为name的hash中获取所有映射键值</td><td>name: key名</td><td>redis.hvals(‘price’)</td><td>从key为price的hash中获取所有映射键值</td><td>[b’5’, b’6’, b’2’, b’6’]</td></tr><tr><td>hgetall(name)</td><td>从key为name的hash中获取所有映射键值对</td><td>name: key名</td><td>redis.hgetall(‘price’)</td><td>从key为price的hash中获取所有映射键值对</td><td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td></tr></tbody></table><h2 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h2><p>RedisDump 提供了 Redis 数据的导入和导出功能。</p><p>RedisDump 提供两个可执行命令：</p><ul><li><code>redis-dump</code> 用于 导出 数据；详见 <code>redis-dump -h</code><ul><li>e.g. <code>$ redis-dump -u :foobared@localhost:6379 &gt; ./redis_data.jl</code></li></ul></li><li><code>redis-load</code> 用于 导入 数据；详见 <code>redis-load -h</code><ul><li>e.g. <code>$ redis-load -u :foobared@localhost:6379 &lt; redis_data.json</code></li><li>等价于<code>$ cat redis_data.json | redis-load -u :foobared@localhost:6379</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之MongoDB</title>
      <link href="/2019/02/20/PythonAndCrawler/crawler-11-mongodb/"/>
      <url>/2019/02/20/PythonAndCrawler/crawler-11-mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫储存库的使用之MongoDB"><a href="#Python爬虫储存库的使用之MongoDB" class="headerlink" title="Python爬虫储存库的使用之MongoDB"></a>Python爬虫储存库的使用之MongoDB</h1><blockquote><p>本文主要介绍 Python 下 MongoDB 的使用（PyMongo库）。</p></blockquote><h2 id="MongoDB-简介"><a href="#MongoDB-简介" class="headerlink" title="MongoDB 简介"></a>MongoDB 简介</h2><blockquote><p>MongoDB 是由 C++ 语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似 Json 对象，它的字段值可以包含其他文档，数组及文档数组，非常灵活。</p></blockquote><p>在使用前要先确定 MongoDB 安装好，并已经开启了服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew services start mongodb</span><br><span class="line">$ sudo mongod</span><br><span class="line">$ mongo</span><br></pre></td></tr></table></figure><p>以上三条命令开启了 MongoDB 的服务，并打开客户端。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># client = pymongo.MongoClient(&#x27;mongodb://localhost:27017/&#x27;)    效果是一样的</span></span><br></pre></td></tr></table></figure><h2 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db = client.test</span><br><span class="line"><span class="comment"># db = client[&#x27;test&#x27;]   等价</span></span><br></pre></td></tr></table></figure><h2 id="指定集合"><a href="#指定集合" class="headerlink" title="指定集合"></a>指定集合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection = db.students    <span class="comment"># 还是可以用`[&#x27;&#x27;]`来取</span></span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>插入数据有3种方法：</p><ul><li><code>collection.insert()</code>：插入一个或多个数据，传入一个对象则插入一个，传入一个对象的list可以插入多个（官方不推荐使用）；</li><li><code>collection.insert_one()</code>：插入一个数据，传入一个dict；</li><li><code>collection.insert_many()</code>：插入多个数据，传入一个dict的list；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;2099133201&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;2099133202&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">student3 = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;2099133203&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Moo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">result0 = collection.insert_one(student1)</span><br><span class="line">result1 = collection.insert_many([student2, student3])</span><br><span class="line">print(result0, result0.inserted_id, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(result1, result1.inserted_ids, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询使用如下方法：</p><ul><li><code>find_one()</code>：查得单个结果</li><li><code>find()</code>：返回一个结果的生成器</li></ul><p>如果查询的结果不存在，会返回 <code>None</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res_of_find = collection.find()     <span class="comment"># 得到所有数据</span></span><br><span class="line">print(<span class="string">&#x27;find:\n&#x27;</span>, res_of_find)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res_of_find:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">res_of_findone = collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Foo&#x27;</span>&#125;)   <span class="comment"># 通过传入一组字典键值来查询</span></span><br><span class="line">print(<span class="string">&#x27;find_one:\n&#x27;</span>, res_of_findone)</span><br></pre></td></tr></table></figure><p>如果要通过 MongoDB 为每条数据添加的 <code>_id</code> 属性来查询，需要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res_of_find_by_id = collection.find_one(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5c78e0c6b92a4e5f17d70cfa&#x27;</span>)&#125;)</span><br><span class="line">print(<span class="string">&#x27;find by id:\n&#x27;</span>, res_of_find_by_id)</span><br></pre></td></tr></table></figure><p>如果要查询 “年龄大于10” 的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">10</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里查询条件的value变成了一个符号加运算值的字典，可用的操作如下：</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>$lt</code></td><td>小于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$lt&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$gt</code></td><td>大于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$gt&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$lte</code></td><td>小于等于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$lte&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$gte</code></td><td>大于等于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$gte&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$ne</code></td><td>不等于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$ne&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$in</code></td><td>在范围内</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$in&#39;: [20, 23]&#125;&#125;</code></td></tr><tr><td><code>$nin</code></td><td>不在范围内</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$nin&#39;: [20, 23]&#125;&#125;</code></td></tr></tbody></table><p>还有多种查询方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection.find(&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$regex&#x27;</span>: <span class="string">&#x27;^M.*&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>常用操作如下：</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>示例含义</th></tr></thead><tbody><tr><td><code>$regex</code></td><td>匹配正则</td><td><code>&#123;&#39;name&#39;: &#123;&#39;$regex&#39;: &#39;^M.*&#39;&#125;&#125;</code></td><td>name 以 M开头</td></tr><tr><td><code>$exists</code></td><td>属性是否存在</td><td><code>&#123;&#39;name&#39;: &#123;&#39;$exists&#39;: True&#125;&#125;</code></td><td>name 属性存在</td></tr><tr><td><code>$type</code></td><td>类型判断</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$type&#39;: &#39;int&#39;&#125;&#125;</code></td><td>age 的类型为 int</td></tr><tr><td><code>$mod</code></td><td>数字模操作</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$mod&#39;: [5, 0]&#125;&#125;</code></td><td>年龄模 5 余 0</td></tr><tr><td><code>$text</code></td><td>文本查询</td><td><code>&#123;&#39;$text&#39;: &#123;&#39;$search&#39;: &#39;Mike&#39;&#125;&#125;</code></td><td>text 类型的属性中包含 Mike 字符串</td></tr><tr><td><code>$where</code></td><td>高级条件查询</td><td><code>&#123;&#39;$where&#39;: &#39;obj.fans_count == obj.follows_count&#39;&#125;</code></td><td>自身粉丝数等于关注数</td></tr></tbody></table><h4 id="去掉-id"><a href="#去掉-id" class="headerlink" title="去掉 _id"></a>去掉 <code>_id</code></h4><p>Mongo 返回的数据中会有一项 <code>_id</code> （Mongo自动加入的用来识别对象的字段），我们常不想看它 ，可以在查询时加入对结果的过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection.find(projection=&#123;<span class="string">&#x27;_id&#x27;</span>: <span class="literal">False</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>要统计查询到的结果条数，可以直接调用查询结果的 <code>count()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">0</span>&#125;&#125;).count()</span><br></pre></td></tr></table></figure><hr><p>P.S. 一点题外话：</p><blockquote><p>写到这里，又是一个熄灯后的美丽夜晚。调暗屏幕背光，小心翼翼地捧起那蠢蠢欲动的白色樱桃机械键盘，把它安置到光明之外，避开红绿蓝的纷争。趁着这五彩缤纷的黑暗，把下一行让人迷醉的代码，作为虔诚的礼物，送给饥饿良久的编译器。静待她施展动人的魔法，变出一串没有间断点的二进制位向量，在 0 和 1 的排列组合中，光影流转，似现星河鹭起，似有高山流水。在心驰神往的一瞬，不妨再分个神，欣赏开和关之间，一扇回到未来的古朴大门。</p></blockquote><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>我们可以通过调用 <code>sort()</code> 方法，传入用来排序的字段、升降序的标志即可对查询的结果排序。</p><ul><li><code>pymongo.ASCENDING</code>：指定升序；</li><li><code>pymongo.DESCENDING</code>：指定降序；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r:</span><br><span class="line">    print(i[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><p>偏移：偏移x个元素，即忽略（跳过）前面的x个元素，得到第x+1开始个元素。<br>这个操作调用查询结果的 <code>skip()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = collection.find().skip(<span class="number">2</span>)</span><br><span class="line">print([i <span class="keyword">for</span> i <span class="keyword">in</span> r])</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新与插入类似，主要有三种方法：</p><ul><li><code>update()</code>：更新一条或多条数据，不推荐使用</li><li><code>update_one()</code>：更新一条数据</li><li><code>update_many()</code>：更新多条数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Foo&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: student&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>这里，我们先查询出了目标条目，然后把它修改成了新的数据，调用update，传入查询条件和一个代表操作的字典完成更新。<br>常用的操作有:</p><ul><li><code>$set</code>: <code>&#123;&#39;$set&#39;: value&#125;</code>: 把value中有的属性更新成新的</li><li><code>$inc</code>: <code>&#123;&#39;$inc&#39;: &#123;&#39;age&#39;: 1&#125;&#125;</code>: 把age加1</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>也是有三个：<code>remove()</code>，<code>delete_one()</code>，<code>delete_many()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection.remove(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Kevin&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更完善的MongoDB还在官网等待我们去学习：<a href="http://api.mongodb.com/python/current/api/pymongo/">官方文档🔗链接</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之MySQL</title>
      <link href="/2019/02/19/PythonAndCrawler/crawler-10-mysql/"/>
      <url>/2019/02/19/PythonAndCrawler/crawler-10-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫储存库的使用之MySQL"><a href="#Python爬虫储存库的使用之MySQL" class="headerlink" title="Python爬虫储存库的使用之MySQL"></a>Python爬虫储存库的使用之MySQL</h1><blockquote><p>本文主要介绍 Python 下 MySQL 的使用（PyMySQL库）。</p></blockquote><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>我们现在来连接位于本地的MySQL数据库，在这之前要先确定本地的MYSQL正在运行，且处于可访问的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  <span class="comment"># 导入库</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;*&#x27;</span>, password=<span class="string">&#x27;***&#x27;</span>) <span class="comment"># 连接数据库，还可以传入 port = 整数值 来指定端口，这里使用默认值（3306）。</span></span><br><span class="line">cursor = db.cursor()    <span class="comment"># 获取 MySQL 操作游标，利用操作游标才能执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT VERSION()&#x27;</span>)  <span class="comment"># 执行SQL语句</span></span><br><span class="line">data = cursor.fetchone()    <span class="comment"># 获取第一条数据</span></span><br><span class="line">print(<span class="string">&quot;Database Version:&quot;</span>, data)</span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8&quot;</span>)    <span class="comment"># 新建一个用来爬虫的数据库</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>, user=<span class="string">&quot;*&quot;</span>, password=<span class="string">&quot;***&quot;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)    <span class="comment"># 直接连接到刚才新建的数据库</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&#x27;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))&#x27;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h4 id="使用一系列变量插入"><a href="#使用一系列变量插入" class="headerlink" title="使用一系列变量插入"></a>使用一系列变量插入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span> = <span class="string">&#x27;2099133201&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;Foo.Bar&#x27;</span></span><br><span class="line">age = <span class="number">101</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;*&#x27;</span>, password=<span class="string">&#x27;***&#x27;</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO students (id, name, age) VALUES (%s, %s, %s)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (<span class="built_in">id</span>, name, age))</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p>⚠️【注意】：</p><ol><li>我们在execute的时候并不必使用python的方法把字符串提前构造好，可以在需要插入的地方使用 <code>%s</code>，然后运行execute的时候把参数列表用一个元组传入即可，然而，这样做的重点是：<strong>避免引号的问题！</strong>。</li><li>注意MySQL的事务机制，对于数据库的 <strong>插入、更新、删除</strong> 操作的标准模版是：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(‘更改操作语句’)</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br></pre></td></tr></table></figure><h4 id="使用字典插入"><a href="#使用字典插入" class="headerlink" title="使用字典插入"></a>使用字典插入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;*&#x27;</span>, password=<span class="string">&#x27;***&#x27;</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;2099133202&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Fuzz.Buzz&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;104&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line"></span><br><span class="line">keys = <span class="string">&#x27;, &#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;INSERT  INTO &#123;table&#125; (&#123;keys&#125;) VALUES (&#123;values&#125;)&#x27;</span>.<span class="built_in">format</span>(table=table, keys=keys, values=values)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql, <span class="built_in">tuple</span>(data.values())):</span><br><span class="line">        print(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;Failed:\n&#x27;</span>, e)</span><br><span class="line">    db.rollback()</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p>在这个例子中如果不使用 <code>%s</code> + 传入 tuple 的那个方法动态构造语句，而直接用 <code>values = &#39;, &#39;.join(data.values())</code> 然后 <code>cursor.execute(sql)</code> 就会 Failed 了。</p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><h4 id="简单的数据更新"><a href="#简单的数据更新" class="headerlink" title="简单的数据更新"></a>简单的数据更新</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&#x27;UPDATE students SET age = %s WHERE name = %s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (<span class="number">999</span>, <span class="string">&#x27;Foo.Bar&#x27;</span>))</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h4 id="更实用的字典更新"><a href="#更实用的字典更新" class="headerlink" title="更实用的字典更新"></a>更实用的字典更新</h4><p>在实际数据抓取过程中，如果出现了重复数据，我们更希望的做法是更新数据：<br>如果重复则更新数据，如果数据不存在则插入数据，另外支持灵活的字典传值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;*&#x27;</span>, password=<span class="string">&#x27;***&#x27;</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;2099133203&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;SomeOne&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line"></span><br><span class="line">keys = <span class="string">&#x27;, &#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO &#123;table&#125; (&#123;keys&#125;) VALUES (&#123;values&#125;) ON DUPLICATE KEY UPDATE&#x27;</span>.<span class="built_in">format</span>(table=table, keys=keys, values=values)</span><br><span class="line">update = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27; &#123;key&#125; = %s&#x27;</span>.<span class="built_in">format</span>(key=key) <span class="keyword">for</span> key <span class="keyword">in</span> data])</span><br><span class="line"></span><br><span class="line">sql += update</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql, <span class="built_in">tuple</span>(data.values()) * <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;Failed:\n&#x27;</span>, e)</span><br><span class="line">    db.rollback()</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;*&#x27;</span>, password=<span class="string">&#x27;***&#x27;</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">condition = <span class="string">&#x27;age &gt; 200&#x27;</span></span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;DELETE FROM &#123;table&#125; WHERE &#123;condition&#125;&#x27;</span>.<span class="built_in">format</span>(table=table, condition=condition)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&#x27;SELECT * FROM students&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    print(<span class="string">&#x27;Count:&#x27;</span>, cursor.rowcount)</span><br><span class="line">    one = cursor.fetchone()</span><br><span class="line">    print(<span class="string">&#x27;One:&#x27;</span>, one)</span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    print(<span class="string">&#x27;Results:&#x27;</span>, results)</span><br><span class="line">    print(<span class="string">&#x27;Results Type:&#x27;</span>, <span class="built_in">type</span>(results))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        print(row)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&#x27;Error&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之CSV</title>
      <link href="/2019/02/18/PythonAndCrawler/crawler-9-csv/"/>
      <url>/2019/02/18/PythonAndCrawler/crawler-9-csv/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫储存库的使用之CSV"><a href="#Python爬虫储存库的使用之CSV" class="headerlink" title="Python爬虫储存库的使用之CSV"></a>Python爬虫储存库的使用之CSV</h1><blockquote><p>本文主要介绍储存库 CSV 的使用。</p></blockquote><h2 id="CSV-简介"><a href="#CSV-简介" class="headerlink" title="CSV 简介"></a>CSV 简介</h2><p><strong>CSV</strong>（Comma-Separated Values），<strong>逗号分隔值</strong>，或<strong>字符分隔值</strong>，以纯文本形式储存表格数据。一个CSV文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id,name,age</span><br><span class="line">0,foo,10</span><br><span class="line">1,bar,11</span><br><span class="line">2,foobar,100</span><br></pre></td></tr></table></figure><h2 id="Python-写-CSV"><a href="#Python-写-CSV" class="headerlink" title="Python 写 CSV"></a>Python 写 CSV</h2><h4 id="列表写入-CSV"><a href="#列表写入-CSV" class="headerlink" title="列表写入 CSV"></a>列表写入 CSV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">d = [[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;10&#x27;</span>], [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;11&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;foobar&#x27;</span>, <span class="string">&#x27;100&#x27;</span>]]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)    <span class="comment"># 要改分隔符，可以传入`delimiter=&#x27;分隔符&#x27;`</span></span><br><span class="line">    </span><br><span class="line">    writer.writerow([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])  <span class="comment"># 写一行，传入list</span></span><br><span class="line">    writer.writerows(d)     <span class="comment"># 写入多行，传入二维list</span></span><br></pre></td></tr></table></figure><p>⚠️【注意】写中文的时候，要在open的时候传入 <code>encoding=&#39;utf-8&#39;</code>，防止乱码。</p><h4 id="字典写入-CSV"><a href="#字典写入-CSV" class="headerlink" title="字典写入 CSV"></a>字典写入 CSV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    fieldnames = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;fuzz&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;666&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="Python-读-CSV"><a href="#Python-读-CSV" class="headerlink" title="Python 读 CSV"></a>Python 读 CSV</h2><h4 id="用-CSV库-读取"><a href="#用-CSV库-读取" class="headerlink" title="用 CSV库 读取"></a>用 CSV库 读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.reader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(<span class="built_in">type</span>(row), row)</span><br></pre></td></tr></table></figure><p>从结果中可以看到，读取出来的是各行的list。</p><h4 id="用-Pandas库-读取"><a href="#用-Pandas库-读取" class="headerlink" title="用 Pandas库 读取"></a>用 Pandas库 读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="built_in">type</span>(df))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之PyQuery</title>
      <link href="/2019/02/17/PythonAndCrawler/crawler-8-pyquery/"/>
      <url>/2019/02/17/PythonAndCrawler/crawler-8-pyquery/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫解析库的使用之PyQuery"><a href="#Python爬虫解析库的使用之PyQuery" class="headerlink" title="Python爬虫解析库的使用之PyQuery"></a>Python爬虫解析库的使用之PyQuery</h1><blockquote><p>本文主要介绍解析库 PyQuery 的使用。</p></blockquote><h2 id="PyQuery"><a href="#PyQuery" class="headerlink" title="PyQuery"></a>PyQuery</h2><blockquote><p>pyquery: a jquery-like library for python</p></blockquote><p>PyQuery 的使用方法和jQuery基本相同。</p><p>⚠️【注意】需要安装好 PyQuery。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>PyQuery 初始化时可以传入多种形式的数据源，如内容是 HTML 的字符串、源的URL、本地的文件名等。</p><h5 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;h1&gt;Header&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;Something&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;Other thing&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;In div&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">doc = pq(html)      <span class="comment"># 传入HTML字符串</span></span><br><span class="line">print(doc(<span class="string">&#x27;p&#x27;</span>))     <span class="comment"># 传入CSS选择器</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(results)</span></span><br><span class="line"><span class="string">&lt;p&gt;Something&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;Other thing&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;In div&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="URL初始化"><a href="#URL初始化" class="headerlink" title="URL初始化"></a>URL初始化</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(url=<span class="string">&#x27;http://www.baidu.com&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)      <span class="comment"># 这里不写encoding可能中文乱码</span></span><br><span class="line">print(doc(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(result)</span></span><br><span class="line"><span class="string">&lt;title&gt;百度一下，你就知道&lt;/title&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>详见 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器表</a>。</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ul><li>查找<strong>子</strong>节点用 <code>children(&#39;css-selector&#39;)</code> 方法，参数为空则为全部。</li><li>查找<strong>子孙</strong>节点用 <code>find(&#39;css-selector&#39;)</code> 方法，<strong>参数不可为空！</strong></li><li>查找<strong>父</strong>节点用 <code>parent(&#39;css-selector&#39;)</code> 方法，参数为空则为全部。</li><li>查找<strong>祖先</strong>节点用 <code>parents(&#39;css-selector&#39;)</code> 方法，参数为空则为全部。</li><li>查找<strong>兄弟</strong>节点用 <code>siblings(&#39;css-selector&#39;)</code> 方法，参数为空则为全部。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = doc(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">[&lt;div<span class="comment">#wrapper&gt;, &lt;div#head&gt;, &lt;div.head_wrapper&gt;, &lt;div.s_form&gt;, &lt;div.s_form_wrapper&gt;, &lt;div#lg&gt;, &lt;div#u1&gt;, &lt;div#ftCon&gt;, &lt;div#ftConw&gt;]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pyquery</span>.<span class="title">pyquery</span>.<span class="title">PyQuery</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">p</span>.<span class="title">find</span>(<span class="params"><span class="string">&#x27;#head&#x27;</span></span>)</span></span><br><span class="line"><span class="class">[&lt;<span class="title">div</span>#<span class="title">head</span>&gt;]</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">p.find(<span class="params"><span class="string">&#x27;#head&#x27;</span></span>)</span>)</span></span><br><span class="line">&lt;div id=&quot;head&quot;&gt; ... &lt;/div&gt; </span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>用 PyQuery 选择到的结果可以遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span>  p.parent():</span><br><span class="line"><span class="meta">... </span>    print(i, <span class="built_in">type</span>(i))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&lt;Element a at <span class="number">0x1055332c8</span>&gt; &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">lxml</span>.<span class="title">html</span>.<span class="title">HtmlElement</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">Element</span> <span class="title">a</span> <span class="title">at</span> 0<span class="title">x105533368</span>&gt; &lt;<span class="title">class</span> &#x27;<span class="title">lxml</span>.<span class="title">html</span>.<span class="title">HtmlElement</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">Element</span> <span class="title">a</span> <span class="title">at</span> 0<span class="title">x105533458</span>&gt; &lt;<span class="title">class</span> &#x27;<span class="title">lxml</span>.<span class="title">html</span>.<span class="title">HtmlElement</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>注意是lxml的Element了，要用lxml的方法处理。</p><h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><h5 id="attr-获取属性"><a href="#attr-获取属性" class="headerlink" title="attr() 获取属性"></a><code>attr()</code> 获取属性</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = doc(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">print(a.attr(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure><p>attr() 必须传入要选择的属性名。<br>若对象包含多个节点，调用对象的attr()，只会返回第一个对象的对应结果。要返回每一个的需要遍历。</p><h5 id="text-获取文本"><a href="#text-获取文本" class="headerlink" title="text() 获取文本"></a><code>text()</code> 获取文本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = doc(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a.text()</span><br></pre></td></tr></table></figure><p>这个会输出所有包含节点的文本join的结果。</p><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><p>PyQuery 还可以操作节点，这个不是重点。</p>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之BeautifulSoup</title>
      <link href="/2019/02/16/PythonAndCrawler/crawler-7-beautifulsoup/"/>
      <url>/2019/02/16/PythonAndCrawler/crawler-7-beautifulsoup/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫解析库的使用之BeautifulSoup"><a href="#Python爬虫解析库的使用之BeautifulSoup" class="headerlink" title="Python爬虫解析库的使用之BeautifulSoup"></a>Python爬虫解析库的使用之BeautifulSoup</h1><blockquote><p>本文主要介绍解析库 BeautifulSoup 的使用。</p></blockquote><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><blockquote><p>BeautifulSoup 提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它通过解析文档为用户提供需要抓取的数据。利用它我们可以提高解析效率。</p></blockquote><p>BeautifulSoup 拥有完善的官方中文文档，可以查看 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">BeautifulSoup官方文档</a></p><p>⚠️【注意】需要安装好 BeautifulSoup 和 LXML。</p><p>BeautifulSoup 可以使用多种解析器，主要的几种如下：</p><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前的版本中文容错能力差</td></tr><tr><td>LXML HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>LXML XML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成 HTML5 格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><p>我们一般使用 LXML 解析器来进行解析，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;lxml&#x27;</span>)    </span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><h4 id="BeaufulSoup对象的初始化"><a href="#BeaufulSoup对象的初始化" class="headerlink" title="BeaufulSoup对象的初始化"></a>BeaufulSoup对象的初始化</h4><p>使用如下代码就可以导入HTML，完成BeautifulSoup对象的初始化，并自动更正（如闭合未闭合的标签）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(markup, <span class="string">&quot;lxml&quot;</span>)   <span class="comment"># markup 是 HTML 的 str</span></span><br></pre></td></tr></table></figure><p>初始化之后我们还可以对要解析的字符串以标准的缩进格式输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure><h4 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h4><h5 id="选择标签"><a href="#选择标签" class="headerlink" title="选择标签"></a>选择标签</h5><p>选择元素的时候直接通过调用节点的名称就可以选择节点元素，<br>调用 string 属性就可以得到节点内的文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(soup.title)           <span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(soup.title))     <span class="comment"># &lt;class &#x27;bs4.element.Tag&#x27;&gt;</span></span><br><span class="line">print(soup.title.string)    <span class="comment"># The Dormouse&#x27;s story</span></span><br><span class="line">print(soup.head)            <span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line">print(soup.p)               <span class="comment"># &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><h5 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h5><p>我们还可以进行 <strong>嵌套选择</strong>，即做类似 <code>父.子.孙</code> 的选择：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.head.title.string)</span><br></pre></td></tr></table></figure><h5 id="关联选择"><a href="#关联选择" class="headerlink" title="关联选择"></a>关联选择</h5><p>有时候我们难以做到一步就可以选择到想要的节点元素，这时我们可以先选中某一个节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等等</p><h6 id="获取子孙节点"><a href="#获取子孙节点" class="headerlink" title="获取子孙节点"></a>获取<strong>子孙节点</strong></h6><p>选取到了一个节点元素之后，如果想要获取它的直接 <strong>子节点</strong> 可以调用 <code>contents</code> 属性，将返回一个依次列有所有子节点的list。</p><p>如p标签之类的节点中可能既包含文本，又包含节点，返回的结果会将他们以列表形式都统一返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">soup.p.contents     <span class="comment"># 注意里面的文字被切成了几部分</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(result)</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#x27;Once upon a time ... were\n&#x27;,</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;sister&quot; href=&quot;...&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">    &#x27;,\n&#x27;,</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;sister&quot; href=&quot;...&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">    &#x27; and\n&#x27;,</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;sister&quot; href=&quot;...&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">    &#x27;;\nand ... well.&#x27;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>同时，查询 <strong>子节点</strong>，我们还可以使用 <code>children</code> 属性，它将返回一个 list_iterator object，化为 list 之后，就和 contents 一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.p.children</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x109d6a8d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">list</span>(soup.p.children)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = soup.p.contents</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>我们可以逐个编号输出子节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, child <span class="keyword">in</span> <span class="built_in">enumerate</span>(soup.p.children):</span><br><span class="line">    print(i, child)</span><br></pre></td></tr></table></figure><p>要得到所有的 <strong>子孙节点</strong>（所有下属节点）的话可以调用 descendants 属性，descendants 会递归地查询所有子节点（深度优先），得到的是所有的子孙节点，返回结果是一个 <code>&lt;generator object Tag.descendants at 0x109d297c8&gt;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.descendants)</span><br><span class="line"><span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(soup.p.descendants):</span><br><span class="line">    print(i, d)</span><br></pre></td></tr></table></figure><h6 id="获取父节点和祖先节点"><a href="#获取父节点和祖先节点" class="headerlink" title="获取父节点和祖先节点"></a>获取父节点和祖先节点</h6><p>如果要获取某个节点元素的父节点，可以调用 <code>parent</code> 属性，返回一个节点:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.span.parent</span><br><span class="line"><span class="comment"># 结果是 &lt;p&gt;...&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们要想获取所有的祖先节点(一层层向上找，直到整个html)，可以调用 <code>parents</code> 属性，返回一个generator：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.span.parents</span><br><span class="line">&lt;generator <span class="built_in">object</span> PageElement.parents at <span class="number">0x109d29ed0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(soup.span.parents)</span><br><span class="line"><span class="comment"># 结果是 [&lt;p&gt;...&lt;/p&gt;, &lt;div&gt;...&lt;/div&gt;, &lt;body&gt;...&lt;/body&gt;, &lt;html&gt;...&lt;/html&gt;]</span></span><br></pre></td></tr></table></figure><p>⚠️【注意】父是 parent，祖先是 parents</p><h6 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h6><p>要获取同级的节点也就是兄弟节点，我们可以调用了四个不同的属性，它们的作用不尽相同：</p><ul><li>next_sibling：获取节点<strong>向下一个</strong>兄弟节点，返回节点。</li><li>previous_sibling：获取<strong>向上一个</strong>兄弟节点，返回节点。</li><li>next_siblings：获取<strong>向下所有</strong>兄弟节点，返回一个generator。</li><li>previous_siblings：获取<strong>向上所有</strong>兄弟节点，返回一个generator。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;html&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;body&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;p class=&quot;story&quot;&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>                &lt;span&gt;Elsie&lt;/span&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            Hello</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span></span><br><span class="line"><span class="string"><span class="meta">... </span>            and</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            and they lived at the bottom of a well.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a.next_sibling</span><br><span class="line"><span class="string">&#x27;\n            Hello\n            &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a.previous_sibling</span><br><span class="line"><span class="string">&#x27;\n            Once upon a time there were three little sisters; and their names were\n            &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a.next_siblings</span><br><span class="line">&lt;generator <span class="built_in">object</span> PageElement.next_siblings at <span class="number">0x1110e57c8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a.previous_siblings</span><br><span class="line">&lt;generator <span class="built_in">object</span> PageElement.previous_siblings at <span class="number">0x1110e5de0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> soup.a.previous_siblings:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line">            Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">            </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> soup.a.next_siblings:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line">            Hello</span><br><span class="line">            </span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">and</span></span><br><span class="line">            </span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><p>有时难以利用节点选择器直接找到想要的节点时，我们可以利用 find_all()、find() 等方法，传入相应等参数就可以灵活地进行查询，得到想要的节点，然后通过关联选择就可以轻松获取需要的信息。</p><h5 id="find"><a href="#find" class="headerlink" title="find()"></a><code>find()</code></h5><p>find() 传入一些属性或文本来得到符合条件的元素，返回第一个匹配的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(name , attrs , recursive , text , **kwargs)</span><br></pre></td></tr></table></figure><p>使用实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;panel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;panel-heading&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;panel-body&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.find(name=<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">print(soup.find(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;element&#x27;</span>&#125;))</span><br><span class="line">print(soup.find(text=re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?o.*?&#x27;</span>, re.S)))      <span class="comment"># 结果会返回匹配正则表达式的第一个节点的文本（结果不是节点）</span></span><br></pre></td></tr></table></figure><h5 id="findall"><a href="#findall" class="headerlink" title="findall()"></a><code>findall()</code></h5><p>find_all，类似于 find，但是 find_all 查询所有符合条件的元素，返回所有匹配的元素组成的列表。</p><h5 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h5><p>还有诸如find_parents()、find_next_siblings()、find_previous_siblings()等的find，基本使用都差不多，只是搜索范围不同，详见 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">文档</a>。</p><hr><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>BeautifulSoup 还提供了 CSS 选择器。<br>使用 CSS 选择器，只需要调用 select() 方法，传入相应的 CSS 选择器即可，返回的结果是符合 CSS 选择器的节点组成的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;panel&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;panel-heading&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;panel-body&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.select(<span class="string">&#x27;.panel .panel-heading&#x27;</span>))</span><br><span class="line">print(soup.select(<span class="string">&#x27;ul li&#x27;</span>))</span><br><span class="line">print(soup.select(<span class="string">&#x27;#list-2 .element&#x27;</span>))</span><br><span class="line">print(<span class="built_in">type</span>(soup.select(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><hr><h4 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h4><h5 id="获取完整标签"><a href="#获取完整标签" class="headerlink" title="获取完整标签"></a>获取完整标签</h5><p>要获取一个标签的完整html代码，只需要写它的节点选择器即可： </p><p><code>soup.title</code></p><h5 id="获取标签类型"><a href="#获取标签类型" class="headerlink" title="获取标签类型"></a>获取标签类型</h5><p>利用 name 属性来获取节点的类型（p、a、title、pre 等）：</p><p><code>print(soup.title.name)</code></p><h5 id="获取标签内容"><a href="#获取标签内容" class="headerlink" title="获取标签内容"></a>获取标签内容</h5><p>正如我们之前所说，调用 string 属性就可以得到节点内的文本：</p><p><code>soup.title.string</code></p><p>⚠️【注意】如果标签下包含其他标签，<code>.string</code> 是不起作用的，它会返回一个 None：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&#x27;&lt;p&gt;Foo&lt;a href=&quot;#None&quot;&gt;Bar&lt;/a&gt;&lt;/p&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p.string)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>获取内容，还可以使用节点的 get_text() 方法：</p><p><code>soup.p.get_text()</code></p><p>利用get_text，可以获取标签下所有文本，包括其子节点中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&#x27;&lt;p&gt;Foo&lt;a href=&quot;#None&quot;&gt;Bar&lt;/a&gt;&lt;/p&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p.string)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p.get_text())</span><br><span class="line">FooBar</span><br></pre></td></tr></table></figure><h5 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h5><p>每个节点可能有多个属性，比如 id，class，我们可以调用 attrs 获取所有属性，进而可以通过字典的取值方法(中括号加属性名称，或调用其<code>get()</code>方法)获取特定属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.attrs)</span><br><span class="line">print(soup.p.attrs[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(results)</span></span><br><span class="line"><span class="string">&#123;&#x27;class&#x27;: [&#x27;title&#x27;], &#x27;name&#x27;: &#x27;dromouse&#x27;&#125;</span></span><br><span class="line"><span class="string">dromouse</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>也可以直接使用中括号和属性名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">&#x27;ul&#x27;</span>):</span><br><span class="line">    print(ul[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    print(ul.attrs[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    <span class="comment"># 循环体的两行代码等效</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之LXML</title>
      <link href="/2019/02/15/PythonAndCrawler/crawler-6-lxml/"/>
      <url>/2019/02/15/PythonAndCrawler/crawler-6-lxml/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫解析库的使用之LXML"><a href="#Python爬虫解析库的使用之LXML" class="headerlink" title="Python爬虫解析库的使用之LXML"></a>Python爬虫解析库的使用之LXML</h1><blockquote><p>本文主要介绍 XPath 和解析库 LXML 的使用。</p></blockquote><h2 id="XPath-amp-LXML"><a href="#XPath-amp-LXML" class="headerlink" title="XPath &amp; LXML"></a>XPath &amp; LXML</h2><p>XPath (XML Path Language) 是设计来在XML文档中查找信息的语言，它同样适用于HTML。</p><p>我们在爬虫时，可以使用 XPath 来做相应的信息抽取。</p><p>⚠️【注意】需要安装好 LXML。</p><h4 id="XPath常用规则"><a href="#XPath常用规则" class="headerlink" title="XPath常用规则"></a>XPath常用规则</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>nodename</code></td><td>选取此节点的所有子节点</td></tr><tr><td><code>/</code></td><td>从当前节点选取直接子节点</td></tr><tr><td><code>//</code></td><td>从当前节点选取子孙节点</td></tr><tr><td><code>.</code></td><td>选取当前节点</td></tr><tr><td><code>..</code></td><td>选取当前节点的父节点</td></tr><tr><td><code>@</code></td><td>选取属性</td></tr></tbody></table><p>我们常用 <code>//</code> 开头的 XPath 规则来选取所有符合要求的节点。</p><p>另外，常用运算符见 <a href="http://www.w3school.com.cn/xpath/xpath_operators.asp">XPath 运算符</a>。</p><h4 id="导入-HTML"><a href="#导入-HTML" class="headerlink" title="导入 HTML"></a>导入 HTML</h4><h5 id="从字符串导入-HTML"><a href="#从字符串导入-HTML" class="headerlink" title="从字符串导入 HTML"></a>从字符串导入 HTML</h5><p>导入了 LXML 库的 etree 模块，然后声明了一段 HTML 文本，调用 HTML 类进行初始化，这样我们就成功构造了一个 XPath 解析对象。</p><p>⚠️【注意】etree 模块可以对 HTML 文本进行修正。</p><p>调用 tostring() 方法即可输出修正后的 HTML 代码，结果是 bytes 类型（可以利用 decode() 方法转成 str 类型）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h5 id="从文件导入-HTML"><a href="#从文件导入-HTML" class="headerlink" title="从文件导入 HTML"></a>从文件导入 HTML</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><h5 id="获取所有节点"><a href="#获取所有节点" class="headerlink" title="获取所有节点"></a>获取所有节点</h5><p>获取一个 HTML 中的所有节点，使用规则 <code>//*</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line"></span><br><span class="line">result = html.xpath(<span class="string">&#x27;//*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>我们得到了一个 由 Element 类型组成的列表。</p><h5 id="获取所有指定标签"><a href="#获取所有指定标签" class="headerlink" title="获取所有指定标签"></a>获取所有指定标签</h5><p>如果我们想获取所有 li 标签，我们可以把上例中的html.xpath() 中的规则改为 <code>&#39;//li&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>如果无法获取任何匹配结果，html.xpath 将会返回 <code>[]</code></p><h5 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h5><p>选择 li 节点所有直接 a 子节点，使用规则 <code>&#39;//li/a&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>要获取其下所有子孙a节点可以这样：<code>//li//a</code></p><h5 id="获取特定属性的节点"><a href="#获取特定属性的节点" class="headerlink" title="获取特定属性的节点"></a>获取特定属性的节点</h5><p>用 @ 符号进行属性过滤。<br>smt[…] 是有 … 限制的smt。</p><p>选中 href 是 link4.html 的 a 节点，规则是 <code>&#39;//a[@href=&quot;link4.html&quot;]</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//a[@href=&quot;link4.html&quot;]&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h5 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h5><p>如果我们想获取上例的父节点, 然后再获取其 class 属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//a[@href=&quot;link4.html&quot;]/../@class&#x27;</span>)</span><br><span class="line"><span class="comment"># 也可以用“节点轴” &#x27;//a[@href=&quot;link4.html&quot;]/parent::*/@class&#x27;</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>关于节点轴的使用，详见 <a href="http://www.w3school.com.cn/xpath/xpath_axes.asp">XPath Axes</a></p><h5 id="获取节点中的的文本"><a href="#获取节点中的的文本" class="headerlink" title="获取节点中的的文本"></a>获取节点中的的文本</h5><p>XPath 中的 text() 方法可以获取节点中的直接文本（不包括其子节点中的文本）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[@class=&quot;item-0&quot;]/text()&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h5 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./test.html&#x27;</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a/@href&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>用上面这种方法只能获取只有一个值的属性，<br>对于下面这种：</p><p><code>&lt;li class=&quot;li li-first&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</code></p><p> li 节点的 class 属性有两个值，上面这个方法会失效，我们可以使用 contains() 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = e<span class="comment">#tree.HTML(text)</span></span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[contains(@class, &quot;li&quot;)]/a/text()&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>这里还可以使用运算符 and 来连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot; name=&quot;item&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[contains(@class, &quot;li&quot;) and @name=&quot;item&quot;]/a/text()&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>点击链接查看详细的 <a href="http://www.w3school.com.cn/xpath/index.asp">XPath 教程</a> 、 <a href="https://lxml.de/">lxml 库</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫抓取电影排行</title>
      <link href="/2019/02/14/PythonAndCrawler/crawler-5-ex-topmoives/"/>
      <url>/2019/02/14/PythonAndCrawler/crawler-5-ex-topmoives/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫基本库实践-–-抓取电影排行"><a href="#爬虫基本库实践-–-抓取电影排行" class="headerlink" title="爬虫基本库实践 – 抓取电影排行"></a>爬虫基本库实践 – 抓取电影排行</h1><blockquote><p>爬虫实践：利用 Requests 和正则表达式来抓取猫眼电影 TOP100 的相关内容。</p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们打算提取出 <a href="http://maoyan.com/board/4">猫眼电影 TOP100 榜</a> 的电影名称、时间、评分、图片等信息，提取的结果我们以文件形式保存下来。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>系统环境：macOS High Sierra 10.13.6</li><li>开发语言：Python 3.7.2 (default)</li><li>第三方库：Requests</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><a href="https://maoyan.com/board/4">目标站点</a>：<code>https://maoyan.com/board/4</code></p><p>打开页面后我们可以发现，页面中显示的有效信息有 <strong>影片名称</strong>、<strong>主演</strong>、<strong>上映时间</strong>、<strong>上映地区</strong>、<strong>评分</strong>、<strong>图片</strong>。</p><p>然后，我们查看一下排名第一的条目的 html 源码，一会儿我们就从这段代码入手设计正则表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;board-index board-index-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/films/1203&quot;</span> <span class="attr">title</span>=<span class="string">&quot;霸王别姬&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-link&quot;</span> <span class="attr">data-act</span>=<span class="string">&quot;boarditem-click&quot;</span> <span class="attr">data-val</span>=<span class="string">&quot;&#123;movieId:1203&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;//s0.meituan.net/bs/?f=myfe/mywww:/image/loading_2.e3d934bf.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">class</span>=<span class="string">&quot;poster-default&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">alt</span>=<span class="string">&quot;霸王别姬&quot;</span> <span class="attr">class</span>=<span class="string">&quot;board-img&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;board-item-main&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;board-item-content&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;movie-item-info&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/films/1203&quot;</span> <span class="attr">title</span>=<span class="string">&quot;霸王别姬&quot;</span> <span class="attr">data-act</span>=<span class="string">&quot;boarditem-click&quot;</span></span></span><br><span class="line"><span class="tag">                                                <span class="attr">data-val</span>=<span class="string">&quot;&#123;movieId:1203&#125;&quot;</span>&gt;</span>霸王别姬<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;star&quot;</span>&gt;</span></span><br><span class="line">                                        主演：张国荣,张丰毅,巩俐</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;releasetime&quot;</span>&gt;</span>上映时间：1993-01-01<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;movie-item-number score-num&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;score&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;integer&quot;</span>&gt;</span>9.<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fraction&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再来看看翻页会发生什么：<br>url 从 <code>https://maoyan.com/board/4</code> 变成了 <code>https://maoyan.com/board/4?offset=10</code>。<br>嗯，多了一个 <code>?offset=10</code>。<br>再下一页，变成了<code>?offset=20</code>。<br>原来，每翻一页offset就加10（一页显示刚好是10个条目，这很合理。）<br>其实我们甚至可以尝试把值改成0（首页），或任何在范围 <code>[0, 100)</code> 内的值。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>我们现在设计一个可以完成目标的爬虫程序。</p><p>这个爬虫应该有这几个部分：</p><ul><li>抓取页面（同时也要注意配合翻页的问题处理）：可以用 <code>requests.get()</code> 来请求，最好再伪造一组headers。</li><li>正则提取（匹配出 影片名称、主演、上映时间、上映地区、评分、图片）：用 <code>re.findall()</code> 和适当的正则表达式来提取信息。</li><li>写入文件（用JSON格式去保存信息）：涉及到 <code>json.dumps()</code> 与 文件写入</li></ul><p>现在，我们还需要设计尤为关键的正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;&#x2F;i&gt;.*?data-src&#x3D;&quot;(.*?)@.*?title&#x3D;&quot;(.*?)&quot;.*?主演：(.*?)\s*&lt;&#x2F;p&gt;.*?上映时间：(.*?)&lt;&#x2F;p&gt;.*?integer&quot;&gt;(.*?)&lt;&#x2F;i&gt;.*?fraction&quot;&gt;(.*?)&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;&#39;</span><br><span class="line">匹配到的顺序是：(排名, 图片地址, 名称, 主演, 上映时间, 评分整数部分, 评分小数部分)</span><br><span class="line">需要使用 re.S</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们现在来按照设计实现第一个版本的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://maoyan.com/board/4&#x27;</span></span><br><span class="line">filename = <span class="string">&#x27;./movies.txt&#x27;</span></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)@.*?title=&quot;(.*?)&quot;.*?主演：(.*?)\s*&lt;/p&gt;.*?上映时间：(.*?)&lt;/p&gt;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-cn&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span>(<span class="params">url</span>):</span>   <span class="comment"># 抓取页面，返回html字符串</span></span><br><span class="line">    print(<span class="string">&#x27;\tGetting...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;[Error]&#x27;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span>(<span class="params">html</span>):</span>  <span class="comment"># 正则提取，返回结果dict的list</span></span><br><span class="line">    print(<span class="string">&#x27;\tExtracting...&#x27;</span>)</span><br><span class="line">    raws = re.findall(pattern, html, re.S)   <span class="comment"># [(排名, 图片地址, 名称, 主演, 上映时间, 评分整数部分, 评分小数部分), ...]</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> raw <span class="keyword">in</span> raws:</span><br><span class="line">        dc = &#123;                      <span class="comment"># 在这里调整了顺序</span></span><br><span class="line">                <span class="string">&#x27;index&#x27;</span>: raw[<span class="number">0</span>],</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: raw[<span class="number">2</span>],</span><br><span class="line">                <span class="string">&#x27;stars&#x27;</span>: raw[<span class="number">3</span>],</span><br><span class="line">                <span class="string">&#x27;otime&#x27;</span>: raw[<span class="number">4</span>],</span><br><span class="line">                <span class="string">&#x27;score&#x27;</span>: raw[<span class="number">5</span>] + raw[<span class="number">6</span>],   <span class="comment"># 合并整数、小数</span></span><br><span class="line">                <span class="string">&#x27;image&#x27;</span>: raw[<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">        result.append(dc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">data</span>):</span>      <span class="comment"># 写入文件</span></span><br><span class="line">    print(<span class="string">&#x27;\tSaving...&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            f.write(json.dumps(i, ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>):     <span class="comment"># 翻页</span></span><br><span class="line">        target = url + <span class="string">&#x27;?offset=&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">        print(<span class="string">&#x27;[%s%%](%s)&#x27;</span> % (i, target))</span><br><span class="line">        page = get_page(target)</span><br><span class="line">        data = extract(page)</span><br><span class="line">        save(data)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)     <span class="comment"># 防制请求过密集被封</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;[100%] All Finished.\n Results in&#x27;</span>, filename)</span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>运行程序，如果一切顺利，我们将得到结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;index&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;霸王别姬&quot;</span>, <span class="string">&quot;stars&quot;</span>: <span class="string">&quot;张国荣,张丰毅,巩俐&quot;</span>, <span class="string">&quot;otime&quot;</span>: <span class="string">&quot;1993-01-01&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;9.6&quot;</span>, <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;肖申克的救赎&quot;</span>, <span class="string">&quot;stars&quot;</span>: <span class="string">&quot;蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿&quot;</span>, <span class="string">&quot;otime&quot;</span>: <span class="string">&quot;1994-10-14(美国)&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;9.5&quot;</span>, <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>: <span class="string">&quot;3&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;罗马假日&quot;</span>, <span class="string">&quot;stars&quot;</span>: <span class="string">&quot;格利高里·派克,奥黛丽·赫本,埃迪·艾伯特&quot;</span>, <span class="string">&quot;otime&quot;</span>: <span class="string">&quot;1953-09-02(美国)&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;9.1&quot;</span>, <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://p0.meituan.net/movie/54617769d96807e4d81804284ffe2a27239007.jpg&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>: <span class="string">&quot;4&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;这个杀手不太冷&quot;</span>, <span class="string">&quot;stars&quot;</span>: <span class="string">&quot;让·雷诺,加里·奥德曼,娜塔莉·波特曼&quot;</span>, <span class="string">&quot;otime&quot;</span>: <span class="string">&quot;1994-09-14(法国)&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;9.5&quot;</span>, <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://p0.meituan.net/movie/e55ec5d18ccc83ba7db68caae54f165f95924.jpg&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>: <span class="string">&quot;5&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;泰坦尼克号&quot;</span>, <span class="string">&quot;stars&quot;</span>: <span class="string">&quot;莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩&quot;</span>, <span class="string">&quot;otime&quot;</span>: <span class="string">&quot;1998-04-03&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;9.6&quot;</span>, <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://p1.meituan.net/movie/0699ac97c82cf01638aa5023562d6134351277.jpg&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>乍一看好像没有问题了，我们需要的结果都得到了。<br>但是，仔细查看，发现还是会有几个问题存在：</p><ol><li>主演（stars）一般都有几个人，我们最好把他们分开用一个list或是tuple来安置。</li><li>信息每一个条目直接相互分离，不便于传输与取用。</li></ol><p>要解决第一个问题，我们可以在 extract 中增加一部分来处理这个问题，而第二个问题则需要我们将所有页都读取完成，放到指定位置，再统一写入文件。</p><p>修改源程序：</p><p>新增 函数，处理主演信息，得到一个list:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stars_split</span>(<span class="params">st</span>):</span></span><br><span class="line">    <span class="keyword">return</span> st.split(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure><p>修改 extract()，在其中添加 stars_split 的调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span>(<span class="params">html</span>):</span>  <span class="comment"># 正则提取，返回结果dict的list</span></span><br><span class="line">    print(<span class="string">&#x27;\tExtracting...&#x27;</span>)</span><br><span class="line">    raws = re.findall(pattern, html, re.S)   <span class="comment"># [(排名, 图片地址, 名称, 主演, 上映时间, 评分整数部分, 评分小数部分), ...]</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> raw <span class="keyword">in</span> raws:</span><br><span class="line">        dc = &#123;                      <span class="comment"># 在这里调整了顺序</span></span><br><span class="line">                <span class="string">&#x27;index&#x27;</span>: raw[<span class="number">0</span>],</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: raw[<span class="number">2</span>],</span><br><span class="line">                <span class="string">&#x27;stars&#x27;</span>: stars_split(raw[<span class="number">3</span>]),   <span class="comment"># 【修改】：分离主演</span></span><br><span class="line">                <span class="string">&#x27;otime&#x27;</span>: raw[<span class="number">4</span>],</span><br><span class="line">                <span class="string">&#x27;score&#x27;</span>: raw[<span class="number">5</span>] + raw[<span class="number">6</span>],       <span class="comment"># 合并整数、小数</span></span><br><span class="line">                <span class="string">&#x27;image&#x27;</span>: raw[<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">        result.append(dc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>新增 一个全局变量、函数，实现结果的整合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;<span class="string">&#x27;top movies&#x27;</span>: []&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">data</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;\tMerging...&#x27;</span>)</span><br><span class="line">    result[<span class="string">&#x27;top movies&#x27;</span>] += data</span><br></pre></td></tr></table></figure><p>修改 save：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">data</span>):</span>      <span class="comment"># 写入文件</span></span><br><span class="line">    print(<span class="string">&#x27;Saving...&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(data, ensure_ascii=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p>修改程序框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>):     <span class="comment"># 翻页</span></span><br><span class="line">        target = url + <span class="string">&#x27;?offset=&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">        print(<span class="string">&#x27;[%s%%](%s)&#x27;</span> % (i, target))</span><br><span class="line">        page = get_page(target)</span><br><span class="line">        data = extract(page)</span><br><span class="line">        merge(data)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)     <span class="comment"># 防制请求过密集被封</span></span><br><span class="line">        </span><br><span class="line">    save(result)</span><br><span class="line">    print(<span class="string">&#x27;[100%] All Finished.\n Results in&#x27;</span>, filename)</span><br></pre></td></tr></table></figure><p>整合代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://maoyan.com/board/4&#x27;</span></span><br><span class="line">result = &#123;<span class="string">&#x27;top movies&#x27;</span>: []&#125;</span><br><span class="line">filename = <span class="string">&#x27;./movies.json&#x27;</span>      <span class="comment"># （最好把保存的文件名改一下，否则会添加到上次运行结果的后面）</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)@.*?title=&quot;(.*?)&quot;.*?主演：(.*?)\s*&lt;/p&gt;.*?上映时间：(.*?)&lt;/p&gt;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-cn&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span>(<span class="params">url</span>):</span>   <span class="comment"># 抓取页面，返回html字符串</span></span><br><span class="line">    print(<span class="string">&#x27;\tGetting...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;[Error]&#x27;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stars_split</span>(<span class="params">st</span>):</span></span><br><span class="line">    <span class="keyword">return</span> st.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span>(<span class="params">html</span>):</span>  <span class="comment"># 正则提取，返回结果dict的list</span></span><br><span class="line">    print(<span class="string">&#x27;\tExtracting...&#x27;</span>)</span><br><span class="line">    raws = re.findall(pattern, html, re.S)   <span class="comment"># [(排名, 图片地址, 名称, 主演, 上映时间, 评分整数部分, 评分小数部分), ...]</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> raw <span class="keyword">in</span> raws:</span><br><span class="line">        dc = &#123;                      <span class="comment"># 在这里调整了顺序</span></span><br><span class="line">                <span class="string">&#x27;index&#x27;</span>: raw[<span class="number">0</span>],</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: raw[<span class="number">2</span>],</span><br><span class="line">                <span class="string">&#x27;stars&#x27;</span>: stars_split(raw[<span class="number">3</span>]),   <span class="comment"># 分离主演</span></span><br><span class="line">                <span class="string">&#x27;otime&#x27;</span>: raw[<span class="number">4</span>],</span><br><span class="line">                <span class="string">&#x27;score&#x27;</span>: raw[<span class="number">5</span>] + raw[<span class="number">6</span>],       <span class="comment"># 合并整数、小数</span></span><br><span class="line">                <span class="string">&#x27;image&#x27;</span>: raw[<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">        result.append(dc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">data</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;\tMerging...&#x27;</span>)</span><br><span class="line">    result[<span class="string">&#x27;top movies&#x27;</span>] += data</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">data</span>):</span>      <span class="comment"># 写入文件</span></span><br><span class="line">    print(<span class="string">&#x27;Saving...&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(data, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>):     <span class="comment"># 翻页</span></span><br><span class="line">        target = url + <span class="string">&#x27;?offset=&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">        print(<span class="string">&#x27;[%s%%](%s)&#x27;</span> % (i, target))</span><br><span class="line">        page = get_page(target)</span><br><span class="line">        data = extract(page)</span><br><span class="line">        merge(data)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)     <span class="comment"># 防制请求过密集被封</span></span><br><span class="line">        </span><br><span class="line">    save(result)</span><br><span class="line">    print(<span class="string">&#x27;[100%] All Finished.\n Results in&#x27;</span>, filename)</span><br></pre></td></tr></table></figure><p>运行修改完毕的程序，得到新的结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;top movies&quot;</span>: [&#123;<span class="attr">&quot;index&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;霸王别姬&quot;</span>, <span class="attr">&quot;stars&quot;</span>: [<span class="string">&quot;张国荣&quot;</span>, <span class="string">&quot;张丰毅&quot;</span>, <span class="string">&quot;巩俐&quot;</span>], <span class="attr">&quot;otime&quot;</span>: <span class="string">&quot;1993-01-01&quot;</span>, <span class="attr">&quot;score&quot;</span>: <span class="string">&quot;9.6&quot;</span>, <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg&quot;</span>&#125;, &#123;<span class="attr">&quot;index&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;肖申克的救赎&quot;</span>, <span class="attr">&quot;stars&quot;</span>: [<span class="string">&quot;蒂姆·罗宾斯&quot;</span>, <span class="string">&quot;摩根·弗里曼&quot;</span>, <span class="string">&quot;鲍勃·冈顿&quot;</span>], <span class="attr">&quot;otime&quot;</span>: <span class="string">&quot;1994-10-14(美国)&quot;</span>, <span class="attr">&quot;score&quot;</span>: <span class="string">&quot;9.5&quot;</span>, <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg&quot;</span>&#125;, ..., &#123;<span class="attr">&quot;index&quot;</span>: <span class="string">&quot;100&quot;</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;龙猫&quot;</span>, <span class="attr">&quot;stars&quot;</span>: [<span class="string">&quot;秦岚&quot;</span>, <span class="string">&quot;糸井重里&quot;</span>, <span class="string">&quot;岛本须美&quot;</span>], <span class="attr">&quot;otime&quot;</span>: <span class="string">&quot;2018-12-14&quot;</span>, <span class="attr">&quot;score&quot;</span>: <span class="string">&quot;9.2&quot;</span>, <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;https://p0.meituan.net/movie/c304c687e287c7c2f9e22cf78257872d277201.jpg&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这样就比较理想了。</p><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>该爬虫项目结束了。<br>总结一下，我们主要用了 <code>requests.get()</code> 完成请求，还伪造了 <code>headers</code>；用 <code>re.findall()</code> 正则解析结果，然后调整了信息的顺序；用 <code>json</code> 格式化保存结果。</p><p>其实，这个项目只要稍作修改，我们就可以用来爬取其他很多种电影排行榜，如我们其实还实现了一个爬取豆瓣top250的程序，真的只是稍微改动，非常容易了。</p><p>我们展现了这个项目开发的过程，从目标到最后完成，一步一步进行，这个开发顺序适用于很多项目，并且富有哲理，我们认为值得感悟与践行。</p>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之正则表达式</title>
      <link href="/2019/02/13/PythonAndCrawler/crawler-4-re/"/>
      <url>/2019/02/13/PythonAndCrawler/crawler-4-re/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫基本库的使用之RE"><a href="#爬虫基本库的使用之RE" class="headerlink" title="爬虫基本库的使用之RE"></a>爬虫基本库的使用之RE</h1><blockquote><p>本文主要介绍 <strong>正则表达式</strong> 及 <strong>RE 库</strong>。</p></blockquote><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种处理字符串的强大的工具，它有自己特定的语法结构，可以高效地实现字符串的检索、替换、匹配验证等操作。</p><p>我们可以利用正则表达式来提取 HTML 中我们感兴趣的信息，正如我们在使用 requests 库爬取知乎发现中的问题时那样。</p><p>下表为 正则表达式 的常用匹配规则：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td><code>\w</code></td><td>匹配字母数字及下划线</td></tr><tr><td><code>\W</code></td><td>匹配非字母数字及下划线</td></tr><tr><td><code>\s</code></td><td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td></tr><tr><td><code>\S</code></td><td>匹配任意非空字符</td></tr><tr><td><code>\d</code></td><td>匹配任意数字，等价于 <code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配任意非数字</td></tr><tr><td><code>\A</code></td><td>匹配字符串开始</td></tr><tr><td><code>\Z</code></td><td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串</td></tr><tr><td><code>\z</code></td><td>匹配字符串结束</td></tr><tr><td><code>\G</code></td><td>匹配最后匹配完成的位置</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符</td></tr><tr><td><code>^</code></td><td>匹配字符串的开头</td></tr><tr><td><code>$</code></td><td>匹配字符串的末尾</td></tr><tr><td><code>.</code></td><td>匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td><code>[...]</code></td><td>用来表示一组字符，单独列出：<code>[amk]</code> 匹配 ‘a’，’m’ 或 ‘k’</td></tr><tr><td><code>[^...]</code></td><td>不在 [] 中的字符：<code>[^abc]</code> 匹配除了 a,b,c 之外的字符。</td></tr><tr><td><code>*</code></td><td>匹配 0 个或多个的表达式。</td></tr><tr><td><code>+</code></td><td>匹配 1 个或多个的表达式。</td></tr><tr><td><code>?</code></td><td>匹配 0 个或 1 个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td><code>&#123;n&#125;</code></td><td>精确匹配 n 个前面表达式。</td></tr><tr><td><code>&#123;n, m&#125;</code></td><td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td>`a</td><td>b`</td></tr><tr><td><code>( )</code></td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table><p>⚠️【注意】贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符；非贪婪匹配则尽可能匹配少的字符。<br>⚠️【注意】转义：如果在正则中想表现表中有的那些符号，我们需要转义，即使用 <code>\</code>+ 符号。例如要表现括号<code>(</code>，我们需要写 <code>\(</code></p><p>例如，之前我们抓取「知乎-发现」中的问题时，使用的是如下正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explore-feed.*?question_link.*?&gt;(.*?)&lt;&#x2F;</span><br></pre></td></tr></table></figure><p>它就可以匹配请求到的 html 中的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;explore-feed feed-item&quot;</span> <span class="attr">data-offset</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;question_link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/question/311635229/answer/...&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">data-za-element-name</span>=<span class="string">&quot;Title&quot;</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RE-库"><a href="#RE-库" class="headerlink" title="RE 库"></a>RE 库</h2><p>Python 内置的 <code>re</code> 库提供了对正则表达式的支持。</p><p>下面我们来了解 re 库的使用：</p><h4 id="match"><a href="#match" class="headerlink" title="match()"></a><code>match()</code></h4><p>match() 方法，需要我们传入<em>要匹配的字符串</em>以及<em>正则表达式</em>，来检测这个字符串是否符合该正则表达式。</p><p>match() 方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。</p><p>match() 会从一开始匹配，也就是说，如果第一个字符就匹配不上去，则就不匹配。</p><p>我们常可以这样用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">&#x27;待测字符串&#x27;</span></span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">r&#x27;正则表达式&#x27;</span>, test):</span><br><span class="line">    print(<span class="string">&#x27;Match&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Failed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>提取分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;abc 123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.match(<span class="string">r&#x27;\s+\w\d&#x27;</span>, text))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = re.match(<span class="string">r&#x27;\w*? (\d&#123;3&#125;)&#x27;</span>, text)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">7</span>), match=<span class="string">&#x27;abc 123&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.group()</span><br><span class="line"><span class="string">&#x27;abc 123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;abc 123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>group()、group(0) 会输出完整的匹配结果。</li><li>group(1)，以及此例中没有的group(2)，group(3)… 则会输出第一、二、三…个被 <code>()</code> 包围的匹配结果。</li></ul><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td><code>re.I</code></td><td>使匹配对大小写不敏感</td></tr><tr><td><code>re.L</code></td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td><code>re.M</code></td><td>多行匹配，影响 <code>^</code> 和 <code>$</code></td></tr><tr><td><code>re.S</code></td><td>使 <code>.</code> 匹配包括换行在内的所有字符</td></tr><tr><td><code>re.U</code></td><td>根据Unicode字符集解析字符。这个标志影响 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>.</td></tr><tr><td><code>re.X</code></td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><p>这些修饰符可以作为 re.match 的第三个参数传入，产生上面描述中的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(<span class="string">&#x27;^He.*?(\d+).*?Demo$&#x27;</span>, content, re.S)</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search()"></a><code>search()</code></h4><p>与 match() 不同，search() 在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果，如果一处都没有，则返回 None.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = <span class="string">&#x27;\d+&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">&#x27;asd123sss&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = re.search(p, c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">3</span>, <span class="number">6</span>), match=<span class="string">&#x27;123&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.group()</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="findall"><a href="#findall" class="headerlink" title="findall()"></a><code>findall()</code></h4><p><code>findall()</code> 会搜索整个字符串然后返回匹配正则表达式的所有内容，返回的结果为一个list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = <span class="string">&#x27;\d+&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">&#x27;asd123dfg456;;;789&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(p, c)</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>, <span class="string">&#x27;789&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python请求库requests</title>
      <link href="/2019/02/12/PythonAndCrawler/crawler-3-requests/"/>
      <url>/2019/02/12/PythonAndCrawler/crawler-3-requests/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫请求库的使用之Requests"><a href="#爬虫请求库的使用之Requests" class="headerlink" title="爬虫请求库的使用之Requests"></a>爬虫请求库的使用之Requests</h1><blockquote><p>本文主要介绍 <strong>Requests 库</strong>。</p></blockquote><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>相较于 Python 内置的 Urllib，第三方库 Requests 为我们提供了一个更加优雅的解决方案。<br>得益于 <code>requests</code> 的强大，我们可以在解决 Cookies、登录验证、代理设置 等问题时更加方便快捷，而无需再琢磨 Urllib 的 Opener、Handler。</p><h3 id="requests-get-——-GET请求"><a href="#requests-get-——-GET请求" class="headerlink" title="requests.get() —— GET请求"></a>requests.get() —— GET请求</h3><p>使用 <code>requests.get(url, *params=&#123;&#125;, headers=&#123;&#125;, timeout=None)</code> 可以完成 GET 请求，返回 response 的各种内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;status_code: &#x27;</span>, <span class="built_in">type</span>(r.status_code), r.status_code)</span><br><span class="line">print(<span class="string">&#x27;headers: &#x27;</span>, <span class="built_in">type</span>(r.headers), r.headers)</span><br><span class="line">print(<span class="string">&#x27;cookies: &#x27;</span>, <span class="built_in">type</span>(r.cookies), r.cookies)</span><br><span class="line">print(<span class="string">&#x27;url: &#x27;</span>, <span class="built_in">type</span>(r.url), r.url)</span><br><span class="line">print(<span class="string">&#x27;history: &#x27;</span>, <span class="built_in">type</span>(r.history), r.history)</span><br></pre></td></tr></table></figure><p>status_code 属性得到状态码， headers 属性得到 Response Headers，cookies 属性得到 Cookies，url 属性得到 URL，history 属性得到请求历史。</p><p>使用 <code>params=&#123;&#125;</code> ，就等于在url中添加了 <code>&#39;?xxx&amp;xxx&#39;</code> 的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">&quot;http://httpbin.org/get&quot;</span>, params=data)    <span class="comment"># 相当于 GET请求 ‘http://httpbin.org/get?name=germey&amp;age=22’</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>在上例中，我们可以看到返回的 r.text 实际上是 JSON 的字符串，requests 提供了 一个 <code>Response.json()</code> 可以直接把 JSON 解析成 dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  承接上一代码块</span></span><br><span class="line">d = r.json()</span><br><span class="line">print(<span class="built_in">type</span>(d), d, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>若返回结果不是 Json 格式，调用 <code>Response.json()</code>，会抛出 <a href="https://www.zhihu.com/explorejson.decoder.JSONDecodeError">https://www.zhihu.com/explorejson.decoder.JSONDecodeError</a> 的异常。</p><p>我们还可以在调用 requests.get() 的时候传入一个 dict 作为 headers：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>, headers=headers)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>我们还可以设置超时，有三种方法：</p><ul><li><code>r = requests.get(&#39;https://www.taobao.com&#39;, timeout=None)</code>，connect 和 read 二者都是 永久等待，这是默认设置</li><li><code>r = requests.get(&#39;https://www.taobao.com&#39;, timeout=1)</code>，connect 和 read 二者的 timeout 总和设置为 1 秒</li><li><code>r = requests.get(&#39;https://www.taobao.com&#39;, timeout=(5, 11))</code>，connect 5秒，read 11秒</li></ul><h3 id="获取二进制数据"><a href="#获取二进制数据" class="headerlink" title="获取二进制数据"></a>获取二进制数据</h3><p>当我们获取得二进制的数据时，Response.text 显然是不好用了，这时我们可以通过 <code>Response.content</code> 取得二进制数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&quot;https://github.com/favicon.ico&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(r.text)       <span class="comment"># 输出乱码</span></span><br><span class="line">print(r.content)    <span class="comment"># 输出十六进制码的bytes（b&#x27;\x..\x........&#x27;）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:        <span class="comment"># 保存到文件</span></span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></table></figure><h3 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h3><p>我们来做一个简单的爬虫实践————爬取 <a href="https://www.zhihu.com/explore">知乎-发现</a> 里的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 知乎-发现的url</span></span><br><span class="line">url = <span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span></span><br><span class="line"><span class="comment"># 匹配问题的正则表达式</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;explore-feed.*?question_link.*?&gt;(.*?)&lt;/&#x27;</span>, re.S)       <span class="comment"># *？表示惰性匹配</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    questions = re.findall(pattern, response.text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> questions:</span><br><span class="line">        print(i)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><h3 id="requests-post-——-POST请求"><a href="#requests-post-——-POST请求" class="headerlink" title="requests.post() —— POST请求"></a>requests.post() —— POST请求</h3><p>用 <code>requests.post(url, data=&#123;&#125;)</code> 我们就可以 POST 请求，这和使用 requests.get() 非常类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;<span class="string">&#x27;Data&#x27;</span>: <span class="string">&#x27;Hello, world!&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>我们同样可以从 Response 中获取各种数据，例如：status_code 属性得到状态码， headers 属性得到 Response Headers，cookies 属性得到 Cookies，url 属性得到 URL，history 属性得到请求历史。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>我们可以使用 POST请求 来完成文件的上传。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, files=files)</span><br><span class="line"></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><h4 id="获取Cookies"><a href="#获取Cookies" class="headerlink" title="获取Cookies"></a>获取Cookies</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">print(r.cookies)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">    print(key + <span class="string">&#x27;=&#x27;</span> + value)</span><br></pre></td></tr></table></figure><h4 id="调用Cookies"><a href="#调用Cookies" class="headerlink" title="调用Cookies"></a>调用Cookies</h4><p>我们先登录一个网站，然后从记录下Cookies，在另一次登录中，把这个Cookies传上去，就可以维持登录。</p><p>例如，我们现在用浏览器登录「百度」，然后打开一次百度首页，我们检查 <code>www.baidu.com</code> 的 Request Headers，我们会发现一项 <code>Cookies</code>，我们把这个值复制下来，让爬虫伪造 headers，带上这个 Cookies，我们就可以模拟登录了:)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BDORZ******3254&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(url, headers=headers)</span><br><span class="line"></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>从结果中，我们可以看到自己的名字，说明成功模仿登录！</p><p>也可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">&#x27;q_c1=316******3b0&#x27;</span></span><br><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.zhihu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">    key, value = cookie.split(<span class="string">&#x27;=&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    jar.<span class="built_in">set</span>(key, value)</span><br><span class="line">    </span><br><span class="line">r = requests.get(<span class="string">&#x27;http://www.zhihu.com&#x27;</span>, cookies=jar, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>在 Requests 中，我们如果直接利用 get() 或 post() 等方法的确可以做到模拟网页的请求。<br>但是这实际上是相当于不同的会话，即不同的 Session，也就是说<strong>每请求一次</strong>都相当于用<strong>不同浏览器打开</strong>，会话不会维持。<br>但我们常需要模拟在一个浏览器中打开同一站点的不同页面，这就需要我们进行会话维持。</p><h6 id="不使用会话维持"><a href="#不使用会话维持" class="headerlink" title="不使用会话维持"></a>不使用会话维持</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>)     <span class="comment"># 一次会话</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)      <span class="comment"># 另一次会话</span></span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(result)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;cookies&quot;: &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们得到的结果是空的，说明两次get不是同一会话了。</p><h6 id="使用会话维持"><a href="#使用会话维持" class="headerlink" title="使用会话维持"></a>使用会话维持</h6><p>使用会话维持最直接的办法就是我们可以获取上一次的 Cookies，下一次请求时把它传上去，但这样做过于繁琐，requests 为我们提供了更加简洁、优雅的解决方案 —— <code>requests.Session</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()      <span class="comment"># 开启一个新会话 s</span></span><br><span class="line">s.get(<span class="string">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>)    <span class="comment"># 会话 s</span></span><br><span class="line">r = s.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)     <span class="comment"># 同样还是会话 s</span></span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(result)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;cookies&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;number&quot;: &quot;123456789&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这一次，我们就维持了会话了。</p><h4 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a>SSL 证书验证</h4><p>Requests 提供了证书验证的功能，当发送 HTTP 请求的时候，它会检查 SSL 证书（针对https），我们可以使用 <code>verify</code> 参数来控制是否检查此证书，缺省值是 True，会自动验证。<br>如果我们不需要检查证书，可以让 <code>verify=False</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.12306.cn&#x27;</span>, verify=<span class="literal">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>指定本地证书用作客户端证书:</p><p>客户端证书可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.12306.cn&#x27;</span>, cert=(<span class="string">&#x27;/path/server.crt&#x27;</span>, <span class="string">&#x27;/path/key&#x27;</span>))</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>⚠️【注意】本地私有证书的 key 必须要是解密状态，加密状态的 key 是不支持的。</p><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p>找一个<a href="https://www.xicidaili.com/nn/">免费的代理服务器</a>，然后用这个服务器来代理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;br, gzip, deflate&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">        <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://110.52.235.57:9999&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://110.52.235.57:9999&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://www.taobao.com&#x27;</span>, proxies=proxies, headers=headers)</span><br><span class="line"></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>另外，若使用非免费的代理，可能需要使用 HTTP Basic Auth，可以使用类似 <a href="http://user:password@host:port">http://user:password@host:port</a> 这样的语法来设置代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://user:password@10.10.1.10:3128/&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><p>Requests 还支持 SOCKS 协议的代理:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install <span class="string">&quot;requests[socks]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;socks5://user:password@host:port&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;socks5://user:password@host:port&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><h4 id="HTTP-基本认证"><a href="#HTTP-基本认证" class="headerlink" title="HTTP 基本认证"></a>HTTP 基本认证</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://pythonscraping.com/pages/auth/login.php&#x27;</span>, auth=HTTPBasicAuth(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>))</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure><p>还可以更简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://pythonscraping.com/pages/auth/login.php&#x27;</span>, auth=(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>))</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure><p>Requests 还支持其他的认证，如 OAuth。关于这方面，可以查看 <a href="https://requests-oauthlib.readthedocs.io/en/latest/">文档</a> 。</p><h4 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h4><p>类似于 Urllib 中的 Request ，我们可以在 Requests 中使用 Prepared Request 来表示一个请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">&#x27;POST&#x27;</span>, url, data=data, headers=headers)</span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line">r = s.send(prepped)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>这里我们引入了 Request，然后用 url、data、headers 参数构造了一个 Request 对象，这时我们需要再调用 Session 的 prepare_request() 方法将其转换为一个 Prepared Request 对象，然后调用 send() 方法发送即可</p><p>通过 Request 对象，我们就可以将一个个请求当做一个独立的对象来看待，这可以方便调度。</p>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python请求库urllib</title>
      <link href="/2019/02/11/PythonAndCrawler/crawler-2-urllib/"/>
      <url>/2019/02/11/PythonAndCrawler/crawler-2-urllib/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫请求库的使用之Urllib"><a href="#爬虫请求库的使用之Urllib" class="headerlink" title="爬虫请求库的使用之Urllib"></a>爬虫请求库的使用之Urllib</h1><blockquote><p>本文主要介绍 <strong>Urllib 库</strong>。</p></blockquote><h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><p><code>urllib</code> 是 Python 内置的 HTTP 请求库。</p><p>urllib 有 request，error，parse，robotparser 四个模块。</p><h3 id="urllib-request-发送请求"><a href="#urllib-request-发送请求" class="headerlink" title="urllib.request 发送请求"></a>urllib.request 发送请求</h3><h4 id="urlopen-发送请求"><a href="#urlopen-发送请求" class="headerlink" title="urlopen(): 发送请求"></a><code>urlopen()</code>: 发送请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 python 官网 HTML 源码</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 查看response内容</span></span><br><span class="line">print(<span class="built_in">type</span>(response))                   <span class="comment"># 查看response类型</span></span><br><span class="line">print(response.status)                  <span class="comment"># 查看response状态码</span></span><br><span class="line">print(response.getheaders())            <span class="comment"># 查看响应头</span></span><br><span class="line">print(response.getheader(<span class="string">&#x27;Server&#x27;</span>))     <span class="comment"># 查看特定的响应头项</span></span><br></pre></td></tr></table></figure><p><code>urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</code></p><h5 id="urlopen-带-data-参数-用-POST-发送一些数据"><a href="#urlopen-带-data-参数-用-POST-发送一些数据" class="headerlink" title="urlopen() 带 data 参数: 用 POST 发送一些数据"></a><code>urlopen()</code> 带 <code>data</code> 参数: 用 POST 发送一些数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">bytes</span>(</span><br><span class="line">    urllib.parse.urlencode(&#123;<span class="string">&#x27;Hello&#x27;</span>: <span class="string">&#x27;World&#x27;</span>&#125;),</span><br><span class="line">    encoding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    )</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data=data)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h5 id="urlopen-带-timeout-参数-如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。"><a href="#urlopen-带-timeout-参数-如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。" class="headerlink" title="urlopen() 带 timeout 参数: 如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。"></a><code>urlopen()</code> 带 <code>timeout</code> 参数: 如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。</h5><p>设置<code>timeout=Sec</code>，Sce 为超时的秒数（可以为小数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">        </span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="Request-类构建-Headers"><a href="#Request-类构建-Headers" class="headerlink" title="Request 类构建 Headers"></a>Request 类构建 Headers</h4><p>利用更强大的 Request类来构建一个完整的请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(<span class="string">&#x27;http://python.org&#x27;</span>)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h5 id="Request类-的构建参数"><a href="#Request类-的构建参数" class="headerlink" title="Request类 的构建参数"></a>Request类 的构建参数</h5><p><code>class urllib.request.Request(ur1, data=None, headers=&#123;&#125;,origin_req_host=None, unverifiable=False, method=None)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;httpbin.org&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">dic = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;CDFMLR&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(dic), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>Handler 包含 各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的…</p><p>urllib.request 模块里的 <code>BaseHandler</code> 类是所有其他 Handler 的父类，它提供最基本的方法。</p><p>其他的 Handler 详见 <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler">Handler</a></p><h5 id="Opener"><a href="#Opener" class="headerlink" title="Opener"></a>Opener</h5><p>之前用过 urlopen()方法，实际上就是 urllib 提供的一个 Opener。 </p><p>urlopen() 相当于类库封装好了极其常用的请求方法，利用它可以完成基本的请求，但如果需要实现更高级的功能，就需要深入一层进行配置，使用更底层的实例来完成操作，就用到了 Opener。 </p><p>Opener 可以使用 open()方法，返回的类型和 urlopen()如出一辙。 </p><p>我们需要利用 Handler来构建 Opener。 </p><hr><p>（以下是几个 Hander &amp; Opener 的应用）</p><h5 id="处理-HTTP-基本认证"><a href="#处理-HTTP-基本认证" class="headerlink" title="处理 HTTP 基本认证"></a>处理 <code>HTTP 基本认证</code></h5><p><code>HTTP基本认证</code>：</p><blockquote><p>有一种 web 登录方式不是通过 <code>cookie</code>，而是把 <code>用户名:密码</code> 用 <code>base64</code> 编码之后的字符串放在 request 中的 <code>header Authorization</code> 中发送给服务端。<br>当打开网页提示需要输入账号和密码时，假设密码/账号错误，服务器会返回401错误。</p></blockquote><p>这种网站在打开时就会弹出提示框，直接提示输入用户名和密码，验证成功后才能查看页面，我们现在来处理这种页面。</p><p>要请求这种页面，可以借用 <code>HTTPBasicAuthHandler</code> 完成：</p><p><em>在我们打算自己实现一个使用 http基本认证 的示例网站时，我们发现了 <a href="http://pythonscraping.com/pages/auth/login.php">一个很好的例子</a>，所以，我们现在来爬取它。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"></span><br><span class="line">username = <span class="string">&#x27;username&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;password&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;http://pythonscraping.com/pages/auth/login.php&#x27;</span></span><br><span class="line"></span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">p.add_password(<span class="literal">None</span>, url, username, password)</span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p)</span><br><span class="line">opener = build_opener(auth_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = opener.<span class="built_in">open</span>(url)</span><br><span class="line">    html = result.read().decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    print(html)</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure><p>在此，我们也想附上这种 <code>http基本认证</code> 的 php 实现，以供实践：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_USER&#x27;</span>])) &#123;</span><br><span class="line">    header(<span class="string">&#x27;WWW-Authenticate: Basic realm=&quot;My Realm&quot;&#x27;</span>);</span><br><span class="line">    header(<span class="string">&#x27;HTTP/1.0 401 Unauthorized&#x27;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Text to send if user hits Cancel button&#x27;</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Hello <span class="subst">&#123;$_SERVER[&#x27;PHP_AUTH_USER&#x27;]&#125;</span>.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;You entered <span class="subst">&#123;$_SERVER[&#x27;PHP_AUTH_PW&#x27;]&#125;</span> as your password.&lt;/p&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用-代理"><a href="#使用-代理" class="headerlink" title="使用 代理"></a>使用 <code>代理</code></h5><p> 尝试找一个<a href="https://www.xicidaili.com/nn/">免费的代理服务器</a>，然后用这个服务器来代理：</p><p> <em>寻找可用代理的时候可以尝试在浏览器中访问代理服务器的 IP:Port，可用的是会出现结果的:)</em></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://171.41.80.197:9999&#x27;</span>,        <span class="comment"># 用 ‘&lt;http||https&gt;://代理服务器_IP:代理服务器_端口’</span></span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://171.41.80.197:9999&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)  <span class="comment"># 要通过代理爬取的网页</span></span><br><span class="line">    print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>))</span><br><span class="line">    print(response.getheaders())</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure><h5 id="处理-Cookies"><a href="#处理-Cookies" class="headerlink" title="处理 Cookies"></a>处理 Cookies</h5><h6 id="获取-Cookies"><a href="#获取-Cookies" class="headerlink" title="获取 Cookies"></a>获取 Cookies</h6><p>获取 <code>http://www.baidu.com</code> 的 Cookies，依次打印出 name = value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name, <span class="string">&#x27;=&#x27;</span>, item.value)</span><br></pre></td></tr></table></figure><p>还是获取 <code>http://www.baidu.com</code> 的 Cookies，把它们保存到文件中（正如实际上 Cookies 的保存方式那样）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;cookies_from_baidu.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar(filename)      <span class="comment"># 用 MozillaCookieJar 类把 Cookies 储存为 Mozilla 型浏览器的格式。</span></span><br><span class="line"><span class="comment"># cookie = http.cookiejar.LWPCookieJar(filename)         # 用这行代替上一行，可以把 Cookies 储存为 libwww-perl(LWP) 的格式。</span></span><br><span class="line"></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>MozillaCookieJar</code> 和 <code>LWPCookieJar</code> 都可以<strong>读取</strong>和<strong>保存</strong> Cookies。只是它们的保存格式有别。</p><h6 id="取用-Cookies"><a href="#取用-Cookies" class="headerlink" title="取用 Cookies"></a>取用 Cookies</h6><p>取用我们刚才保存下来的 Cookies：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar()</span><br><span class="line">cookie.load(<span class="string">&#x27;cookies_from_baidu.txt&#x27;</span>, ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="urllib-error-处理异常"><a href="#urllib-error-处理异常" class="headerlink" title="urllib.error 处理异常"></a>urllib.error 处理异常</h3><h4 id="URLError"><a href="#URLError" class="headerlink" title="URLError:"></a>URLError:</h4><p><code>URLError</code> 类来自 <code>Urllib</code> 库的 <code>error</code> 模块，它继承自 <code>OSError</code> 类，是 error 异常模块的基类，由 request 模块生的异常都可以通过捕获这个类来处理。</p><p>它具有一个属性 <code>reason</code>，即返回错误的原因:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">&#x27;http://www.google.com&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure><p>通过如上操作，我们就可以避免程序异常终止，同时异常得到了有效处理。</p><h4 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h4><p><code>HTTPError</code> 是 <code>URLError</code> 的子类。用来处理 <strong>HTTP 请求错误</strong>，比如认证请求失败等等。</p><p><code>HTTPError</code> 的属性：</p><ul><li><code>code</code>，返回 HTTP Status Code，即状态码，比如 404 网页不存在，500 服务器内部错误等等。</li><li><code>reason</code>，同父类一样，返回错误的原因。</li><li><code>headers</code>，返回 Request Headers。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">&#x27;http://cr0123.gz01.bdysite.com/no_such_a_page.html&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;\n[Reason]&#x27;</span>, e.reason,</span><br><span class="line">        <span class="string">&#x27;\n[code]&#x27;</span>, e.code,</span><br><span class="line">        <span class="string">&#x27;\n[headers]&#x27;</span>, e.headers</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h4 id="综合使用："><a href="#综合使用：" class="headerlink" title="综合使用："></a>综合使用：</h4><p>在实际的使用过程中，我们可以先选择捕获子类的错误，再去捕获父类的错误，从而使处理完整，层次清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">&#x27;http://www.google.com&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;HTTPError:&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;[Reason]&#x27;</span>, e.reason, <span class="string">&#x27;[code]&#x27;</span>, e.code, <span class="string">&#x27;[headers]&#x27;</span>, e.headers, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;URLError:&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;[Error Reason]\n&#x27;</span>, e.reason)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;Exception:&#x27;</span>)</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Request Successfully&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="urllib-parse-解析链接"><a href="#urllib-parse-解析链接" class="headerlink" title="urllib.parse 解析链接"></a>urllib.parse 解析链接</h3><p><code>urllib.parse</code> 模块定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取，合并以及链接转换。</p><h4 id="quote-将内容转化为-URL-编码的格式"><a href="#quote-将内容转化为-URL-编码的格式" class="headerlink" title="quote() 将内容转化为 URL 编码的格式"></a>quote() 将内容转化为 URL 编码的格式</h4><p>可以用来把中文字符转化为 URL 编码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quote(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;%E4%B8%AD%E6%96%87&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;https://www.baidu.com/s?wd=&#x27;</span> + quote(<span class="string">&#x27;URL 编码&#x27;</span>)    <span class="comment"># 合成的网址即可百度搜索‘URL 编码’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(url)</span><br><span class="line">https://www.baidu.com/s?wd=URL%20%E7%BC%96%E7%A0%81</span><br></pre></td></tr></table></figure><p>要解码，可是使用对应的 <code>unquote()</code>。</p><h4 id="urlparse-URL的识别和分段"><a href="#urlparse-URL的识别和分段" class="headerlink" title="urlparse() URL的识别和分段"></a>urlparse() URL的识别和分段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">&#x27;http://www.baidu.com/index.html;user?id=5#comment&#x27;</span>)</span><br><span class="line">print(<span class="built_in">type</span>(result))</span><br><span class="line">print(result)</span><br><span class="line">print(result.netloc)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(results)</span></span><br><span class="line"><span class="string">&lt;class &#x27;urllib.parse.ParseResult&#x27;&gt;</span></span><br><span class="line"><span class="string">ParseResult(scheme=&#x27;http&#x27;, netloc=&#x27;www.baidu.com&#x27;, path=&#x27;/index.html&#x27;, params=&#x27;user&#x27;, query=&#x27;id=5&#x27;, fragment=&#x27;comment&#x27;)</span></span><br><span class="line"><span class="string">www.baidu.com</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>ParseResult 包含：</p><ul><li>scheme ———— 协议</li><li>netloc ———— 主机名</li><li>path ———— 路径</li><li>params ———— <code>;XXX</code></li><li>query ———— <code>?XXX</code></li><li>fragment ———— <code>#XXX</code></li></ul><h4 id="urlunparse-合成URL"><a href="#urlunparse-合成URL" class="headerlink" title="urlunparse() 合成URL"></a>urlunparse() 合成URL</h4><p><strong>依次</strong>传入六个部分：(scheme, netloc, path, params, query, fragment)，<br>将合成一个: <code>scheme://netloc/path;params?query#fragment</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;/index.php&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;id=5&#x27;</span>, <span class="string">&#x27;123&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlunparse(data)</span><br><span class="line"><span class="string">&#x27;https://www.baidu.com/index.php;user?id=5#123&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="urlencode-字典类型-转化为-GET请求参数"><a href="#urlencode-字典类型-转化为-GET请求参数" class="headerlink" title="urlencode()  字典类型 转化为 GET请求参数"></a>urlencode()  字典类型 转化为 GET请求参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">&#x27;http://www.baidu.com?&#x27;</span></span><br><span class="line">url = base_url + urlencode(params)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(result)</span></span><br><span class="line"><span class="string">http://www.baidu.com?name=germey&amp;age=22</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="parse-qs-GET请求参数-转化为-字典类型"><a href="#parse-qs-GET请求参数-转化为-字典类型" class="headerlink" title="parse_qs()  GET请求参数 转化为 字典类型"></a>parse_qs()  GET请求参数 转化为 字典类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">query = <span class="string">&#x27;name=germey&amp;age=22&#x27;</span></span><br><span class="line">print(parse_qs(query))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(result)</span></span><br><span class="line"><span class="string">&#123;&#x27;name&#x27;: [&#x27;germey&#x27;], &#x27;age&#x27;: [&#x27;22&#x27;]&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>另有一个 <code>parse_qsl()</code> 与 <code>parse_qs()</code> 类似，只是得到的结果是 元组</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>这个库中还有一些 <code>urljoin</code> 等方式，可以在 <a href="https://germey.gitbooks.io/python3webspider/content/3.1.3-%E8%A7%A3%E6%9E%90%E9%93%BE%E6%8E%A5.html">这里</a> 查看。</p><h3 id="urllib-robotparser-分析Robots协议"><a href="#urllib-robotparser-分析Robots协议" class="headerlink" title="urllib.robotparser 分析Robots协议"></a>urllib.robotparser 分析Robots协议</h3><h4 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h4><p>网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。<br>它通常是一个叫做 robots.txt 的文本文件，放在网站的根目录下。</p><p>Robots协议的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *               这里的*代表的所有的搜索引擎种类，*是一个通配符</span><br><span class="line">Disallow: &#x2F;admin&#x2F;           这里定义是禁止爬寻admin目录下面的目录</span><br><span class="line">Disallow: &#x2F;require&#x2F;         这里定义是禁止爬寻require目录下面的目录</span><br><span class="line">Disallow: &#x2F;ABC&#x2F;             这里定义是禁止爬寻ABC目录下面的目录</span><br><span class="line">Disallow: &#x2F;cgi-bin&#x2F;*.htm    禁止访问&#x2F;cgi-bin&#x2F;目录下的所有以&quot;.htm&quot;为后缀的URL(包含子目录)。</span><br><span class="line">Disallow: &#x2F;*?*              禁止访问网站中所有包含问号 (?) 的网址</span><br><span class="line">Disallow: &#x2F;.jpg$            禁止抓取网页所有的.jpg格式的图片</span><br><span class="line">Disallow:&#x2F;ab&#x2F;adc.html       禁止爬取ab文件夹下面的adc.html文件。</span><br><span class="line">Allow: &#x2F;cgi-bin&#x2F;　          这里定义是允许爬寻cgi-bin目录下面的目录</span><br><span class="line">Allow: &#x2F;tmp                 这里定义是允许爬寻tmp的整个目录</span><br><span class="line">Allow: .htm$                仅允许访问以&quot;.htm&quot;为后缀的URL。</span><br><span class="line">Allow: .gif$                允许抓取网页和gif格式图片</span><br><span class="line">Sitemap:                    网站地图 告诉爬虫这个页面是网站地图</span><br></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">禁止所有搜索引擎访问网站的任何部分</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line"></span><br><span class="line">允许所有的robot访问</span><br><span class="line">User-agent: *</span><br><span class="line">Allow:　&#x2F;</span><br><span class="line"></span><br><span class="line">允许某个搜索引擎的访问</span><br><span class="line">User-agent: Baiduspider</span><br><span class="line">allow:&#x2F;</span><br></pre></td></tr></table></figure><h4 id="解析-Robots-txt-—-urllib-robotparser-RobotFileParser-类"><a href="#解析-Robots-txt-—-urllib-robotparser-RobotFileParser-类" class="headerlink" title="解析 Robots.txt —- urllib.robotparser.RobotFileParser 类"></a>解析 Robots.txt —- <code>urllib.robotparser.RobotFileParser</code> 类</h4><p>robotparser 模块提供了一个 <code>RobotFileParser</code> 类。它可以根据某网站的 robots.txt 文件来判断一个爬取爬虫是否有权限来爬取这个网页。</p><h5 id="RobotFileParser-实例的构造"><a href="#RobotFileParser-实例的构造" class="headerlink" title="RobotFileParser 实例的构造"></a><code>RobotFileParser</code> 实例的构造</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.robotparser.RobotFileParser(url&#x3D;&#39;&#39;)      # 传入 robots.txt 的链接</span><br></pre></td></tr></table></figure><h5 id="RobotFileParser-常用方法"><a href="#RobotFileParser-常用方法" class="headerlink" title="RobotFileParser 常用方法"></a><code>RobotFileParser</code> 常用方法</h5><ul><li><code>set_url(url)</code> 用来设置 robots.txt 的链接</li><li><code>read()</code> 读取 robots.txt 文件并进行分析。<br>⚠️【注意】如果不 read()，所有的判断函数都会返回 False！</li><li><code>parse()</code> 用来解析 robots.txt 文件，传入的参数是 robots.txt 某些行的内容，它会按照 robots.txt 的语法规则来分析这些内容。</li><li><code>can_fetch()</code> 传入两个参数，第一个是 User-agent，第二个是要抓取的 URL，返回的内容是该搜索引擎是否可以抓取这个 URL，返回结果是 True 或 False。</li><li><code>mtime()</code>，返回的是上次抓取和分析 robots.txt 的时间，这个对于长时间分析和抓取的搜索爬虫是很有必要的，你可能需要定期检查来抓取最新的 robots.txt。</li><li><code>modified()</code>，同样的对于长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析 robots.txt 的时间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础</title>
      <link href="/2019/02/10/PythonAndCrawler/crawler-1-basic/"/>
      <url>/2019/02/10/PythonAndCrawler/crawler-1-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h1><blockquote><p>本文主要介绍爬虫涉及到的基础知识。</p></blockquote><h2 id="HTTP-基本原理"><a href="#HTTP-基本原理" class="headerlink" title="HTTP 基本原理"></a>HTTP 基本原理</h2><h3 id="URI-amp-URL"><a href="#URI-amp-URL" class="headerlink" title="URI &amp; URL"></a>URI &amp; URL</h3><table><thead><tr><th>简写</th><th>全名</th><th>中文</th><th>说明</th></tr></thead><tbody><tr><td>URI</td><td>Uniform Resource Identifier</td><td>统一资源标志符</td><td>对应着一个资源</td></tr><tr><td>URL</td><td>Uniform Resource Locator</td><td>统一资源定位符</td><td>说明从哪里可以找到一个资源</td></tr><tr><td>URN</td><td>Universal Resource Name</td><td>统一资源名称</td><td>说明一个资源的唯一名字</td></tr></tbody></table><p>URI 包含着 URL 和 URN。</p><p>通常，我们使用的网址，就是一个URI，同时也是一个URL。</p><h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><blockquote><p>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。</p></blockquote><p>我们平时看到的网页的源代码使用 HTML 写出的，HTML 就是一种超文本。</p><h3 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP &amp; HTTPS"></a>HTTP &amp; HTTPS</h3><p>我们用URL访问资源需要指定使用的协议类型，协议就是URL地址一开始的那个字段。</p><table><thead><tr><th>协议</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>HTTP</td><td>Hyper Text Transfer Protocol（超文本传输协议）</td><td>用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档</td></tr><tr><td>HTTPS</td><td>Hyper Text Transfer Protocol over Secure Socket Layer（在SSL上的HTTP）</td><td>以安全为目标的 HTTP 通道，是 HTTP 的安全版</td></tr></tbody></table><p>HTTPS 相较于 HTTP 有以下优点：</p><ul><li>建立一个信息安全通道来保证数据传输的安全。</li><li>确认网站的真实性，凡是使用了 HTTPS 的网站，都可以通过点击浏览器地址栏的锁头标志来<br>查看网站认证之后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。</li></ul><h3 id="HTTP-请求过程"><a href="#HTTP-请求过程" class="headerlink" title="HTTP 请求过程"></a>HTTP 请求过程</h3><p>我们在浏览器中输入网址，便显示出一个网页的过程实际上是：</p><ol start="0"><li>浏览器向网站的服务器发送了一个请求；</li><li>服务器接收到这个请求后进行解析和处理；</li><li>服务器返回对应的响应；</li><li>浏览器对收到的响应解析；</li><li>浏览器将解析的结果显示出来，即最后我们看到的网页。</li></ol><p>我们可以在 Chrome浏览器 的开发者工具的“Network”页面看到的一个条目就是一次 <em>发送请求和接收响应</em> 的过程。</p><table><thead><tr><th>Network的列</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>请求的名称，一般会将 URL 的最后一部分内容当作名称 。</td></tr><tr><td>Status</td><td>响应的状态码，这里显示为 200， 代表响应是正常的 。 通过状态码，我们可以判断发送了请求之后是杏得到了正常的响应 。</td></tr><tr><td>Type</td><td>请求的文梢类型 。 这里为 document，代表我们这次请求的是一个 HTML文档， 内容就是一些 HTML代码。</td></tr><tr><td>Initiator</td><td>请求源 。 用来标记请求是由哪个对象或进程发起的 。</td></tr><tr><td>Size</td><td>从服务器下载的文件和请求的资源大小 。 如果是从缓存中取得的资源，则该列会显示from cache。</td></tr><tr><td>Time</td><td>发起请求到获取响应所用的总时间 。</td></tr><tr><td>Waterfall</td><td>网络请求的可视化瀑布流 。</td></tr></tbody></table><p>点击条目，我们将看到更加详细的请求、响应信息。</p><h3 id="请求（Request）"><a href="#请求（Request）" class="headerlink" title="请求（Request）"></a>请求（Request）</h3><p>请求，是由 <strong>客户端</strong> 向 <strong>服务端</strong> 发出的。</p><p>请求分为4部分：</p><ul><li><p><strong>请求方法</strong>（Request Method）：常见的请求方法分为两种 GET 和 POST：</p><ul><li><code>GET</code> 请求中的参数包含在 URL 里面，数据可以在 URL 中看到（可能暴露敏感信息）。GET请求提交的数据最多只有 1024 字节。</li><li><code>POST</code> 请求中的 URL 不包含数据，数据都是通过表单形式传输的，会包含在请求体中。POST方式没有大小限制（可以传文件）。</li><li>我们输入一个网址，这是一个 GET 请求。</li><li>其实还有一些其他的请求方法，可以参考 <a href="http://www.runoob.com/http/http-methods.html">HTTP请求方法</a></li></ul></li><li><p><strong>请求地址</strong>（Request URL）：统一资惊定位符 URL，唯一确定我们想请求的资源。</p></li><li><p><strong>请求头</strong>（Request Headers）：用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、 Referer、 User-Agent：</p><ul><li><code>Accept</code>: 请求报头域，用于指定客户端可 <strong>接受哪些类型的信息</strong>。</li><li><code>Accept-Language</code>: 指定客户端可接受的 <strong>语言类型</strong>。</li><li><code>Acceot-Encoding</code>: 指定客户端可接受的 <strong>内容编码</strong>。</li><li><code>Host</code>: 指定 <strong>请求资源的主机 IP 和端口号</strong>，其内容为 <strong>请求 URL 的原始服务器或网关的位置</strong>。</li><li><code>Cookies</code>: 网站为了辨别用户进行会话跟踪而 <strong>存储在用户本地的数据</strong>。它的主要功能是 <strong>维持当前访问会话</strong>，如检查用户登录。</li><li><code>Referer</code>: 此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相 应的处理，如做来源统计、防盗链处理等 。</li><li><code>User-Agent</code>: 简称 UA，它可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。 <strong>在做爬虫时加上此信息，可以伪装为浏览器; 如果不加，很可能会被识别州为爬虫 。</strong></li><li><code>Content-Type</code>: 也叫互联网媒体类型( Internet Media Type )或者 MIME类型，在 HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。<ul><li>text/html 代表 HTML 格式</li><li>image/gif代表 GIF 图片</li><li>application/json代表 JSON类型</li><li>详见 <a href="http://tool.oschina.net/commons/">Content-Type 请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。对照表</a></li></ul></li></ul></li><li><p><strong>请求体</strong>（Request Body）：</p><ul><li><code>POST</code> 的请求体是表单数据;</li><li><code>GET</code> 的请求体为空;</li></ul></li></ul><h3 id="响应（Response）"><a href="#响应（Response）" class="headerlink" title="响应（Response）"></a>响应（Response）</h3><p>响应，由 <strong>服务端</strong> 返回给 <strong>客户端</strong>：</p><ul><li><strong>响应状态码</strong>（Response Status Code）：表示服务器的响应状态<ul><li>HTTP状态码分类，具体HTTP状态码列表，见<a href="http://www.runoob.com/http/http-status-codes.html">HTTP状态码</a></li></ul></li></ul><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><ul><li><p><strong>响应头</strong>（Response Headers）: 响应头包含了服务器对请求的应答信息</p><ul><li><code>Date</code>: 标识 <strong>响应产生的时间</strong></li><li><code>Last-Modified</code>: 指定 <strong>资源的最后修改时间</strong></li><li><code>Content-Encoding</code>: 指定响应 <strong>内容的编码</strong></li><li><code>Server</code>: 包含 <strong>服务器的信息</strong>，比如名称、版本号等</li><li><code>Content-Type</code>: 文档类型，指定 <strong>返回的数据类型</strong> 是什么（和 Request 的一样）</li><li><code>Set-Cookie</code>: <strong>设置 Cookies</strong>。告诉浏览器需要将此内容放在 Cookies 中， 下次请求携带 Cookies 请求</li><li><code>Expires</code>: <strong>指定响应的过期时间</strong>，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从<strong>缓存</strong>中加载，降低服务器负载，缩短加载时间。</li></ul></li><li><p><strong>响应体</strong>（Response Body）响应的正文数据都在响应体中</p><ul><li>请求网页时，它的响应体就 是网页的 HTML代码</li><li>请求一张图片时， 它的响应体就是图片的二进制数据</li><li>我们做爬虫请求网页后，要解析的内容就是响应体</li></ul></li></ul><h2 id="网页基础"><a href="#网页基础" class="headerlink" title="网页基础"></a>网页基础</h2><p>网页分为三大部分 ———— HTML（框架），CSS（样式），JavaScript（逻辑）。</p><h3 id="HTML-超文本标记语言"><a href="#HTML-超文本标记语言" class="headerlink" title="HTML, 超文本标记语言"></a>HTML, 超文本标记语言</h3><p>详见 <a href="http://www.w3school.com.cn/html/index.asp">HTML 教程</a>。</p><p>Another recommended HTML guide: <a href="https://www.websiteplanet.com/blog/html-guide-beginners/">https://www.websiteplanet.com/blog/html-guide-beginners/</a></p><h3 id="CSS-层叠样式表"><a href="#CSS-层叠样式表" class="headerlink" title="CSS, 层叠样式表"></a>CSS, 层叠样式表</h3><p>详见 <a href="http://www.w3school.com.cn/css/index.asp">CSS 教程</a></p><h3 id="JavaScript-脚本语言"><a href="#JavaScript-脚本语言" class="headerlink" title="JavaScript, 脚本语言"></a>JavaScript, 脚本语言</h3><p>详见 <a href="http://www.w3school.com.cn/js/index.asp">JavaScript 教程</a></p><h3 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h3><p>在 HTML 中，所有标签定义的内容都是节点，它们构成了一个 HTML DOM 树。（DOM：文档对象模型）<br>通过 HTML DOM，树中的所有节点均可通过 JavaScript访问，所有 HTML 节点元素均可被修改，也可以被创建或删除 。</p><p>详见 <a href="http://www.w3school.com.cn/htmldom/index.asp">HTML DOM 教程</a></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>在 css 中，我们使用 css 选择器来定位节点。</p><p>详见 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器表</a></p><h2 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h2><p>爬虫是<strong>获取</strong>网页并<strong>提取</strong>和<strong>保存</strong>信息的<strong>自动化程序</strong>。</p><p>可以说，我们能在浏览器中看到的一切内容，都可以通过爬虫得到（包括那些由JavaScript渲染出来的网页）。</p><p>爬虫主要解决以下几个问题：</p><h4 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h4><p>构造一个请求并发送给服务器，然后接收到响应并将其解析出来。</p><p>我们可以用urllib、 requests 等库来帮助我们实现 HTTP请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的 Body 部分即可，即得到网页的源代码。</p><h4 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h4><p>分析网页源代码，从中提取我们想要的数据。 </p><p>最通用的方法是采用 <strong>正则表达式</strong> 提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。<br>使用 Beautiful Soup、 pyquery、 lxml 等库，我们可以高效快速地从中提 取网页信息，如节点的属性、文本值等。</p><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><p>将提取到的数据保存到某处以便后续使用。 </p><h4 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h4><p>让爬虫来代替人，完成上述这些操作。<br>并在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p><h2 id="会话-和-Cookies"><a href="#会话-和-Cookies" class="headerlink" title="会话 和 Cookies"></a>会话 和 Cookies</h2><p>HTTP 本身是<em>无状态</em>的，这是指 HTTP 协议对事物的处理是没有记忆能力的。<br>换言之，服务器 不知道 客户端是说明状态。</p><p>然而，我们日常接触的很多网页都可以实现用户登录等需要服务器<em>记住</em>客户端的操作。<br>实现这一类操作，就会用到 <strong>会话</strong> 和 <strong>Cookies</strong>。</p><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p><strong>会话</strong>，是一系列有始有终的动作/消息。例如，从拿起电话拨号到挂断 电话这中间的一系列过程可以称为一个会话。 </p><p>在 Web 中，<strong>会话对象</strong> 用来存储特定用户会话所需的属性及配置信息。</p><p>当用户在应用程序的 Web 页之间跳转时，存储在会话对象中的变量将不会丢失（如用户的登录状态）；<br>当用户请求来自应用程序的 Web 页时如果该用户还没有会话，则服务器将自动创建一个会话对象 ；<br>当会话过期或被放弃后，服务器将终止该会话；</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p><p>服务器可以通过 Cookies 得知 那个客户端对应着那个会话、那个用户。<br>在 <strong>客户端</strong> 的 <em>Cookies</em> 和 <strong>服务端</strong> 的 <em>会话</em> 的协作下，我们便可以实现会话的维持。</p><p>Cookie有如下几个属性 ：</p><ul><li><p><code>Name</code>: 该 Cookie 的名称。一旦创建，该名称便不可更改。 </p></li><li><p><code>Value</code>: 该 Cookie 的值。</p><ul><li>如果值为 <code>Unicode</code> 字符，需要为字符编码。</li><li>如果值为二进制数据，则需要使用 <code>BASE64</code> 编码。</li></ul></li><li><p><code>Domain</code>: 可以访问该 Cookie的域名。例如，如果设置为 <code>.zhihu.com</code>，则所有以 <code>zhihu.com</code> 结尾的域名都可以访问该 Cookie。</p></li><li><p><code>MaxAge</code>: 该 Cookie失效的时间，单位为秒，也常和 <code>Expires</code> 一起使用，通过它可以计算有效时间。</p><ul><li>MaxAge 如果为正数，则该Cookie在MaxAge秒之后失效。</li><li>如果为负数，则关闭 浏览器时 Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。  </li></ul></li><li><p><code>Path</code> : 该 Cookie 的使用路径。<br>如果设置为 <code>/path/</code>，则只有路径为 <code>/path/</code> 的页面可以访问该 Cookie。<br>如果设置为 <code>/</code> 则本域名下的所有页面都可以访问该 Cookie。</p></li><li><p><code>Size</code>字段: 此 Cookie 的大小。</p></li><li><p><code>HTTP</code> 字段: Cookie 的 httponly 属性。</p><ul><li>若此属性为 true，则只有在 HTTP 头中会带有此 Cookie的信息，而不能通过 document.cookie来访问此 Cookie。</li></ul></li><li><p><code>Secure</code>: 该 Cookie 是否仅被使用安全协议传输。安全协议有 HTTPS 和 SSL 等，在网络上传输数据之前先将数据加密。默认为 false。 </p></li></ul><h2 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h2><p>在我们正常请求一个网站时，我们直接把请求发给了Web服务器，Web服务器又直接把响应回传给我们。</p><p>而如果我们使用 <strong>代理服务</strong>，就等于是多了一个中间人，即<em>代理服务器</em>，这个过程变成了：<br>我们直接把请求发给 代理服务器，代理服务器 把响应回传给 代理服务器，代理服务器再把这个消息传给我们。</p><p>通过代理，我们就可以伪装IP，防制在爬虫时被查出来封IP或事需要提供验证码，影响爬虫运行。</p><p>⚠️【注意】并不是所有的 代理 都可以让我们隐藏 IP！<br>有的 代理服务 会在向 web服务器 的请求 时，不会原封不动的转发我们的消息，而是在其中添加上我们的真实IP等信息，这时就隐藏不了了。</p>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3爬虫环境配置</title>
      <link href="/2019/02/09/PythonAndCrawler/crawler-0-env/"/>
      <url>/2019/02/09/PythonAndCrawler/crawler-0-env/</url>
      
        <content type="html"><![CDATA[<h1 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h1><blockquote><p>本文主要介绍 Python 3 网络爬虫 所需要的软件的安装及配置。</p></blockquote><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>我们在 <code>macOS X</code> 上使用 <code>Python 3.7</code> 来开发爬虫。</li></ul><h2 id="请求库-安装"><a href="#请求库-安装" class="headerlink" title="请求库 安装"></a><strong>请求库</strong> 安装</h2><p>网络爬虫，首先要获取网络上的数据，即抓取页面，这就需要我们模拟浏览器向服务器发出请求。<br>我们可以安装一些 Python 库来帮助我们比较容易地完成这个操作。</p><p>让我们来安装它们吧：</p><ul><li><p><strong>requests</strong> : 网络请求: </p><ul><li><code>pip3 inastal requests</code></li></ul></li><li><p><strong>Selenium</strong> : 自动测试工具（驱动浏览器执行特定的动作，如点击、下拉等 操作 ）:</p><ul><li> <code>pip3 install selenium</code></li></ul></li><li><p><strong>ChromeDriver</strong> : 用 <em>Chrome</em> 与 Selenium 配合工作:</p><ul><li>安装 Chrome 浏览器</li><li>在 Chrome 菜单（“···”） -&gt; “关于 Google Chrome”，查看当前Chrome版本。</li><li>从 <a href="http://chromedriver.chromium.org/">ChromeDriver官网</a> 下载配对 Chrome 版本的 ChromeDriver（⚠️【注意】ChromeDriver 一定要与 Chrome 的版本兼容！）。</li><li>解压下载的文件，得到可执行文件，将其加入环境变量（可以简单地把它放到环境变量中有的目录下）。</li></ul></li><li><p><strong>GeckoDriver</strong>: 用 <em>Firefox</em> 与 Selenium 配合工作:</p><ul><li><em>暂时并没有使用 Firefox，所以没有安装这个😂。</em></li></ul></li><li><p>~~<strong>PhantomJS</strong>: 还是配合 Selenium 工作的:</p><ul><li>(PhantomJS 简介)PhantomJS是一个无界面的、可脚本编程的 WebKit浏览器引擎，它原生支持多种 Web标准: DOM操作、 css选择器、 JSON、 Canvas以及 SVG。Selenium支持 PhantomJS，这样在运行的时候就不会再弹出 一个浏览器了 。 而且 PhantomJS 的运行效率也很高，还支持各种参数配置，使用非常方便。</li><li>从 <a href="http://phantomjs.org/">PhantomJS官网</a> 下载 PhantomJS。</li><li>将下载得到的目录中的 可执行文件 加入环境变量。</li><li>⚠️【注意】在 2018年3月4日， PhantomJS 宣布<a href="https://github.com/ariya/phantomjs/issues/15344">暂停开发</a>了！Selenium 也不再赞同使用 PhantomJS了。~~</li></ul></li><li><p><strong>aiohttp</strong>: 一个异步的 Web 服务库（相比之下 <code>requests</code> 是阻塞式的）:</p><ul><li><code>pip3 install aiohttp</code></li></ul></li><li><p><strong>cchardet</strong>: 字符编码检测库（aiohttp官方推荐安装的）:</p><ul><li><code>pip3 install cchardet</code></li></ul></li><li><p><strong>aiodns</strong>: 加速 DNS 的解析库（aiohttp官方推荐安装的）:</p><ul><li><code>pip3 install aiodns</code></li></ul></li></ul><h2 id="解析库-安装"><a href="#解析库-安装" class="headerlink" title="解析库 安装"></a><strong>解析库</strong> 安装</h2><p>抓取网页之后，我们就要从中提取有用的信息了。<br>我们当然可以使用令人望而生畏的 <strong>正则表达式</strong> 来完成这一操作；<br>不过，有很多强大的库可以帮助我们更优雅地处理这一问题。</p><p>下面，我们将安装这些库：</p><ul><li><p><strong>lxml</strong>: 一个 Python 的 HTML、XML 解析库，支持XPath:</p><ul><li><code>pip3 install lxml</code></li><li>这个库安装常有问题，主要可能是缺少必要的库，不同的平台，解决办法差异太大，应自行Google。</li></ul></li><li><p><strong>Beautiful Soup</strong>: 一个 Python 的 HTML、XML 解析库，拥有强大的API和多种解析方式:</p><ul><li><code>pip3 install beautifulsoup4</code></li><li>⚠️【注意】Beautiful Soup 安装好之后的库名是<code>bs4</code>，所以 import 的时候是<code>import bs4</code>。</li></ul></li><li><p><strong>pyquery</strong>: 一个提供了类似于 jQuery 的语法的 HTML 解析工具，支持 CSS 选择器:</p><ul><li><code>pip3 install pyquery</code></li></ul></li><li><p><strong>tesserocr</strong>: 一个 OCR 库，用来处理验证码:</p><ul><li>tesserocr 是对 tesseract 的 Python API 封装，故要先安装 <strong>tesseract</strong><ul><li><code>$ brew install imagemagick</code></li><li><code>$ brew install tesseract</code></li></ul></li><li><code>pip3 install tesserocr pillow</code></li><li>⚠️ 这时，在 Mac 上试图 <code>&gt;&gt;&gt; import tesserocr</code> 会遇到 <code>!strcmp(locale, &quot;C&quot;):Error:Assert failed:in file baseapi.cpp</code> 的断言失败，导致 <code>Illegal instruction: 4</code> 使 Python 错误退出。</li><li>要解决上述问题，可以通过 <code>$ export LC_ALL=C</code>（临时性），或把 <code>export LC_ALL=C</code> 写入 <code>~/.bashrc</code>（永久性）。</li></ul></li></ul><h2 id="数据库-安装"><a href="#数据库-安装" class="headerlink" title="数据库 安装"></a>数据库 安装</h2><ul><li><p><strong>MySQL</strong>: 关系型数据库:</p><ul><li><code>$ brew install mysql</code></li></ul></li><li><p><strong>MongoDB</strong>: 非关系型数据库:</p><ul><li><code>$ brew install mongodb</code></li></ul></li><li><p><strong>Redis</strong>: 一个基于内存的高效非关系型数据库:</p><ul><li><code>$ brew install redis</code></li></ul></li></ul><h2 id="储存库-安装"><a href="#储存库-安装" class="headerlink" title="储存库 安装"></a><strong>储存库</strong> 安装</h2><p>储存库 是让 Python 使用我们之前安装好的数据库的库。</p><ul><li><p><strong>PyMySQL</strong>: 让 Python 与 MySQL 交互:</p><ul><li><code>pip3 install pymysql</code></li></ul></li><li><p><strong>PyMongo</strong>: 让 Python 与 MongoDB 交互:</p><ul><li><code>pip3 install pymongo</code></li></ul></li><li><p><strong>redis-py</strong>: 让 Python 与 Redis 交互:</p><ul><li><code>pip3 install redis</code></li></ul></li><li><p><strong>RedisDump</strong>: 一个用于 Redis 数据导入/导出的工具，基于Ruby:</p><ul><li>安装 RedisDump 首先要安装 <code>Ruby</code>，这里我们使用 MacOS 自带的 Ruby。</li><li>使用 Ruby 的 gem（类似于pip）安装 RedisDump：<ul><li><code>$ sudo gem install redis-dump</code></li><li>⚠️【注意】由于安装目录是 MacOS 的一部分，必须要sudo，否则无权安装！</li></ul></li></ul></li></ul><h2 id="Web库-安装"><a href="#Web库-安装" class="headerlink" title="Web库 安装"></a><strong>Web库</strong> 安装</h2><p>我们需要用到 Web服务程序 来搭建一些 API接口，供爬虫使用。</p><ul><li><p><strong>Flask</strong>: 一个轻量级 Web 服务程序，这里用来做一些 API 服务:</p><ul><li><code>pip3 install flask</code></li></ul></li><li><p><strong>Tornado</strong>: 一个异步的 Web 框架:</p><ul><li><code>pip3 install tornado</code></li></ul></li></ul><h2 id="App爬取相关库-安装"><a href="#App爬取相关库-安装" class="headerlink" title="App爬取相关库 安装"></a><strong>App爬取相关库</strong> 安装</h2><h2 id="爬虫框架-安装"><a href="#爬虫框架-安装" class="headerlink" title="爬虫框架 安装"></a><strong>爬虫框架</strong> 安装</h2><ul><li><p><strong>pyspider</strong>:</p><ul><li>首先要<em>解决一个依赖问题</em>：<code>$ PYCURL_SSL_LIBRARY=openssl LDFLAGS=&quot;-L/usr/local/opt/openssl/lib&quot; CPPFLAGS=&quot;-I/usr/local/opt/openssl/include&quot; pip3 install --no-cache-dir pycurl</code></li><li><code>$ pip3 install pyspider</code></li><li>pyspider v0.3.10 中使用了一个名为 <code>async</code> 的变量，这个名字在 <code>Python 3.7</code> 中被列为了保留字，这意味着二者合作将无法运行！</li><li>在这里，我们为了解决这个问题，简单地把 pyspider 模块中所有的 <code>async</code> 替换成了 <code>async_</code>😂。</li></ul></li><li><p><strong>Scrapy</strong>: </p><ul><li>大多数的安装教程都要先: <code>$ xcode-select --install</code>，但我们跳过了这一步，并没有遇到问题。</li><li><code>pip3 install Scrapy</code></li></ul></li><li><p><strong>Scrapy-Splash</strong>: 一个 Scripy 中支持 JavaScript 渲染的工具:</p><ul><li>这是一个安装的链条：Scrapy-Splash &lt;- Splash &lt;- Docker</li><li>安装 <strong>Docker</strong>：<code>$ brew cask install docker</code></li><li>登录 <strong>Docker</strong>：<code>$ docker login</code></li><li>安装 <strong>Splash</strong>：<code>$ docker run -p 8050:8050 scrapinghub/splash</code></li><li>安装 <strong>Scrapy-Splash</strong>：<code>pip3 install scrapy-splash</code></li></ul></li><li><p><strong>Scrapy-Redis</strong>: Scrapy 的分布式拓展模块:</p><ul><li><code>pip3 install scrapy_redis</code></li></ul></li></ul><h2 id="部署相关库的安装"><a href="#部署相关库的安装" class="headerlink" title="部署相关库的安装"></a>部署相关库的安装</h2><ul><li><p>安装 &amp; 配置 <strong>Docker</strong>：</p><ul><li><code>$ brew cask install docker</code></li><li><a href="https://www.daocloud.io/mirror">使用 Docker 加速器</a></li></ul></li><li><p>安装 <strong>Scrapyd</strong>：</p><ul><li><code>pip3 install scrapyd</code></li><li><code>$ sudo mkdir /etc/scrapyd</code></li><li><code>$ sudo vim /etc/scrapyd/scrapyd.conf</code>，当然，也可以使用其他任何文本编辑器打开。</li><li>在其中写入以下内容（主要是参考<a href="https://scrapyd.readthedocs.io/en/stable/config.html#example">官方文档</a>，但做了有限的改动。）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[scrapyd]</span><br><span class="line">eggs_dir    &#x3D; eggs</span><br><span class="line">logs_dir    &#x3D; logs</span><br><span class="line">items_dir   &#x3D;</span><br><span class="line">jobs_to_keep &#x3D; 5</span><br><span class="line">dbs_dir     &#x3D; dbs</span><br><span class="line">max_proc    &#x3D; 0</span><br><span class="line">max_proc_per_cpu &#x3D; 4</span><br><span class="line">finished_to_keep &#x3D; 100</span><br><span class="line">poll_interval &#x3D; 5.0</span><br><span class="line">bind_address &#x3D; 0.0.0.0</span><br><span class="line">http_port   &#x3D; 6800</span><br><span class="line">debug       &#x3D; off</span><br><span class="line">runner      &#x3D; scrapyd.runner</span><br><span class="line">application &#x3D; scrapyd.app.application</span><br><span class="line">launcher    &#x3D; scrapyd.launcher.Launcher</span><br><span class="line">webroot     &#x3D; scrapyd.website.Root</span><br><span class="line"></span><br><span class="line">[services]</span><br><span class="line">schedule.json     &#x3D; scrapyd.webservice.Schedule</span><br><span class="line">cancel.json       &#x3D; scrapyd.webservice.Cancel</span><br><span class="line">addversion.json   &#x3D; scrapyd.webservice.AddVersion</span><br><span class="line">listprojects.json &#x3D; scrapyd.webservice.ListProjects</span><br><span class="line">listversions.json &#x3D; scrapyd.webservice.ListVersions</span><br><span class="line">listspiders.json  &#x3D; scrapyd.webservice.ListSpiders</span><br><span class="line">delproject.json   &#x3D; scrapyd.webservice.DeleteProject</span><br><span class="line">delversion.json   &#x3D; scrapyd.webservice.DeleteVersion</span><br><span class="line">listjobs.json     &#x3D; scrapyd.webservice.ListJobs</span><br><span class="line">daemonstatus.json &#x3D; scrapyd.webservice.DaemonStatus</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Scrapyrt</strong>:</p><ul><li><code>pip3 install scrapyrt</code></li></ul></li><li><p><strong>Gerapy</strong>:</p><ul><li><code>pip3 install gerapy</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Crawler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-9.2-awk</title>
      <link href="/2017/01/12/Linux/linux-9-2-Awk/"/>
      <url>/2017/01/12/Linux/linux-9-2-Awk/</url>
      
        <content type="html"><![CDATA[<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><h2 id="awk命令的通用语法格式"><a href="#awk命令的通用语法格式" class="headerlink" title="awk命令的通用语法格式"></a>awk命令的通用语法格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;commands&#125;&#39;</span><br><span class="line">    commands为一个或多个命令</span><br><span class="line">    常用选项：</span><br><span class="line">        -f，表明awk命令将从该标志之后的文件中读取指令而不是从命令行读取；</span><br><span class="line">        -Fc，这个标志表明字段之间的分隔符是c而不是默认的空白字符（如制表键、一个或多个空格符）。</span><br></pre></td></tr></table></figure><p>常用点：</p><ul><li><strong>print</strong>：将一行接一行地打印出文件中的所有数据行。</li></ul><p>可用 <code>print str1 str2 int1,int2...</code></p><p>也可<code>print(A,B,C,...)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who | awk &#39;&#123; print &#125;&#39;</span><br><span class="line">        &#x3D;&#x3D;直接使用「who」</span><br></pre></td></tr></table></figure><p>awk 中也可以用 c 风格的 printf()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Total: %s\n&quot;,totalsize)</span><br><span class="line">    用printf注意&#39;\n&#39;</span><br></pre></td></tr></table></figure><h2 id="n：字段变量"><a href="#n：字段变量" class="headerlink" title="$n：字段变量"></a><code>$n</code>：字段变量</h2><p>在文件和Linux命令的结果显示中:</p><pre><code>    每行信息被指定的分隔符分隔成若干个字段，    每个字段都被赋予一个唯一的标识符。    如，字段1的标识符是 `$1`，字段2的标识符是 `$2` 等。    特殊地，有变量 `$0` 表示整行 「`$0=re(&#39;^\*$&#39;)`」</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ who | awk &#39;&#123; print $1 &#125;&#39;</span><br><span class="line">    列出who命令显示结果中每行的第1个字段，即目前登录Linux系统的用户名</span><br><span class="line">$ who | awk &#39;&#123; print &quot;User  &quot; $1 &quot; is on terminal line &quot; $2&#125;&#39;</span><br><span class="line">    再上一个命令的基础上加入一些解释性的话</span><br><span class="line">$ awk &#39;&#123; print &quot;Employee  &quot; $2 &quot; has salary &quot; $4&#125;&#39; emp.data</span><br><span class="line">    emp.data文件中的第2个字段为员工姓，第4个字段为工资，</span><br><span class="line">    在员工姓前加上Employee，</span><br><span class="line">    在员工的姓和工资之间加上has salary字符串</span><br><span class="line">$ egrep &#39;foo|bar&#39; &#x2F;etc&#x2F;passwd | awk -F: &#39;&#123; print $1&quot; has &quot; $7 &quot; as loggin shell.&quot; &#125;&#39;</span><br><span class="line">        # 在&#x2F;etc&#x2F;passwd中所有的字段都是以:分隔的。</span><br><span class="line">  获取某些用户登录时使用的shell：</span><br><span class="line">    egrep命令从&#x2F;etc&#x2F;passwd文件中抽取包含foo或bar的数据行；</span><br><span class="line">    awk命令把冒号看成字段的分隔符并将列出第1个（用户名）和第7个字段（登录时的shell），</span><br><span class="line">    同时还将在显示结果中加入一些描述信息以帮助阅读和理解；</span><br><span class="line">$ awk -F: &#39;&#123; print $7 &#125;&#39; &#x2F;etc&#x2F;passwd | sort | uniq -c</span><br><span class="line">    获取系统上各个shell分别被几个用户默认使用</span><br><span class="line">$ grep &#x2F;bin&#x2F; &#x2F;etc&#x2F;passwd | awk -F: &#39;&#123; print $1&quot; &quot; $7 &#125;&#39; | sed &#39;&#x2F;sync&#x2F;d&#39; | sort</span><br><span class="line">    获取哪些用户在登录时使用的shell是存放在&#x2F;bin目录中以及这个shell的名字；</span><br><span class="line">    并且有个用&#x2F;bin&#x2F;sync的sync用户，不让它出现在显示的结果；</span><br><span class="line">    最后进行排序。</span><br><span class="line">$ who | awk &#39;&#123; print $6&quot;: &quot;$0&#125;&#39;</span><br><span class="line">     在每个用户记录的最前面显示这个用户登录Linux系统所使用的计算机</span><br><span class="line">     # who显示结果中的最后一个字段是用户登录Linux系统所使用的计算机的IP地址，如果为空表示是本机登录</span><br></pre></td></tr></table></figure><h2 id="NF、NR变量"><a href="#NF、NR变量" class="headerlink" title="NF、NR变量"></a><code>NF</code>、<code>NR</code>变量</h2><ul><li><code>NF</code></li></ul><p>若 在命令表达式中使用没有 <code>$</code> 符号的NF变量：</p><pre><code>     `NF` 将显示一行记录中**有多少个字段**。</code></pre><p>若 在命令表达式中使用带有<code>$</code>符号的NF变量，</p><pre><code>     `$NF` 将显示一行记录中**最后一个字段**(即，第NF个字段 -&gt; 最后一个字段)</code></pre><ul><li><code>NR</code></li></ul><p>变量 <code>NR</code> 用来追踪所显示的数据行的数目，即<strong>显示数据行的编号</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ who | awk &#39;&#123; print NF &#125;&#39;</span><br><span class="line">    列出who命令显示结果中每一行的字段数（列数）</span><br><span class="line">$ who | awk &#39;&#123; print $NF &#125;&#39;</span><br><span class="line">    列出who命令显示结果中每一行的最后一个字段</span><br><span class="line">$ egrep &#39;bin|sbin&#39; &#x2F;etc&#x2F;passwd | awk -F: &#39;&#123; print $NF &#125;&#39; | sort | uniq -c | sort -n</span><br><span class="line">    egrep    ：从&#x2F;etc&#x2F;passwd文件中抽取包含bin或sbin的数据行</span><br><span class="line">    awk      ：把冒号看成字段的分隔符，列出每一行的最后一个字段</span><br><span class="line">    sort     ：将那些字段进行排序</span><br><span class="line">    uniq -c  ：合并相同行，并在每行前面冠以该行出现次数</span><br><span class="line">    sort -n  ：按次数的大小进行排序。</span><br><span class="line">$ ls -l ~&#x2F;wolf | awk &#39;&#123; print NR&quot;: &quot;$0&#125;&#39;        # 用N给每行一个编号</span><br><span class="line">1: total 16</span><br><span class="line">2: drwxrwxr-x  2 dog dog 4096 Jan 25  2009 boywolf</span><br><span class="line">3: -rw-rw-r--  1 dog dog   84 Dec 22 19:07 delete_disable\</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li>awk的command中print可打印 <code>\n</code>, <code>\t</code> 等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lF &#x2F;boot | awk &#39;&#123; print $5 &quot;\t&quot; $9&#125;&#39; | sort -rn | head -3</span><br><span class="line">    列出&#x2F;boot目录中每一个文件的文件名和大小，文件的大小在前，而文件名随后，文件大小和文件名由制表键隔开。</span><br><span class="line">    按大小反序排列（从大到小）</span><br><span class="line">    把其中最大的3个文件</span><br></pre></td></tr></table></figure><h2 id="awk中计算"><a href="#awk中计算" class="headerlink" title="awk中计算"></a>awk中计算</h2><p>变量使用前不用声明</p><p>使用c语言的运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lF &#x2F;boot | awk &#39;&#123; totalsize +&#x3D; $5; print totalsize &#125;&#39;</span><br><span class="line">    获取&#x2F;boot目录中所有文件大小的总和</span><br><span class="line">    （将得到累加过程中每一步的totalsize值）</span><br><span class="line">为得到最终结果，不输出中间值：</span><br><span class="line">$ ls -lF &#x2F;boot | awk &#39;&#123; totalsize +&#x3D; $5; print totalsize &#125;&#39; | tail -1</span><br><span class="line">    除了使用tail命令之外，一种更好的方法是在awk命令中使用END关键字：</span><br><span class="line">$ ls -lF &#x2F;boot | awk &#39;&#123; totalsize +&#x3D; $5&#125; END &#123; print totalsize &#125;&#39;</span><br></pre></td></tr></table></figure><h2 id="END-关键字："><a href="#END-关键字：" class="headerlink" title="END 关键字："></a><code>END</code> 关键字：</h2><p>在最后一步执行END后的{statements}，如上例最后一个命令。</p><h2 id="将-commands表达式放入文件"><a href="#将-commands表达式放入文件" class="headerlink" title="将 commands表达式放入文件"></a>将 <code>commands</code>表达式放入文件</h2><ul><li>用cat</li></ul><p>框中为要输入的（注意末尾新行键入EOF后回车（&lt;&lt;EOF）可以自动退出）</p><p>（直接用cat &gt; script2写完后ctrl+D也可以）</p><p>用此法会有写完后文件中“$5”字样缺失的问题。</p><ul><li>用vi直接写完保存更好（不用写EOF，也没有$n缺失的问题）</li></ul><p>保存入文件后可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lF &#x2F;boot | awk -f script1</span><br></pre></td></tr></table></figure><ul><li>将awk写入shell脚本</li></ul><p>将一些经常使用的命令放入一个正文文件，这个文件就是所谓的shell脚本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写入：（注意用&quot;&quot;把命令括起来，否则将把&quot;$(ls ...)&quot;写入）</span><br><span class="line">$ echo &quot;ls -lF &#x2F;boot | awk -f script1&quot; &gt; boot_size</span><br><span class="line">调用：</span><br><span class="line">$ bash boot_size</span><br><span class="line">$ sh boot_size</span><br><span class="line">$ ksh boot_size</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="awk中使用if条件、for循环与-C-语言相似"><a href="#awk中使用if条件、for循环与-C-语言相似" class="headerlink" title="awk中使用if条件、for循环与 C 语言相似"></a>awk中使用if条件、for循环与 C 语言相似</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk  &#39;&#123; if (length($4) &#x3D;&#x3D; 3  ) print $0 &#125;&#39; emp.data | wc -l</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6b0tm7hpgj30go04qjrv.jpg" alt="IMG_1074"></p><p><code>count[length($1)]++</code>：将第1个字段的长度作为数组元素的下标，并将这个数组元素的个数加1再重新存回到原来的数组元素中。（似动态语言）</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-9.1-sed</title>
      <link href="/2017/01/11/Linux/linux-9-1-Sed/"/>
      <url>/2017/01/11/Linux/linux-9-1-Sed/</url>
      
        <content type="html"><![CDATA[<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>利用被称为管道操作符的|，多个命令由管道符连成了管道线。</p><p>在UNIX或Linux系统中，流过管道线的信息（数据）就叫做流（stream）;</p><p>为了编辑或修改一条管道中的信息，就使用流编辑器（stream editor）;</p><p>这是sed这个命令的名字的由来。</p><p>sed编辑文件，将结果输出到1，不改变原文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] &#39;以引号括起来的命令表达式&#39; [输入文件]</span><br><span class="line">    -e &lt;expression&gt;：e是expression, 以选项中指定的script来处理输入的文本文件，后接表达式</span><br><span class="line">    -f &lt;file&gt;：以选项中指定的script文件来处理输入的文本文件。</span><br><span class="line">    -i：直接在文件中替换，不在终端输出</span><br><span class="line">            -i常和 备份原本文件的-l 配合使用。</span><br><span class="line">    在sed命令中使用多个命令表达式，这命令表达式中间要使用分号（;）分隔开</span><br></pre></td></tr></table></figure><p><span style="color: rgb(51, 51, 51);">在一个文件中指定数据行的范围内抽取某一字符串并用新的模式替代它：</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#39;s&#x2F;旧模式&#x2F;新模式&#x2F;标志&#39; file</span><br><span class="line">        s是substitute，</span><br><span class="line">        两个最有用的标志分别是g和n。</span><br><span class="line">            g是globally，表示要替代每一行中所出现的全部模式。（无g只换每行的头一个）</span><br><span class="line">            n告诉sed只替代前n行中所出现的模式。</span><br></pre></td></tr></table></figure><p>    e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep CLERK emp.fmt | sed -e &#39;s&#x2F; &#x2F;;&#x2F;g;s&#x2F;CLERK&#x2F;ASSISTANT MANAGER&#x2F;g&#39;</span><br><span class="line">    1. grep将所有带CLERK的行找出；</span><br><span class="line">    2. sed 将所有的空格（分隔符）都转换成分号（;）；</span><br><span class="line">    3. sed 将所有的CLERK字符串都替换成ASSISTANT MANAGER；</span><br></pre></td></tr></table></figure><p>删除某行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sed &#39;nd&#39; file</span><br><span class="line">    在显示结果中删除第n行</span><br><span class="line">$ sed &#39;m,nd&#39; file</span><br><span class="line">    在显示结果中删除第m到n行</span><br><span class="line">$ sed &#39;&#x2F;str&#x2F;d&#39; file</span><br><span class="line">    删除所有带str的行</span><br><span class="line">$ sed &#39;&#x2F;^$&#x2F;d&#39; file</span><br><span class="line">    删除所有空行        # re(&quot;^$&quot;) means a line without any word.(只有开始符^和结尾符$的行)</span><br><span class="line">$ sed &#39;1,&#x2F;str&#x2F;d&#39; file</span><br><span class="line">    删除从第1行开始直到包含有str的数据行（包括有str的那行）</span><br></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）电子邮件和一些应用程序显示的每一行信息都是以&gt;开始的，使用下面的一条sed命令来做到这一点：</span><br><span class="line">$ sed &#39;&#x2F;^$&#x2F;d;s&#x2F;^&#x2F;&gt; &#x2F;g&#39; source &gt;result</span><br><span class="line">    第1个命令表达式&#x2F;^$&#x2F;d表示要删除所有的空行，</span><br><span class="line">    第2个命令表达式s&#x2F;^&#x2F;&gt;&#x2F;表示将开始符号替换成大于符号和空格符，</span><br><span class="line">    最后的&gt;result表示将sed命令的结果存入result文件。</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">（2）在删除所有空行的同时，删除所有包含了“cal“的行，并将所有的字符串“tie“变成“fox“,将结果保存：</span><br><span class="line">$ sed &#39;&#x2F;^$&#x2F;d;&#x2F;cal&#x2F;d;s&#x2F;tie&#x2F;fox&#x2F;g&#39; source &gt;result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-9.0-grep</title>
      <link href="/2017/01/10/Linux/linux-9-0-Grep/"/>
      <url>/2017/01/10/Linux/linux-9-0-Grep/</url>
      
        <content type="html"><![CDATA[<h1 id="grep-egrep-fgrep"><a href="#grep-egrep-fgrep" class="headerlink" title="grep/egrep/fgrep"></a>grep/egrep/fgrep</h1><p>grep、egrep、fgrep：搜索文件中满足特定模式(pattern)或字符串的内容，将结果输出到1，不改变原文件。</p><p>（UNIX中的patterns被称为 _Regular Expressions_）</p><blockquote><p>grep=”Global，Regular Expressions，Print”，即“在文件全局中用正则表达式搜索结果打印输出”</p></blockquote><p>grep、egrep能在一个或多个文件等内容中搜索某一特定的Character Pattern（R.E.）。</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep命令支持以下几种正则表达式的元字符（regular expression metacharacters），即通配符：</p><ul><li><code>c*</code> ：将匹配0个（即空白）或多个字符c（c为任一字符）。</li><li><code>.</code> ：将匹配任何一个字符而且只能是一个字符。</li><li><code>[xyz]</code> ：将匹配方括号中的任意一个字符。</li><li><code>[^xyz]</code>  ：将匹配不包括方括号中的字符的所有字符。</li><li><code>^</code> ：锁定行的开头。</li><li><code>$</code> ：锁定行的结尾。</li></ul><p>在基本正则表达式中：</p><p>        如元字符<code>*</code>、<code>+</code>、<code>&#123;</code>、<code>|</code>、<code>(</code> 和 <code>)</code> 已经失去了它们原来的含义，</p><p>        如果要恢复它们原本的含义要在之前冠以反斜线’\‘，如 <code>\*</code>、<code>\+</code>、<code>\&#123;</code>、<code>\|</code>、<code>\(</code> 和 <code>\)</code>。</p><p>grep命令是用来在每一个文件中或标准输出上搜索特定的模式。</p><p>当使用grep命令时，包含一个指定字符模式的每一行都会被打印在屏幕上，</p><p>使用grep命令并不改变文件中的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep 选项 模式 文件名</span><br><span class="line">        选项可以改变grep命令的搜寻方式：</span><br><span class="line">            -c：仅列出包含模式的行的数量。</span><br><span class="line">            -i：忽略模式中的字母大小写。</span><br><span class="line">            -l：列出带有匹配行的文件名。</span><br><span class="line">            -n：在每行的最前面列出行号。</span><br><span class="line">            -v：列出没有匹配模式的行。</span><br><span class="line">            -w：把表达式作为一个完整的单字来搜寻，忽略那些部分匹配的行。</span><br><span class="line">[⚠️]除了-w选项之外，其他的每个选项都可以在egrep和fgrep命令中使用。</span><br><span class="line">[⚠️]如果是搜索多个文件，grep命令的结果只显示在文件中发现匹配模式的文件名，而搜索的是单一的文件，grep命令的结果将显示每一个包含匹配模式的行。</span><br></pre></td></tr></table></figure><p><em>e.g.</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ grep CLERK emp.data        #显示包含了CLERK的行</span><br><span class="line">7369    SMITH   CLERK   800     17-DEC-80</span><br><span class="line">7876    ADAMS  CLERK   1100    23-MAY-87</span><br><span class="line">$ grep -c CLERK emp.data        # 只显示用几个满足行</span><br><span class="line">2</span><br><span class="line">$ grep ^78 emp.data      # 列出在emp.data文件中所有以78开始的数据行</span><br><span class="line">$ grep &#39;1..0&#39; emp.data    #&#39;1..0&#39;表示以1开始随后是两个任意字符最后是0的字符串。</span><br><span class="line">$ grep &#39;[12]..0&#39;        # &#39;[12]..0&#39;表示以1或2开始随后是两个任意字符最后是0的字符串。</span><br><span class="line">$ grep -l root group passwd hosts    # 在当前目录中的group、passwd和hosts 3个文件中搜索模式root并列出包含这一模式的文件名。</span><br><span class="line">$ grep &#39;&#x2F;bash$&#39; passwd    # 列出在passwd文件中所有以&#x2F;bash结尾的行（Get所有默认使用bash的用户）。</span><br><span class="line">$ ps -e | grep ftp    # 获取目前系统使用的ftp服务的进程名</span><br><span class="line">$ ps -e | grep ora    # To know is Oracle Database runing</span><br></pre></td></tr></table></figure><h3 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h3><p align="left"><span style="color: rgb(253, 4, 4);">/* egrep 在RHEL等Linux上其实是「grep -E」的别名 \*/</span></p><p align="left">egrep的语法格式与grep命令相同，</p>但egrep是用来在一个或多个文件的内容中利用**扩展的正则表达式**的元字符搜索特定的模式。<p>egrep所增加的元字符：</p><ul><li>+：匹配一个或多个前导字符。</li><li>a|b：匹配a或b。</li><li>(RE)：匹配括号中的正则表达式RE。</li></ul><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ egrep &#39;[1-5]+000&#39; emp.data        # 匹配1000，2000，3000，4000，5000</span><br><span class="line">$ egrep &#39;S[A-Z]+MAN&#39; emp.fmt        # 匹配“Sxx...xxMAN”</span><br><span class="line">$ egrep &#39;E(S|R) &#39; emp.fmt           # 在每一行数据中搜寻字母E后面紧跟着S或R</span><br></pre></td></tr></table></figure><h3 id="fgrep"><a href="#fgrep" class="headerlink" title="fgrep"></a>fgrep</h3><p><span style="color: rgb(253, 4, 4);">/* fgrep 在RHEL等Linux上其实是「grep -F」的别名 */</span></p><p>fgrep也用来在一个或多个文件中搜索与指定字符串匹配的行。</p><p>搜索文件fgrep的速度要比grep快，</p><p>fgrep可以一次迅速地搜索多个模式。</p><p>与grep不同，fgrep命令不能搜索任何正则表达式，</p><p>即将<strong>通配符当作普通字符</strong>来处理（按该字符的字面意思来处理）。</p><p>搜索文件命令fgrep不能使用特殊字符，只能搜索确定的模式。</p><p>fgrep既可以在命令行上键入搜索的模式，</p><p>也可以使用-f选项从文件中读取要搜索的模式。</p><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat emp.fmt | fgrep -f conditions</span><br><span class="line">    # 等价于</span><br><span class="line">$  fgrep -f conditions.txt emp.fmt</span><br><span class="line"># grep也可以如以上二者操作: 列出emp.fmt文件中所有与conditions.txt文件中内容相匹配的数据行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-8-邮件系统</title>
      <link href="/2017/01/09/Linux/linux-8-Mail/"/>
      <url>/2017/01/09/Linux/linux-8-Mail/</url>
      
        <content type="html"><![CDATA[<h1 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h1><h2 id="使用-mail-命令发送邮件："><a href="#使用-mail-命令发送邮件：" class="headerlink" title="使用 mail 命令发送邮件："></a>使用 <code>mail</code> 命令发送邮件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s &quot;主题&quot; 目标 [&lt; 内容]</span><br><span class="line">        目标：可以是本机上的用户名；</span><br><span class="line">            也可以是一般的邮件地址；</span><br><span class="line">        若使用重定向输入内容，Enter后直接发送，不回显；</span><br><span class="line">        若不重定向，键入命令后从stdin读邮件正文（类似于“cat &gt; file”）。</span><br><span class="line">    </span><br><span class="line">        要结束邮件内容，在一个空白行输入一个点(&#39;.&#39;)，然后Enter；</span><br><span class="line">        之后会出现“Cc: ”（Carbon copy，副本）填写抄送目标，Enter；</span><br><span class="line">        之后，mail发送邮件并退出。</span><br></pre></td></tr></table></figure><p>e.g.    <strong>foo</strong> 用户发送邮件给 <strong>bar</strong> 用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[foo@Example ~]$ mail -s &quot;A Testing Mail&quot; bar        # To bar</span><br><span class="line">Hi Bar,</span><br><span class="line">Its a testing mail.        # 正文</span><br><span class="line">From foo</span><br><span class="line">.                          # 结束</span><br><span class="line">Cc:                        # Enter，发送，退出</span><br><span class="line">[foo@Example ~]</span><br></pre></td></tr></table></figure><h2 id="阅读电子邮件"><a href="#阅读电子邮件" class="headerlink" title="阅读电子邮件"></a>阅读电子邮件</h2><ul><li>收件箱：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l &#x2F;var&#x2F;spool&#x2F;mail</span><br><span class="line">        Linux为每个用户准备了一个邮箱（file）</span><br><span class="line">        以存放用户的邮件（including all mails）</span><br><span class="line">$ cat &#x2F;var&#x2F;spool&#x2F;mail&#x2F;USER_NAME</span><br><span class="line">        查看某用户的所有邮件（收件箱）</span><br></pre></td></tr></table></figure><ul><li>显示收件箱中的邮件列表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[User@Example ~]$ mail        # to get a mail list.</span><br><span class="line">Heirloom Mail version 12.4 7&#x2F;29&#x2F;08.  Type ? for help.</span><br><span class="line">&quot;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;User&quot;: 2 messages 2 new</span><br><span class="line">&gt;N  1 Mail Delivery System  Thu Aug 23 12:46  80&#x2F;2695  &quot;Undelivered Mail Retu&quot;</span><br><span class="line"> N  2 Mail Delivery System  Thu Aug 23 12:52  94&#x2F;3407  &quot;Undelivered Mail Retu&quot;</span><br><span class="line">&amp; 2        # Enter the number after &#39;N&#39; to see the E-mail which you want.</span><br><span class="line">Head</span><br><span class="line">......        # Details.</span><br><span class="line">End</span><br><span class="line">&amp; x    # Enter &#123;x&#125; to keep that mail in Mail-Box,</span><br><span class="line">       # while &#123;q&#125; to move it to Trush-Box(mbox,a file to keep removed mail in $HOME).</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-7.1-管道(|)操作</title>
      <link href="/2017/01/07/Linux/linux-7-1-Pipes/"/>
      <url>/2017/01/07/Linux/linux-7-1-Pipes/</url>
      
        <content type="html"><![CDATA[<h1 id="管道-操作"><a href="#管道-操作" class="headerlink" title="管道(|)操作"></a>管道(|)操作</h1><h2 id="：管道："><a href="#：管道：" class="headerlink" title="|：管道："></a><code>|</code>：管道：</h2><p>“<span style="color: rgb(9, 175, 255);">$ </span><span style="color: rgb(9, 175, 255);">cmd1 | cmd2</span>” ：将cmd1的<strong>输出</strong>  <u>重定向</u> 为cmd2的<strong>输入。</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6b05sda96j31kw0km75u.jpg" alt="ink-image"></p><p>使用管道符号将两个命令组合起来就相当于使用水管接头将水龙头与高压水枪接在一起，还可以先将水龙头来的水送到热水炉加温后再送到高压水枪，使用水管接头将3个现有的正常工作器系统组合成一个新的功能更强的系统。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6b05sl6pxj30go01i0so.jpg" alt="IMG_1047"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ who | wc -l</span><br><span class="line">        显示工作用户数</span><br><span class="line">$ cat &#x2F;etc&#x2F;passwd | wc -l</span><br><span class="line">        显示注册用户数</span><br><span class="line">$ ls -lF &#x2F;bin | more</span><br><span class="line">        用more显示ls的大量信息（可翻页）</span><br></pre></td></tr></table></figure><h2 id="xargs”：将管道导入的数据转换成后面命令的输入参数"><a href="#xargs”：将管道导入的数据转换成后面命令的输入参数" class="headerlink" title="| xargs”：将管道导入的数据转换成后面命令的输入参数"></a><code>| xargs</code>”：将管道导入的数据转换成后面命令的输入参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat bd.txt</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line">$ cat bd.txt | xargs rm -f        # 删除a.txt，b.txt，c.txt</span><br></pre></td></tr></table></figure><h2 id="tee：命令分流输出：（T型管道）"><a href="#tee：命令分流输出：（T型管道）" class="headerlink" title="|tee：命令分流输出：（T型管道）"></a><code>|tee</code>：命令分流输出：（T型管道）</h2><p>将前一个命令的输出结果直接输入给后一个命令，同时还要将前面命令的结果存入一个文件。</p><blockquote><p>tee命令的功能就是将标准输入复制给每一个指定的文件和标准输出。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6b10dk5pcj31kw0km40s.jpg" alt="ink-image"></p><p> T型管道的概念来自生活中的自来水管的T型接头。在一个公厕的水管阀门上接了一个T型接头将“免费”的水进行了分流，同时接入了洗车的高压水枪和抽水马桶。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6b10nyojhj30bu043weo.jpg" alt="IMG_1048"></p><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cut -f1 -d: &#x2F;etc&#x2F;passwd | tee passwd.cut | sort -r | tee passwd.sort | more</span><br><span class="line">        从&#x2F;etc&#x2F;passwd中剪出注册用户名列表，通过在sort -r命令之前和之后加入管道符和tee命令的方式将排序之前和之后的数据分别存入passwd.cut和passwd.sort文件。</span><br><span class="line">        tee passwd.cut命令将由管道送过来的数据存入passwd.cut文件，同时还通过管道将这些数据送给下一个命令进行处理（sort -r命令进行反向排序）。tee passwd.sort命令将由管道送过来的数据（反向排序后的用户名）存入passwd.sort文件，同时还通过管道将这些数据送给下一个命令进行处理（more命令进行分页显示）。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-7.0-文件描述符与重定向</title>
      <link href="/2017/01/06/Linux/linux-7-0-IORedirections/"/>
      <url>/2017/01/06/Linux/linux-7-0-IORedirections/</url>
      
        <content type="html"><![CDATA[<h1 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h1><h2 id="文件描述：决定从哪里读输入，向哪里写-输出-与-错误"><a href="#文件描述：决定从哪里读输入，向哪里写-输出-与-错误" class="headerlink" title="文件描述：决定从哪里读输入，向哪里写 输出 与 错误"></a>文件描述：决定从哪里读输入，向哪里写 输出 与 错误</h2><p><strong>文件描述符：</strong></p><p> 由 <code>$ ls -l /dev/std*</code> 可见:</p><ul><li><code>0</code> ：stdin</li><li><code>1</code> ：stdout</li><li><code>2</code> ：stderr</li></ul><h2 id="输出重定向："><a href="#输出重定向：" class="headerlink" title="输出重定向："></a>输出重定向：</h2><ul><li><code>cmd [1|2]&gt; file</code> ：覆盖源文件，无则建</li><li><code>cmd [1|2\]&gt;&gt; file</code> ：追加，无则建</li></ul><blockquote><ol><li>不会自动递归补全路径</li><li><code>[1|2]</code>，文件描述符（stdin|stderr），缺省为 <code>1</code>，与 <code>&gt;</code> 之间无空格</li></ol></blockquote><ul><li><code>$ ls &gt; outfile 2&gt;&amp;1</code> -&gt;    将stdout、stderr一同重定向到 <code>outfile</code></li></ul><blockquote><p><code>1</code> 省略，<code>2</code> 重定向到 <code>1</code> 指向的文件</p></blockquote><ul><li><code>cmd &amp;&gt; file</code> ：把0，1，2都重定向至file。（<code>&amp;</code> 代表 <code>0&amp;1&amp;2</code>）</li></ul><blockquote><p>用<code>&amp;&gt;</code>可能会在文文件中产生一些无用的信息</p></blockquote><h2 id="输入重定向（-lt-）："><a href="#输入重定向（-lt-）：" class="headerlink" title="输入重定向（&lt;）："></a>输入重定向（<code>&lt;</code>）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tr &#39;A-Z&#39; &#39;a-z&#39; &lt; w.txt &gt; u.txt        # 将w中的大写-&gt;小写，放入u中</span><br><span class="line">                # 0 -&gt; w.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-6-计算与逃逸</title>
      <link href="/2017/01/05/Linux/linux-6-Computation/"/>
      <url>/2017/01/05/Linux/linux-6-Computation/</url>
      
        <content type="html"><![CDATA[<h1 id="计算与逃逸"><a href="#计算与逃逸" class="headerlink" title="计算与逃逸"></a>计算与逃逸</h1><ol><li>用Linux命令进行数字运算</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ $a1&#x3D;1;a2&#x3D;2;        # 定义变量，一行可多个</span><br><span class="line">$ echo $a1           # 输出a1的值</span><br><span class="line">$ echo $[$a1+$a2]    # 输出a1+a2的值</span><br><span class="line"># 可用运算有：</span><br><span class="line">     + - * &#x2F; % **    # 同Python，对整数用／要去尾</span><br></pre></td></tr></table></figure><ol start="2"><li><code>\</code>——逃逸符号</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;$6830&quot;        # 未定义的空变量$6</span><br><span class="line">830        # output</span><br><span class="line">$ echo &quot;\$6830&quot;       # 用“\”逃逸符号还原“$”</span><br><span class="line">$6830      # output</span><br></pre></td></tr></table></figure><p>‘\‘还可以放在命令最后表续行（在下一行继续输入该命令）</p><ol start="3"><li><p><code>&#39;str&#39;</code>、<code>&quot;str&quot;</code>：文字 -&gt; 字符串</p><ul><li><code>&#39;abc&#39;</code>   ：禁止所有命令行拓展功能</li><li><code>&quot;abc&quot;</code>  ：允许以下拓展：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$</span><br><span class="line">&#96;</span><br><span class="line">\</span><br><span class="line">!</span><br></pre></td></tr></table></figure></li><li><p>利用拓展：</p></li></ol><p>将一个命令的输出作为另一个的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Today is &#96;date&#96;&quot;</span><br><span class="line">等价于</span><br><span class="line">$ echo &quot;Today is $(date)&quot;</span><br><span class="line">即：</span><br><span class="line">    用“ &#96;cmd&#96; ”或“ $(cmd) ”实现：</span><br><span class="line">        print(&#39;Today is %s&#39; % cmd())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-5-快捷操作</title>
      <link href="/2017/01/04/Linux/linux-5-ShellShortcuts/"/>
      <url>/2017/01/04/Linux/linux-5-ShellShortcuts/</url>
      
        <content type="html"><![CDATA[<h1 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h1><h2 id="快速命令"><a href="#快速命令" class="headerlink" title="快速命令"></a>快速命令</h2><ul><li>认识默认bash提示符：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#96;whoami&#96; @ &#96;uname -n&#96;   &#96;pwd&#96;]</span><br></pre></td></tr></table></figure><ul><li>用<code>&#123;Tab&#125;</code>补全命令。</li></ul><p>若有多个可选方案，按一次不显示，按两次显示全部。</p><ul><li>Linux 通配符</li></ul><table><thead><tr><th>通配符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>匹配0或多个字符</td></tr><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>[xyz]</td><td>匹配括号中的任意一个字符</td></tr><tr><td>[x-y]</td><td>匹配x～y范围内所有字符</td></tr><tr><td>[^a-z]</td><td>除a～z的字符</td></tr><tr><td>[^xyz]</td><td>除括号中的任意字符</td></tr></tbody></table><ul><li>使用<code>&#123;&#125;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ touch &#123;a,b&#125;</span><br><span class="line">        分别touch文件a和b</span><br><span class="line">$ touch a.&#123;b,c&#125;</span><br><span class="line">        分别touch文件a.b和a.c</span><br><span class="line">$ touch &#123;a,b&#125;.&#123;c,d&#125;</span><br><span class="line">        分别touch文件a.c和a.d和b.c和b.d</span><br></pre></td></tr></table></figure><ul><li><p><code>history</code>命令：列出用户最近输入过的命令</p><p>​    左边是命令的编号</p><p>​    用<code>$ !&lt;n&gt;</code>：重新运行编号为<code>&lt;n&gt;</code>的命令</p></li><li><p><code>^x^y</code>：将上一命令中的x改为y后重新执行</p></li><li><p><code>&#123;上下箭头&#125;</code>：在以前使用过的命令中移动</p></li><li><p><code>&#123;ctrl+r&#125;</code>在命令的历史中查找:</p><ul><li>出现<code>(reverse-i-search)&#39;:</code></li><li>输入关键字</li><li>出现命令，回车执行</li></ul></li><li><p>先按<code>&#123;Esc&#125;</code>再按<code>&#123;.&#125;</code> 或 同时按<code>&#123;Alt+.&#125;</code>：提取上一命令的最后一个参数</p></li></ul><h2 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h2><ul><li><code>ctrl+A</code>: 光标移到命令行<strong>开头</strong>处</li><li><code>ctrl+E</code>: 光标移到命令行<strong>结尾</strong>处</li><li><code>ctrl+U</code>: 向前<strong>删除内容</strong>至提示符</li><li><code>ctrl+K</code>: 向后<strong>删除内容</strong>至结尾</li><li><code>ctrl+左|右</code>: 向左右<strong>移动</strong>一个字</li></ul><h2 id="Gnome终端快捷键"><a href="#Gnome终端快捷键" class="headerlink" title="Gnome终端快捷键"></a>Gnome终端快捷键</h2><ul><li><code>ctrl+shift+T</code>: 开启新选项卡</li><li><code>ctrl+PgUp/PgDn</code>: 切换到上/下个选项卡</li><li><code>alt+N</code>: 切换到第N个选项卡</li><li><code>ctrl+shift+C/V</code>: 复制，粘贴</li><li><code>ctrl+shift+W</code>: 关闭一个选项卡</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-4.2-正文处理</title>
      <link href="/2017/01/03/Linux/linux-4-2-TextHandle/"/>
      <url>/2017/01/03/Linux/linux-4-2-TextHandle/</url>
      
        <content type="html"><![CDATA[<h1 id="正文-处理"><a href="#正文-处理" class="headerlink" title="正文.处理"></a>正文.处理</h1><h2 id="unix2dos-dos2unix：Unix-与-DOS-正文转化"><a href="#unix2dos-dos2unix：Unix-与-DOS-正文转化" class="headerlink" title="unix2dos, dos2unix：Unix 与 DOS 正文转化"></a><code>unix2dos</code>, <code>dos2unix</code>：Unix 与 DOS 正文转化</h2><p>UNIX 系统的正文（纯文字）格式中只用换行符<code>\n</code>作为行结束符；</p><p>DOS &amp; Windows 系统的正文中是以回车符 <code>\r</code> 和换行符 <code>\n</code> 作为行结束符；</p><p>用 <code>cat -A filename</code> 可见二者区别。</p><p>将 DOS 格式的文件转换成 UNIX 格式的文件用 <code>dos2unix file_name</code>；</p><p>将 UNIX 格式的文件转换成 DOS 格式的文件用 <code>unix2dos file_name</code>；</p><h2 id="diff-sdiff：比较两个文件的差别"><a href="#diff-sdiff：比较两个文件的差别" class="headerlink" title="diff, sdiff：比较两个文件的差别"></a><code>diff</code>, <code>sdiff</code>：比较两个文件的差别</h2><h3 id="diff-file-1-file-2：只输出两者不同点"><a href="#diff-file-1-file-2：只输出两者不同点" class="headerlink" title="diff file_1 file_2：只输出两者不同点"></a><code>diff file_1 file_2</code>：只输出两者不同点</h3><p>显示结果中：</p><ul><li>字母c为 比较，比较某行二者不同点；</li><li>字母d是 不同，显示一文无一文有的；</li><li>“&lt;”表示第1个文件中的数据行。</li><li>“&gt;”表示第2个文件中的数据行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ diff letters.upper letters</span><br><span class="line">2c2        # 第1个文件的第2行与第2个文件的第2行比较。</span><br><span class="line">&lt; B        # 第1个文件的第2行为B。</span><br><span class="line">---</span><br><span class="line">&gt; b        # 第2个文件的第2行为b。</span><br><span class="line">6c6        # 第1个文件的第6行与第2个文件的第6行比较。</span><br><span class="line">&lt; F        # 第1个文件的第6行为F。</span><br><span class="line">---</span><br><span class="line">&gt; f        # 第2个文件的第6行为f。</span><br><span class="line">8d7        # 第1个文件一共有8行，而第2个文件一共有7行。</span><br><span class="line">&lt; H        # 第1个文件的第8行（也是最后一行）为H。</span><br></pre></td></tr></table></figure><h3 id="sdiff-file-1-file-2：side-by-side-输出两者所有行，标示不同"><a href="#sdiff-file-1-file-2：side-by-side-输出两者所有行，标示不同" class="headerlink" title="sdiff file_1 file_2：side-by-side 输出两者所有行，标示不同"></a><code>sdiff file_1 file_2</code>：side-by-side 输出两者所有行，标示不同</h3><p>显示结果中：</p><ul><li><p>“|”左侧表示第1个文件中的数据行。</p></li><li><p>“|”右侧表示第2个文件中的数据行。</p></li><li><p>“&lt;”表示第1个文件中的数据行（当第1个文件中有数据，但第2个文件中没有时）。</p></li><li><p>“&gt;”表示第2个文件中的数据行（当第2个文件中有数据，但第1个文件中没有时）。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sdiff letters.upper letters</span><br><span class="line">A                             A</span><br><span class="line">B                            | b            # 第1个文件中为B，第2个文件中为b。</span><br><span class="line">C                             C </span><br><span class="line">D                             D</span><br><span class="line">E                             E</span><br><span class="line">F                            | f            # 第1个文件中为F，第2个文件中为f。</span><br><span class="line">G                             G</span><br><span class="line">H                             &lt;            # 第1个文件中为H，第2个文件中的这一行为空。</span><br></pre></td></tr></table></figure><blockquote><p><code>sdiff</code> 命令的显示结果更容易阅读。<br>但是如果比较的两个文件很大，而其中的差别又很少，使用 <code>diff</code> 命令可能更好些。</p></blockquote><h2 id="aspell-look：检查单词的拼写"><a href="#aspell-look：检查单词的拼写" class="headerlink" title="aspell, look：检查单词的拼写"></a><code>aspell</code>, <code>look</code>：检查单词的拼写</h2><p>aspell，look 的字典是 <code>/usr/share/dict/words </code></p><h3 id="aspell"><a href="#aspell" class="headerlink" title="aspell"></a><code>aspell</code></h3><p><code>aspell</code> 是Linux系统上的一个交互式的英语拼写检查程序，该程序通过一个简单的菜单驱动的界面来提供改正英文单词的建议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ aspell check file_name</span><br><span class="line">        Enter后，</span><br><span class="line">        光标停留在第1个有拼写错误的单词上，</span><br><span class="line">        并在终端窗口下部给出一些可供选择的正确单词；</span><br><span class="line">        输入某个单词前面的编号来选择这个单词，</span><br><span class="line">        系统就会立即修改光标所在处的单词；</span><br><span class="line">        之后光标将移到下一个有拼写错误的单词。</span><br><span class="line">$ aspell list &lt; file_name</span><br><span class="line">            以非交互的方式在终端窗口中列出某个文件中的全部有拼法错误的英语单词</span><br></pre></td></tr></table></figure><p>• <code>look  &lt;sth&gt;</code>：列出所有以sth开头的英语单词以供选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ look progra</span><br><span class="line">prograde</span><br><span class="line">program</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="expand-fmt-pr-重新格式化正文"><a href="#expand-fmt-pr-重新格式化正文" class="headerlink" title="expand, fmt, pr: 重新格式化正文"></a><code>expand</code>, <code>fmt</code>, <code>pr</code>: 重新格式化正文</h2><h3 id="expand：将Tab化为空格"><a href="#expand：将Tab化为空格" class="headerlink" title="expand：将Tab化为空格"></a><code>expand</code>：将Tab化为空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expand [-t 1] data.tab &gt; data.spaces</span><br><span class="line">        -t n：表示将制表键转换成n个空格符。</span><br></pre></td></tr></table></figure><h3 id="fmt-格式化文本"><a href="#fmt-格式化文本" class="headerlink" title="fmt: 格式化文本"></a><code>fmt</code>: 格式化文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ fmt -u -w48 news &gt; news.fmt</span><br><span class="line">        fmt将它的输入格式化成一些段落，</span><br><span class="line">        其中段落宽度是使用-wn选项来定义的（w为width，n为字符的数目，系统默认宽度为75个字符）。</span><br><span class="line">        利用-u选项将文件中的空格统一化（每个单词之间使用一个空格分隔，每个句子之间使用两个空格分隔）。</span><br><span class="line">            </span><br><span class="line">        fmt命令将它的输入中的空行当作段落分隔符看待。</span><br></pre></td></tr></table></figure><h3 id="pr：按照打印机的格式重新编排纯文本文件中的内容"><a href="#pr：按照打印机的格式重新编排纯文本文件中的内容" class="headerlink" title="pr：按照打印机的格式重新编排纯文本文件中的内容"></a><code>pr</code>：按照打印机的格式重新编排纯文本文件中的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ pr file</span><br><span class="line">        pr命令的默认输出为每页66行，其中56行为正文内容，并包括表头。</span><br><span class="line">        若没有指定列表头（Header），系统默认使用文件名作为列表头，并在每页的页首部分显示。</span><br><span class="line">        另外，每页的页首部分还有页码和时间(inode.M_time)。</span><br><span class="line">$ pr -h&quot;English Dictionary on Linux&quot; -l18 -5 &#x2F;usr&#x2F;share&#x2F;dict&#x2F;words | more</span><br><span class="line">        -h选项为列表头（Header），</span><br><span class="line">        在h后面使用双引号括起来的就是要显示的表头信息，</span><br><span class="line">        -l选项用来定义每页的行数，-l18表示每页都有18行，</span><br><span class="line">                （-l选项后的数目不能太小，如果太小pr命令会忽略这一选项）</span><br><span class="line">        -5表示每页打印5列。</span><br><span class="line">        </span><br><span class="line">---------------------------</span><br><span class="line">        </span><br><span class="line"># Output：</span><br><span class="line"></span><br><span class="line">2006-10-08 02:00           English Dictionary on Linux            Page 1</span><br><span class="line">&amp;c             &#39;prentice      &#39;shun          &#39;tis          &#39;un</span><br><span class="line">&#39;d             &#39;re            &#39;slid          &#39;twas         &#39;ve</span><br><span class="line">......</span><br><span class="line">2006-10-08 02:00           English Dictionary on Linux            Page 2</span><br><span class="line">-acal          -acy          -age          -ana           -ar</span><br><span class="line">-acea          -ad           -agogue       -ance          -arch</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-4.1-正文文本操作</title>
      <link href="/2017/01/02/Linux/linux-4-1-TextOperate/"/>
      <url>/2017/01/02/Linux/linux-4-1-TextOperate/</url>
      
        <content type="html"><![CDATA[<h1 id="正文文本操作"><a href="#正文文本操作" class="headerlink" title="正文文本操作"></a>正文文本操作</h1><h3 id="tr：字符转换"><a href="#tr：字符转换" class="headerlink" title="tr：字符转换"></a><code>tr</code>：字符转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tr &#39;A-Z&#39; &#39;a-z&#39; &lt; w.txt &gt; u.txt        # 将w中的大写-&gt;小写，放入u中</span><br><span class="line">$ tr -d &quot;\r&quot; &lt; dept.data &gt; dept.data.unix        # 将DOS格式的正文文件（以回车“\r”符和换行“\n”符结束一行）转换成Linux格式的文件（只用换行符“\n”来结束一行）</span><br></pre></td></tr></table></figure><h3 id="cut：从文件中剪出一个字段-列-至1-stdout"><a href="#cut：从文件中剪出一个字段-列-至1-stdout" class="headerlink" title="cut：从文件中剪出一个字段(列)至1(stdout)"></a><code>cut</code>：从文件中剪出一个字段(列)至1(stdout)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cut [options] [file]</span><br><span class="line">        -f：说明(定义)字段(列)</span><br><span class="line">        -c：要剪切的字符：</span><br><span class="line">                「-c4-7」：剪下每行4～7的字符</span><br><span class="line">        -d：说明(定义)字段的分隔符(默认为Tab)</span><br><span class="line">                「-d,」：以“,”为分隔符</span><br><span class="line">$ cut -f2 emp.data</span><br><span class="line">        显示emp.data中的第二列至stdout</span><br></pre></td></tr></table></figure><h3 id="paste：粘贴"><a href="#paste：粘贴" class="headerlink" title="paste：粘贴"></a><code>paste</code>：粘贴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ paste  -d,  name.txt  score.txt  &gt;  student.txt</span><br><span class="line">        -d：说明(定义)字段的分隔符(默认为Tab)</span><br><span class="line">                「-d,」：以“,”为分隔符</span><br><span class="line">        &gt; ：横向合并文件：</span><br><span class="line">            |Mike|         |99|          |Mike,99|</span><br><span class="line">            |Jake|    +    |98|    -&gt;    |Jake,98|</span><br><span class="line">            |Anny|         |97|          |Anny,97|</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="uniq：去掉文件中相邻的重复行"><a href="#uniq：去掉文件中相邻的重复行" class="headerlink" title="uniq：去掉文件中相邻的重复行"></a><code>uniq</code>：去掉文件中相邻的重复行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ uniq [opts] [file]</span><br><span class="line">        -c：在显示的行前冠以该行出现的次数</span><br><span class="line">        -d：只显示重复行</span><br><span class="line">        -i：忽略字符的大小写</span><br><span class="line">        -u：只显示唯一的行</span><br></pre></td></tr></table></figure><h3 id="sort：排序"><a href="#sort：排序" class="headerlink" title="sort：排序"></a><code>sort</code>：排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sort [opt] [file]</span><br><span class="line">         -r：反向排序</span><br><span class="line">         -f：忽略大小写</span><br><span class="line">         -n：按数字顺序排序</span><br><span class="line">          -u：去掉重复行</span><br><span class="line">          -t c：以字符c为分割符</span><br><span class="line">          -k N1,[N2]：按N1-&gt;N2字段排序</span><br></pre></td></tr></table></figure><h3 id="col-Tab转空格："><a href="#col-Tab转空格：" class="headerlink" title="col: Tab转空格："></a><code>col</code>: Tab转空格：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ col -x &lt; e.tabs &gt;e.spaces</span><br><span class="line">        将e.tabs中的Tab字符(^I)化为空格存在e.spaces中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-4.0-正文浏览</title>
      <link href="/2017/01/01/Linux/linux-4-0-TextRead/"/>
      <url>/2017/01/01/Linux/linux-4-0-TextRead/</url>
      
        <content type="html"><![CDATA[<h1 id="正文浏览"><a href="#正文浏览" class="headerlink" title="正文浏览"></a>正文浏览</h1><blockquote><p>正文，即字符串 / 纯文本文件的内容。</p></blockquote><h3 id="cat：浏览正文文件内容"><a href="#cat：浏览正文文件内容" class="headerlink" title="cat：浏览正文文件内容"></a><code>cat</code>：浏览正文文件内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat [options] [files]</span><br><span class="line">    -A：显示内容，包括不可见的特殊字符</span><br><span class="line">    -s：将两个及以上的空行省略为一个空行</span><br><span class="line">    -b：加入行号</span><br><span class="line">$ cat &gt; filename</span><br><span class="line">    创建新文本文件，写入内容</span><br><span class="line">    空行&#123;Ctr+d&#125;，保存退出        # &#123;Ctr+c&#125;:强行终止</span><br><span class="line">            [注意]：用cat打开二进制文件会造成终端停止工作，可开启一个新的终端以解决。</span><br></pre></td></tr></table></figure><pre><code>       ⚠️ \[注意\]：用 cat 打开二进制文件可能会造成终端停止工作，可开启一个新的终端以解决。</code></pre><h3 id="head：浏览文件头几行"><a href="#head：浏览文件头几行" class="headerlink" title="head：浏览文件头几行"></a><code>head</code>：浏览文件头几行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ head [-n x] file</span><br><span class="line">    浏览文件头x行</span><br><span class="line">    若省去[-n x]则显示头10行</span><br></pre></td></tr></table></figure><h3 id="tail：浏览文件后几行"><a href="#tail：浏览文件后几行" class="headerlink" title="tail：浏览文件后几行"></a><code>tail</code>：浏览文件后几行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tail file</span><br><span class="line">    浏览文件后10行</span><br><span class="line">$ tail -[n]x  file</span><br><span class="line">    显示从末尾算起的x行</span><br><span class="line">    有无n都一样</span><br><span class="line">$ tail +[n]x  file</span><br><span class="line">    显示从文件第x行之后的内容</span><br><span class="line">    有无n都一样</span><br><span class="line">$tail -f file</span><br><span class="line">    “-f“ &#x3D;&#x3D; ”--follow“</span><br><span class="line">    当一个正文文件内容发生变化时，把变化显示出来</span><br><span class="line">    &#123;ctrl+c&#125;退出</span><br><span class="line"># tail -f &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">    监视日志</span><br></pre></td></tr></table></figure><h3 id="wc：-word-count-字数统计"><a href="#wc：-word-count-字数统计" class="headerlink" title="wc：(word count)字数统计"></a><code>wc</code>：(word count)字数统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wc [-options] file</span><br><span class="line">    显示文件 行、单词、字符 数</span><br><span class="line">        无选项依次显示l，w，c</span><br><span class="line">        -l：行数</span><br><span class="line">        -w：单词数</span><br><span class="line">        -c：字符数</span><br></pre></td></tr></table></figure><h3 id="more-file-：可翻页地浏览文件"><a href="#more-file-：可翻页地浏览文件" class="headerlink" title="more [file]：可翻页地浏览文件"></a><code>more [file]</code>：可翻页地浏览文件</h3><p>在more中键入：</p><ul><li><p><code>&#123;空格&#125;</code>：下一页</p></li><li><p><code>&#123;Enter&#125;</code>：移动一行</p></li><li><p><code>&#123;b&#125;</code>：上一页</p></li><li><p><code>&#123;h&#125;</code>：帮助</p></li><li><p><code>&#123;/str&#125;</code>：向前搜索str</p></li><li><p><code>&#123;n&#125;</code>：发现这个字符串的下一次出现</p></li><li><p><code>&#123;q&#125;</code>：退出 more</p></li><li><p><code>&#123;v&#125;</code>：在当前行启动 vi</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.3-文件归档与压缩</title>
      <link href="/2016/12/30/Linux/linux-3-1-3-Archiving/"/>
      <url>/2016/12/30/Linux/linux-3-1-3-Archiving/</url>
      
        <content type="html"><![CDATA[<h1 id="文件归档与压缩"><a href="#文件归档与压缩" class="headerlink" title="文件归档与压缩"></a>文件归档与压缩</h1><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><p>归档（archiving）就是将许多文件（或目录）打包成一个文件。</p><p>归档的目的就是方便备份、还原及文件的传输操作。</p><p>Linux操作系统的标准归档命令是tar（tape archive）。</p><p>tar命令的功能是将多个文件（也可有目录）放在一起存放到一个磁带或磁盘归档文件中，</p><p>并且将来可以根据需要只还原归档文件中的某些指定的文件。</p><p>tar命令默认并不进行文件的压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tar [选项]... [归档文件名]...</span><br><span class="line">    必须至少使用如下选项中的一个：</span><br><span class="line">        c：创建一个新的tar文件。</span><br><span class="line">        t：列出tar文件中内容的目录。</span><br><span class="line">        x：从tar文件中抽取文件。</span><br><span class="line">        f：指定归档文件或磁带（也可能是软盘）设备（一般都要选）</span><br><span class="line">            （在RHEL 4之前的版本中规定在f选项之后必须紧跟着文件名而不能再加其他参数，</span><br><span class="line">                但是从RHEL 4开始已经取消了这一限制。）</span><br><span class="line">以下为可选的选项：</span><br><span class="line">        v：显示所打包的文件的详细信息（v是verbose）</span><br><span class="line">                (执行过程中会显示所有打包的文件和目录)</span><br><span class="line">        z：使用gzip压缩算法来压缩打包后的文件。</span><br><span class="line">                「$ tar cvfz arch.tar.gz dir2arch」</span><br><span class="line">        j：使用bzip2压缩算法来压缩打包后的文件。</span><br><span class="line">                「$ tar cvfj arch.tar.bz2 dirarch」</span><br><span class="line">【注意】在tar命令中，所有的选项之前都不能使用前导的“-”。</span><br></pre></td></tr></table></figure><p>创建新的归档文件：<code>c\[v\]f</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar  cvf  arch.tar  dir2arch    # File to be archived should be a RELATIVE path</span><br><span class="line">dir2arch&#x2F;</span><br><span class="line">dir2arch&#x2F;learning.txt</span><br><span class="line">dir2arch&#x2F;name.txt</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>查看归档文件内容：<code>t\[v\]f</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tar tf arch.tar</span><br><span class="line">dir2arch&#x2F;</span><br><span class="line">dir2arch&#x2F;learning.txt</span><br><span class="line">dir2arch&#x2F;name.txt </span><br><span class="line">……</span><br><span class="line"># 可以在tar命令中再加入v命令来显示文件更加详细的信息(like 「ls -l」):</span><br><span class="line">$ tar tvf arch.tar</span><br><span class="line">drwxrwxr-x User&#x2F;User           0 2010-02-04 05:09:43 dir2arch&#x2F;</span><br><span class="line">-rw-r--r--   User&#x2F;User        4720 2010-02-04 05:07:22 dir2arch&#x2F;learning.txt</span><br><span class="line">-rw-rw-r--   User&#x2F;User          84 2010-02-04 05:07:22 dir2arch&#x2F;name.txt </span><br><span class="line">……</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解开打包好的文件：<code>x\[v\]f</code></p><p>[⚠️]<span style="color: #fd0404;">解开前要将工作目录切换到打包时所在的目录，才能保证抽取的文件放回到原来的位置。</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvf arch.tar</span><br><span class="line">dir2arch&#x2F;</span><br><span class="line">dir2arch&#x2F;learning.txt</span><br><span class="line">dir2arch&#x2F;name.txt</span><br><span class="line">dir2arch&#x2F;flowers.JPG</span><br><span class="line">dir2arch&#x2F;dog.JPG  ……</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>进行文件压缩的主要目的是缩小文件的大小。</p><p>一般对正文文件进行压缩之后，文件的大小可以被压缩大约75%。</p><p>但是二进制的文件，如图像文件通常不会被压缩多少。</p><p>Linux系统中两组常用的压缩工具：</p><ol><li><code>gzip \ gunzip -&gt; [*.gz]</code></li></ol><p>[⚠️]<span style="color: #fcb100;">用gzip不能压缩<strong>目录</strong></span></p><p>用gzip来压缩文件，就必须使用gunzip来解压缩。</p><p>它们是Linux系统上标准的压缩和解压缩工具，</p><p><em>gzip对正文文件的压缩比一般超过75%</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gzip [选项] [压缩文件名…]</span><br><span class="line">        若不用-c则会压缩源文件（把原来多foo.txt变成一个foo.txt.gz）</span><br><span class="line">        -v：在屏幕上显示出文件的压缩比（v是verbose的第1个字母）。</span><br><span class="line">        -c：保留原来的文件，而新创建一个压缩文件(要重定向出来)，其中压缩文件名以.gz结尾。</span><br><span class="line">                （gzip -vc bar.txt &gt; foobar.gz）</span><br><span class="line">解压缩时，输入gunzip空格后跟要解压缩的文件，如命令gunzip arch.gz。</span><br></pre></td></tr></table></figure><ol start="2"><li><code>bzip2 \ bunzip2 -&gt;[*.bz2]</code></li></ol><p>用bzip2压缩，必须用bunzip2解压。</p><p>它们是Linux系统上比较新的压缩和解压缩工具，</p><p>通常bzip2对归档文件的压缩比要优于gzip工具。</p><p>比较新的Linux版本才支持bzip2和bunzip2命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.2-磁盘，可移除式媒体</title>
      <link href="/2016/12/29/Linux/linux-3-1-2-Disk-RemovableMedia/"/>
      <url>/2016/12/29/Linux/linux-3-1-2-Disk-RemovableMedia/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘，可移除式媒体"><a href="#磁盘，可移除式媒体" class="headerlink" title="磁盘，可移除式媒体"></a>磁盘，可移除式媒体</h1><ul><li><strong>检查磁盘空间</strong></li></ul><p>监督文件系统的使用情况，可使用如下两个命令：</p><ul><li>df：显示文件系统中磁盘使用和空闲区的数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ df [选项] [dir|file|设备]</span><br><span class="line">    无[dir|file]：以KB为单位列出每个(Every)文件系统中 所有的空间，已用空间，空闲空间</span><br><span class="line">    加上 dir|file：显示该文件所在的文件系统的情况</span><br><span class="line">    加上 设备(如 &#x2F;dev&#x2F;sda1)：显示该设备的文件系统的情况</span><br><span class="line">    选项：</span><br><span class="line">        -h或-H ：以人类容易理解的方式表示</span><br><span class="line">        -i：列出inode的使用情况</span><br></pre></td></tr></table></figure><ul><li>du：显示磁盘使用的总量（xx目录，有多大）</li></ul><p>du命令<u>以KB为单位</u>🐱显示文件系统磁盘空间使用的总量，并将递归地显示所有子目录的磁盘空间使用量。</p><p>如果在这个命令中使用-s选项，命令的结果就只显示一个目录总的磁盘空间使用量。</p><p>在du命令中也同样可以加上-h或-H选项。</p><p>🐱. 部分UNIX上（如Solaris上），du的单位是 <em>512B</em> 的数据块数。</p><ul><li><strong>可移除式媒体</strong></li></ul><p><strong><em>Removable Media</em></strong>（一种翻译为  可移除式媒体）：指USB闪存、软盘、CD、DVD等介质。</p><p><em>Removable Media</em> 的<strong>特点</strong>：</p><ul><li><p>在访问之前，必须将这个Removable Media挂载（mount）到系统上。</p></li><li><p>在移除之前，必须将这个Removable Media从系统上卸载掉。</p></li><li><p>在默认的情况下，一般非root的普通用户只能挂载某些特定的设备（如USB闪存、软盘、CD、DVD等）。</p></li><li><p>默认的挂载点一般是根目录下的media，即/media。</p></li></ul><p><strong>MOUNT</strong> Removable Media：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">    列出当前系统中挂载的所有文件系统</span><br></pre></td></tr></table></figure><ul><li>Mount <strong>CD/DVD:</strong>  </li></ul><p>在gnome或KDE的中，只要在光驱中放入CD或DVD，就会被自动地挂载到系统中来。</p><p>如果没有被自动地挂载到系统中来，就必须手动地挂载CD/DVD。</p><p>如果是CD/DVD Reader，将使用 <code>mount  ...  /media/cdrom</code> 命令将CD/DVD挂载到 <code>/media/cdrom</code> 之下。</p><p>如果是CD/DVD Writer，将使用 <code>mount ... /media/cdrecorder</code> 命令将CD/DVD挂载到 <code>/media/cdrecorder</code> 之下。</p><p>可以使用eject命令退出（umount）CD/DVD。</p><p>[⚠️]<span style="color: #fcb100;">当安装有<strong>多个光盘</strong>软件时，千万<strong>不要将工作目录设为CD所在的目录</strong>，这样将无法更换光盘，因为执行eject或umount命令时系统要求CD目录中没有任何操作。</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">挂载CD／DVD：</span><br><span class="line"># mount  &#x2F;dev&#x2F;hdc  &#x2F;media&#x2F;cdrom        # Only root can do that</span><br><span class="line">Read it：</span><br><span class="line">$ ls -l &#x2F;media&#x2F;cdrom</span><br><span class="line">Umount it：</span><br><span class="line"># eject &#x2F;media&#x2F;cdrom</span><br></pre></td></tr></table></figure><ul><li>Mount <strong>USB闪存：</strong>  </li></ul><p>将USB闪存插入计算机，Linux内核会自动探测到这一设备，并将其自动安装为SCSI设备。</p><p>通常它会被挂载在<code>/media/&lt;Device ID&gt;</code>。</p><p>手动挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount &#x2F;media&#x2F;KINGSTON</span><br><span class="line">或</span><br><span class="line"># mount  &#x2F;dev&#x2F;sdb1  &#x2F;media&#x2F;KINGSTON</span><br></pre></td></tr></table></figure><p>只有root可以 umount USB 闪存。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.1-连接(link)</title>
      <link href="/2016/12/28/Linux/linux-3-1-1-Link/"/>
      <url>/2016/12/28/Linux/linux-3-1-1-Link/</url>
      
        <content type="html"><![CDATA[<h1 id="连接-link"><a href="#连接-link" class="headerlink" title="连接(link)"></a>连接(link)</h1><ol><li><strong>符号连接（软连接）</strong>：指向另一个文件的文件</li></ol><p>符号连接也只能包含一种类型的数据；</p><p>一个符号连接包含了它所指向的文件的路径；</p><p>因为符号连接使用的是指向其他文件的路径名，</p><p>所以符号连接可以指向其他文件系统上的文件。</p><p>º。查看符号连接：使用 <code>ls -l</code>：</p><pre><code>    文件类型码如果是“l”表示是一个连接。</code></pre><p>另外在显示结果的最后一列中，</p><p>在-&gt;左边的是符号连接名，</p><p>在-&gt;右边的是所指向对象的完整路径，</p><p>显示结果中的大小为这个完整路径的字符个数。  </p><p>º。创建软连接：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ln  -s  abs_path&#x2F;文件名  abs_path&#x2F;[连接名]</span><br><span class="line">    [⚠️]可以对目录建立软连接</span><br><span class="line">    文件名：连接指向的文件</span><br><span class="line">    连接名：新建的link file的名字</span><br><span class="line">            缺省为与指向文件同名</span><br><span class="line">    [⚠️]注意两文件的path都要写绝对路径</span><br><span class="line">            若使用相对路径会出现软连接断开的问题：</span><br><span class="line">                使用连接时会报错：</span><br><span class="line">                    Too many levels of symbolic links.</span><br><span class="line">                可对link file使用file命令发现错误：</span><br><span class="line">                    $ file link_file</span><br><span class="line">                    abs_path&#x2F;link_file:broken symbolic links to &#39;pointing file&#39;</span><br></pre></td></tr></table></figure><p>º。软连接的使用：</p><p>对 link_file rwx == 对 pointing_file rwx</p><p>º。软连接的工作原理</p><p>／*符号连接也要占用一个i节点，即软连接本身也是一个文件*／</p><p>使用symbolic link：</p><p>（1）首先系统利用_符号连接名_查找到这个软连接所对应的i节点。</p><p>（2）通过i节点中的指针查找到_link file_的数据块（其中，存放着所_指向文件_的全路径和对应的i节点号）。</p><p>（3）利用_link file_数据块中的数据查找到这个文件所对应的i节点号。</p><p>（4）通过i节点中的指针查找到_pointing file_对应的数据块。</p><p>（5）对_pointing file_的数据块中的数据进行操作。</p><ol start="2"><li><strong>硬连接：</strong>把文件名对应到inode</li></ol><p>一个硬连接（Hard Link）是一个文件名与一个i节点之间的对应关系。</p><p>添加一个硬连接是在所对应的文件上添加一个路径名。</p><p>每一个文件都至少使用一个硬连接，</p><p>在一个目录中的每一个记录都构成了一个硬连接。</p><p>可以将每一个文件名都看成为对应于一个i节点的硬连接。  </p><p>为文件添加额外的hard link可以避免一些重要的信息被误删，因为当存储信息的文件被删除后，还可以通过硬连接访问对应的i节点并找到存储信息的数据块。  </p><p>若将名为foo和bar的两个文件对应到一个i节点上：</p><p>foo、bar使用相同的i节点记录。</p><pre><code>    将文件foo误删，还可以通过文件bar把信息找回来。</code></pre><p>º。创建hard link</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln 文件名 [连接名]</span><br><span class="line">    [⚠️]只能对文件建立硬连接，而不能对一个目录建立硬连接。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.0-文件系统与inode</title>
      <link href="/2016/12/27/Linux/linux-3-1-0-FileSystem-inode/"/>
      <url>/2016/12/27/Linux/linux-3-1-0-FileSystem-inode/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件系统与inode"><a href="#Linux文件系统与inode" class="headerlink" title="Linux文件系统与inode"></a>Linux文件系统与inode</h1><h2 id="硬盘分区和文件系统"><a href="#硬盘分区和文件系统" class="headerlink" title="硬盘分区和文件系统"></a>硬盘分区和文件系统</h2><p>一个新的硬盘，不能直接使用。首先必须把这个硬盘划分成数个（也可能是一个）<span style="background-color: rgb(255, 250, 165);">分区</span>，之后再把每一个分区<span style="background-color: rgb(255, 250, 165);">格式化</span>为文件系统，然后Linux系统才能在格式化后的硬盘分区上存储数据和进行相应的文件管理及维护。</p><p>Linux或UNIX系统上的磁盘分区就相当于Windows系统上的逻辑盘。</p><p>把一个分区格式化为文件系统就是将这个分区划分成许多大小相等的小单元，</p><p>并将这些小单元顺序地编号。</p><p>这些小单元被称为块（block），Linux默认的block大小为4KB。</p><p>Block是存储数据的最小单位，</p><p>每个block最多只能存储一个文件，</p><p>如果一个文件的大小超过4KB，那么就会占用多个blocks。</p><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><h3 id="inode-概念"><a href="#inode-概念" class="headerlink" title="inode 概念"></a>inode 概念</h3><p>i节点就是一个与某个特定的对象（如文件或目录）相关的信息列表。</p><p>i节点实际上是一个数据结构，它存放了有关一个普通文件、目录或其他文件系统对象的基本信息。</p><p>当一个磁盘被格式化成文件系统（如ext2或ext3）时，系统将自动生成一个i节点（inode）表；</p><p>在该表中包含了所有文件的元数据（metadata，描述数据的数据），每一个文件和目录都会对应于一个唯一的i节点，而这个i节点是使用一个i节点号（inode number简写成inode-no）来标识的；</p><p>inodes的数量决定了在这个文件系统中最多可以存储多少个文件，在一个分区（partition）中有多少个i节点就只能够存储多少个文件和目录。</p><p>在多数类型的文件系统中，i节点的数目是固定的，并且是在创建文件系统时生成的。</p><p>在一个典型的UNIX或Linux文件系统中，i节点所占用的空间大约是整个文件系统大小的1%。</p><hr><h3 id="inode-解读"><a href="#inode-解读" class="headerlink" title="inode 解读"></a>inode 解读</h3><p>i节点中所有的属性都是用来描述文件的，而不是文件中的内容。</p><p>i节点类似图书馆中的图书目录，在每一本书的图书目录中印有该书的内容简介、作者信息、出版日期、页数等<strong>摘要信息</strong>。</p><p>通常每个i节点由两部分组成，第1部分是有关文件的基本信息，第2部分是指向存储文件信息的数据块的指针：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g60fl18enfj30go0730tl.jpg" alt="IMG_1066"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">（1）inode-no ：i节点号。</span><br><span class="line">在一个文件系统中，每一个i节点都有一个唯一的编号。</span><br><span class="line">（2）File type ：文件的类型。</span><br><span class="line">&#39;-&#39;为  普通文件，</span><br><span class="line">&#39;d&#39;为 目录。</span><br><span class="line">（3）permission ：权限。</span><br><span class="line">在i节点中使用数字表示法来表示文件的权限。</span><br><span class="line">（4）Link count ：硬连接（hard link）数。</span><br><span class="line">（5）UID ：文件所有者的UID。</span><br><span class="line">（6）GID ：owner所属群组的GID。</span><br><span class="line">（7）size ：文件的大小。</span><br><span class="line">（8）Time stamp：时间戳。</span><br><span class="line">时间戳包含了3个时间：</span><br><span class="line">①Access time（A time） ：最后一次存取的时间。</span><br><span class="line">②Modify time（M time） ：最后一次编辑的时间。</span><br><span class="line">③Change time（C time）：该文件inode中任一元数据发生变化的时间。</span><br><span class="line">如果M time被更新时，通常A time和C time也会跟着一起被更新：</span><br><span class="line">在更新一个文件之前必须先打开这个文件，所以要先更新A time；</span><br><span class="line">编辑完之后一般文件的大小要发生变化，所以C time也会被更新。</span><br><span class="line">（9）Other information</span><br><span class="line">（10）pointer：指向保存文件的blocks的指针。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看文件的-inode-number："><a href="#查看文件的-inode-number：" class="headerlink" title="查看文件的 inode number："></a>查看文件的 inode number：</h3><p>可以使用带有-i选项的ls命令，在每一行记录的开始显示这个文件的i节点号码。</p><h3 id="普通文件-与-目录"><a href="#普通文件-与-目录" class="headerlink" title="普通文件 与 目录"></a><em>普通文件</em> 与 <em>目录</em></h3><p>1.普通文件（Regular File）：只存放数据，</p><p>可以存放多种不同类型的数据。</p><p>2.目录：“特殊”的文件，目录中存储的是文件名和与文件名相关的i节点号码的信息。目录中只能存放一类数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct file_list&#123;</span><br><span class="line">    char name[MAX];</span><br><span class="line">    unsign inode;</span><br><span class="line">    struct file_list next;</span><br><span class="line">&#125; * pBarFiles;</span><br><span class="line">char * make_the_list(struct file_list *);</span><br><span class="line">fooDirectoty.content &#x3D; make_the_list(pBarFiles);</span><br></pre></td></tr></table></figure><h3 id="cp、rm、mv-的-operate-inode"><a href="#cp、rm、mv-的-operate-inode" class="headerlink" title="cp、rm、mv 的 operate(inode)"></a>cp、rm、mv 的 operate(inode)</h3><ol><li><code>cp</code>：</li></ol><p>（1）找到一个空闲的i节点记录（inode number），把新文件的meta data写入到这个空闲的i节点中并将这个新记录放入inode表中。</p><p>（2）产生一条目录记录，把新增的文件名对应到这个空的inode号码。</p><p>（3）将文件的内容（数据）复制到新增的文件中去。</p><ol start="2"><li><code>rm</code>：</li></ol><p>（1）首先将这个文件的连接数（hard link）减1；</p><p>（如原文件的link count为3，运行了rm后，它的link count将为2）</p><p>之后这个文件的link count如果小于1，</p><p>就释放这个i节点以便重用。</p><p>（2）释放存储这个文件内容的数据块；</p><pre><code>            （即将这些数据块标记为可以使用）</code></pre><p>（3）删除记录这个文件名和i节点号的目录记录。</p><ol start="3"><li><code>mv</code>：</li></ol><p>若 <em>原位置</em> 与 <em>目标位置</em>  位于 <strong>同一文件系统</strong>：  </p><pre><code>（1）首先产生一个新的目录记录，把新的文件名对应到源文件的i节点。  （2）删除带有旧文件名的原有的目录记录。/* 这是&lt;u&gt;逻辑移动&lt;/u&gt;：除了更新时间戳外，移动文件行为对原本在inode表中的数据不会有任何影响，也**不会将数据移动**到其他的文件中去，即**没有发生真正的数据移动**。\*/</code></pre><p>若 <em>源位置</em> 与 <em>目的位置</em> 是在 <strong>不同文件系统</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp(source, destination)；</span><br><span class="line">rm(source)；</span><br></pre></td></tr></table></figure><p>必要情况下：为确保数据确实发生移动，应使用cp，rm而非mv</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>关于文件的几个术语：</p><p>  （1）文件名是访问和维护文件时最常使用的。</p><p>  （2）i节点（inodes）是系统用来记录有关文件信息的对象。</p><p>  （3）数据块是用来存储数据的磁盘空间的单位。</p></li><li><p>其中关联：</p><p>  每个文件必须具有一个名字并且与一个i节点相关。</p><p>  通常系统通过文件名就可以确定i节点，</p><p>  之后通过i节点中的指针就可以定位存储数据的数据块</p></li></ul><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g60oehim96j30go00v0sr.jpg" alt="IMG_1067"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.0.1-文件及其操作</title>
      <link href="/2016/12/26/Linux/linux-3-0-1-Files/"/>
      <url>/2016/12/26/Linux/linux-3-0-1-Files/</url>
      
        <content type="html"><![CDATA[<h1 id="文件及其操作"><a href="#文件及其操作" class="headerlink" title="文件及其操作"></a>文件及其操作</h1><h2 id="Linux文件类型："><a href="#Linux文件类型：" class="headerlink" title="Linux文件类型："></a>Linux文件类型：</h2><table><thead><tr><th>表示</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>-</td><td>regular file</td><td>普通文件，或称正规文件</td></tr><tr><td>d</td><td>directory</td><td>目录</td></tr><tr><td>l</td><td>symbolic link🏎</td><td>符号（软）连接</td></tr><tr><td>b</td><td>block</td><td>块特殊文件：一般是指块设备，如硬盘。</td></tr><tr><td>c</td><td>character</td><td>字符特殊文件：一般是指字符设备，如键盘。</td></tr><tr><td>p</td><td>pipe</td><td>命名的管道文件：一般用于在进程之间传输数据。</td></tr><tr><td>s</td><td>socket🐶</td><td>套接字：通信（过程中）的一个终点。</td></tr></tbody></table><p>🏎. 详见本系列文章的“<u>连接(link)</u>”</p><p>🐶.  socket 的比喻性解释：</p><p><strong>socket与电话十分相似：</strong></p><p><em>当与某人通话时就要建立两个通信的终点：</em></p><p><em>（1）自己的电话</em></p><p><em>（2）对方的电话</em></p><p><em>只要双方进行通话，就必须有两个通话所必需的终点（电话）和一条在它们之间的通信线路存在。</em></p><p>        socket就相当于一条通信线路的终点（电话），而在这些终点（sockets）之间存在着数据通信网络。</p><p><em>当打电话给他人时，需要拨打对方的电话号码。</em></p><p>        sockets使用网络地址取代了电话号码。通过访问远程（计算机）的socket地址，本机程序就可以用的本机socket与远程的终点（socket）之间建立起一条通信线路。</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li>file：确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ file 文件名</span><br></pre></td></tr></table></figure><ul><li>touch：刷新、新建文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch file(s)</span><br><span class="line">        若file存在，更新时间戳</span><br><span class="line">        若file不存在，新建空文件</span><br></pre></td></tr></table></figure><ul><li>cp：复制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cp [-option(s)]  source(s)  target</span><br><span class="line">    把source复制到target：</span><br><span class="line">        -i：交互式：防止覆盖，覆盖前提示</span><br><span class="line">        -f：强制式：有同名，强制覆盖，不提示</span><br><span class="line">        -r：递归式：复制目录时包括子目录</span><br><span class="line">        -p：维持式：保留属性（如时间戳）</span><br><span class="line">        source是目录名或文件名</span><br><span class="line">        target是目录名或 新文件名(复制并重命名)</span><br></pre></td></tr></table></figure><ul><li>mv：移动及修改文件、目录名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv file(s) target</span><br><span class="line">    把source移动到target：</span><br><span class="line">        source是目录名或文件名</span><br><span class="line">        target是目录名或 新文件名(移动并重命名)</span><br></pre></td></tr></table></figure><p>        重命名可用“<strong>mv  path/old_name  path/new_nam</strong>e”实现</p><ul><li>rm：删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm  [option(s)]  file(s)|directory(s)</span><br><span class="line">    删除文件或 目录(加-r)：</span><br><span class="line">        -i：交互式：删前提示</span><br><span class="line">        -r：递归式：包括子目录、文件</span><br><span class="line">        -f：强制性：不询问，直接删</span><br></pre></td></tr></table></figure><ul><li>find：搜索文件和目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ find Pathname Expressions Actions</span><br><span class="line">    •Pathname：遍历起始路径</span><br><span class="line">    •Expressions：条件表达式：</span><br><span class="line">        -name“指定文件名”</span><br><span class="line">        -size[+|-]n</span><br><span class="line">                文件大小大于小于或等于(n*512B)</span><br><span class="line">        -atime[+|-]n</span><br><span class="line">                访问天数</span><br><span class="line">        -mtime[+|-]n：更改天数</span><br><span class="line">        -user LoginID：属于某用户的所有文件</span><br><span class="line">        -type：某一类型的文件：</span><br><span class="line">                f：文件</span><br><span class="line">                d：目录</span><br><span class="line">                e t c</span><br><span class="line">        -perm：查找具有某些特定访问许可位的文件</span><br><span class="line">    •Actions：对找出的文件进行的操作：</span><br><span class="line">        -exec命令&#123;&#125; \;</span><br><span class="line">                在每一个所定位的文件上运行指定的命令。</span><br><span class="line">                “&#123;&#125;“  表明文件名将传给前面的命令。</span><br><span class="line">                “ \;” 表示命令的结束。</span><br><span class="line">                （在大括号与反斜线之间必须有一个空格。）</span><br><span class="line">        -ok命令&#123;&#125; \;</span><br><span class="line">                -exec命令的交互方式</span><br><span class="line">                （在find命令对每个定位的文件执行命令之前需要确认）</span><br><span class="line">        -print</span><br><span class="line">                指示find命令将当前的路径名打印在终端屏幕上</span><br><span class="line">                （默认方式）</span><br><span class="line">        -ls</span><br><span class="line">                显示当前路径名和相关的统计信息</span><br><span class="line">                如i节点（inode）数、以K字节为单位的大小（尺寸）、保护模式、硬连接和用户</span><br></pre></td></tr></table></figure><p>    可用<code>find /etc -name passwd  2&gt;finderrs.txt</code>重定向，把权限不足的错误不在屏幕显示。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.0.0-目录及其操作</title>
      <link href="/2016/12/25/Linux/linux-3-0-0-Directory/"/>
      <url>/2016/12/25/Linux/linux-3-0-0-Directory/</url>
      
        <content type="html"><![CDATA[<h1 id="目录及其操作"><a href="#目录及其操作" class="headerlink" title="目录及其操作"></a>目录及其操作</h1><h3 id="几个特殊目录"><a href="#几个特殊目录" class="headerlink" title="几个特殊目录"></a>几个特殊目录</h3><table><thead><tr><th>目录</th><th>作用</th></tr></thead><tbody><tr><td>/</td><td>根目录</td></tr><tr><td>~（==$HOME）</td><td>家目录🚩</td></tr><tr><td>.</td><td>当前目录</td></tr><tr><td>..</td><td>上一层目录</td></tr></tbody></table><p>以’ . ‘开头的文件或目录表示隐藏；</p><p>🚩. 普通用户的家目录为 <code>/home</code> 的子目录，root的是 <code>/root</code></p><p>    “<code>～</code>”代表当前用户的家目录，</p><p>    “<code>～username</code>”代表某用户的家目录。</p><p>登录系统或重启 shell后默认的 <code>pwd</code> 是 <code>$(whoami)</code>的 <code>$HOME</code></p><h3 id="与程序相关的几个目录："><a href="#与程序相关的几个目录：" class="headerlink" title="与程序相关的几个目录："></a>与程序相关的几个目录：</h3><table><thead><tr><th>目录</th><th>功能</th></tr></thead><tbody><tr><td>/bin</td><td>存放可执行文件</td></tr><tr><td>/sbin</td><td>存放系统可执行文件</td></tr><tr><td>/usr(Unix System Resources)</td><td>存放系统的应用程序和与命令相关的系统数据（类似于 Windows 的C:\Program File）</td></tr></tbody></table><h3 id="目录操作："><a href="#目录操作：" class="headerlink" title="目录操作："></a><strong>目录操作：</strong></h3><ul><li>pwd</li></ul><p><code>$ pwd</code></p><p> 打印工作（当前）目录的绝对路径</p><ul><li>cd</li></ul><p><code>$ cd path</code></p><p> 切换工作目录</p><p>                “<code>cd ~</code>” == “cd”无参：切换到 <code>$HOME</code></p><p>                “<code>cd -</code>”：切换到上一工作目录</p><ul><li>ls</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ls [keyword]</span><br><span class="line"> 无keyword：列出当前目录下内容</span><br><span class="line">    有keyword：列出目录中名含keyword的内容</span><br><span class="line">    </span><br><span class="line">$ ls dirA dirB</span><br><span class="line">    同时显示dirA与dirB中的内容</span><br><span class="line">    </span><br><span class="line">$ ls -F</span><br><span class="line">    显示 *文件类型*🚏</span><br><span class="line"></span><br><span class="line">$ ls -a</span><br><span class="line">     &#x3D;&#x3D; “ls --all”</span><br><span class="line">    显示正常、隐藏文件</span><br><span class="line"></span><br><span class="line">$ ls -l</span><br><span class="line">    列出文件详细信息（其中大小为字节）</span><br><span class="line">    再加上-h：大小以惯例表示</span><br><span class="line"></span><br><span class="line">$ ls -d</span><br><span class="line">    只列出当前目录的信息，不包含子目录下的信息</span><br></pre></td></tr></table></figure><p>🚏. 文件类型：详见本系列文章的“文件及其操作”</p><ul><li>mkdir</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir 目录名</span><br><span class="line">    创建目录</span><br><span class="line"></span><br><span class="line">$ mkdir -p 命令名</span><br><span class="line">    创建目录（补足不存在的路径）</span><br></pre></td></tr></table></figure><ul><li>rmdir：删除目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.3-文件的安全控制</title>
      <link href="/2016/12/24/Linux/linux-2-3-fileSafe/"/>
      <url>/2016/12/24/Linux/linux-2-3-fileSafe/</url>
      
        <content type="html"><![CDATA[<h1 id="文件的安全控制"><a href="#文件的安全控制" class="headerlink" title="文件的安全控制"></a>文件的安全控制</h1><ul><li><p>Linux系统的安全模型</p></li><li><p>用户<strong>登录</strong>系统时必须<strong>提供用户名和密码</strong>。</p></li></ul><p>/*  用户是由root用户创建的，最初的密码也是root用户设定的 */</p><ul><li><p>使用<strong>用户</strong>和<strong>群组</strong>来控制使用者<strong>访问</strong>文件和其他资源的<strong>权限</strong>。</p></li><li><p>系统上的每一个<strong>文件</strong>都一定<strong>属于</strong>一个<strong>用户</strong>（一般该用户就是文件的创建者）并<strong>与</strong>一个<strong>群组相关</strong>。</p></li><li><p>每一个<strong>进程</strong>都会<strong>与</strong>一个<strong>用户和群组</strong>相<strong>关联</strong>。可以通过在所有的文件和资源上设定权限来只允许该文件的<strong>所有者</strong>或者某个<strong>群组</strong>的成员访问它们。</p></li><li><p>Linux 上文件有三种类型的权限：</p></li><li><p>所有者  ：（u）：文件的**<u>所有者</u>**的权限</p></li><li><p>同组用户：（g）：与所有者**<u>同一群组</u>**的其他用户的权限</p></li><li><p>其他用户：（o）：非所有者也**<u>不同群</u>**的用户的权限</p></li></ul><p>/* root用户不受权限限制，可以访问Linux上的任何资源 */</p><ul><li><p>权限的表示：</p><table><thead><tr><th>字母表示</th><th>数字表示</th><th>含义</th><th>对文件的权限</th><th>对目录的权限</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>Read</td><td>可阅读文件</td><td>使用ls列出目录内容</td></tr><tr><td>w</td><td>2</td><td>Write</td><td>可编辑文件</td><td>编辑目录(在其中创建、删除等)</td></tr><tr><td>x</td><td>1</td><td>eXecute</td><td>可执行程序(可执行文件)</td><td>使用cd进入目录，用ls -l查看目录详情</td></tr><tr><td>- （连字符）</td><td>0</td><td>no</td><td>没用相应的权限(同位的r|w|x)</td><td>没用相应的权限(同位的r|w|x)</td></tr></tbody></table></li><li><p>查看文件的权限</p></li></ul><p>用 **ls -l **命令：显示结果中的第1列（10个字符）表示文件的mode：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g60eo9tu5zj306n02j74b.jpg" alt="IMG_1065"></p><p align="left">其中第1个字符表示文件的类型：</p>- 如果是d就表示是目录<ul><li>如果是-就表示是文件。</li></ul><p>紧接其后的9个字符是这个文件或命令的权限：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g60ep4llfaj30ax02fglj.jpg" alt="IMG_1062"></p><ul><li>Linux 的安全检测流程</li></ul><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g60epak066j30go072aak.jpg" alt="IMG_1060"></p><ul><li>设定文件或目录上的权限要用chmod命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] mode 文件或目录名</span><br><span class="line">        -R：递归的，设置同时应用于目录中的子目录和所有文件，只有root可用。</span><br><span class="line">        mode: 详见👇</span><br></pre></td></tr></table></figure><p><span style="color: rgb(38, 180, 80);"><em>*.</em></span><strong><em>mode</em></strong>：</p><ol><li>用<strong>表达式</strong>表示：</li></ol><p><em>用“{who}  {operator}  {permission}”表示mode：</em></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g60eps4gcej30go03nmxf.jpg" alt="IMG_1061"></p><p>权限状态可以分成3个部分：</p><ul><li><p>第1部分，表示要设定<strong>谁</strong>的状态：</p></li><li><p>u：<span style="background-color: rgb(255, 250, 165);">所有者</span>的权限。</p></li><li><p>g：<span style="background-color: rgb(255, 250, 165);">群组</span>的权限。</p></li><li><p>o：既不是owner也不与owner在同一个group的<span style="background-color: rgb(255, 250, 165);">其他用户</span>的权限。</p></li><li><p>a：所以，以上3组，也就是<span style="background-color: rgb(255, 250, 165);"><u>所有用户</u></span>的权限。</p></li><li><p>第2部分，<strong>运算符</strong>（操作符）</p></li><li><p>+：<span style="background-color: rgb(255, 250, 165);">加入</span>权限。</p></li><li><ul><li>：<span style="background-color: rgb(255, 250, 165);">去掉</span>权限。</li></ul></li><li><p>=：<span style="background-color: rgb(255, 250, 165);">设定</span>权限。</p></li><li><p>第3部分，<strong>权限</strong>（permission）</p></li><li><p>r  ：read权限。</p></li><li><p>w：write权限。</p></li><li><p>x ：execute权限。</p></li></ul><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod ug+x tastingFile</span><br><span class="line">        在tastingFile文件上添加上所有者和同组用户的可执行权限</span><br></pre></td></tr></table></figure><ol start="2"><li>用<strong>数字</strong>表示：</li></ol><p><em>用  一组三位数  表示mode：</em></p><p>（1）第1个数字  代表  所有者      (own user)    的权限   （u）</p><p>（2）第2个数字  代表  群组       （group）       的权限   （g）</p><p>（3）第3个数字  代表  其他用户（other）        的权限   （o）</p><p>这组3位数中的每一位数字都是由以下表示资源权限状态的数字（即4、2、1和0）相加而获得的总和：</p><p>        4：100(2)：表示具有    read       权限。</p><p>        2：010(2)：表示具有    write      权限。</p><p>        1：001(2)：表示具有  execute   权限。</p><p>        0：000(2)：表示  没有相应的权限。</p><p>即：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g60eq5o2mej30go05i3z4.jpg" alt="IMG_1064"></p><p>e.g.</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g60eqx53n4j30e204jwep.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chmod -R 754 &#x2F;home&#x2F;foo&#x2F;bar</span><br><span class="line"></span><br><span class="line">        对owner(foo)开放家目录的bar子目录和其中所有文件的一切权限，但是对同组用户开放读和执行权限而对其他用户只开放读权限</span><br></pre></td></tr></table></figure><ul><li><strong>特殊权限</strong>（第4组权限）</li></ul><p>第4组权限包括suid、sgid和sticky 3种权限。</p><p>其中，</p><ul><li><p>suid  ：100：4：借用u的可执行权限位，并以 <strong>s</strong> 来表示；  </p></li><li><p>sgid  ：  10：2：借用g的可执行权限位，并以 <strong>s</strong> 来表示；</p></li><li><p>sticky ：    1：1：借用o的可执行权限位，并以 <strong>t</strong> 来表示；</p></li></ul><p>当在一个文件上加入suid|sgid|sticky特殊权限时：</p><p>如果原来的文件的u|g|o具有x权限：</p><p>就使用小写的s|s|t来代替x；</p><p>如果原来没有x：</p><p>就用大写的S|S|T来代替；</p><p><u>设置</u>特殊权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 字符：</span><br><span class="line">$ chmod [u|g|o][+,-,&#x3D;][s|s|t] file</span><br><span class="line"># 数字：（第四组表示特殊权限）</span><br><span class="line">$ chmod [0-7][0-7][0-7][0-7] file</span><br></pre></td></tr></table></figure><p>特殊权限<u>作用</u>：</p><p>将suid和sgid设定在<em>可执行文件</em>上：</p><ul><li><p>运行有suid特殊权限的可执行文件时：是以可执行文件的<strong>所有者权限来运行</strong>这一可执行文件的，而不是以执行者的权限来运行该命令。</p></li><li><p>sgid特殊权限与suid类似，是以命令的群组的权限来运行这一命令的。</p></li></ul><p>将sgid和sticky设定在<em>目录</em>上：  </p><ul><li><p>一个目录上设置了sticky权限，就只有文件的所有者和root用户才可以删除该目录中的文件，而Linux系统不会理会group或other的写权限。</p></li><li><p>一个目录上设置了sgid权限，只要是同一群组的成员，都可以在这个目录中创建文件。</p></li><li><p>通常会对目录同时设置sticky和sgid这两个特殊权限以方便项目的管理（将同一个项目的文件都放到这一个目录中以方便同一项目的成员之间共享信息）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.2-群组</title>
      <link href="/2016/12/23/Linux/linux-2-2-Group/"/>
      <url>/2016/12/23/Linux/linux-2-2-Group/</url>
      
        <content type="html"><![CDATA[<h1 id="群组（Group）"><a href="#群组（Group）" class="headerlink" title="群组（Group）"></a>群组（Group）</h1><ul><li><p>Linux群组的<strong>特性</strong>：</p></li><li><p>Linux系统中，每一个<strong>用户</strong>都一定<strong>隶属于</strong>至少一个<strong>群组</strong>，而每一个群组都有一个group标识符（号码），即gid。</p></li><li><p>所有的群组和对应的gids都存放在_<u>/etc/group</u>_文件中。</p></li><li><p>Linux系统在<strong>创建用户时</strong>为每一个用户<strong>创建</strong>一个<strong>同名的群组</strong>并且把这个用户加入到该群组中，也就是说每个用户至少会加入一个与他同名的群组中，并且也可以加入到其他的群组中。加入到其他群组的目的是为了获取适当的权限来访问（存取）特定的资源。</p></li><li><p>如果有一个文件属于某个群组，那么这个群组中所有的用户都可以存取这个文件。</p></li><li><p><span style="color: #fd0404;"><span style="color: rgb(253, 4, 4);"><strong>group</strong></span></span>文件</p></li></ul><p><strong><em>/etc/group</em></strong> 保存着群组信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group的内容：</span><br><span class="line"></span><br><span class="line"> e.g.| foobar **:   **x   **: **503 **: **foo**,**bar</span><br><span class="line"></span><br><span class="line">means| 群组名  **: **密码否 **: **gid **: **群组成员</span><br></pre></td></tr></table></figure><pre><code>    # 第二字段为x表示这个群组在登录Linux时必须使用密码。</code></pre><ul><li><span style="color: rgb(253, 4, 4);"><strong>gshadow</strong></span>文件</li></ul><p><strong>_/etc/gshadow _</strong>保存着群组信息。</p><p>[⚠️]普通用户无权访问<em><u>/etc/gshadow</u></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># more &#x2F;etc&#x2F;gshadow</span><br><span class="line"></span><br><span class="line">root:::root            # 在gshadow中，每个群组占一行记录</span><br><span class="line"></span><br><span class="line">bin:::root,bin,daemon ......</span><br><span class="line"></span><br><span class="line">foo:!::</span><br><span class="line"></span><br><span class="line">bar:!::</span><br><span class="line"></span><br><span class="line">群组名:加密后的密码::</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.1-用户</title>
      <link href="/2016/12/22/Linux/linux-2-1-User/"/>
      <url>/2016/12/22/Linux/linux-2-1-User/</url>
      
        <content type="html"><![CDATA[<h1 id="用户（User）"><a href="#用户（User）" class="headerlink" title="用户（User）"></a>用户（User）</h1><ul><li><p>用户（Users）</p></li><li><p>系统中的每一个<strong>用户</strong>都有一个唯一的<strong>用户标识符</strong>（号码），即<strong>uid</strong>（user identifier）</p></li></ul><p>（<em>uid 0</em> 为 <code>root</code> 用户的标识符。）</p><ul><li><p>所有的用户名和_用户标识符_都被存放在 <code>/etc/passwd</code> 文件中。</p></li><li><p>在 <em>passwd</em> 文件中还存放了每个用户的家目录，以及该用户登录后第一个执行的程序</p></li></ul><p>（通常是 shell，在 Linux 系统中默认是 bash。）</p><ul><li><p>如果没有相应的权限就不能<strong>读、写或执行</strong>其他用户的文件。</p></li><li><p>passwd 文件：用户信息数据库</p></li></ul><p><em><u>/etc/passwd</u></em> 储存用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;passwd 的内容：</span><br><span class="line">e.g|  exp :  x  :     500    :       500     :Example_User:&#x2F;home&#x2F;exp :   &#x2F;bin&#x2F;bash</span><br><span class="line">说明| 用户名:密码否:uid（用户ID）:gid（所属群组ID）:   注释信息  :   家目录  :启动后第一个执行程序</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于第二个字段：如果是<strong>x</strong>，表示这个用户登录Linux系统时必须使用密码，如果为<strong>空</strong>则该用户在登录系统时无须提供密码。</p><ul><li>shadow文件：用户密码数据库</li></ul><p>[⚠️]普通用户无权访问<em><u>/etc/shadow</u></em></p><p><em><u>/etc/shadow</u></em> 储存用户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadow 的内容：</span><br><span class="line">e.g|  exp :$1$wg...w4:14561:0:99999:7:::</span><br><span class="line">说明| 用户名:   密码   :      :      :  :::</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于第二个字段：第2列是密码，这个密码是经过MD5加密算法加密过的密码。</p><ul><li><p>如果该列以$1$开头，则表示这个用户已经设定了密码。<br>  （包括手动把passwd中的x去掉，不用密码即可登录的“空秘密”）</p></li><li><p>如果该列以!!开头，则表示这个用户还没有设定密码。<br>  （新建后<strong>passwd -S</strong>显示_Password locked_的状态，这种用户不可登录）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.0-用户管理</title>
      <link href="/2016/12/21/Linux/linux-2-0-UsersManage/"/>
      <url>/2016/12/21/Linux/linux-2-0-UsersManage/</url>
      
        <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><ul><li><code>su</code>：切换用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su [-]用户名</span><br><span class="line">    -   ：有则重启shell，重装$PATH（环境变量），pwd切换至用户名的$HOME（家目录）</span><br><span class="line">         无则不变 环境变量（检索命令的目录），pwd不变</span><br></pre></td></tr></table></figure><p>用户名 ：缺省为 root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@Example ~]$ su - root</span><br><span class="line">密码：</span><br><span class="line">[root@Example~]# whoami</span><br><span class="line">root</span><br><span class="line">[root@Example~]# exit</span><br><span class="line">logout</span><br><span class="line">[me@Example~]$ whoami</span><br><span class="line">me</span><br></pre></td></tr></table></figure><ul><li><code>passwd</code>：修改密码</li></ul><p>1⃣️ <em>普通用户：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd            修改当前用户密码</span><br></pre></td></tr></table></figure><p>多按几个回车可取消退出</p><p>对于root “too short”的密码重输也可以成功</p><p>2⃣️ <em>root：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># passwd username    修改某用户密码</span><br><span class="line"># passwd -S username    查看密码状态，【注意】S大写</span><br></pre></td></tr></table></figure><ul><li>新建，删除 用户</li></ul><ol><li>useradd：新建用户：<code># useradd new_user_name</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@Example ~]# useradd newone</span><br><span class="line">[root@Example ~]# passwd -S newone</span><br><span class="line">newone LK [2016-12-18 0 99999 7 -1](tel:2016-12-18 0 99999 7 -1)(密码已被锁定。)       # 说明密码未设定</span><br><span class="line">[root@Example ~]# passwd newone</span><br><span class="line">更改用户 newone 的密码 。</span><br><span class="line">新的 密码：             # 尝试键入一个弱口令</span><br><span class="line">无效的密码:  过于简单化&#x2F;系统化        # 提示口令过于简单，但不阻止</span><br><span class="line">重新输入新的 密码:                   # 仍输入那个弱口令，可以成功，因为是root</span><br><span class="line">passwd： 所有的身份验证令牌已经成功更新。</span><br><span class="line"># 如果是普通用户，键入弱口令不可成。（不会叫“Retype“，而是“New“）</span><br><span class="line">[root@Example ~]# passwd -S newone</span><br><span class="line">newone PS [2016-12-18 0 99999 7 -1](tel:2016-12-18 0 99999 7 -1)(密码已设置，使用 SHA512 加密。</span><br></pre></td></tr></table></figure><ol start="2"><li>userdel：删除用户:  <code>userdel [-r] [-f] user_name</code></li></ol><p>​                <code>-r</code> ：同时删除用户的家目录</p><p>​                        无’-r’时，家目录不会被删除</p><p>​                <code>-f</code> ：强行删除，哪怕用户已登录，这个选项有些危险，会使系统进入不一致状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Example ~]# userdel -r newone</span><br><span class="line">userdel: user newone is currently used by process 3848    # 用户正登录，删除失败</span><br><span class="line">[root@Example ~]# userdel -fr newone                        #用 -f 强行删除</span><br><span class="line">userdel: user newone is currently used by process 3848    # 说明用户正登录，但命令本身已经成功</span><br><span class="line"># 这时虽然还被删user还是登入、活跃状态，但已经被删除，登出后不可再登入</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">[newone@Example ~]$ exit                                    #退出用户</span><br><span class="line">logout</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">[root@Example ~]# userdel -r newone</span><br><span class="line">userdel：用户“newone”不存在                            #再作尝试时，确定用户已被之前的 -f 删除</span><br><span class="line">[root@Example ~]# ls &#x2F;home</span><br><span class="line">c  lost+found                                        #家目录被 -r 删除</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.linuxidc.com/Linux/2016-05/131755.htm">https://www.linuxidc.com/Linux/2016-05/131755.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-1.2-帮助信息</title>
      <link href="/2016/12/20/Linux/linux-1-2-getHelp/"/>
      <url>/2016/12/20/Linux/linux-1-2-getHelp/</url>
      
        <content type="html"><![CDATA[<h1 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis *命令名*</span><br></pre></td></tr></table></figure><p>​                说明<em>命令</em>是什么，了解命令的功能；</p><p>​                “whatis  <em>cmd</em>”命令 == “<strong>man -f</strong> <em>cmd</em>”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ type [-options] 命令名</span><br></pre></td></tr></table></figure><p>​    无选：显示命令类型</p><p>​    <code>-t</code>：显示文件的类型：</p><p>​        <code>file</code>：外部命令</p><p>​        <code>alias</code>：别名</p><p>​        <code>builtin</code>：shell内置命令</p><p>​    <code>-a</code>：列出所有包含指定命令名的命令，包括别名</p><p>​    <code>-p</code>：显示完整的文件名（外部命令）或内部命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which 命令名</span><br></pre></td></tr></table></figure><p>​    列出命令的类型相关的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ *命令名* --help</span><br></pre></td></tr></table></figure><p>​                显示<em>命令</em>的<strong>简要说明</strong>和<strong>选项列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man *命令名*</span><br></pre></td></tr></table></figure><p>​                浏览<em>命令</em>的 <strong>Man Page</strong> 1⃣️</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man -k **keyword**</span><br></pre></td></tr></table></figure><p>​                欲使用一个命令，又无法确定它的名字是用 -k选项+<em>关键字</em>搜寻它；</p><p>​                “man -k  <em>kw</em>”命令 == “<strong>apropos</strong> <em>kw</em>”命令；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ info *cmd*</span><br></pre></td></tr></table></figure><p>​                “info2⃣️”与“man”类似，但info更加简洁详尽(开发者认为的)；</p><p>1⃣️、2⃣️.  浏览 <strong>Man page</strong> <em>或</em>  <strong>Info Page</strong> ：</p><ul><li><ul><li><p>使用man \ info命令进入Man \ Info Page</p></li><li><p>键盘 &lt; , &gt; , ^, v , PgUp, PgDn, 空格：翻页</p></li><li><p>Home键：移到第一页</p></li><li><p>End键： 最后一页</p></li><li><p>在屏幕底部<code>: </code>处输入<code>?string</code>：向前搜索string</p></li><li><ul><li>按 n 键继续下一个搜索</li><li>按 N 键进行反向搜索</li></ul></li><li><p>按 q 键退出Page</p></li></ul></li></ul><p>在 <strong>Info Page</strong> 中还有：</p><ul><li><ul><li>按Tab：跳到下一个“*<strong>**</strong>”（超链接）</li><li>{Tab}*3：Index</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-1.1-系统信息</title>
      <link href="/2016/12/19/Linux/linux-1-1-SystemInformation/"/>
      <url>/2016/12/19/Linux/linux-1-1-SystemInformation/</url>
      
        <content type="html"><![CDATA[<h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><ul><li><p><code>uname</code> 命令:  获取系统信息<br>(其中’u’代表UNIX)</p></li><li><p><code>$ uname</code>       显示当前操作系统</p><pre><code>  `-n`    显示主机名  `-i`    硬件平台名  `-r`    系统发布版本信息  `-s`    系统名  `-m`    机器硬件名  `-p`    显示CPU信息  `-a`    以上全部</code></pre><p>用 <code>-n -r</code> == <code>-i -n</code> == <code>-ni</code> == <code>-in</code>；<br>(详见 <code>$ man uname</code>。)</p></li><li><p><code>$ date</code>       显示当前系统日期、时间</p></li><li><p><code>$ cal</code>         显示日历：</p><ul><li><p><code>$ cal</code>         无参显示本月日历</p></li><li><p><code>$ cal m y</code>    m y是月份 年份，显示y年m月的</p></li><li><p><code>$ cal y</code>      y 是年份，     显示y全年</p><p>(详见 <code>$ man cal</code>。)</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-1.0-用户信息</title>
      <link href="/2016/12/18/Linux/linux-1-0-UsersInfomation/"/>
      <url>/2016/12/18/Linux/linux-1-0-UsersInfomation/</url>
      
        <content type="html"><![CDATA[<h1 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h1><ul><li><code>$ whoami</code><br>输出当前用户名</li><li><code>$ users</code><br>列出当前登录的所有用户名</li><li><code>$ who am i</code><br>显示用户名，登录终端，当前时间，IP</li><li><code>$ who</code><br>比“who am i”多出 其他用户的信息</li><li><code>$ w</code><br>信息更多的“who”：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Me@Example ~]$ w</span><br><span class="line"> 10:59:09 up 4 min,  1 user,  load average:  0.46 , 0.35 ,  0.15</span><br><span class="line"> 当前时间 up 启动时长, 登录用户数, 平均提交任务数: 1min内, 10min内, 15min内</span><br><span class="line">USER     TTY      FROM              LOGIN@    IDLE       JCPU       PCPU     WHAT</span><br><span class="line">用户名    登录终端   登录地            登录时间   空闲时长    一共使用CPU时长    当前程序用CPU时长    当前任务CPU时长</span><br><span class="line">                                                        </span><br><span class="line">Me        pts&#x2F;0    MyComputer       10:58     0.00s      0.06s      0.02s     w</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-0.2-系统开关</title>
      <link href="/2016/12/17/Linux/linux-0-2-StartHalt/"/>
      <url>/2016/12/17/Linux/linux-0-2-StartHalt/</url>
      
        <content type="html"><![CDATA[<h1 id="系统开关"><a href="#系统开关" class="headerlink" title="系统开关"></a>系统开关</h1><ul><li>关闭系统：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sync</span><br><span class="line"># init 0    或    shutdown -n    或    halt</span><br></pre></td></tr></table></figure><ul><li>重启系统：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sync</span><br><span class="line"># init 6    或    shutdown -rn</span><br></pre></td></tr></table></figure><ul><li>退出当前用户登录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exit</span><br></pre></td></tr></table></figure><p>Linux的 <code>exit</code> 类似于 Windows 的注销；</p><ul><li>查看当前使用的虚拟终端：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br><span class="line">&#x2F;dev&#x2F;tty2        #二号虚拟终端</span><br></pre></td></tr></table></figure><ul><li>切换终端：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;Ctr + Alt + Fn&#125;</span><br><span class="line">#其中 n &#x3D; &#123;1, 2, 3, ... ,7&#125;,代表 tty n</span><br></pre></td></tr></table></figure><p>切换至图形终端（也是一个tty）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Ctr + Alt + F7&#125;</span><br></pre></td></tr></table></figure><ul><li>清空屏幕：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clear</span><br></pre></td></tr></table></figure><ul><li>找到系统中所有shell：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;shells</span><br></pre></td></tr></table></figure><ul><li>切换shell：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sh# 切换至Bourn Shell</span><br><span class="line">$ ksh# 切换至Korn Shell</span><br></pre></td></tr></table></figure><p>可以在命令行中输入一个不存在的命令（如<code>OK</code>），以确定用户当前的shell。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-0.1-系统安装</title>
      <link href="/2016/12/16/Linux/linux-0-1-Install/"/>
      <url>/2016/12/16/Linux/linux-0-1-Install/</url>
      
        <content type="html"><![CDATA[<h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><h3 id="挂载建议："><a href="#挂载建议：" class="headerlink" title="挂载建议："></a>挂载建议：</h3><p>Linux只要求两个基本分区 <code>／</code> 和 <code>swap</code>； </p><p>如果<code>／</code>足够的，可以在桌面放很多东西而不影响进入 Linux 的速度； </p><table><thead><tr><th>分区</th><th>大小</th><th>格式</th></tr></thead><tbody><tr><td>/boot1⃣️</td><td>128MB</td><td>ext3</td></tr><tr><td>swap</td><td>2⃣️</td><td></td></tr><tr><td>／</td><td>8GB</td><td>ext3</td></tr><tr><td>／home</td><td>余下全部</td><td>ext3</td></tr></tbody></table><p>若要安装很多软件最好分配个 <code>/usr</code>； </p><p>若要作服务器最好分配较大的 <code>/var</code>； </p><p>1⃣️.  <code>/boot</code>： </p><p>2018年后的新版本都可以不分； </p><p>可以分配10MB-100MB </p><p>如果硬盘不支持LBA模式，最好挂载/boot于第一个分区，以保稳妥。 </p><p>参考：<a href="https://wapbaike.baidu.com/item/boot%E5%88%86%E5%8C%BA/16830421?ms=1&rid=8645769021174590193">https://wapbaike.baidu.com/item/boot分区/16830421?ms=1&amp;rid=8645769021174590193</a></p><p>2⃣️. <code>swap</code>： </p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g60bdmoskaj30d108xglx.jpg" alt="Image 20180817 230902"></p><table><thead><tr><th>物理内存</th><th>swap</th><th>swap(开启休眠)</th></tr></thead><tbody><tr><td>2GB</td><td>2倍RAM</td><td>3倍RAM</td></tr><tr><td>&gt;2GB-8GB</td><td>=RAM</td><td>2倍RAM</td></tr><tr><td>&gt;8GB-64GB</td><td>4GB+</td><td>1.5倍RAM</td></tr><tr><td>&gt;64GB</td><td>4GB+</td><td>不建议休眠</td></tr></tbody></table><p>参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007</a> </p><p>开始的几个服务配置：</p><ul><li>检查<em>telnet</em>服务是否启动： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig telnet --list</span><br></pre></td></tr></table></figure><ul><li>启动<em>telnet</em>服务： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chkonfig telnet on</span><br></pre></td></tr></table></figure><p>开启telnet后在win下可用”&gt; telnet $IP”连接Linux。 </p><ul><li>检验<em>FTP</em>服务当前状态： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service vsftpd status </span><br></pre></td></tr></table></figure><ul><li>开启<em>FTP</em>服务： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service vsftpd start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-0.0-Linux?</title>
      <link href="/2016/12/15/Linux/linux-0-0-Linux/"/>
      <url>/2016/12/15/Linux/linux-0-0-Linux/</url>
      
        <content type="html"><![CDATA[<p>我会发一系列 Linux 学习笔记（它们最多可以算是“操作手册”，我不认为它们可以代替一本正经的入门书），这些东西是很久以前写的了，可能在 排版、内容 上质量都不高，请见谅。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><blockquote><p>Linux (/ˈlɪnəks/ LIN-əks) is a family of open source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991 by Linus Torvalds. Linux is typically packaged in a Linux distribution.<br>【翻译】Linux 是一系列基于 Linux 内核(一个最早由 Linus Torvalds 在 1991 年 9 月 17 日发布的操作系统内核)的类 Unix 开源操作系统。Linux 通常打包在 Linux 发行版中。</p></blockquote><p>👆这是 <a href="https://en.wikipedia.org/wiki/Linux">维基百科</a> 对 Linux 的介绍。</p><p>Linux 是什么不重要，重要的是为什么用Linux。就像对用户来说软件的代码实现不重要，重要的是这个软件可以用来干什么。</p><h2 id="为什么用-Linux？"><a href="#为什么用-Linux？" class="headerlink" title="为什么用 Linux？"></a>为什么用 Linux？</h2><p>我们常说，用 Linux 是因为它安全，或者因为它自由、因为它的高度可定制、因为它免费、因为它的背后有专业的社区支持……</p><p>然而，所有的这些全是瞎扯！我们说这种鬼话来欺骗非 Linux 用户，只因他们不会懂得 Linux 的真谛。<br>久而久之，说的多了，有时候连我们自己都开始相信这些乱七八糟的“充分理由”了。</p><p>夜深人静时再扪心自问，我们用 Linux 的原因到底何在？</p><p>……</p><p>我们用 Linux —— —— 是因为它好玩呀！</p><p>对着各种设置一阵捣鼓、把系统无情地玩弄到崩坏，再夹着尾巴跑到恢复系统、笨拙地为她缝合伤口、虔诚为她祈祷痊愈、期待着下一次把她摆布成不一样的姿势，这难道不好玩吗？<br>在那数百种发行版中肆意尝试她们各不相同的命令行不好玩吗？</p><p>是的，我们觉得命令行超级有趣！</p><p>其实 Linux 爱好者们爱上 Linux，爱的只是 Linux 本身！</p><p>是，我们使用 Linux 完成老板布置的工作；<br>是，我们使用 Linux 保障安全、远离病毒；<br>是，我们使用 Linux 省下几个柴米油盐钱；<br>但，这些都只是我们使用 Linux 的副作用！ </p><p>真正重要的是 —— —— 这系统好玩啊！</p><p>Linux 让我们像探险家一样游荡在系统深处，四处搅合，随性发掘，在软件的背后寻觅可爱的诗篇！</p><p>（翻译自一篇出处难寻的文章）</p><h2 id="用-Linux-做什么？"><a href="#用-Linux-做什么？" class="headerlink" title="用 Linux 做什么？"></a>用 Linux 做什么？</h2><p>所以，我们到底可以用 Linux 干什么？</p><p>毫无疑问——<strong>玩</strong>！</p><h2 id="Linux-UNIX，MacOS，Windows"><a href="#Linux-UNIX，MacOS，Windows" class="headerlink" title="Linux/UNIX，MacOS，Windows"></a>Linux/UNIX，MacOS，Windows</h2><p>Linux/UNIX，MacOS，Windows，这几乎就是我们平时接触到的所有操作系统了。</p><p>抛开刚才写的那么多 Linux 的好处不看，客观地比较一下它们：</p><ul><li><p>Linux/UNIX 以自由著称，但正如很多开源的东西，设计上会有一些缺陷，用户体验绝对不是最好的，但它几乎可以满足你在计算机编程、工作上的全部需求（只是操作起来可能需要时间、精力）。其实在 Linux/UNIX 的内部有很多很糟糕的部分，这是历史遗留问题了，在学会  Linux 的基础之前我们最好不去过多研究。</p></li><li><p>MacOS，这是我现在日常使用的操作系统，Apple一向以用户体验著称。MacOS绝对是我用过的体验最好的计算机操作系统，你不用了解太多的东西就可以专心地高效完成你的工作。但 MacOS 无论如何还是脱离不了 UNIX 的影响，UNIX 有的问题，MacOS 也会有，只是在表面上看不出来。在开发方面，按照 Apple 的文档，你虽然可以快速地开发出一个 App，但你很难去了解底层的东西，这给移植之类的工作带来了很大的麻烦，不过近年来也有好转。</p></li><li><p>Windows，我承认微软很厉害，Windows的设计也有很多很好的地方，但我始终无法接受 Windows 呈现给用户的那种……，我想是我的程序设计功夫还不到家，所以我也不喜欢微软风格的代码——虽然客观地说我承认它们其实很好。在 Windows 10 中我已经看到了它朝我想要的方向有了十足的进步，但这还不够！我期望微软有一天可以让我用回 Windows，毕竟它是我对计算机的最初回忆。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2016/08/14/helloworld/"/>
      <url>/2016/08/14/helloworld/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
