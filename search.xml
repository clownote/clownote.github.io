<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GitHub加Hexo打造个人博客</title>
      <link href="/2019/08/15/GitHub%E5%8A%A0Hexo%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/08/15/GitHub%E5%8A%A0Hexo%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Hexo-gt-个人博客"><a href="#GitHub-Hexo-gt-个人博客" class="headerlink" title="GitHub + Hexo =&gt; 个人博客"></a>GitHub + Hexo =&gt; 个人博客</h1><blockquote><p>打造一个个人博客其实很简单，我们不需要拥有一台服务器、甚至可以对 Web 开发不甚了解。</p></blockquote><p>这篇文章记录我如何在 Mac 上通过 <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>、<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 打造一个<em>个人博客</em> —— <strong><a href="https://clownote.github.io">clownote</a></strong></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我一直不喜欢 CSDN 和博客园等博客平台，但确实有写东西的习惯。写了东西就要发表，所以在之前，我把我学习计算机知识的笔记都放到了一个自己初学 Web 开发时搞的一个超级简陋的静态网站上。</p><p>但它实在是太简陋了导致使用起来<strong>巨</strong>麻烦，发布文章要手动把 markdown 写的文章用自己写的一个转换器渲染成 HTML，然后调用一个可以及时渲染代码颜色的 js 进去，然后 FTP 上传到服务器上，再到手动修改 <code>index.html</code>，加入这篇新文章的链接……</p><p>这完全不是正常人应该用的操作！</p><p>我一直在考虑写一个功能完整的、更方便的博客。计划是用 Flask 写后端，Vue 做前端，Git 来管理内容，然后再写一些 Apple Script、Bash Script 让这个博客系统方便在 Mac 中使用 。但最近一直忙其他项目，没时间来实现。现在我的服务器到期了，百度云的，感觉不太好用（主要是受对这家公司的某些其他产品的不良印象的影响），不续费了。</p><p>笔记急需迁出！写之前想的博客系统是来不及了，突然想起来很多人用一个叫 <code>Hexo</code> 的东西做博客，于是一番 Google、Bing。最终，我觉定用 <code>GitHub</code> + <code>Hexo</code> 快速（Less than One Day）打造一个<strong>不用服务器</strong>、<strong>不用写代码</strong>的博客。</p><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p><del>废话不多说，代码赶快写起来</del>，，，（哦，错了，咱们今天不用写代码！只是几个简单的命令 + 配置就好了😂）</p><p>废话不多说，建站走起！</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h4><p>首先，我们需要注册一个 <code>GitHub</code> 账户，我相信绝大多数的读者已经完成了这一步，所以不再赘述；如果您幸运的属于少数人，请打开 <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>，即可按照感觉轻松完成。</p><h4 id="创建-GitHub-Pages"><a href="#创建-GitHub-Pages" class="headerlink" title="创建 GitHub Pages"></a>创建 GitHub Pages</h4><p>在您的 GitHub 中，<code>New</code> 一个 <code>Repository</code>，名字为 <code>&lt;userName&gt;.github.io</code>，其中的 <code>&lt;userName&gt;</code> 与您的 GitHub 用户名相同。</p><p>注意，在这个新建的 Repository 的 <code>Settings</code> 中，您应该可以找到，有关 <code>GitHub Pages</code> 的设置里写了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your site is published at https://&lt;userName&gt;.github.io</span><br></pre></td></tr></table></figure><p>这样就成了，否则请检查之前的步骤是否正确。</p><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>在安装 <code>Hexo</code> 前，需要确定电脑中是否已安装了：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (版本至少为 nodejs 6.9)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node --version</span><br></pre></td></tr></table></figure><p>如果没有，要先安装他们。接下来只需要使用 <code>npm</code> 即可完成 Hexo 的安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建您的博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>然后，可以看到指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>目录中的 <code>_config.yml</code> 是网站的配置信息，我们需要在此配置一些参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat _config.yml</span><br><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>需要配置的项目有：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言</td></tr><tr><td align="left"><code>url</code></td><td align="left">网址</td></tr><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr></tbody></table><p>需要说明的是，<code>deploy</code> 项的配置就可以把Hexo与GitHub关联起来，即将我们的博客<strong>推送</strong>到 GitHub，打开站点的配置文件_config.yml，<code>deploy</code> 项配置为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="attr">https://github.com/&lt;userName&gt;/&lt;userName&gt;.github.io</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后，我们需要让 Hexo 连接上我们的 GitHub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>每一条命令的作用都很直观。操作完之后你就会发现你的博客已经上线了，可以在网络上被访问了！</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>如果你像我一样，觉得 <code>Hexo</code> 自带的 <code>landscape</code> 主题不太好看，我们可以跟换一个主题。</p><p>我们可以在 Hexo 官网上找到很丰富的 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题资源</a>，具体的使用方法主题项目的 README 里会写明，照着做就行。</p><p>这里以配置一个叫做 <a href="https://github.com/probberechts/hexo-theme-cactus" target="_blank" rel="noopener"><code>cactus</code></a> 的主题为例：</p><ol><li>下载、安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;# hexo init 的目录</span><br><span class="line">$ git clone https://github.com/probberechts/hexo-theme-cactus.git themes/cactus# 拷贝一份主题</span><br></pre></td></tr></table></figure><ol start="2"><li>修改Hexo主题：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ./config.yml</span><br></pre></td></tr></table></figure><p>修改其中的 <code>theme</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># theme: landscape</span><br><span class="line">theme: cactus</span><br></pre></td></tr></table></figure><ol start="3"><li>主题配置</li></ol><p>在 <code>themes/cactus/_config.yml</code> 中按照自己的需要对主题进行配置。</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>其实到这里，我们的博客就已经构建完成了。接下来我们就可以用新建的博客系统写作了😊。</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p>可选的布局有：</p><table><thead><tr><th><code>layout</code></th><th>储存路径</th><th>功能</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td><td>存放要发布的博客文章</td></tr><tr><td><code>page</code></td><td><code>source</code></td><td>网站中的一些固定页面，比如说”关于”</td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td><td>草稿</td></tr></tbody></table><p><code>hexo new</code> 成功后，Hexo 会告诉你新建的文件路径，利用 markdown 编辑器打开它，就可以开始书写了，在我的 Mac 里，默认的 markdown 编辑器是 <code>Typora</code>，可以直接用 <code>open</code> 命令来用默认程序打开并编辑文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open ~/&lt;blogFolder&gt;/source/_drafts&lt;title&gt;.md</span><br></pre></td></tr></table></figure><h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><p>我们在写文章时，可以先写草稿(draft)。草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><p>文章写好后，通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，在里面写 YAML 配置，用于指定个别文件的变量，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>以下是一些常用的参数：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left"></td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>keywords</code></td><td align="left">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td><td align="left"></td></tr></tbody></table><h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>对于大多数人来讲，对一篇文章分类和标签的设置是必不可少的。</p><p>分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：<strong>分类(<code>categories</code>)</strong> 具有<em>顺序性</em>和<em>层次性</em>，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而 <strong>标签(<code>tags</code>)</strong> 没有顺序和层次。</p><p>在 <code>Front-matter</code> 中，分类和标签的设置方法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure><p>在使用 <code>categories</code> 时，请注意：</p><p>Hexo不支持指定多个同级分类！下面的指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure><p>会使分类 <code>Life</code> 成为 <code>Diary</code> 的子分类，而不是 <em>并列分类</em>。因此，有必要为您的文章选择尽可能准确的分类。</p><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>在完成写作后，我们先保存编辑好的 markdown 文件，然后执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish post &lt;title&gt;.md# 如果新建时 layout 为 draft</span><br><span class="line"></span><br><span class="line">$ hexo deploy --generate# 生成文件完成后部署</span><br><span class="line"># 可以简写为 `$ hexo d -g`</span><br></pre></td></tr></table></figure><h4 id="操作总结"><a href="#操作总结" class="headerlink" title="操作总结"></a>操作总结</h4><p>现在，回顾一下我们用 Hexo 写作的过程:</p><ol><li><code>$ hexo new draft &lt;title&gt;</code></li><li><code>$ open ~/&lt;blogFolder&gt;/source/_drafts/&lt;title&gt;.md</code></li><li><code>在编辑器中填写Front-matter，并完成内容写作</code></li><li><code>$ hexo publish post &lt;title&gt;</code></li><li><code>$ hexo deploy --generate</code></li></ol><p>如果有能力，我们还可以写一个简单的小脚本来简化这些操作。很容易实现，在这里就不介绍了。</p><h3 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h3><p>现在，我们已经完成了博客系统的安装、建站并且学会了在其中写作。</p><p>当我们打开自己的博客网站时，会发现，我们的 <code>Cactus</code> 主题已经提供了诸如分享、导航的功能。</p><p>但或许我们还是觉得它有些太简陋了，我们可能还想让它有一些让用户体验更好的特性，比如，搜索、评论功能，现在我们尝试来实现它们。</p><p>其实，我们使用的 <code>Cactus</code> 主题中，已经包含了对搜索、评论的支持，直接使用即可。</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>安装 hexo 的搜索插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>创建一个新页面，用来承载搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page search</span><br></pre></td></tr></table></figure><p>在 Front-matter 里加上 <code>type: search</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Search</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">search</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>在 <code>themes/cactus/_config.yml</code> 里配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line"><span class="attr">  search:</span> <span class="string">/search/</span></span><br></pre></td></tr></table></figure><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p> <code>Cactus</code> 主题为我们提供的评论工具是 <code>Disqus</code>，这是一个各方面都很好的评论系统，但有一点问题是，这个评论系统<strong>在国内无法使用</strong>，所以我们只是简单翻译一下官方的介绍：</p><p>首先，在 Disqus 注册我们的站点: <a href="http://disqus.com/admin/create/" target="_blank" rel="noopener">https://disqus.com/admin/create/</a>.</p><p>然后, 修改 <code>themes/cactus/_config.yml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enabled: true</span><br><span class="line">  shortname: SITENAME</span><br></pre></td></tr></table></figure><p>这里的 <code>SITENAME</code> 是在注册 Disqus 时，你给你的站点填写的名字。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，我们的博客网站建好了。由于我最迫切的需求就是快速的完成博客建站，所以多余的东西我都没有研究，但其实 Hexo 还可以有很多拓展，GitHub Pages 也还有一些东西可以配置，这些都需要大家自己去研究。</p><p>后期我还会持续优化这个网站，比如我计划修改一下源码，把 Cactus 中的 <code>Disqus</code> 评论换成墙内能用的如 <code>livere</code> 之类的东西 ，如果可以，我会另外发文记录。</p><p>其实，这篇文章中的绝大多数内容都来源于咱们使用的各个工具的官网，我只是粗糙地把他们按照一定的逻辑顺序排列到一起。如果需要更详细的说明，大家可以看下面列出的这些参考文档：</p><ul><li>GitHub的注册与使用：<a href="https://help.github.com/cn" target="_blank" rel="noopener">https://help.github.com/cn</a></li><li>Hexo的安装及使用：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li>Cactus主题的配置：<a href="https://github.com/probberechts/hexo-theme-cactus" target="_blank" rel="noopener">https://github.com/probberechts/hexo-theme-cactus</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-4.2-正文处理</title>
      <link href="/2017/01/03/Linux/linux-4-2-TextHandle/"/>
      <url>/2017/01/03/Linux/linux-4-2-TextHandle/</url>
      
        <content type="html"><![CDATA[<h1 id="正文-处理"><a href="#正文-处理" class="headerlink" title="正文.处理"></a>正文.处理</h1><h2 id="unix2dos-dos2unix：Unix-与-DOS-正文转化"><a href="#unix2dos-dos2unix：Unix-与-DOS-正文转化" class="headerlink" title="unix2dos, dos2unix：Unix 与 DOS 正文转化"></a><code>unix2dos</code>, <code>dos2unix</code>：Unix 与 DOS 正文转化</h2><p>UNIX 系统的正文（纯文字）格式中只用换行符<code>\n</code>作为行结束符；</p><p>DOS &amp; Windows 系统的正文中是以回车符 <code>\r</code> 和换行符 <code>\n</code> 作为行结束符；</p><p>用 <code>cat -A filename</code> 可见二者区别。</p><p>将 DOS 格式的文件转换成 UNIX 格式的文件用 <code>dos2unix file_name</code>；</p><p>将 UNIX 格式的文件转换成 DOS 格式的文件用 <code>unix2dos file_name</code>；</p><h2 id="diff-sdiff：比较两个文件的差别"><a href="#diff-sdiff：比较两个文件的差别" class="headerlink" title="diff, sdiff：比较两个文件的差别"></a><code>diff</code>, <code>sdiff</code>：比较两个文件的差别</h2><h3 id="diff-file-1-file-2：只输出两者不同点"><a href="#diff-file-1-file-2：只输出两者不同点" class="headerlink" title="diff file_1 file_2：只输出两者不同点"></a><code>diff file_1 file_2</code>：只输出两者不同点</h3><p>显示结果中：</p><ul><li>字母c为 比较，比较某行二者不同点；</li><li>字母d是 不同，显示一文无一文有的；</li><li>“&lt;”表示第1个文件中的数据行。</li><li>“&gt;”表示第2个文件中的数据行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ diff letters.upper letters</span><br><span class="line">2c2        # 第1个文件的第2行与第2个文件的第2行比较。</span><br><span class="line">&lt; B        # 第1个文件的第2行为B。</span><br><span class="line">---</span><br><span class="line">&gt; b        # 第2个文件的第2行为b。</span><br><span class="line">6c6        # 第1个文件的第6行与第2个文件的第6行比较。</span><br><span class="line">&lt; F        # 第1个文件的第6行为F。</span><br><span class="line">---</span><br><span class="line">&gt; f        # 第2个文件的第6行为f。</span><br><span class="line">8d7        # 第1个文件一共有8行，而第2个文件一共有7行。</span><br><span class="line">&lt; H        # 第1个文件的第8行（也是最后一行）为H。</span><br></pre></td></tr></table></figure><h3 id="sdiff-file-1-file-2：side-by-side-输出两者所有行，标示不同"><a href="#sdiff-file-1-file-2：side-by-side-输出两者所有行，标示不同" class="headerlink" title="sdiff file_1 file_2：side-by-side 输出两者所有行，标示不同"></a><code>sdiff file_1 file_2</code>：side-by-side 输出两者所有行，标示不同</h3><p>显示结果中：</p><ul><li><p>“|”左侧表示第1个文件中的数据行。</p></li><li><p>“|”右侧表示第2个文件中的数据行。</p></li><li><p>“&lt;”表示第1个文件中的数据行（当第1个文件中有数据，但第2个文件中没有时）。</p></li><li><p>“&gt;”表示第2个文件中的数据行（当第2个文件中有数据，但第1个文件中没有时）。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sdiff letters.upper letters</span><br><span class="line">A                             A</span><br><span class="line">B                            | b            # 第1个文件中为B，第2个文件中为b。</span><br><span class="line">C                             C </span><br><span class="line">D                             D</span><br><span class="line">E                             E</span><br><span class="line">F                            | f            # 第1个文件中为F，第2个文件中为f。</span><br><span class="line">G                             G</span><br><span class="line">H                             &lt;            # 第1个文件中为H，第2个文件中的这一行为空。</span><br></pre></td></tr></table></figure><blockquote><p><code>sdiff</code> 命令的显示结果更容易阅读。<br>但是如果比较的两个文件很大，而其中的差别又很少，使用 <code>diff</code> 命令可能更好些。</p></blockquote><h2 id="aspell-look：检查单词的拼写"><a href="#aspell-look：检查单词的拼写" class="headerlink" title="aspell, look：检查单词的拼写"></a><code>aspell</code>, <code>look</code>：检查单词的拼写</h2><p>aspell，look 的字典是 <code>/usr/share/dict/words</code></p><h3 id="aspell"><a href="#aspell" class="headerlink" title="aspell"></a><code>aspell</code></h3><p><code>aspell</code> 是Linux系统上的一个交互式的英语拼写检查程序，该程序通过一个简单的菜单驱动的界面来提供改正英文单词的建议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ aspell check file_name</span><br><span class="line">        Enter后，</span><br><span class="line">        光标停留在第1个有拼写错误的单词上，</span><br><span class="line">        并在终端窗口下部给出一些可供选择的正确单词；</span><br><span class="line">        输入某个单词前面的编号来选择这个单词，</span><br><span class="line">        系统就会立即修改光标所在处的单词；</span><br><span class="line">        之后光标将移到下一个有拼写错误的单词。</span><br><span class="line">$ aspell list &lt; file_name</span><br><span class="line">            以非交互的方式在终端窗口中列出某个文件中的全部有拼法错误的英语单词</span><br></pre></td></tr></table></figure><p>• <code>look  &lt;sth&gt;</code>：列出所有以sth开头的英语单词以供选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ look progra</span><br><span class="line">prograde</span><br><span class="line">program</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="expand-fmt-pr-重新格式化正文"><a href="#expand-fmt-pr-重新格式化正文" class="headerlink" title="expand, fmt, pr: 重新格式化正文"></a><code>expand</code>, <code>fmt</code>, <code>pr</code>: 重新格式化正文</h2><h3 id="expand：将Tab化为空格"><a href="#expand：将Tab化为空格" class="headerlink" title="expand：将Tab化为空格"></a><code>expand</code>：将Tab化为空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expand [-t 1] data.tab &gt; data.spaces</span><br><span class="line">        -t n：表示将制表键转换成n个空格符。</span><br></pre></td></tr></table></figure><h3 id="fmt-格式化文本"><a href="#fmt-格式化文本" class="headerlink" title="fmt: 格式化文本"></a><code>fmt</code>: 格式化文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ fmt -u -w48 news &gt; news.fmt</span><br><span class="line">        fmt将它的输入格式化成一些段落，</span><br><span class="line">        其中段落宽度是使用-wn选项来定义的（w为width，n为字符的数目，系统默认宽度为75个字符）。</span><br><span class="line">        利用-u选项将文件中的空格统一化（每个单词之间使用一个空格分隔，每个句子之间使用两个空格分隔）。</span><br><span class="line">            </span><br><span class="line">        fmt命令将它的输入中的空行当作段落分隔符看待。</span><br></pre></td></tr></table></figure><h3 id="pr：按照打印机的格式重新编排纯文本文件中的内容"><a href="#pr：按照打印机的格式重新编排纯文本文件中的内容" class="headerlink" title="pr：按照打印机的格式重新编排纯文本文件中的内容"></a><code>pr</code>：按照打印机的格式重新编排纯文本文件中的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ pr file</span><br><span class="line">        pr命令的默认输出为每页66行，其中56行为正文内容，并包括表头。</span><br><span class="line">        若没有指定列表头（Header），系统默认使用文件名作为列表头，并在每页的页首部分显示。</span><br><span class="line">        另外，每页的页首部分还有页码和时间(inode.M_time)。</span><br><span class="line">$ pr -h&quot;English Dictionary on Linux&quot; -l18 -5 /usr/share/dict/words | more</span><br><span class="line">        -h选项为列表头（Header），</span><br><span class="line">        在h后面使用双引号括起来的就是要显示的表头信息，</span><br><span class="line">        -l选项用来定义每页的行数，-l18表示每页都有18行，</span><br><span class="line">                （-l选项后的数目不能太小，如果太小pr命令会忽略这一选项）</span><br><span class="line">        -5表示每页打印5列。</span><br><span class="line">        </span><br><span class="line">---------------------------</span><br><span class="line">        </span><br><span class="line"># Output：</span><br><span class="line"></span><br><span class="line">2006-10-08 02:00           English Dictionary on Linux            Page 1</span><br><span class="line">&amp;c             &apos;prentice      &apos;shun          &apos;tis          &apos;un</span><br><span class="line">&apos;d             &apos;re            &apos;slid          &apos;twas         &apos;ve</span><br><span class="line">......</span><br><span class="line">2006-10-08 02:00           English Dictionary on Linux            Page 2</span><br><span class="line">-acal          -acy          -age          -ana           -ar</span><br><span class="line">-acea          -ad           -agogue       -ance          -arch</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-4.1-正文文本操作</title>
      <link href="/2017/01/02/Linux/linux-4-1-TextOperate/"/>
      <url>/2017/01/02/Linux/linux-4-1-TextOperate/</url>
      
        <content type="html"><![CDATA[<h1 id="正文文本操作"><a href="#正文文本操作" class="headerlink" title="正文文本操作"></a>正文文本操作</h1><h3 id="tr：字符转换"><a href="#tr：字符转换" class="headerlink" title="tr：字符转换"></a><code>tr</code>：字符转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tr &apos;A-Z&apos; &apos;a-z&apos; &lt; w.txt &gt; u.txt        # 将w中的大写-&gt;小写，放入u中</span><br><span class="line">$ tr -d &quot;\r&quot; &lt; dept.data &gt; dept.data.unix        # 将DOS格式的正文文件（以回车“\r”符和换行“\n”符结束一行）转换成Linux格式的文件（只用换行符“\n”来结束一行）</span><br></pre></td></tr></table></figure><h3 id="cut：从文件中剪出一个字段-列-至1-stdout"><a href="#cut：从文件中剪出一个字段-列-至1-stdout" class="headerlink" title="cut：从文件中剪出一个字段(列)至1(stdout)"></a><code>cut</code>：从文件中剪出一个字段(列)至1(stdout)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cut [options] [file]</span><br><span class="line">        -f：说明(定义)字段(列)</span><br><span class="line">        -c：要剪切的字符：</span><br><span class="line">                「-c4-7」：剪下每行4～7的字符</span><br><span class="line">        -d：说明(定义)字段的分隔符(默认为Tab)</span><br><span class="line">                「-d,」：以“,”为分隔符</span><br><span class="line">$ cut -f2 emp.data</span><br><span class="line">        显示emp.data中的第二列至stdout</span><br></pre></td></tr></table></figure><h3 id="paste：粘贴"><a href="#paste：粘贴" class="headerlink" title="paste：粘贴"></a><code>paste</code>：粘贴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ paste  -d,  name.txt  score.txt  &gt;  student.txt</span><br><span class="line">        -d：说明(定义)字段的分隔符(默认为Tab)</span><br><span class="line">                「-d,」：以“,”为分隔符</span><br><span class="line">        &gt; ：横向合并文件：</span><br><span class="line">            |Mike|         |99|          |Mike,99|</span><br><span class="line">            |Jake|    +    |98|    -&gt;    |Jake,98|</span><br><span class="line">            |Anny|         |97|          |Anny,97|</span><br></pre></td></tr></table></figure><h3 id="uniq：去掉文件中相邻的重复行"><a href="#uniq：去掉文件中相邻的重复行" class="headerlink" title="uniq：去掉文件中相邻的重复行"></a><code>uniq</code>：去掉文件中相邻的重复行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ uniq [opts] [file]</span><br><span class="line">        -c：在显示的行前冠以该行出现的次数</span><br><span class="line">        -d：只显示重复行</span><br><span class="line">        -i：忽略字符的大小写</span><br><span class="line">        -u：只显示唯一的行</span><br></pre></td></tr></table></figure><h3 id="sort：排序"><a href="#sort：排序" class="headerlink" title="sort：排序"></a><code>sort</code>：排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sort [opt] [file]</span><br><span class="line">         -r：反向排序</span><br><span class="line">         -f：忽略大小写</span><br><span class="line">         -n：按数字顺序排序</span><br><span class="line">          -u：去掉重复行</span><br><span class="line">          -t c：以字符c为分割符</span><br><span class="line">          -k N1,[N2]：按N1-&gt;N2字段排序</span><br></pre></td></tr></table></figure><h3 id="col-Tab转空格："><a href="#col-Tab转空格：" class="headerlink" title="col: Tab转空格："></a><code>col</code>: Tab转空格：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ col -x &lt; e.tabs &gt;e.spaces</span><br><span class="line">        将e.tabs中的Tab字符(^I)化为空格存在e.spaces中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-4.0-正文浏览</title>
      <link href="/2017/01/01/Linux/linux-4-0-TextRead/"/>
      <url>/2017/01/01/Linux/linux-4-0-TextRead/</url>
      
        <content type="html"><![CDATA[<h1 id="正文浏览"><a href="#正文浏览" class="headerlink" title="正文浏览"></a>正文浏览</h1><blockquote><p>正文，即字符串 / 纯文本文件的内容。</p></blockquote><h3 id="cat：浏览正文文件内容"><a href="#cat：浏览正文文件内容" class="headerlink" title="cat：浏览正文文件内容"></a><code>cat</code>：浏览正文文件内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat [options] [files]</span><br><span class="line">    -A：显示内容，包括不可见的特殊字符</span><br><span class="line">    -s：将两个及以上的空行省略为一个空行</span><br><span class="line">    -b：加入行号</span><br><span class="line">$ cat &gt; filename</span><br><span class="line">    创建新文本文件，写入内容</span><br><span class="line">    空行&#123;Ctr+d&#125;，保存退出        # &#123;Ctr+c&#125;:强行终止</span><br><span class="line">            [注意]：用cat打开二进制文件会造成终端停止工作，可开启一个新的终端以解决。</span><br></pre></td></tr></table></figure><pre><code>⚠️ \[注意\]：用 cat 打开二进制文件可能会造成终端停止工作，可开启一个新的终端以解决。</code></pre><h3 id="head：浏览文件头几行"><a href="#head：浏览文件头几行" class="headerlink" title="head：浏览文件头几行"></a><code>head</code>：浏览文件头几行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ head [-n x] file</span><br><span class="line">    浏览文件头x行</span><br><span class="line">    若省去[-n x]则显示头10行</span><br></pre></td></tr></table></figure><h3 id="tail：浏览文件后几行"><a href="#tail：浏览文件后几行" class="headerlink" title="tail：浏览文件后几行"></a><code>tail</code>：浏览文件后几行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tail file</span><br><span class="line">    浏览文件后10行</span><br><span class="line">$ tail -[n]x  file</span><br><span class="line">    显示从末尾算起的x行</span><br><span class="line">    有无n都一样</span><br><span class="line">$ tail +[n]x  file</span><br><span class="line">    显示从文件第x行之后的内容</span><br><span class="line">    有无n都一样</span><br><span class="line">$tail -f file</span><br><span class="line">    “-f“ == ”--follow“</span><br><span class="line">    当一个正文文件内容发生变化时，把变化显示出来</span><br><span class="line">    &#123;ctrl+c&#125;退出</span><br><span class="line"># tail -f /var/log/messages</span><br><span class="line">    监视日志</span><br></pre></td></tr></table></figure><h3 id="wc：-word-count-字数统计"><a href="#wc：-word-count-字数统计" class="headerlink" title="wc：(word count)字数统计"></a><code>wc</code>：(word count)字数统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wc [-options] file</span><br><span class="line">    显示文件 行、单词、字符 数</span><br><span class="line">        无选项依次显示l，w，c</span><br><span class="line">        -l：行数</span><br><span class="line">        -w：单词数</span><br><span class="line">        -c：字符数</span><br></pre></td></tr></table></figure><h3 id="more-file-：可翻页地浏览文件"><a href="#more-file-：可翻页地浏览文件" class="headerlink" title="more [file]：可翻页地浏览文件"></a><code>more [file]</code>：可翻页地浏览文件</h3><p>在more中键入：</p><ul><li><p><code>{空格}</code>：下一页</p></li><li><p><code>{Enter}</code>：移动一行</p></li><li><p><code>{b}</code>：上一页</p></li><li><p><code>{h}</code>：帮助</p></li><li><p><code>{/str}</code>：向前搜索str</p></li><li><p><code>{n}</code>：发现这个字符串的下一次出现</p></li><li><p><code>{q}</code>：退出 more</p></li><li><p><code>{v}</code>：在当前行启动 vi</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.3-文件归档与压缩</title>
      <link href="/2016/12/30/Linux/linux-3-1-3-Archiving/"/>
      <url>/2016/12/30/Linux/linux-3-1-3-Archiving/</url>
      
        <content type="html"><![CDATA[<h1 id="文件归档与压缩"><a href="#文件归档与压缩" class="headerlink" title="文件归档与压缩"></a>文件归档与压缩</h1><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><p>归档（archiving）就是将许多文件（或目录）打包成一个文件。</p><p>归档的目的就是方便备份、还原及文件的传输操作。</p><p>Linux操作系统的标准归档命令是tar（tape archive）。</p><p>tar命令的功能是将多个文件（也可有目录）放在一起存放到一个磁带或磁盘归档文件中，</p><p>并且将来可以根据需要只还原归档文件中的某些指定的文件。</p><p>tar命令默认并不进行文件的压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tar [选项]... [归档文件名]...</span><br><span class="line">    必须至少使用如下选项中的一个：</span><br><span class="line">        c：创建一个新的tar文件。</span><br><span class="line">        t：列出tar文件中内容的目录。</span><br><span class="line">        x：从tar文件中抽取文件。</span><br><span class="line">        f：指定归档文件或磁带（也可能是软盘）设备（一般都要选）</span><br><span class="line">            （在RHEL 4之前的版本中规定在f选项之后必须紧跟着文件名而不能再加其他参数，</span><br><span class="line">                但是从RHEL 4开始已经取消了这一限制。）</span><br><span class="line">以下为可选的选项：</span><br><span class="line">        v：显示所打包的文件的详细信息（v是verbose）</span><br><span class="line">                (执行过程中会显示所有打包的文件和目录)</span><br><span class="line">        z：使用gzip压缩算法来压缩打包后的文件。</span><br><span class="line">                「$ tar cvfz arch.tar.gz dir2arch」</span><br><span class="line">        j：使用bzip2压缩算法来压缩打包后的文件。</span><br><span class="line">                「$ tar cvfj arch.tar.bz2 dirarch」</span><br><span class="line">【注意】在tar命令中，所有的选项之前都不能使用前导的“-”。</span><br></pre></td></tr></table></figure><p>创建新的归档文件：<code>c\[v\]f</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar  cvf  arch.tar  dir2arch    # File to be archived should be a RELATIVE path</span><br><span class="line">dir2arch/</span><br><span class="line">dir2arch/learning.txt</span><br><span class="line">dir2arch/name.txt</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>查看归档文件内容：<code>t\[v\]f</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tar tf arch.tar</span><br><span class="line">dir2arch/</span><br><span class="line">dir2arch/learning.txt</span><br><span class="line">dir2arch/name.txt </span><br><span class="line">……</span><br><span class="line"># 可以在tar命令中再加入v命令来显示文件更加详细的信息(like 「ls -l」):</span><br><span class="line">$ tar tvf arch.tar</span><br><span class="line">drwxrwxr-x User/User           0 2010-02-04 05:09:43 dir2arch/</span><br><span class="line">-rw-r--r--   User/User        4720 2010-02-04 05:07:22 dir2arch/learning.txt</span><br><span class="line">-rw-rw-r--   User/User          84 2010-02-04 05:07:22 dir2arch/name.txt </span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>解开打包好的文件：<code>x\[v\]f</code></p><p>[⚠️]<span style="color: #fd0404;">解开前要将工作目录切换到打包时所在的目录，才能保证抽取的文件放回到原来的位置。</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvf arch.tar</span><br><span class="line">dir2arch/</span><br><span class="line">dir2arch/learning.txt</span><br><span class="line">dir2arch/name.txt</span><br><span class="line">dir2arch/flowers.JPG</span><br><span class="line">dir2arch/dog.JPG  ……</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>进行文件压缩的主要目的是缩小文件的大小。</p><p>一般对正文文件进行压缩之后，文件的大小可以被压缩大约75%。</p><p>但是二进制的文件，如图像文件通常不会被压缩多少。</p><p>Linux系统中两组常用的压缩工具：</p><ol><li><code>gzip \ gunzip -&gt; [*.gz]</code></li></ol><p>[⚠️]<span style="color: #fcb100;">用gzip不能压缩<strong>目录</strong></span></p><p>用gzip来压缩文件，就必须使用gunzip来解压缩。</p><p>它们是Linux系统上标准的压缩和解压缩工具，</p><p><em>gzip对正文文件的压缩比一般超过75%</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gzip [选项] [压缩文件名…]</span><br><span class="line">        若不用-c则会压缩源文件（把原来多foo.txt变成一个foo.txt.gz）</span><br><span class="line">        -v：在屏幕上显示出文件的压缩比（v是verbose的第1个字母）。</span><br><span class="line">        -c：保留原来的文件，而新创建一个压缩文件(要重定向出来)，其中压缩文件名以.gz结尾。</span><br><span class="line">                （gzip -vc bar.txt &gt; foobar.gz）</span><br><span class="line">解压缩时，输入gunzip空格后跟要解压缩的文件，如命令gunzip arch.gz。</span><br></pre></td></tr></table></figure><ol start="2"><li><code>bzip2 \ bunzip2 -&gt;[*.bz2]</code></li></ol><p>用bzip2压缩，必须用bunzip2解压。</p><p>它们是Linux系统上比较新的压缩和解压缩工具，</p><p>通常bzip2对归档文件的压缩比要优于gzip工具。</p><p>比较新的Linux版本才支持bzip2和bunzip2命令。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.2-磁盘，可移除式媒体</title>
      <link href="/2016/12/29/Linux/linux-3-1-2-Disk-RemovableMedia/"/>
      <url>/2016/12/29/Linux/linux-3-1-2-Disk-RemovableMedia/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘，可移除式媒体"><a href="#磁盘，可移除式媒体" class="headerlink" title="磁盘，可移除式媒体"></a>磁盘，可移除式媒体</h1><ul><li><strong>检查磁盘空间</strong></li></ul><p>监督文件系统的使用情况，可使用如下两个命令：</p><ul><li>df：显示文件系统中磁盘使用和空闲区的数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ df [选项] [dir|file|设备]</span><br><span class="line">    无[dir|file]：以KB为单位列出每个(Every)文件系统中 所有的空间，已用空间，空闲空间</span><br><span class="line">    加上 dir|file：显示该文件所在的文件系统的情况</span><br><span class="line">    加上 设备(如 /dev/sda1)：显示该设备的文件系统的情况</span><br><span class="line">    选项：</span><br><span class="line">        -h或-H ：以人类容易理解的方式表示</span><br><span class="line">        -i：列出inode的使用情况</span><br></pre></td></tr></table></figure><ul><li>du：显示磁盘使用的总量（xx目录，有多大）</li></ul><p>du命令<u>以KB为单位</u>🐱显示文件系统磁盘空间使用的总量，并将递归地显示所有子目录的磁盘空间使用量。</p><p>如果在这个命令中使用-s选项，命令的结果就只显示一个目录总的磁盘空间使用量。</p><p>在du命令中也同样可以加上-h或-H选项。</p><p>🐱. 部分UNIX上（如Solaris上），du的单位是 <em>512B</em> 的数据块数。</p><ul><li><strong>可移除式媒体</strong></li></ul><p><strong><em>Removable Media</em></strong>（一种翻译为  可移除式媒体）：指USB闪存、软盘、CD、DVD等介质。</p><p><em>Removable Media</em> 的<strong>特点</strong>：</p><ul><li><p>在访问之前，必须将这个Removable Media挂载（mount）到系统上。</p></li><li><p>在移除之前，必须将这个Removable Media从系统上卸载掉。</p></li><li><p>在默认的情况下，一般非root的普通用户只能挂载某些特定的设备（如USB闪存、软盘、CD、DVD等）。</p></li><li><p>默认的挂载点一般是根目录下的media，即/media。</p></li></ul><p><strong>MOUNT</strong> Removable Media：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">    列出当前系统中挂载的所有文件系统</span><br></pre></td></tr></table></figure><ul><li>Mount <strong>CD/DVD:</strong>  </li></ul><p>在gnome或KDE的中，只要在光驱中放入CD或DVD，就会被自动地挂载到系统中来。</p><p>如果没有被自动地挂载到系统中来，就必须手动地挂载CD/DVD。</p><p>如果是CD/DVD Reader，将使用 <code>mount  ...  /media/cdrom</code> 命令将CD/DVD挂载到 <code>/media/cdrom</code> 之下。</p><p>如果是CD/DVD Writer，将使用 <code>mount ... /media/cdrecorder</code> 命令将CD/DVD挂载到 <code>/media/cdrecorder</code> 之下。</p><p>可以使用eject命令退出（umount）CD/DVD。</p><p>[⚠️]<span style="color: #fcb100;">当安装有<strong>多个光盘</strong>软件时，千万<strong>不要将工作目录设为CD所在的目录</strong>，这样将无法更换光盘，因为执行eject或umount命令时系统要求CD目录中没有任何操作。</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">挂载CD／DVD：</span><br><span class="line"># mount  /dev/hdc  /media/cdrom        # Only root can do that</span><br><span class="line">Read it：</span><br><span class="line">$ ls -l /media/cdrom</span><br><span class="line">Umount it：</span><br><span class="line"># eject /media/cdrom</span><br></pre></td></tr></table></figure><ul><li>Mount <strong>USB闪存：</strong>  </li></ul><p>将USB闪存插入计算机，Linux内核会自动探测到这一设备，并将其自动安装为SCSI设备。</p><p>通常它会被挂载在<code>/media/&lt;Device ID&gt;</code>。</p><p>手动挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount /media/KINGSTON</span><br><span class="line">或</span><br><span class="line"># mount  /dev/sdb1  /media/KINGSTON</span><br></pre></td></tr></table></figure><p>只有root可以 umount USB 闪存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.1-连接(link)</title>
      <link href="/2016/12/28/Linux/linux-3-1-1-Link/"/>
      <url>/2016/12/28/Linux/linux-3-1-1-Link/</url>
      
        <content type="html"><![CDATA[<h1 id="连接-link"><a href="#连接-link" class="headerlink" title="连接(link)"></a>连接(link)</h1><ol><li><strong>符号连接（软连接）</strong>：指向另一个文件的文件</li></ol><p>符号连接也只能包含一种类型的数据；</p><p>一个符号连接包含了它所指向的文件的路径；</p><p>因为符号连接使用的是指向其他文件的路径名，</p><p>所以符号连接可以指向其他文件系统上的文件。</p><p>º。查看符号连接：使用 <code>ls -l</code>：</p><pre><code>文件类型码如果是“l”表示是一个连接。</code></pre><p>另外在显示结果的最后一列中，</p><p>在-&gt;左边的是符号连接名，</p><p>在-&gt;右边的是所指向对象的完整路径，</p><p>显示结果中的大小为这个完整路径的字符个数。  </p><p>º。创建软连接：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ln  -s  abs_path/文件名  abs_path/[连接名]</span><br><span class="line">    [⚠️]可以对目录建立软连接</span><br><span class="line">    文件名：连接指向的文件</span><br><span class="line">    连接名：新建的link file的名字</span><br><span class="line">            缺省为与指向文件同名</span><br><span class="line">    [⚠️]注意两文件的path都要写绝对路径</span><br><span class="line">            若使用相对路径会出现软连接断开的问题：</span><br><span class="line">                使用连接时会报错：</span><br><span class="line">                    Too many levels of symbolic links.</span><br><span class="line">                可对link file使用file命令发现错误：</span><br><span class="line">                    $ file link_file</span><br><span class="line">                    abs_path/link_file:broken symbolic links to &apos;pointing file&apos;</span><br></pre></td></tr></table></figure><p>º。软连接的使用：</p><p>对 link_file rwx == 对 pointing_file rwx</p><p>º。软连接的工作原理</p><p>／*符号连接也要占用一个i节点，即软连接本身也是一个文件*／</p><p>使用symbolic link：</p><p>（1）首先系统利用_符号连接名_查找到这个软连接所对应的i节点。</p><p>（2）通过i节点中的指针查找到_link file_的数据块（其中，存放着所_指向文件_的全路径和对应的i节点号）。</p><p>（3）利用_link file_数据块中的数据查找到这个文件所对应的i节点号。</p><p>（4）通过i节点中的指针查找到_pointing file_对应的数据块。</p><p>（5）对_pointing file_的数据块中的数据进行操作。</p><ol start="2"><li><strong>硬连接：</strong>把文件名对应到inode</li></ol><p>一个硬连接（Hard Link）是一个文件名与一个i节点之间的对应关系。</p><p>添加一个硬连接是在所对应的文件上添加一个路径名。</p><p>每一个文件都至少使用一个硬连接，</p><p>在一个目录中的每一个记录都构成了一个硬连接。</p><p>可以将每一个文件名都看成为对应于一个i节点的硬连接。  </p><p>为文件添加额外的hard link可以避免一些重要的信息被误删，因为当存储信息的文件被删除后，还可以通过硬连接访问对应的i节点并找到存储信息的数据块。  </p><p>若将名为foo和bar的两个文件对应到一个i节点上：</p><p>foo、bar使用相同的i节点记录。</p><pre><code>将文件foo误删，还可以通过文件bar把信息找回来。</code></pre><p>º。创建hard link</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln 文件名 [连接名]</span><br><span class="line">    [⚠️]只能对文件建立硬连接，而不能对一个目录建立硬连接。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.1.0-文件系统与inode</title>
      <link href="/2016/12/27/Linux/linux-3-1-0-FileSystem-inode/"/>
      <url>/2016/12/27/Linux/linux-3-1-0-FileSystem-inode/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件系统与inode"><a href="#Linux文件系统与inode" class="headerlink" title="Linux文件系统与inode"></a>Linux文件系统与inode</h1><h2 id="硬盘分区和文件系统"><a href="#硬盘分区和文件系统" class="headerlink" title="硬盘分区和文件系统"></a>硬盘分区和文件系统</h2><p>一个新的硬盘，不能直接使用。首先必须把这个硬盘划分成数个（也可能是一个）<span style="background-color: rgb(255, 250, 165);">分区</span>，之后再把每一个分区<span style="background-color: rgb(255, 250, 165);">格式化</span>为文件系统，然后Linux系统才能在格式化后的硬盘分区上存储数据和进行相应的文件管理及维护。</p><p>Linux或UNIX系统上的磁盘分区就相当于Windows系统上的逻辑盘。</p><p>把一个分区格式化为文件系统就是将这个分区划分成许多大小相等的小单元，</p><p>并将这些小单元顺序地编号。</p><p>这些小单元被称为块（block），Linux默认的block大小为4KB。</p><p>Block是存储数据的最小单位，</p><p>每个block最多只能存储一个文件，</p><p>如果一个文件的大小超过4KB，那么就会占用多个blocks。</p><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><h3 id="inode-概念"><a href="#inode-概念" class="headerlink" title="inode 概念"></a>inode 概念</h3><p>i节点就是一个与某个特定的对象（如文件或目录）相关的信息列表。</p><p>i节点实际上是一个数据结构，它存放了有关一个普通文件、目录或其他文件系统对象的基本信息。</p><p>当一个磁盘被格式化成文件系统（如ext2或ext3）时，系统将自动生成一个i节点（inode）表；</p><p>在该表中包含了所有文件的元数据（metadata，描述数据的数据），每一个文件和目录都会对应于一个唯一的i节点，而这个i节点是使用一个i节点号（inode number简写成inode-no）来标识的；</p><p>inodes的数量决定了在这个文件系统中最多可以存储多少个文件，在一个分区（partition）中有多少个i节点就只能够存储多少个文件和目录。</p><p>在多数类型的文件系统中，i节点的数目是固定的，并且是在创建文件系统时生成的。</p><p>在一个典型的UNIX或Linux文件系统中，i节点所占用的空间大约是整个文件系统大小的1%。</p><hr><h3 id="inode-解读"><a href="#inode-解读" class="headerlink" title="inode 解读"></a>inode 解读</h3><p>i节点中所有的属性都是用来描述文件的，而不是文件中的内容。</p><p>i节点类似图书馆中的图书目录，在每一本书的图书目录中印有该书的内容简介、作者信息、出版日期、页数等<strong>摘要信息</strong>。</p><p>通常每个i节点由两部分组成，第1部分是有关文件的基本信息，第2部分是指向存储文件信息的数据块的指针：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g60fl18enfj30go0730tl.jpg" alt="IMG_1066"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">（1）inode-no ：i节点号。</span><br><span class="line">在一个文件系统中，每一个i节点都有一个唯一的编号。</span><br><span class="line">（2）File type ：文件的类型。</span><br><span class="line">&apos;-&apos;为  普通文件，</span><br><span class="line">&apos;d&apos;为 目录。</span><br><span class="line">（3）permission ：权限。</span><br><span class="line">在i节点中使用数字表示法来表示文件的权限。</span><br><span class="line">（4）Link count ：硬连接（hard link）数。</span><br><span class="line">（5）UID ：文件所有者的UID。</span><br><span class="line">（6）GID ：owner所属群组的GID。</span><br><span class="line">（7）size ：文件的大小。</span><br><span class="line">（8）Time stamp：时间戳。</span><br><span class="line">时间戳包含了3个时间：</span><br><span class="line">①Access time（A time） ：最后一次存取的时间。</span><br><span class="line">②Modify time（M time） ：最后一次编辑的时间。</span><br><span class="line">③Change time（C time）：该文件inode中任一元数据发生变化的时间。</span><br><span class="line">如果M time被更新时，通常A time和C time也会跟着一起被更新：</span><br><span class="line">在更新一个文件之前必须先打开这个文件，所以要先更新A time；</span><br><span class="line">编辑完之后一般文件的大小要发生变化，所以C time也会被更新。</span><br><span class="line">（9）Other information</span><br><span class="line">（10）pointer：指向保存文件的blocks的指针。</span><br></pre></td></tr></table></figure><h3 id="查看文件的-inode-number："><a href="#查看文件的-inode-number：" class="headerlink" title="查看文件的 inode number："></a>查看文件的 inode number：</h3><p>可以使用带有-i选项的ls命令，在每一行记录的开始显示这个文件的i节点号码。</p><h3 id="普通文件-与-目录"><a href="#普通文件-与-目录" class="headerlink" title="普通文件 与 目录"></a><em>普通文件</em> 与 <em>目录</em></h3><p>1.普通文件（Regular File）：只存放数据，</p><p>可以存放多种不同类型的数据。</p><p>2.目录：“特殊”的文件，目录中存储的是文件名和与文件名相关的i节点号码的信息。目录中只能存放一类数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct file_list&#123;</span><br><span class="line">    char name[MAX];</span><br><span class="line">    unsign inode;</span><br><span class="line">    struct file_list next;</span><br><span class="line">&#125; * pBarFiles;</span><br><span class="line">char * make_the_list(struct file_list *);</span><br><span class="line">fooDirectoty.content = make_the_list(pBarFiles);</span><br></pre></td></tr></table></figure><h3 id="cp、rm、mv-的-operate-inode"><a href="#cp、rm、mv-的-operate-inode" class="headerlink" title="cp、rm、mv 的 operate(inode)"></a>cp、rm、mv 的 operate(inode)</h3><ol><li><code>cp</code>：</li></ol><p>（1）找到一个空闲的i节点记录（inode number），把新文件的meta data写入到这个空闲的i节点中并将这个新记录放入inode表中。</p><p>（2）产生一条目录记录，把新增的文件名对应到这个空的inode号码。</p><p>（3）将文件的内容（数据）复制到新增的文件中去。</p><ol start="2"><li><code>rm</code>：</li></ol><p>（1）首先将这个文件的连接数（hard link）减1；</p><p>（如原文件的link count为3，运行了rm后，它的link count将为2）</p><p>之后这个文件的link count如果小于1，</p><p>就释放这个i节点以便重用。</p><p>（2）释放存储这个文件内容的数据块；</p><pre><code>（即将这些数据块标记为可以使用）</code></pre><p>（3）删除记录这个文件名和i节点号的目录记录。</p><ol start="3"><li><code>mv</code>：</li></ol><p>若 <em>原位置</em> 与 <em>目标位置</em>  位于 <strong>同一文件系统</strong>：  </p><pre><code>（1）首先产生一个新的目录记录，把新的文件名对应到源文件的i节点。  （2）删除带有旧文件名的原有的目录记录。/* 这是&lt;u&gt;逻辑移动&lt;/u&gt;：除了更新时间戳外，移动文件行为对原本在inode表中的数据不会有任何影响，也**不会将数据移动**到其他的文件中去，即**没有发生真正的数据移动**。\*/</code></pre><p>若 <em>源位置</em> 与 <em>目的位置</em> 是在 <strong>不同文件系统</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp(source, destination)；</span><br><span class="line">rm(source)；</span><br></pre></td></tr></table></figure><p>必要情况下：为确保数据确实发生移动，应使用cp，rm而非mv</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>关于文件的几个术语：</p><p>  （1）文件名是访问和维护文件时最常使用的。</p><p>  （2）i节点（inodes）是系统用来记录有关文件信息的对象。</p><p>  （3）数据块是用来存储数据的磁盘空间的单位。</p></li><li><p>其中关联：</p><p>  每个文件必须具有一个名字并且与一个i节点相关。</p><p>  通常系统通过文件名就可以确定i节点，</p><p>  之后通过i节点中的指针就可以定位存储数据的数据块</p></li></ul><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g60oehim96j30go00v0sr.jpg" alt="IMG_1067"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.0.1-文件及其操作</title>
      <link href="/2016/12/26/Linux/linux-3-0-1-Files/"/>
      <url>/2016/12/26/Linux/linux-3-0-1-Files/</url>
      
        <content type="html"><![CDATA[<h1 id="文件及其操作"><a href="#文件及其操作" class="headerlink" title="文件及其操作"></a>文件及其操作</h1><h2 id="Linux文件类型："><a href="#Linux文件类型：" class="headerlink" title="Linux文件类型："></a>Linux文件类型：</h2><table><thead><tr><th>表示</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>-</td><td>regular file</td><td>普通文件，或称正规文件</td></tr><tr><td>d</td><td>directory</td><td>目录</td></tr><tr><td>l</td><td>symbolic link🏎</td><td>符号（软）连接</td></tr><tr><td>b</td><td>block</td><td>块特殊文件：一般是指块设备，如硬盘。</td></tr><tr><td>c</td><td>character</td><td>字符特殊文件：一般是指字符设备，如键盘。</td></tr><tr><td>p</td><td>pipe</td><td>命名的管道文件：一般用于在进程之间传输数据。</td></tr><tr><td>s</td><td>socket🐶</td><td>套接字：通信（过程中）的一个终点。</td></tr></tbody></table><p>🏎. 详见本系列文章的“<u>连接(link)</u>”</p><p>🐶.  socket 的比喻性解释：</p><p><strong>socket与电话十分相似：</strong></p><p><em>当与某人通话时就要建立两个通信的终点：</em></p><p><em>（1）自己的电话</em></p><p><em>（2）对方的电话</em></p><p><em>只要双方进行通话，就必须有两个通话所必需的终点（电话）和一条在它们之间的通信线路存在。</em></p><pre><code>socket就相当于一条通信线路的终点（电话），而在这些终点（sockets）之间存在着数据通信网络。</code></pre><p><em>当打电话给他人时，需要拨打对方的电话号码。</em></p><pre><code>sockets使用网络地址取代了电话号码。通过访问远程（计算机）的socket地址，本机程序就可以用的本机socket与远程的终点（socket）之间建立起一条通信线路。</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li>file：确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ file 文件名</span><br></pre></td></tr></table></figure><ul><li>touch：刷新、新建文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch file(s)</span><br><span class="line">        若file存在，更新时间戳</span><br><span class="line">        若file不存在，新建空文件</span><br></pre></td></tr></table></figure><ul><li>cp：复制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cp [-option(s)]  source(s)  target</span><br><span class="line">    把source复制到target：</span><br><span class="line">        -i：交互式：防止覆盖，覆盖前提示</span><br><span class="line">        -f：强制式：有同名，强制覆盖，不提示</span><br><span class="line">        -r：递归式：复制目录时包括子目录</span><br><span class="line">        -p：维持式：保留属性（如时间戳）</span><br><span class="line">        source是目录名或文件名</span><br><span class="line">        target是目录名或 新文件名(复制并重命名)</span><br></pre></td></tr></table></figure><ul><li>mv：移动及修改文件、目录名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv file(s) target</span><br><span class="line">    把source移动到target：</span><br><span class="line">        source是目录名或文件名</span><br><span class="line">        target是目录名或 新文件名(移动并重命名)</span><br></pre></td></tr></table></figure><pre><code>重命名可用“**mv  path/old\_name  path/new\_nam**e”实现</code></pre><ul><li>rm：删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm  [option(s)]  file(s)|directory(s)</span><br><span class="line">    删除文件或 目录(加-r)：</span><br><span class="line">        -i：交互式：删前提示</span><br><span class="line">        -r：递归式：包括子目录、文件</span><br><span class="line">        -f：强制性：不询问，直接删</span><br></pre></td></tr></table></figure><ul><li>find：搜索文件和目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ find Pathname Expressions Actions</span><br><span class="line">    •Pathname：遍历起始路径</span><br><span class="line">    •Expressions：条件表达式：</span><br><span class="line">        -name“指定文件名”</span><br><span class="line">        -size[+|-]n</span><br><span class="line">                文件大小大于小于或等于(n*512B)</span><br><span class="line">        -atime[+|-]n</span><br><span class="line">                访问天数</span><br><span class="line">        -mtime[+|-]n：更改天数</span><br><span class="line">        -user LoginID：属于某用户的所有文件</span><br><span class="line">        -type：某一类型的文件：</span><br><span class="line">                f：文件</span><br><span class="line">                d：目录</span><br><span class="line">                e t c</span><br><span class="line">        -perm：查找具有某些特定访问许可位的文件</span><br><span class="line">    •Actions：对找出的文件进行的操作：</span><br><span class="line">        -exec命令&#123;&#125; \;</span><br><span class="line">                在每一个所定位的文件上运行指定的命令。</span><br><span class="line">                “&#123;&#125;“  表明文件名将传给前面的命令。</span><br><span class="line">                “ \;” 表示命令的结束。</span><br><span class="line">                （在大括号与反斜线之间必须有一个空格。）</span><br><span class="line">        -ok命令&#123;&#125; \;</span><br><span class="line">                -exec命令的交互方式</span><br><span class="line">                （在find命令对每个定位的文件执行命令之前需要确认）</span><br><span class="line">        -print</span><br><span class="line">                指示find命令将当前的路径名打印在终端屏幕上</span><br><span class="line">                （默认方式）</span><br><span class="line">        -ls</span><br><span class="line">                显示当前路径名和相关的统计信息</span><br><span class="line">                如i节点（inode）数、以K字节为单位的大小（尺寸）、保护模式、硬连接和用户</span><br></pre></td></tr></table></figure><pre><code>可用`find /etc -name passwd  2&gt;finderrs.txt`重定向，把权限不足的错误不在屏幕显示。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-3.0.0-目录及其操作</title>
      <link href="/2016/12/25/Linux/linux-3-0-0-Directory/"/>
      <url>/2016/12/25/Linux/linux-3-0-0-Directory/</url>
      
        <content type="html"><![CDATA[<h1 id="目录及其操作"><a href="#目录及其操作" class="headerlink" title="目录及其操作"></a>目录及其操作</h1><h3 id="几个特殊目录"><a href="#几个特殊目录" class="headerlink" title="几个特殊目录"></a>几个特殊目录</h3><table><thead><tr><th>目录</th><th>作用</th></tr></thead><tbody><tr><td>/</td><td>根目录</td></tr><tr><td>~（==$HOME）</td><td>家目录🚩</td></tr><tr><td>.</td><td>当前目录</td></tr><tr><td>..</td><td>上一层目录</td></tr></tbody></table><p>以’ . ‘开头的文件或目录表示隐藏；</p><p>🚩. 普通用户的家目录为 <code>/home</code> 的子目录，root的是 <code>/root</code></p><pre><code>“`～`”代表当前用户的家目录，“`～username`”代表某用户的家目录。</code></pre><p>登录系统或重启 shell后默认的 <code>pwd</code> 是 <code>$(whoami)</code>的 <code>$HOME</code></p><h3 id="与程序相关的几个目录："><a href="#与程序相关的几个目录：" class="headerlink" title="与程序相关的几个目录："></a>与程序相关的几个目录：</h3><table><thead><tr><th>目录</th><th>功能</th></tr></thead><tbody><tr><td>/bin</td><td>存放可执行文件</td></tr><tr><td>/sbin</td><td>存放系统可执行文件</td></tr><tr><td>/usr(Unix System Resources)</td><td>存放系统的应用程序和与命令相关的系统数据（类似于 Windows 的C:\Program File）</td></tr></tbody></table><h3 id="目录操作："><a href="#目录操作：" class="headerlink" title="目录操作："></a><strong>目录操作：</strong></h3><ul><li>pwd</li></ul><p><code>$ pwd</code></p><p> 打印工作（当前）目录的绝对路径</p><ul><li>cd</li></ul><p><code>$ cd path</code></p><p> 切换工作目录</p><pre><code>“`cd ~`” == “cd”无参：切换到 `$HOME`“`cd -`”：切换到上一工作目录</code></pre><ul><li>ls</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ls [keyword]</span><br><span class="line"> 无keyword：列出当前目录下内容</span><br><span class="line">    有keyword：列出目录中名含keyword的内容</span><br><span class="line">    </span><br><span class="line">$ ls dirA dirB</span><br><span class="line">    同时显示dirA与dirB中的内容</span><br><span class="line">    </span><br><span class="line">$ ls -F</span><br><span class="line">    显示 *文件类型*🚏</span><br><span class="line"></span><br><span class="line">$ ls -a</span><br><span class="line">     == “ls --all”</span><br><span class="line">    显示正常、隐藏文件</span><br><span class="line"></span><br><span class="line">$ ls -l</span><br><span class="line">    列出文件详细信息（其中大小为字节）</span><br><span class="line">    再加上-h：大小以惯例表示</span><br><span class="line"></span><br><span class="line">$ ls -d</span><br><span class="line">    只列出当前目录的信息，不包含子目录下的信息</span><br></pre></td></tr></table></figure><p>🚏. 文件类型：详见本系列文章的“文件及其操作”</p><ul><li>mkdir</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir 目录名</span><br><span class="line">    创建目录</span><br><span class="line"></span><br><span class="line">$ mkdir -p 命令名</span><br><span class="line">    创建目录（补足不存在的路径）</span><br></pre></td></tr></table></figure><ul><li>rmdir：删除目录</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.3-文件的安全控制</title>
      <link href="/2016/12/24/Linux/linux-2-3-fileSafe/"/>
      <url>/2016/12/24/Linux/linux-2-3-fileSafe/</url>
      
        <content type="html"><![CDATA[<h1 id="文件的安全控制"><a href="#文件的安全控制" class="headerlink" title="文件的安全控制"></a>文件的安全控制</h1><ul><li><p>Linux系统的安全模型</p></li><li><p>用户<strong>登录</strong>系统时必须<strong>提供用户名和密码</strong>。</p></li></ul><p>/*  用户是由root用户创建的，最初的密码也是root用户设定的 */</p><ul><li><p>使用<strong>用户</strong>和<strong>群组</strong>来控制使用者<strong>访问</strong>文件和其他资源的<strong>权限</strong>。</p></li><li><p>系统上的每一个<strong>文件</strong>都一定<strong>属于</strong>一个<strong>用户</strong>（一般该用户就是文件的创建者）并<strong>与</strong>一个<strong>群组相关</strong>。</p></li><li><p>每一个<strong>进程</strong>都会<strong>与</strong>一个<strong>用户和群组</strong>相<strong>关联</strong>。可以通过在所有的文件和资源上设定权限来只允许该文件的<strong>所有者</strong>或者某个<strong>群组</strong>的成员访问它们。</p></li><li><p>Linux 上文件有三种类型的权限：</p></li><li><p>所有者  ：（u）：文件的<strong><u>所有者</u></strong>的权限</p></li><li><p>同组用户：（g）：与所有者<strong><u>同一群组</u></strong>的其他用户的权限</p></li><li><p>其他用户：（o）：非所有者也<strong><u>不同群</u></strong>的用户的权限</p></li></ul><p>/* root用户不受权限限制，可以访问Linux上的任何资源 */</p><ul><li><p>权限的表示：</p><table><thead><tr><th>字母表示</th><th>数字表示</th><th>含义</th><th>对文件的权限</th><th>对目录的权限</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>Read</td><td>可阅读文件</td><td>使用ls列出目录内容</td></tr><tr><td>w</td><td>2</td><td>Write</td><td>可编辑文件</td><td>编辑目录(在其中创建、删除等)</td></tr><tr><td>x</td><td>1</td><td>eXecute</td><td>可执行程序(可执行文件)</td><td>使用cd进入目录，用ls -l查看目录详情</td></tr><tr><td>- （连字符）</td><td>0</td><td>no</td><td>没用相应的权限(同位的r|w|x)</td><td>没用相应的权限(同位的r|w|x)</td></tr></tbody></table></li><li><p>查看文件的权限</p></li></ul><p>用 *<em>ls -l *</em>命令：显示结果中的第1列（10个字符）表示文件的mode：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g60eo9tu5zj306n02j74b.jpg" alt="IMG_1065"></p><p align="left">其中第1个字符表示文件的类型：</p>- 如果是d就表示是目录<ul><li>如果是-就表示是文件。</li></ul><p>紧接其后的9个字符是这个文件或命令的权限：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g60ep4llfaj30ax02fglj.jpg" alt="IMG_1062"></p><ul><li>Linux 的安全检测流程</li></ul><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g60epak066j30go072aak.jpg" alt="IMG_1060"></p><ul><li>设定文件或目录上的权限要用chmod命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] mode 文件或目录名</span><br><span class="line">        -R：递归的，设置同时应用于目录中的子目录和所有文件，只有root可用。</span><br><span class="line">        mode: 详见👇</span><br></pre></td></tr></table></figure><p><span style="color: rgb(38, 180, 80);"><em>*.</em></span><strong><em>mode</em></strong>：</p><ol><li>用<strong>表达式</strong>表示：</li></ol><p><em>用“{who}  {operator}  {permission}”表示mode：</em></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g60eps4gcej30go03nmxf.jpg" alt="IMG_1061"></p><p>权限状态可以分成3个部分：</p><ul><li><p>第1部分，表示要设定<strong>谁</strong>的状态：</p></li><li><p>u：<span style="background-color: rgb(255, 250, 165);">所有者</span>的权限。</p></li><li><p>g：<span style="background-color: rgb(255, 250, 165);">群组</span>的权限。</p></li><li><p>o：既不是owner也不与owner在同一个group的<span style="background-color: rgb(255, 250, 165);">其他用户</span>的权限。</p></li><li><p>a：所以，以上3组，也就是<span style="background-color: rgb(255, 250, 165);"><u>所有用户</u></span>的权限。</p></li><li><p>第2部分，<strong>运算符</strong>（操作符）</p></li><li><p>+：<span style="background-color: rgb(255, 250, 165);">加入</span>权限。</p></li><li><ul><li>：<span style="background-color: rgb(255, 250, 165);">去掉</span>权限。</li></ul></li><li><p>=：<span style="background-color: rgb(255, 250, 165);">设定</span>权限。</p></li><li><p>第3部分，<strong>权限</strong>（permission）</p></li><li><p>r  ：read权限。</p></li><li><p>w：write权限。</p></li><li><p>x ：execute权限。</p></li></ul><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod ug+x tastingFile</span><br><span class="line">        在tastingFile文件上添加上所有者和同组用户的可执行权限</span><br></pre></td></tr></table></figure><ol start="2"><li>用<strong>数字</strong>表示：</li></ol><p><em>用  一组三位数  表示mode：</em></p><p>（1）第1个数字  代表  所有者      (own user)    的权限   （u）</p><p>（2）第2个数字  代表  群组       （group）       的权限   （g）</p><p>（3）第3个数字  代表  其他用户（other）        的权限   （o）</p><p>这组3位数中的每一位数字都是由以下表示资源权限状态的数字（即4、2、1和0）相加而获得的总和：</p><pre><code>4：100(2)：表示具有    read       权限。2：010(2)：表示具有    write      权限。1：001(2)：表示具有  execute   权限。0：000(2)：表示  没有相应的权限。</code></pre><p>即：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g60eq5o2mej30go05i3z4.jpg" alt="IMG_1064"></p><p>e.g.</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g60eqx53n4j30e204jwep.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chmod -R 754 /home/foo/bar</span><br><span class="line"></span><br><span class="line">        对owner(foo)开放家目录的bar子目录和其中所有文件的一切权限，但是对同组用户开放读和执行权限而对其他用户只开放读权限</span><br></pre></td></tr></table></figure><ul><li><strong>特殊权限</strong>（第4组权限）</li></ul><p>第4组权限包括suid、sgid和sticky 3种权限。</p><p>其中，</p><ul><li><p>suid  ：100：4：借用u的可执行权限位，并以 <strong>s</strong> 来表示；  </p></li><li><p>sgid  ：  10：2：借用g的可执行权限位，并以 <strong>s</strong> 来表示；</p></li><li><p>sticky ：    1：1：借用o的可执行权限位，并以 <strong>t</strong> 来表示；</p></li></ul><p>当在一个文件上加入suid|sgid|sticky特殊权限时：</p><p>如果原来的文件的u|g|o具有x权限：</p><p>就使用小写的s|s|t来代替x；</p><p>如果原来没有x：</p><p>就用大写的S|S|T来代替；</p><p><u>设置</u>特殊权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 字符：</span><br><span class="line">$ chmod [u|g|o][+,-,=][s|s|t] file</span><br><span class="line"># 数字：（第四组表示特殊权限）</span><br><span class="line">$ chmod [0-7][0-7][0-7][0-7] file</span><br></pre></td></tr></table></figure><p>特殊权限<u>作用</u>：</p><p>将suid和sgid设定在<em>可执行文件</em>上：</p><ul><li><p>运行有suid特殊权限的可执行文件时：是以可执行文件的<strong>所有者权限来运行</strong>这一可执行文件的，而不是以执行者的权限来运行该命令。</p></li><li><p>sgid特殊权限与suid类似，是以命令的群组的权限来运行这一命令的。</p></li></ul><p>将sgid和sticky设定在<em>目录</em>上：  </p><ul><li><p>一个目录上设置了sticky权限，就只有文件的所有者和root用户才可以删除该目录中的文件，而Linux系统不会理会group或other的写权限。</p></li><li><p>一个目录上设置了sgid权限，只要是同一群组的成员，都可以在这个目录中创建文件。</p></li><li><p>通常会对目录同时设置sticky和sgid这两个特殊权限以方便项目的管理（将同一个项目的文件都放到这一个目录中以方便同一项目的成员之间共享信息）。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.2-群组</title>
      <link href="/2016/12/23/Linux/linux-2-2-Group/"/>
      <url>/2016/12/23/Linux/linux-2-2-Group/</url>
      
        <content type="html"><![CDATA[<h1 id="群组（Group）"><a href="#群组（Group）" class="headerlink" title="群组（Group）"></a>群组（Group）</h1><ul><li><p>Linux群组的<strong>特性</strong>：</p></li><li><p>Linux系统中，每一个<strong>用户</strong>都一定<strong>隶属于</strong>至少一个<strong>群组</strong>，而每一个群组都有一个group标识符（号码），即gid。</p></li><li><p>所有的群组和对应的gids都存放在_<u>/etc/group</u>_文件中。</p></li><li><p>Linux系统在<strong>创建用户时</strong>为每一个用户<strong>创建</strong>一个<strong>同名的群组</strong>并且把这个用户加入到该群组中，也就是说每个用户至少会加入一个与他同名的群组中，并且也可以加入到其他的群组中。加入到其他群组的目的是为了获取适当的权限来访问（存取）特定的资源。</p></li><li><p>如果有一个文件属于某个群组，那么这个群组中所有的用户都可以存取这个文件。</p></li><li><p><span style="color: #fd0404;"><span style="color: rgb(253, 4, 4);"><strong>group</strong></span></span>文件</p></li></ul><p><strong><em>/etc/group</em></strong> 保存着群组信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/group的内容：</span><br><span class="line"></span><br><span class="line"> e.g.| foobar **:   **x   **: **503 **: **foo**,**bar</span><br><span class="line"></span><br><span class="line">means| 群组名  **: **密码否 **: **gid **: **群组成员</span><br></pre></td></tr></table></figure><pre><code># 第二字段为x表示这个群组在登录Linux时必须使用密码。</code></pre><ul><li><span style="color: rgb(253, 4, 4);"><strong>gshadow</strong></span>文件</li></ul><p><strong>_/etc/gshadow _</strong>保存着群组信息。</p><p>[⚠️]普通用户无权访问_<u>/etc/gshadow</u>_</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># more /etc/gshadow</span><br><span class="line"></span><br><span class="line">root:::root            # 在gshadow中，每个群组占一行记录</span><br><span class="line"></span><br><span class="line">bin:::root,bin,daemon ......</span><br><span class="line"></span><br><span class="line">foo:!::</span><br><span class="line"></span><br><span class="line">bar:!::</span><br><span class="line"></span><br><span class="line">群组名:加密后的密码::</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.1-用户</title>
      <link href="/2016/12/22/Linux/linux-2-1-User/"/>
      <url>/2016/12/22/Linux/linux-2-1-User/</url>
      
        <content type="html"><![CDATA[<h1 id="用户（User）"><a href="#用户（User）" class="headerlink" title="用户（User）"></a>用户（User）</h1><ul><li><p>用户（Users）</p></li><li><p>系统中的每一个<strong>用户</strong>都有一个唯一的<strong>用户标识符</strong>（号码），即<strong>uid</strong>（user identifier）</p></li></ul><p>（<em>uid 0</em> 为 <code>root</code> 用户的标识符。）</p><ul><li><p>所有的用户名和_用户标识符_都被存放在 <code>/etc/passwd</code> 文件中。</p></li><li><p>在 <em>passwd</em> 文件中还存放了每个用户的家目录，以及该用户登录后第一个执行的程序</p></li></ul><p>（通常是 shell，在 Linux 系统中默认是 bash。）</p><ul><li><p>如果没有相应的权限就不能<strong>读、写或执行</strong>其他用户的文件。</p></li><li><p>passwd 文件：用户信息数据库</p></li></ul><p>_<u>/etc/passwd</u>_ 储存用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd 的内容：</span><br><span class="line">e.g|  exp :  x  :     500    :       500     :Example_User:/home/exp :   /bin/bash</span><br><span class="line">说明| 用户名:密码否:uid（用户ID）:gid（所属群组ID）:   注释信息  :   家目录  :启动后第一个执行程序</span><br></pre></td></tr></table></figure><p>关于第二个字段：如果是<strong>x</strong>，表示这个用户登录Linux系统时必须使用密码，如果为<strong>空</strong>则该用户在登录系统时无须提供密码。</p><ul><li>shadow文件：用户密码数据库</li></ul><p>[⚠️]普通用户无权访问_<u>/etc/shadow</u>_</p><p>_<u>/etc/shadow</u>_ 储存用户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow 的内容：</span><br><span class="line">e.g|  exp :$1$wg...w4:14561:0:99999:7:::</span><br><span class="line">说明| 用户名:   密码   :      :      :  :::</span><br></pre></td></tr></table></figure><p>关于第二个字段：第2列是密码，这个密码是经过MD5加密算法加密过的密码。</p><ul><li><p>如果该列以$1$开头，则表示这个用户已经设定了密码。<br>  （包括手动把passwd中的x去掉，不用密码即可登录的“空秘密”）</p></li><li><p>如果该列以!!开头，则表示这个用户还没有设定密码。<br>  （新建后<strong>passwd -S</strong>显示_Password locked_的状态，这种用户不可登录）</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-2.0-用户管理</title>
      <link href="/2016/12/21/Linux/linux-2-0-UsersManage/"/>
      <url>/2016/12/21/Linux/linux-2-0-UsersManage/</url>
      
        <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><ul><li><code>su</code>：切换用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su [-]用户名</span><br><span class="line">    -   ：有则重启shell，重装$PATH（环境变量），pwd切换至用户名的$HOME（家目录）</span><br><span class="line">         无则不变 环境变量（检索命令的目录），pwd不变</span><br></pre></td></tr></table></figure><p>用户名 ：缺省为 root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@Example ~]$ su - root</span><br><span class="line">密码：</span><br><span class="line">[root@Example~]# whoami</span><br><span class="line">root</span><br><span class="line">[root@Example~]# exit</span><br><span class="line">logout</span><br><span class="line">[me@Example~]$ whoami</span><br><span class="line">me</span><br></pre></td></tr></table></figure><ul><li><code>passwd</code>：修改密码</li></ul><p>1⃣️ <em>普通用户：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd            修改当前用户密码</span><br></pre></td></tr></table></figure><p>多按几个回车可取消退出</p><p>对于root “too short”的密码重输也可以成功</p><p>2⃣️ <em>root：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># passwd username    修改某用户密码</span><br><span class="line"># passwd -**S**username    查看密码状态，【注意】S大写</span><br></pre></td></tr></table></figure><ul><li>新建，删除 用户</li></ul><ol><li>useradd：新建用户：<code># useradd new_user_name</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@Example ~]# **useradd** newone</span><br><span class="line">[root@Example ~]# passwd -S newone</span><br><span class="line">newone LK [2016-12-18 0 99999 7 -1](tel:2016-12-18 0 99999 7 -1)(密码已被锁定。)       # 说明密码未设定</span><br><span class="line">[root@Example ~]# passwd newone</span><br><span class="line">更改用户 newone 的密码 。</span><br><span class="line">新的 密码：             # 尝试键入一个弱口令</span><br><span class="line">无效的密码:  过于简单化/系统化        # 提示口令过于简单，但不阻止</span><br><span class="line">重新输入新的 密码:                   # 仍输入那个弱口令，可以成功，因为是root</span><br><span class="line">passwd： 所有的身份验证令牌已经成功更新。</span><br><span class="line"># 如果是普通用户，键入弱口令不可成。（不会叫“Retype“，而是“New“）</span><br><span class="line">[root@Example ~]# passwd -S newone</span><br><span class="line">newone PS [2016-12-18 0 99999 7 -1](tel:2016-12-18 0 99999 7 -1)(密码已设置，使用 SHA512 加密。</span><br></pre></td></tr></table></figure><ol start="2"><li>userdel：删除用户:  <code>userdel [-r] [-f] user_name</code></li></ol><p>​                <code>-r</code> ：同时删除用户的家目录</p><p>​                        无’-r’时，家目录不会被删除</p><p>​                <code>-f</code> ：强行删除，哪怕用户已登录，这个选项有些危险，会使系统进入不一致状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Example ~]# userdel -r newone</span><br><span class="line">userdel: user newone is currently used by process 3848    # 用户正登录，删除失败</span><br><span class="line">[root@Example ~]# userdel -fr newone                        #用 -f 强行删除</span><br><span class="line">userdel: user newone is currently used by process 3848    # 说明用户正登录，但命令本身已经成功</span><br><span class="line"># 这时虽然还被删user还是登入、活跃状态，但已经被删除，登出后不可再登入</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">[newone@Example ~]$ exit                                    #退出用户</span><br><span class="line">logout</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">[root@Example ~]# userdel -r newone</span><br><span class="line">userdel：用户“newone”不存在                            #再作尝试时，确定用户已被之前的 -f 删除</span><br><span class="line">[root@Example ~]# ls /home</span><br><span class="line">c  lost+found                                        #家目录被 -r 删除</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.linuxidc.com/Linux/2016-05/131755.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-05/131755.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-1.2-帮助信息</title>
      <link href="/2016/12/20/Linux/linux-1-2-getHelp/"/>
      <url>/2016/12/20/Linux/linux-1-2-getHelp/</url>
      
        <content type="html"><![CDATA[<h1 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis *命令名*</span><br></pre></td></tr></table></figure><p>​                说明<em>命令</em>是什么，了解命令的功能；</p><p>​                “whatis  <em>cmd</em>”命令 == “<strong>man -f</strong> <em>cmd</em>”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ type [-options] 命令名</span><br></pre></td></tr></table></figure><p>​    无选：显示命令类型</p><p>​    <code>-t</code>：显示文件的类型：</p><p>​        <code>file</code>：外部命令</p><p>​        <code>alias</code>：别名</p><p>​        <code>builtin</code>：shell内置命令</p><p>​    <code>-a</code>：列出所有包含指定命令名的命令，包括别名</p><p>​    <code>-p</code>：显示完整的文件名（外部命令）或内部命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which 命令名</span><br></pre></td></tr></table></figure><p>​    列出命令的类型相关的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ *命令名* --help</span><br></pre></td></tr></table></figure><p>​                显示<em>命令</em>的<strong>简要说明</strong>和<strong>选项列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man *命令名*</span><br></pre></td></tr></table></figure><p>​                浏览<em>命令</em>的 <strong>Man Page</strong> 1⃣️</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man -k **keyword**</span><br></pre></td></tr></table></figure><p>​                欲使用一个命令，又无法确定它的名字是用 -k选项+<em>关键字</em>搜寻它；</p><p>​                “man -k  <em>kw</em>”命令 == “<strong>apropos</strong> <em>kw</em>”命令；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ info *cmd*</span><br></pre></td></tr></table></figure><p>​                “info2⃣️”与“man”类似，但info更加简洁详尽(开发者认为的)；</p><p>1⃣️、2⃣️.  浏览 <strong>Man page</strong> <em>或</em>  <strong>Info Page</strong> ：</p><ul><li><ul><li><p>使用man \ info命令进入Man \ Info Page</p></li><li><p>键盘 &lt; , &gt; , ^, v , PgUp, PgDn, 空格：翻页</p></li><li><p>Home键：移到第一页</p></li><li><p>End键： 最后一页</p></li><li><p>在屏幕底部<code>:</code>处输入<code>?string</code>：向前搜索string</p></li><li><ul><li>按 n 键继续下一个搜索</li><li>按 N 键进行反向搜索</li></ul></li><li><p>按 q 键退出Page</p></li></ul></li></ul><p>在 <strong>Info Page</strong> 中还有：</p><ul><li><ul><li>按Tab：跳到下一个“<strong>***</strong>”（超链接）</li><li>{Tab}*3：Index</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-1.1-系统信息</title>
      <link href="/2016/12/19/Linux/linux-1-1-SystemInformation/"/>
      <url>/2016/12/19/Linux/linux-1-1-SystemInformation/</url>
      
        <content type="html"><![CDATA[<h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><ul><li><p><code>uname</code> 命令:  获取系统信息<br>(其中’u’代表UNIX)</p></li><li><p><code>$ uname</code>       显示当前操作系统</p><pre><code>`-n`    显示主机名`-i`    硬件平台名`-r`    系统发布版本信息`-s`    系统名`-m`    机器硬件名`-p`    显示CPU信息`-a`    以上全部</code></pre><p>用 <code>-n -r</code> == <code>-i -n</code> == <code>-ni</code> == <code>-in</code>；<br>(详见 <code>$ man uname</code>。)</p></li><li><p><code>$ date</code>       显示当前系统日期、时间</p></li><li><p><code>$ cal</code>         显示日历：</p><ul><li><p><code>$ cal</code>         无参显示本月日历</p></li><li><p><code>$ cal m y</code>    m y是月份 年份，显示y年m月的</p></li><li><p><code>$ cal y</code>      y 是年份，     显示y全年</p><p>(详见 <code>$ man cal</code>。)</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-1.0-用户信息</title>
      <link href="/2016/12/18/Linux/linux-1-0-UsersInfomation/"/>
      <url>/2016/12/18/Linux/linux-1-0-UsersInfomation/</url>
      
        <content type="html"><![CDATA[<h1 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h1><ul><li><code>$ whoami</code><br>输出当前用户名</li><li><code>$ users</code><br>列出当前登录的所有用户名</li><li><code>$ who am i</code><br>显示用户名，登录终端，当前时间，IP</li><li><code>$ who</code><br>比“who am i”多出 其他用户的信息</li><li><code>$ w</code><br>信息更多的“who”：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Me@Example ~]$ w</span><br><span class="line"> 10:59:09 up 4 min,  1 user,  load average:  0.46 , 0.35 ,  0.15</span><br><span class="line"> 当前时间 up 启动时长, 登录用户数, 平均提交任务数: 1min内, 10min内, 15min内</span><br><span class="line">USER     TTY      FROM              LOGIN@    IDLE       JCPU       PCPU     WHAT</span><br><span class="line">用户名    登录终端   登录地            登录时间   空闲时长    一共使用CPU时长    当前程序用CPU时长    当前任务CPU时长</span><br><span class="line">                                                        </span><br><span class="line">Me        pts/0    MyComputer       10:58     0.00s      0.06s      0.02s     w</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-0.2-系统开关</title>
      <link href="/2016/12/17/Linux/linux-0-2-StartHalt/"/>
      <url>/2016/12/17/Linux/linux-0-2-StartHalt/</url>
      
        <content type="html"><![CDATA[<h1 id="系统开关"><a href="#系统开关" class="headerlink" title="系统开关"></a>系统开关</h1><ul><li>关闭系统：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sync</span><br><span class="line"># init 0    或    shutdown -n    或    halt</span><br></pre></td></tr></table></figure><ul><li>重启系统：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sync</span><br><span class="line"># init 6    或    shutdown -rn</span><br></pre></td></tr></table></figure><ul><li>退出当前用户登录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exit</span><br></pre></td></tr></table></figure><p>Linux的 <code>exit</code> 类似于 Windows 的注销；</p><ul><li>查看当前使用的虚拟终端：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tty</span><br><span class="line">/dev/tty2        #二号虚拟终端</span><br></pre></td></tr></table></figure><ul><li>切换终端：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;Ctr + Alt + Fn&#125;</span><br><span class="line">#其中 n = &#123;1, 2, 3, ... ,7&#125;,代表 tty n</span><br></pre></td></tr></table></figure><p>切换至图形终端（也是一个tty）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Ctr + Alt + F7&#125;</span><br></pre></td></tr></table></figure><ul><li>清空屏幕：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clear</span><br></pre></td></tr></table></figure><ul><li>找到系统中所有shell：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells</span><br></pre></td></tr></table></figure><ul><li>切换shell：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sh# 切换至Bourn Shell</span><br><span class="line">$ ksh# 切换至Korn Shell</span><br></pre></td></tr></table></figure><p>可以在命令行中输入一个不存在的命令（如<code>OK</code>），以确定用户当前的shell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-0.1-系统安装</title>
      <link href="/2016/12/16/Linux/linux-0-1-Install/"/>
      <url>/2016/12/16/Linux/linux-0-1-Install/</url>
      
        <content type="html"><![CDATA[<h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><h3 id="挂载建议："><a href="#挂载建议：" class="headerlink" title="挂载建议："></a>挂载建议：</h3><p>Linux只要求两个基本分区 <code>／</code> 和 <code>swap</code>； </p><p>如果<code>／</code>足够的，可以在桌面放很多东西而不影响进入 Linux 的速度； </p><table><thead><tr><th>分区</th><th>大小</th><th>格式</th></tr></thead><tbody><tr><td>/boot1⃣️</td><td>128MB</td><td>ext3</td></tr><tr><td>swap</td><td>2⃣️</td><td></td></tr><tr><td>／</td><td>8GB</td><td>ext3</td></tr><tr><td>／home</td><td>余下全部</td><td>ext3</td></tr></tbody></table><p>若要安装很多软件最好分配个 <code>/usr</code>； </p><p>若要作服务器最好分配较大的 <code>/var</code>； </p><p>1⃣️.  <code>/boot</code>： </p><p>2018年后的新版本都可以不分； </p><p>可以分配10MB-100MB </p><p>如果硬盘不支持LBA模式，最好挂载/boot于第一个分区，以保稳妥。 </p><p>参考：<a href="https://wapbaike.baidu.com/item/boot分区/16830421?ms=1&rid=8645769021174590193" target="_blank" rel="noopener">https://wapbaike.baidu.com/item/boot分区/16830421?ms=1&amp;rid=8645769021174590193</a></p><p>2⃣️. <code>swap</code>： </p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g60bdmoskaj30d108xglx.jpg" alt="Image 20180817 230902"></p><table><thead><tr><th>物理内存</th><th>swap</th><th>swap(开启休眠)</th></tr></thead><tbody><tr><td>2GB</td><td>2倍RAM</td><td>3倍RAM</td></tr><tr><td>&gt;2GB-8GB</td><td>=RAM</td><td>2倍RAM</td></tr><tr><td>&gt;8GB-64GB</td><td>4GB+</td><td>1.5倍RAM</td></tr><tr><td>&gt;64GB</td><td>4GB+</td><td>不建议休眠</td></tr></tbody></table><p>参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007</a> </p><p>开始的几个服务配置：</p><ul><li>检查<em>telnet</em>服务是否启动： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig telnet --list</span><br></pre></td></tr></table></figure><ul><li>启动<em>telnet</em>服务： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chkonfig telnet on</span><br></pre></td></tr></table></figure><p>开启telnet后在win下可用”&gt; telnet $IP”连接Linux。 </p><ul><li>检验<em>FTP</em>服务当前状态： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service vsftpd status</span><br></pre></td></tr></table></figure><ul><li>开启<em>FTP</em>服务： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service vsftpd start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-0.0-Linux?</title>
      <link href="/2016/12/15/Linux/linux-0-0-Linux/"/>
      <url>/2016/12/15/Linux/linux-0-0-Linux/</url>
      
        <content type="html"><![CDATA[<p>我会发一系列 Linux 学习笔记（它们最多可以算是“操作手册”，我不认为它们可以代替一本正经的入门书），这些东西是很久以前写的了，可能在 排版、内容 上质量都不高，请见谅。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><blockquote><p>Linux (/ˈlɪnəks/ LIN-əks) is a family of open source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991 by Linus Torvalds. Linux is typically packaged in a Linux distribution.<br>【翻译】Linux 是一系列基于 Linux 内核(一个最早由 Linus Torvalds 在 1991 年 9 月 17 日发布的操作系统内核)的类 Unix 开源操作系统。Linux 通常打包在 Linux 发行版中。</p></blockquote><p>👆这是 <a href="https://en.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">维基百科</a> 对 Linux 的介绍。</p><p>Linux 是什么不重要，重要的是为什么用Linux。就像对用户来说软件的代码实现不重要，重要的是这个软件可以用来干什么。</p><h2 id="为什么用-Linux？"><a href="#为什么用-Linux？" class="headerlink" title="为什么用 Linux？"></a>为什么用 Linux？</h2><p>我们常说，用 Linux 是因为它安全，或者因为它自由、因为它的高度可定制、因为它免费、应为它的背后有专业的社区支持……</p><p>然而，所有的这些全是瞎扯！我们这样欺骗非 Linux 用户，只是因为他们不会懂得 Linux 的真谛。<br>久而久之，说的多了，有时候连我们自己都开始相信这些乱七八糟的“充分理由”了。</p><p>夜深人静时再扪心自问，我们用 Linux 的原因到底何在？</p><p>……</p><p>我们用 Linux —— —— 是因为它好玩呀！</p><p>对着各种设置一阵捣鼓、把系统无情地玩弄到崩坏，再夹着尾巴跑到恢复系统、笨拙地为她缝合伤口、虔诚为她祈祷痊愈、期待着下一次把她摆布成不一样的姿势，这难道不好玩吗？<br>在那数百种发行版中肆意尝试她们各不相同的命令行不好玩吗？</p><p>是的，我们觉得命令行超级有趣！</p><p>其实 Linux 爱好者们爱上 Linux，爱的只是 Linux 本身！</p><p>是，我们使用 Linux 完成老板布置的工作；<br>是，我们使用 Linux 保障安全、远离病毒；<br>是，我们使用 Linux 省下几个柴米油盐钱；<br>但，这些都只是我们使用 Linux 的副作用！ </p><p>真正重要的是 —— —— 这系统好玩啊！</p><p>Linux 让我们像探险家一样游荡在系统深处，四处搅合，随性发掘，在软件的背后寻觅可爱的诗篇！</p><p>（翻译自一篇出处难寻的文章）</p><h2 id="用-Linux-做什么？"><a href="#用-Linux-做什么？" class="headerlink" title="用 Linux 做什么？"></a>用 Linux 做什么？</h2><p>我们可以用 Linux 干什么？</p><p>毫无疑问——玩！</p><h2 id="Linux-UNIX，MacOS，Windows"><a href="#Linux-UNIX，MacOS，Windows" class="headerlink" title="Linux/UNIX，MacOS，Windows"></a>Linux/UNIX，MacOS，Windows</h2><p>Linux/UNIX，MacOS，Windows，这几乎就是我们平时接触到的所有操作系统了。</p><p>抛开刚才写的那么多 Linux 的好处不看，客观地比较一下它们：</p><ul><li><p>Linux/UNIX 以自由著称，但正如很多开源的东西，设计上会有一些缺陷，用户体验绝对不是最好的，但它几乎可以满足你在计算机编程、工作上的全部需求（只是操作起来可能需要时间、精力）。其实在 Linux/UNIX 的内部有很多很糟糕的部分，这是历史遗留问题了，在学会  Linux 的基础之前我们最好不去过多研究。</p></li><li><p>MacOS，这是我现在正在使用的操作系统，Apple一向以用户体验著称。MacOS绝对是我用过的体验最好的计算机操作系统，你不用了解太多的东西就可以专心地高效完成你的工作。但 MacOS 无论如何还是脱离不了 UNIX 的影响，UNIX 有的问题，MacOS 也会有，只是在表面上看不出来。在开发方面，按照 Apple 的文档，你虽然可以快速地开发出一个 App，但你很难去了解底层的东西，这给移植之类的工作带来了很大的麻烦，不过近年来也有好转。</p></li><li><p>Windows，我承认微软很厉害，Windows的设计也有很多很好的地方，但我始终无法接受 Windows 呈现给用户的那种东西，我想是我的程序设计功夫还不到家，所以不喜欢微软风格的代码——虽然客观地说我承认它们其实很好。在 Windows 10 中我已经看到了它朝我想要的方向有了十足的进步，但这还不够！我期望微软有一天可以让我用回 Windows，毕竟它是我对计算机的最初回忆。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2016/08/14/helloworld/"/>
      <url>/2016/08/14/helloworld/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
