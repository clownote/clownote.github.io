<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Leetcode 课程表 I、II、III 这篇文章介绍 Leetcode 的课程表 I、II、III 三道题目的解法。 [TOC] 本文由 CDFMLR 原创，收录于个人主页 https://clownote.github.io。  207. 课程表  题目 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想">
<meta name="keywords" content="School">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode 课程表 I、II、III">
<meta property="og:url" content="https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/index.html">
<meta property="og:site_name" content="clownote">
<meta property="og:description" content="Leetcode 课程表 I、II、III 这篇文章介绍 Leetcode 的课程表 I、II、III 三道题目的解法。 [TOC] 本文由 CDFMLR 原创，收录于个人主页 https://clownote.github.io。  207. 课程表  题目 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepo6jel4dj30qe05ymxv.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1geproy8i5cj30o805maar.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1geq2tnkgy4j30p605yjs3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqkex0ey2j30oa05oaar.jpg">
<meta property="og:updated_time" content="2020-05-13T03:08:08.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode 课程表 I、II、III">
<meta name="twitter:description" content="Leetcode 课程表 I、II、III 这篇文章介绍 Leetcode 的课程表 I、II、III 三道题目的解法。 [TOC] 本文由 CDFMLR 原创，收录于个人主页 https://clownote.github.io。  207. 课程表  题目 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepo6jel4dj30qe05ymxv.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/rabbit.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/rabbit_192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/rabbit_180.png">
          
        
    
    <!-- title -->
    <title>Leetcode 课程表 I、II、III</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
    <!--Google search varification (PRIVATE)-->
    <meta name="google-site-verification" content="MrqlpFAD8nDanw3Ypv7ZsIWHLnTdhRuLa4QhSVwxIvc">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/06/23/SwiftUI/SwiftUI_Essentials_1_Creating_and_Combining_Views/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/05/12/DeepLearningWithPython/Deep-Learning with-Python-ch2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&text=Leetcode 课程表 I、II、III"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&is_video=false&description=Leetcode 课程表 I、II、III"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Leetcode 课程表 I、II、III&body=Check out this article: https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&name=Leetcode 课程表 I、II、III&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-课程表-i-ii-iii"><span class="toc-number">1.</span> <span class="toc-text"> Leetcode 课程表 I、II、III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#207-课程表"><span class="toc-number">1.1.</span> <span class="toc-text"> 207. 课程表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs"><span class="toc-number">1.1.2.</span> <span class="toc-text"> DFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#210-课程表-ii"><span class="toc-number">1.2.</span> <span class="toc-text"> 210. 课程表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-2"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#630-课程表-iii"><span class="toc-number">1.3.</span> <span class="toc-text"> 630. 课程表 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心优先队列"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 贪心优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">1.3.2.1.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序-归并排序"><span class="toc-number">1.3.2.2.</span> <span class="toc-text"> 插入排序 + 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准库-sort-heap"><span class="toc-number">1.3.2.3.</span> <span class="toc-text"> 标准库 sort + heap</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Leetcode 课程表 I、II、III
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">clownote</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-05-13T03:01:55.605Z" itemprop="datePublished">2020-05-13</time>
        
        (Updated: <time datetime="2020-05-13T03:08:08.234Z" itemprop="dateModified">2020-05-13</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/School/">School</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="leetcode-课程表-i-ii-iii"><a class="markdownIt-Anchor" href="#leetcode-课程表-i-ii-iii"></a> Leetcode 课程表 I、II、III</h1>
<p>这篇文章介绍 Leetcode 的课程表 I、II、III 三道题目的解法。</p>
<p>[TOC]</p>
<p>本文由 CDFMLR 原创，收录于个人主页 <a href="https://clownote.github.io">https://clownote.github.io</a>。</p>
<h2 id="207-课程表"><a class="markdownIt-Anchor" href="#207-课程表"></a> <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是 邻接矩阵 。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
<li><code>1 &lt;= numCourses &lt;= 10^5</code></li>
</ol>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/course-schedule" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h3>
<p>这个东西要可以学就是要图里没有环。有环就“循环依赖”，没法学了。所以解法就是深度优先去搜索有没有环，有就不行，没有就行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    adj := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adj[p[<span class="number">1</span>]] = <span class="built_in">append</span>(adj[p[<span class="number">1</span>]], p[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> hasCycle(i, adj, <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(node <span class="keyword">int</span>, adj [][]<span class="keyword">int</span>, visited []<span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    visited[node] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> adj[node] &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[a] || hasCycle(a, adj, visited) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[node] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepo6jel4dj30qe05ymxv.jpg" alt="执行通过的截图，图片上显示执行用时44ms在所有 Go 提交中击败了14.12%的用户，内存消耗6.7MB在所有 Go 提交中击败了100%的用户"></p>
<h2 id="210-课程表-ii"><a class="markdownIt-Anchor" href="#210-课程表-ii"></a> <a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>
你可以假定输入的先决条件中没有重复的边。</p>
<p><strong>提示</strong>:</p>
<ol>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>
<li>拓扑排序也可以通过 BFS 完成。</li>
</ol>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/course-schedule-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-ii</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3>
<p>这个题就是做拓扑排序，但拓扑排序只能用于 DAG (有向无环图) ！所以我们直接把上面那个题目的 hasCycle 抄过来判断是否有环，有环就返回一个空序列就好了，没环就拿去拓扑排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    adj := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adj[p[<span class="number">1</span>]] = <span class="built_in">append</span>(adj[p[<span class="number">1</span>]], p[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited :=  <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> hasCycle(i, adj, <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)) &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfsForTopoSort(i, adj, visited, &amp;ret)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ret) &lt; numCourses &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(node <span class="keyword">int</span>, adj [][]<span class="keyword">int</span>, visited []<span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    visited[node] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> adj[node] &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[a] || hasCycle(a, adj, visited) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[node] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsForTopoSort</span><span class="params">(node <span class="keyword">int</span>, adj [][]<span class="keyword">int</span>, visited []<span class="keyword">bool</span>, ret *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !visited[node] &#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, a := <span class="keyword">range</span> adj[node] &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[a] &#123;</span><br><span class="line">                dfsForTopoSort(a, adj, visited, ret)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        *ret = <span class="built_in">append</span>(*ret, node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> left, right := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; left &lt; right; left, right = left+<span class="number">1</span>, right<span class="number">-1</span> &#123;</span><br><span class="line">        a[left], a[right] = a[right], a[left]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个很好理解，也可以通过，但判断环 + 拓扑排序跑了两遍嘛，最后还做了一个切片翻转，所以比较慢。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geproy8i5cj30o805maar.jpg" alt="Leetcode 执行结果截图，执行用时 40 ms, 在所有 Go 提交中击败了11.81%的用户; 内存消耗 6.8 MB, 在所有 Go 提交中击败了100.00%的用户"></p>
<h2 id="630-课程表-iii"><a class="markdownIt-Anchor" href="#630-课程表-iii"></a> <a href="https://leetcode-cn.com/problems/course-schedule-iii/" target="_blank" rel="noopener">630. 课程表 III</a></h2>
<h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3>
<p>这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。</p>
<p>给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">这里一共有 4 门课程, 但是你最多可以修 3 门:</span><br><span class="line">首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。</span><br><span class="line">第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。</span><br><span class="line">第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。</span><br><span class="line">第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。</span><br></pre></td></tr></table></figure>
<p>提示:</p>
<ol>
<li>整数 1 &lt;= d, t, n &lt;= 10,000 。</li>
<li>你不能同时修两门课程。</li>
</ol>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/course-schedule-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-iii</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="贪心优先队列"><a class="markdownIt-Anchor" href="#贪心优先队列"></a> 贪心优先队列</h3>
<p>哇，这个题的贪心策略还是很6⃣️的，思路写起来比较麻烦，<a href="https://leetcode-cn.com/problems/course-schedule-iii/solution/ke-cheng-biao-iii-by-leetcode/" target="_blank" rel="noopener">官方题解</a> 写的很好了，直接照着它那个，其实基本的代码很简单的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sort(&amp;courses)</span><br><span class="line"></span><br><span class="line">	queue := PriorityQueue&#123;&#125;</span><br><span class="line">	time := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line">		<span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">			queue.Push(c[<span class="number">0</span>])</span><br><span class="line">			time += c[<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !queue.IsEmpty() &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">			time += c[<span class="number">0</span>] - queue.Poll()</span><br><span class="line">			queue.Push(c[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> queue.Size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是，这里面需要 sort 和 PriorityQueue。Python、Java、甚至 C++ 写这个都还是比较方便的，直接用标准库里的实现。但 Golang，，，标准库的这两个东西有点诡异，用起来没那么方便。</p>
<p>所以，我们先试试自己实现<strong>排序</strong>和<strong>优先队列</strong>，练习一下，也当是追忆以前写 C 时那种啥都自己写的时光。</p>
<h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4>
<p>优先队列一般我们使用堆去实现，但这里为了方便，我们直接维护一个切片，每次插入元素的时候排个序也就“优先队列”了。</p>
<p>我们先写一个快速排序，让 courses 的排序和优先队列都基于这个快排。</p>
<p>由于 courses 是 <code>[][]int</code>，优先队列是 <code>[]int</code>，我们写一种通用的——对 <code>[]interface{}</code> 的快排，这个代码还是很传统的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	q := partition(pA, p, r, le)</span><br><span class="line">	quick_sort(pA, p, q<span class="number">-1</span>, le)</span><br><span class="line">	quick_sort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	A := (*pA)</span><br><span class="line"></span><br><span class="line">	q := p</span><br><span class="line">	<span class="keyword">for</span> u := p; u &lt; r; u++ &#123;</span><br><span class="line">		<span class="keyword">if</span> le(A[u], A[r]) &#123;</span><br><span class="line">			A[q], A[u] = A[u], A[q]</span><br><span class="line">			q++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[q], A[r] = A[r], A[q]</span><br><span class="line">	<span class="keyword">return</span> q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把它封装一层，分别提供<code>[][]int</code>、<code>[]int</code> 的排序接口，其实这两个代码基本是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_sint</span><span class="params">(pA *([]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line">	<span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">		interfaceSlice[i] = d</span><br><span class="line">	&#125;</span><br><span class="line">	quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">		(*pA)[i] = v.(<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_ssint</span><span class="params">(pA *([][]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line">	<span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">		interfaceSlice[i] = d</span><br><span class="line">	&#125;</span><br><span class="line">	quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">		(*pA)[i] = v.([]<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好了排序，再看优先队列，实现基本的入、出、顶、大小、空判断就好：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">push</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	q.data = <span class="built_in">append</span>(q.data, element)</span><br><span class="line">	quick_sort_sint(&amp;q.data, <span class="number">0</span>, <span class="built_in">len</span>(q.data)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b.(<span class="keyword">int</span>) &lt;= a.(<span class="keyword">int</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">poll</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	r := q.data[<span class="number">0</span>]</span><br><span class="line">	q.data = q.data[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合到一起，就有解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	quick_sort_ssint(&amp;courses, <span class="number">0</span>, <span class="built_in">len</span>(courses)<span class="number">-1</span>,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a.([]<span class="keyword">int</span>)[<span class="number">1</span>] &lt;= b.([]<span class="keyword">int</span>)[<span class="number">1</span>]</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	queue := PriorityQueue&#123;&#125;</span><br><span class="line">	time := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line">		<span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">			queue.push(c[<span class="number">0</span>])</span><br><span class="line">			time += c[<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !queue.isEmpty() &amp;&amp; queue.top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">			time += c[<span class="number">0</span>] - queue.poll()</span><br><span class="line">			queue.push(c[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> queue.size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 优先队列 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">push</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	q.data = <span class="built_in">append</span>(q.data, element)</span><br><span class="line">	quick_sort_sint(&amp;q.data, <span class="number">0</span>, <span class="built_in">len</span>(q.data)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b.(<span class="keyword">int</span>) &lt;= a.(<span class="keyword">int</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">poll</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	r := q.data[<span class="number">0</span>]</span><br><span class="line">	q.data = q.data[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 把对 []int 的快排转化为对 []interface&#123;&#125; 的快排  **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_sint</span><span class="params">(pA *([]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line">	<span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">		interfaceSlice[i] = d</span><br><span class="line">	&#125;</span><br><span class="line">	quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">		(*pA)[i] = v.(<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 把对 [][]int 的快排转化为对 []interface&#123;&#125; 的快排  **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort_ssint</span><span class="params">(pA *([][]<span class="keyword">int</span>)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(*pA))</span><br><span class="line">	<span class="keyword">for</span> i, d := <span class="keyword">range</span> *pA &#123;</span><br><span class="line">		interfaceSlice[i] = d</span><br><span class="line">	&#125;</span><br><span class="line">	quick_sort(&amp;interfaceSlice, p, r, le)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> interfaceSlice &#123;</span><br><span class="line">		(*pA)[i] = v.([]<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对 []interface&#123;&#125; 的快排  **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quick_sort</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	q := partition(pA, p, r, le)</span><br><span class="line">	quick_sort(pA, p, q<span class="number">-1</span>, le)</span><br><span class="line">	quick_sort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(pA *([]<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">p</span> <span class="title">int</span>, <span class="title">r</span> <span class="title">int</span>, <span class="title">le</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	A := (*pA)</span><br><span class="line"></span><br><span class="line">	q := p</span><br><span class="line">	<span class="keyword">for</span> u := p; u &lt; r; u++ &#123;</span><br><span class="line">		<span class="keyword">if</span> le(A[u], A[r]) &#123;</span><br><span class="line">			A[q], A[u] = A[u], A[q]</span><br><span class="line">			q++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[q], A[r] = A[r], A[q]</span><br><span class="line">	<span class="keyword">return</span> q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本算法是正确的，但提交运行会超时！</p>
<p><code>clown0te（防{盗[文()爬]虫}的追踪标签，读者不必在意）</code></p>
<h4 id="插入排序-归并排序"><a class="markdownIt-Anchor" href="#插入排序-归并排序"></a> 插入排序 + 归并排序</h4>
<p>我们的程序里大量的排序，这个也是最主要的时间消耗，而刚才简单粗暴的全用了快排，这肯定不是最好的，考虑在这方面优化一下：</p>
<ol>
<li><code>PriorityQueue.Push</code> 数据基本有序，对基本有序的数据用快排肯定慢（所以我们有时候用快排要先把数据打乱），我们把这里改成对基本有序的数据最快的——插入排序。</li>
<li><code>courses</code> 的排序，既然不需要重复使用快排我们就可以把之前的 <code>interface{}</code> 封装去掉，直接实现一个对 <code>[][]int</code> 的排序（我还把快排改成了归并排序，只是为了好玩）</li>
</ol>
<p>先写最简单的插入排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSortReverse</span><span class="params">(pA *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	A := *pA</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">		key := A[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; A[j] &lt; key &#123;</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		A[j+<span class="number">1</span>] = key</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，归并排序，这个代码也不是很难：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> INF = []<span class="keyword">int</span>&#123;<span class="number">99999999</span>, <span class="number">99999999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(pA *[][]<span class="keyword">int</span>, p, q, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// n1 := q - p + 1</span></span><br><span class="line">	<span class="comment">// n2 := r - q</span></span><br><span class="line">	<span class="comment">// b, c := make([][]int, n1+1), make([][]int, n2+1)</span></span><br><span class="line">	A := *pA</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[p: q+<span class="number">1</span>]...)</span><br><span class="line">	c := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[q+<span class="number">1</span>: r+<span class="number">1</span>]...)</span><br><span class="line"></span><br><span class="line">	b = <span class="built_in">append</span>(b, INF)</span><br><span class="line">	c = <span class="built_in">append</span>(c, INF)</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := p; k &lt;= r; k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> le(b[i], c[j]) &#123;</span><br><span class="line">			A[k] = b[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			A[k] = c[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(pA *[][]<span class="keyword">int</span>, p <span class="keyword">int</span>, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	q := (p + r) / <span class="number">2</span></span><br><span class="line">	mergeSort(pA, p, q, le)</span><br><span class="line">	mergeSort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">	merge(pA, p, q, r, le)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码写的时候要注意一点，b 和 c 这里，不能直接这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">append</span>(A[p: q+<span class="number">1</span>], INF)</span><br><span class="line">c := <span class="built_in">append</span>(A[q+<span class="number">1</span>: r+<span class="number">1</span>], INF)</span><br></pre></td></tr></table></figure>
<p>原因是，<strong>切片和底层数组</strong>。你构建 b 的时候往里面 append 了一个 INF，实际上是底层数组的<code>A[q+1]</code> 位置变成了 INF，所以再构建 c 的时候，切片 <code>A[q+1: r+1]</code> 的值就成了 <code>[INF, ...]</code>，然后归并就爆炸了💥。</p>
<p>把代码合一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	mergeSort(&amp;courses, <span class="number">0</span>, <span class="built_in">len</span>(courses)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span> <span class="params">(a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a[<span class="number">1</span>] &lt;= b[<span class="number">1</span>]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	queue := PriorityQueue&#123;&#125;</span><br><span class="line">	time := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line">		<span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">			queue.Push(c[<span class="number">0</span>])</span><br><span class="line">			time += c[<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !queue.IsEmpty() &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">			time += c[<span class="number">0</span>] - queue.Poll()</span><br><span class="line">			queue.Push(c[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> queue.Size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 优先队列 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Push</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	q.data = <span class="built_in">append</span>(q.data, element)</span><br><span class="line">	insertSortReverse(&amp;q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Poll</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	r := q.data[<span class="number">0</span>]</span><br><span class="line">	q.data = q.data[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  对 []int 的插入排序**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSortReverse</span><span class="params">(pA *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	A := *pA</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">		key := A[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; A[j] &lt; key &#123;</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		A[j+<span class="number">1</span>] = key</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对 [][]int 的归并排序 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> INF = []<span class="keyword">int</span>&#123;<span class="number">99999999</span>, <span class="number">99999999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(pA *[][]<span class="keyword">int</span>, p, q, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// n1 := q - p + 1</span></span><br><span class="line">	<span class="comment">// n2 := r - q</span></span><br><span class="line">	<span class="comment">// b, c := make([][]int, n1+1), make([][]int, n2+1)</span></span><br><span class="line">	A := *pA</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[p: q+<span class="number">1</span>]...)</span><br><span class="line">	c := <span class="built_in">append</span>(<span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>), A[q+<span class="number">1</span>: r+<span class="number">1</span>]...)</span><br><span class="line"></span><br><span class="line">	b = <span class="built_in">append</span>(b, INF)</span><br><span class="line">	c = <span class="built_in">append</span>(c, INF)</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := p; k &lt;= r; k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> le(b[i], c[j]) &#123;</span><br><span class="line">			A[k] = b[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			A[k] = c[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(pA *[][]<span class="keyword">int</span>, p <span class="keyword">int</span>, r <span class="keyword">int</span>, le <span class="keyword">func</span> (a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	q := (p + r) / <span class="number">2</span></span><br><span class="line">	mergeSort(pA, p, q, le)</span><br><span class="line">	mergeSort(pA, q+<span class="number">1</span>, r, le)</span><br><span class="line">	merge(pA, p, q, r, le)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一个版本就可以通过了：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geq2tnkgy4j30p605yjs3.jpg" alt="Leetcode 执行结果截图，执行用时 580 ms, 在所有 Go 提交中击败了50.00%的用户;内存消耗 8.1 MB, 在所有 Go 提交中击败了100.00%的用户"></p>
<h4 id="标准库-sort-heap"><a class="markdownIt-Anchor" href="#标准库-sort-heap"></a> 标准库 sort + heap</h4>
<p>Go 的标准库还是很强大的，但是标准库的设计相当的 Golang，才从其他语言转过来用着真的很不习惯（比如 math 包里连 Max 都没有），不过多用用这些东西、多看看它们的源码（Go 标准库的好多源码写的挺有意思的），对理解 Go 的思想很有帮助。</p>
<p>我们用到的两个东西，排序和优先队列，Go 标准库里其实都有可用的：</p>
<ul>
<li>排序：<code>sort</code> 包</li>
<li>优先队列：<code>container/heap</code> 包，Go 没有直接的优先队列，但我们可以用堆来快速实现一个。</li>
</ul>
<p>首先看排序：</p>
<blockquote>
<p><strong>Package sort</strong></p>
<p>Package sort provides primitives for sorting slices and user-defined collections.</p>
</blockquote>
<p><code>sort</code> 包里已经封装好了很多我们常用的排序情况，比如，对整数切片 <code>[]int</code> 的排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// unsorted</span></span><br><span class="line">	sort.Ints(s)</span><br><span class="line">	fmt.Println(s)	<span class="comment">// [1 2 3 4 5 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种用起来很方便，但我们现在要排一个 <code>[][]int</code> 这就不太常规了。对这种非常规东西的排序，go 提供的方式和其他语言有一些区别。</p>
<p>大多数语言，对这种非常规东西的排序，我们是把一个可迭代对象传进去，然后给他一个函数，告诉它比较的结果。例如，这是 C++ STL 的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);	<span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line">    <span class="comment">// using function as comp</span></span><br><span class="line">	<span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction);	<span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 语言里也有这种用法，它提供了一个<code>sort.Slice</code> 对任意切片进行排序，比如这是一个文档里的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="keyword">string</span></span><br><span class="line">		Age  <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">"Gopher"</span>, <span class="number">7</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Alice"</span>, <span class="number">55</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Vera"</span>, <span class="number">24</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Bob"</span>, <span class="number">75</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Name &lt; people[j].Name &#125;)</span><br><span class="line">	fmt.Println(<span class="string">"By name:"</span>, people) <span class="comment">// By name: [&#123;Alice 55&#125; &#123;Bob 75&#125; &#123;Gopher 7&#125; &#123;Vera 24&#125;]</span></span><br><span class="line"></span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;)</span><br><span class="line">	fmt.Println(<span class="string">"By age:"</span>, people) <span class="comment">// By age: [&#123;Gopher 7&#125; &#123;Vera 24&#125; &#123;Alice 55&#125; &#123;Bob 75&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里对 <code>[][]int</code> 排序的需求可以解决了，but we do need one more thing.</p>
<p>Go 还提供了一种更加 Go 风格的排序：<code>sort.Sort</code>。</p>
<blockquote>
<p><code>func Sort(data Interface)</code></p>
<p>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</p>
</blockquote>
<p>这玩意儿是传一个 <code>sort.Interface</code> 的实现进来，这真的很 Golang！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>长度、大小、交换的方法都由你来定。其实一般用起来还是很简单的，Len、Swap基本就这样，一般要改的只有 Less（只改Less，其实也差不多就是 sort.Slice，但内部实现还是有所区别的）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByAge implements sort.Interface for []Person based on</span></span><br><span class="line"><span class="comment">// the Age field.</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []Person&#123;</span><br><span class="line">		&#123;<span class="string">"Bob"</span>, <span class="number">31</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"John"</span>, <span class="number">42</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Michael"</span>, <span class="number">17</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Jenny"</span>, <span class="number">26</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(people)</span><br><span class="line"></span><br><span class="line">	sort.Sort(ByAge(people))</span><br><span class="line">	fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序的问题解决了，再看优先队列：</p>
<blockquote>
<p>Package container/heap</p>
<p>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</p>
<p>The minimum element in the tree is the root, at index 0.</p>
<p>A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.</p>
</blockquote>
<p>优先队列可以用堆来实现，实现一个堆要实现 heap.Interface，你可以看到，这个接口是“继承”了 sort.Interface 的，这也是为什么我们刚才要介绍它的原因：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体要怎么做，其实 Go 的文档里给出了些优先队列的例子了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates a priority queue built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">	priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">	<span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">	index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">	<span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">	pq[i].index = i</span><br><span class="line">	pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*pq)</span><br><span class="line">	item := x.(*Item)</span><br><span class="line">	item.index = n</span><br><span class="line">	*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *pq</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	item := old[n<span class="number">-1</span>]</span><br><span class="line">	old[n<span class="number">-1</span>] = <span class="literal">nil</span>  <span class="comment">// avoid memory leak</span></span><br><span class="line">	item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">	*pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	item.value = value</span><br><span class="line">	item.priority = priority</span><br><span class="line">	heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Some items and their priorities.</span></span><br><span class="line">	items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">"banana"</span>: <span class="number">3</span>, <span class="string">"apple"</span>: <span class="number">2</span>, <span class="string">"pear"</span>: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">	<span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">	pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">		pq[i] = &amp;Item&#123;</span><br><span class="line">			value:    value,</span><br><span class="line">			priority: priority,</span><br><span class="line">			index:    i,</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">	item := &amp;Item&#123;</span><br><span class="line">		value:    <span class="string">"orange"</span>,</span><br><span class="line">		priority: <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Push(&amp;pq, item)</span><br><span class="line">	pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">	<span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">		fmt.Printf(<span class="string">"%.2d:%s "</span>, item.priority, item.value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正用起来没有这么难，它这个是比较一般的情况了。我们这里需要的只是一个简单的基于 <code>[]int</code> 的堆，可以简化很多的。</p>
<p>用库就比较简单，直接写全部的代码了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Slice(courses, <span class="function"><span class="keyword">func</span> <span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> courses[i][<span class="number">1</span>] &lt; courses[j][<span class="number">1</span>]&#125;)</span><br><span class="line">	</span><br><span class="line">	queue := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">	time := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> courses &#123;</span><br><span class="line">		<span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">			heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">			time += c[<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.Len() != <span class="number">0</span> &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">			time += c[<span class="number">0</span>] - heap.Pop(queue).(<span class="keyword">int</span>)</span><br><span class="line">			heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queue.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Swap</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	q[a], q[b] = q[b], q[a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Less</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q[a] &gt; q[b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*q = <span class="built_in">append</span>(*q, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	v := (*q)[q.Len()<span class="number">-1</span>]</span><br><span class="line">	*q = (*q)[: q.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 scheduleCourse 里调用 PriorityQueue 时要注意，我们使用的必须是 <code>heap.Push</code> 和 <code>heap.Pop</code>，不能去调用自己写的那个 <code>queue.Push/Pop</code>，heap.Push、Pop 才能保证堆的正确性。</p>
<p>这个可以通过，执行用时 152 ms（击败87.5%），内存消耗：7.3 MB。还有人写的比这快？</p>
<p>我看了一下 sort.Slice 源码，它用了些反射（reflectlite）😂，所以比 sort.Sort 慢（sort.Sort没有反射），那些写的更快的人都是用  sort.Sort ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> coursesSoted SS4Sort = courses</span><br><span class="line">	sort.Sort(coursesSoted)</span><br><span class="line">	</span><br><span class="line">	queue := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">	time := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> coursesSoted &#123;</span><br><span class="line">		<span class="keyword">if</span> time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>] &#123;</span><br><span class="line">			heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">			time += c[<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.Len() != <span class="number">0</span> &amp;&amp; queue.Top() &gt; c[<span class="number">0</span>] &#123;</span><br><span class="line">			time += c[<span class="number">0</span>] - heap.Pop(queue).(<span class="keyword">int</span>)</span><br><span class="line">			heap.Push(queue, c[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queue.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对 [][]int 排序的接口 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SS4Sort [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SS4Sort)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SS4Sort)</span> <span class="title">Swap</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[a], s[b] = s[b], s[a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SS4Sort)</span> <span class="title">Less</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[a][<span class="number">1</span>] &lt; s[b][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 优先队列 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Swap</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	q[a], q[b] = q[b], q[a]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Less</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q[a] &gt; q[b]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q PriorityQueue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*q = <span class="built_in">append</span>(*q, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	v := (*q)[q.Len()<span class="number">-1</span>]</span><br><span class="line">	*q = (*q)[: q.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqkex0ey2j30oa05oaar.jpg" alt="Leetcode 执行结果截图，执行用时 136 ms, 在所有 Go 提交中击败了100.00%的用户; 内存消耗 7.3 MB, 在所有 Go 提交中击败了100.00%的用户"></p>
<p>哎，，Go 还是写结构化比较强的东西好用。这种库里大量的接口需要自己写实现，在工程里倒是挺好用，但拿来解这种小问题写起来就各种不方便了。</p>

  </div>
</article>
<!--Disqus-->


<!--Livere-->

    <div class="blog-post-comments">
        <div id="lv-container" data-id="city" data-uid="MTAyMC80NjEzMi8yMjY0Mw==">
            <noscript>不启用 JavaScript 支持的人是看不到可爱的评论区的。😥</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-课程表-i-ii-iii"><span class="toc-number">1.</span> <span class="toc-text"> Leetcode 课程表 I、II、III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#207-课程表"><span class="toc-number">1.1.</span> <span class="toc-text"> 207. 课程表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs"><span class="toc-number">1.1.2.</span> <span class="toc-text"> DFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#210-课程表-ii"><span class="toc-number">1.2.</span> <span class="toc-text"> 210. 课程表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-2"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#630-课程表-iii"><span class="toc-number">1.3.</span> <span class="toc-text"> 630. 课程表 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心优先队列"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 贪心优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">1.3.2.1.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序-归并排序"><span class="toc-number">1.3.2.2.</span> <span class="toc-text"> 插入排序 + 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准库-sort-heap"><span class="toc-number">1.3.2.3.</span> <span class="toc-text"> 标准库 sort + heap</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&text=Leetcode 课程表 I、II、III"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&is_video=false&description=Leetcode 课程表 I、II、III"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Leetcode 课程表 I、II、III&body=Check out this article: https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&title=Leetcode 课程表 I、II、III"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/05/13/School/Leetcode-course-tab-I-II-III/&name=Leetcode 课程表 I、II、III&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 CDFMLR
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-146911386-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?9a0d2e6fde93dad496ac79f04f3aba97";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


<!--Livere Comments-->

    <script type="text/javascript">
      (function (d, s) {
        var j, e = d.getElementsByTagName(s)[0];

        if (typeof LivereTower === 'function') { return; }

        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;

        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>

</body>
</html>
