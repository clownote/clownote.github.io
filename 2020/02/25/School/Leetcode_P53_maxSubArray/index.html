<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Leetcode P53 最大子序和  题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCod">
<meta name="keywords" content="School">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode P53 最大子序和">
<meta property="og:url" content="https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/index.html">
<meta property="og:site_name" content="clownote">
<meta property="og:description" content="Leetcode P53 最大子序和  题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCod">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om3s4ngj319q0u0hc0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om9mpytj319q0u01kx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc8prg5j7dj319q0u01kx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc8qbpo8axj319q0u01kx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc8qmkxcpvj31yi0tm7bl.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc9110gn6pj319q0u01kx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc91o1k64ij30u00yegro.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc9ibdwblmj319q0u04qg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc9jkwzn71j319q0u04pc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc9k4h6ab8j31d90u01kx.jpg">
<meta property="og:updated_time" content="2020-07-25T16:13:11.216Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode P53 最大子序和">
<meta name="twitter:description" content="Leetcode P53 最大子序和  题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCod">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om3s4ngj319q0u0hc0.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/rabbit.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/rabbit_192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/rabbit_180.png">
          
        
    
    <!-- title -->
    <title>Leetcode P53 最大子序和</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
    <!--Google search varification (PRIVATE)-->
    <meta name="google-site-verification" content="MrqlpFAD8nDanw3Ypv7ZsIWHLnTdhRuLa4QhSVwxIvc">
    <!--Google AdSense 关联 (PRIVATE)-->
    <script data-ad-client="ca-pub-1510963483941114" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/02/26/School/Leetcode_P88_MergeSortedArray/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/02/20/blog/SQL_CRUD/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&text=Leetcode P53 最大子序和"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&is_video=false&description=Leetcode P53 最大子序和"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Leetcode P53 最大子序和&body=Check out this article: https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&name=Leetcode P53 最大子序和&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-p53-最大子序和"><span class="toc-number">1.</span> <span class="toc-text"> Leetcode P53 最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">1.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心"><span class="toc-number">1.2.</span> <span class="toc-text"> 贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动规"><span class="toc-number">1.3.</span> <span class="toc-text"> 动规</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治"><span class="toc-number">1.4.</span> <span class="toc-text"> 分治</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力"><span class="toc-number">1.5.</span> <span class="toc-text"> 暴力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一行代码的解法"><span class="toc-number">1.6.</span> <span class="toc-text"> 一行代码的解法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后的废话"><span class="toc-number">1.7.</span> <span class="toc-text"> 最后的废话</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Leetcode P53 最大子序和
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">clownote</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-02-25T16:29:02.000Z" itemprop="datePublished">2020-02-25</time>
        
        (Updated: <time datetime="2020-07-25T16:13:11.216Z" itemprop="dateModified">2020-07-25</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/School/">School</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="leetcode-p53-最大子序和"><a class="markdownIt-Anchor" href="#leetcode-p53-最大子序和"></a> Leetcode P53 最大子序和</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6<br>
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>
进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h2>
<p>emmm，一看又是动规题。但我不（bu）爱（hui）写动规，每次写动规都要爆炸好久。。。先试试能不能贪心贪出来吧。</p>
<p>我们来考虑这样的贪心策略：</p>
<blockquote>
<p>从头到尾遍历数组，在每一个元素 <code>i</code> 处，贪最大和。</p>
</blockquote>
<p>也就是在每次迭代里，一个部分最大和要么是<em>前面的某一部分和</em> + <em>当前元素值</em>，要么是当前元素一个就比前面辛苦积累起来的和大了，那部分最大和就变成当前元素一个人的值了；之后，如果我们新得到的这个部分和比之前的全局的最优解还大，那么全局最优解就变成现在的这个部分和了。</p>
<p>用代码来表示，即当前部分最大和 <code>part = Max(part + nums[i], nums[i])</code>，以及全局最大和 <code>max = Max(max, part)</code>，这样我们每一步都保证 <code>part</code>、<code>max</code> 都是最优的，完成遍历就得到了全局最优解。</p>
<p>Golang 实现，首先为了突出贪心策略，我们实现一个辅助的 <code>MaxI()</code> 来返回两个 <code>int</code> 的最大值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1 (记住这些代码版本的标号呀。本文代码版本比较多，而且有相互比较)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxI</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	part, max := nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		part = MaxI(nums[i], part + nums[i])</span><br><span class="line">		max = MaxI(part, max)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om3s4ngj319q0u0hc0.jpg" alt="屏幕快照 2020-02-25 15.15.03"></p>
<p>Nice，过了，难得有这种懒得动规拿贪心这么简单就贪到的题目。</p>
<p>再整理一下代码，去掉 <code>MaxI</code>，减少函数调用的消耗：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	part, max := nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        part += nums[i]</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; part &#123;</span><br><span class="line">            part = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> part &gt; max &#123;</span><br><span class="line">            max = part</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8om9mpytj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 15.17.46"></p>
<p>Emmm，不但没有优化，还更差了，不管了，这个是运气问题。</p>
<p>分析一下这个算法，时间上只遍历了一次数组，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；空间上都是常量空间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。应该说这个算法还是不错的。</p>
<h2 id="动规"><a class="markdownIt-Anchor" href="#动规"></a> 动规</h2>
<p>虽然不喜欢，但还是要练习嘛，动规肝起。</p>
<p>建一个备忘录 <code>memo</code> 来记录各个可能的部分和，最后返回 <code>memo</code> 中最大的就好了。</p>
<p>这里“各个可能的部分和”，我们采取和刚才贪心类似的思路，记录每一个元素处的最大值。具体来说，我们可以采用这样的方法：看看备忘录 <code>memo</code> 中前面一个元素处的最大值如果这个值是负的了，那当前元素加上它肯定更小了，所以当前最大和就是当前元素本身；如果记录中前面的值是正的，那加上就更大了，所以我们务必把它加上。</p>
<p>继续 Golang 实现：（Golang 写服务和写题都是很舒服的😌）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V3</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	memo := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	memo[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> memo[i<span class="number">-1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">			memo[i] = nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memo[i] = memo[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(memo)</span><br><span class="line">	<span class="keyword">return</span> memo[<span class="built_in">len</span>(memo)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8prg5j7dj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 16.06.33"></p>
<p>。。。我们这里用了一个标准库里的 <code>sort.Ints</code>，它的代码实现是个 quick sort。这居然没有影响速度，空间的影响倒是看出来了。</p>
<p>（其实这个动规也不难）</p>
<p>分析一下这个算法，时间主要是一个迭代（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>）还有一个快排（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>），合起来是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；空间上，写了一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的备忘录，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>其实这一个版本的代码里有好几个地方可以优化，第一这个快排完全是可以避免的，用之前贪心时的策略，用一个 <code>max</code> 取记录每一步后的全局最优解:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	memo := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	memo[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	max := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> memo[i<span class="number">-1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">			memo[i] = nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memo[i] = memo[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> memo[i] &gt; max &#123;</span><br><span class="line">			max = memo[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不忙跑这个版本，还可以继续优化，再观察代码，我们自始至终只使用了 <code>memo[i-1]</code> 这一个记录值来更新下一个记录值 <code>memo[i]</code>，之前的所有记录都不会用到。既然如此，何不直接用一个 <code>int</code> 变量把之前的数组取代掉，空间就从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 降到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	memo := nums[<span class="number">0</span>]</span><br><span class="line">	max := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> memo &lt; <span class="number">0</span> &#123;</span><br><span class="line">			memo = nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memo += nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> memo &gt; max &#123;</span><br><span class="line">			max = memo</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8qbpo8axj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 16.30.49"></p>
<p>这个结果比较好，时间上比之前的所有版本都要快。</p>
<p>接下来再研究一下能不能搞出分治。，，嗯？？！！等一下！发现一个有意思的东西！</p>
<p>我们再来观察一下 <code>V5</code> 和 <code>V2</code> 这两个版本的代码，一个是优化后的贪心，一个是优化后的动规。为了方便观察，我们稍微修改一下代码表述（算法、大体框架都不动），然后把它们肩并肩比较一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8qmkxcpvj31yi0tm7bl.jpg" alt="屏幕快照 2020-02-25 16.42.05"></p>
<p>我们会发现，这两个版本的大体框架是一样的，区别在于迭代里的处理。而且，这不一样的代码都是用来这一步当前的最大部分和的！稍微思考一下这两个方法，V5 里如果前面的记录是正的我们才加，负的就不加了；V2 里我们是先加上去试试看，如果加上去变小了就不加了。而我们知道由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>&lt;</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + b &lt; a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 可以推出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。也就是说，我们的这两种处理在本质上是一样的！</p>
<p>哈，一个是优化后的贪心，一个是优化后的动规，从不同的思想出发，居然殊途同归！还是很有意思的。</p>
<h2 id="分治"><a class="markdownIt-Anchor" href="#分治"></a> 分治</h2>
<p><s>【16:46】：分治好难的，平时用的也不多，好多东西我都忘了。。。</s></p>
<p><s>【16:49】: 唉，早知不能回学校就应该把《算法导论》（还有我的琴23333）带回来的，看扫描版的 PDF 好难受啊。😭</s></p>
<p><s>【17:26】：啊，天呐，我发现我完全忘了，只会归并排序了（归并可能都不能完全流畅手写了），不想做了。</s></p>
<p><s>【17:39】：我直接看了题解。。。试着自己复述一遍吧。</s></p>
<hr>
<p>用类似于二分法的思想啊，最大和子串的所有元素可能在这三个位置：</p>
<ul>
<li>全在数组中心左边</li>
<li>跨过数组中心</li>
<li>全在数组中心右边</li>
</ul>
<p>我们“分治“就是”分“这几种情况了。其中比较特殊的是跨中心的，跨中心的需要从中心左侧和中心右侧分别用贪心，求得跨中心的最大和。</p>
<p>而非跨中心的情况就分左右去递归嘛，把问题看成只有左边一半、右边一半分别求解。</p>
<p>我们的递归需要有基础情况，那这个问题中的基础情况就是递归到子串只是单独的一个元素了，那这个元素自己就是这个子序的最大子序了，直接返回它本身。而非基础情况的时候，也就是子串长度&gt;1时，就像刚才说的那样递归下去，继续用上面讨论的三种情况找子串啊。</p>
<p>递归到头后，返回来时有点像棵树，比较兄弟（左半、右半、跨中 三种情况分别取得的最大和）的值，找到最大的往上返回…这样返回到头问题就解决了。</p>
<p>（好乱啊，没写代码，边思考边来写思路好怪，其实我还没完全搞懂这个算法是在干什么，不管了，来试一下代码实现，代码出来思路就清晰了。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getMaxSubArray(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxSubArray</span><span class="params">(nums []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left == right &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[right]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	center := (left + right) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">	leftSum := getMaxSubArray(nums, left, center)</span><br><span class="line">	crossSum := getCrossSum(nums, left, center, right)</span><br><span class="line">	rightSum := getMaxSubArray(nums, center+<span class="number">1</span>, right)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> maxI(leftSum, crossSum, rightSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCrossSum</span><span class="params">(nums []<span class="keyword">int</span>, left, center, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left == right &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[right]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	leftSubMaxSum := nums[center]</span><br><span class="line">	memo := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := center; i &gt;= left; i-- &#123;</span><br><span class="line">		memo += nums[i]</span><br><span class="line">		<span class="keyword">if</span> memo &gt;= leftSubMaxSum &#123;</span><br><span class="line">			leftSubMaxSum = memo</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rightSubMaxSum := nums[center+<span class="number">1</span>]</span><br><span class="line">	memo = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := center + <span class="number">1</span>; i &lt;= right; i++ &#123;</span><br><span class="line">		memo += nums[i]</span><br><span class="line">		<span class="keyword">if</span> memo &gt;= rightSubMaxSum &#123;</span><br><span class="line">			rightSubMaxSum = memo</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> leftSubMaxSum + rightSubMaxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxI</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> a &gt;= b &amp;&amp; a &gt;= c:</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	<span class="keyword">case</span> b &gt;= a &amp;&amp; b &gt;= c:</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9110gn6pj319q0u01kx.jpg" alt="屏幕快照 2020-02-25 22.38.51"></p>
<p>这样，分治法就过了，其实分治没有之前的那些算法快，这个分治是个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，递归调用也会比较耗时，还有空间消耗也会比较大，因为开递归栈要了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但整个问题解决的比较精妙，代码很漂亮。</p>
<p>P.S. 我前面写的思路不太清楚，所以补一张图来说明这个算法是在干什么（我思考的时候随手画的，不一定正确，仅供参考）：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc91o1k64ij30u00yegro.jpg" alt="image-20200225230422143"></p>
<h2 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h2>
<p>再补一个暴力解法吧，把这道题主要的几种方法都写全。</p>
<p>暴力法就是把所有的可能子序都搞出来，比较它们的和，返回最大的。</p>
<p>Golang 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	maxSubSum := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> l := <span class="number">0</span>; l &lt; <span class="built_in">len</span>(nums); l++ &#123;</span><br><span class="line">		part := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> r := l; r &lt; <span class="built_in">len</span>(nums); r++ &#123;</span><br><span class="line">			part += nums[r]</span><br><span class="line">			<span class="keyword">if</span> part &gt; maxSubSum &#123;</span><br><span class="line">				maxSubSum = part</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSubSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9ibdwblmj319q0u04qg.jpg" alt="屏幕快照 2020-02-26 08.37.10"></p>
<h2 id="一行代码的解法"><a class="markdownIt-Anchor" href="#一行代码的解法"></a> 一行代码的解法</h2>
<p>按照传统，我还是尽力想出一个使用最短代码行数的解法。</p>
<p>我们首先来看一个两行代码的 Python3 解法：（不算<code>import</code>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># V8</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums[<span class="number">0</span>] = (nums[<span class="number">0</span>], nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: (max(x[<span class="number">0</span>]+y, y), max(x[<span class="number">1</span>], x[<span class="number">0</span>]+y, y)), nums)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>其实这就是我们的贪心/动规解法嘛，只是利用了 reduce 来在一行代码里完成所有操作（另一行代码为这一行代码做了必要的准备），我挺喜欢这个解法的，还是很优雅的。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9jkwzn71j319q0u04pc.jpg" alt="屏幕快照 2020-02-26 09.21.26"></p>
<p>再来把代码减少到一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># V9</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: (max(x[<span class="number">0</span>]+y[<span class="number">0</span>], y[<span class="number">0</span>]), max(x[<span class="number">1</span>], x[<span class="number">0</span>]+y[<span class="number">0</span>], y[<span class="number">0</span>])), [(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> nums])[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>为了完成一行代码的任务，我们用了一个生成器生成了好多无用的数据，造成了时间、空间的浪费，结果就不太好了：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9k4h6ab8j31d90u01kx.jpg" alt="image-20200226094257065"></p>
<h2 id="最后的废话"><a class="markdownIt-Anchor" href="#最后的废话"></a> 最后的废话</h2>
<p>这一道题，我们写出来 9 个版本的代码，还是很有意思的，从贪心、动规到分治，最后居然还用一行代码解决了它！不同的思考角度出发，我们写出过几乎相同的代码；用相同的思想去实现，我们又写出了不同的程序…这或许就是编程的魅力吧。我不喜欢编程，但编程的这种魅力深深地吸引着我，为我指引着未来或许没有希望的方向。</p>

  </div>
</article>
<!--Disqus-->


<!--Livere-->

    <div class="blog-post-comments">
        <div id="lv-container" data-id="city" data-uid="MTAyMC80NjEzMi8yMjY0Mw==">
            <noscript>不启用 JavaScript 支持的人是看不到可爱的评论区的。😥</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-p53-最大子序和"><span class="toc-number">1.</span> <span class="toc-text"> Leetcode P53 最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">1.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心"><span class="toc-number">1.2.</span> <span class="toc-text"> 贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动规"><span class="toc-number">1.3.</span> <span class="toc-text"> 动规</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治"><span class="toc-number">1.4.</span> <span class="toc-text"> 分治</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力"><span class="toc-number">1.5.</span> <span class="toc-text"> 暴力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一行代码的解法"><span class="toc-number">1.6.</span> <span class="toc-text"> 一行代码的解法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后的废话"><span class="toc-number">1.7.</span> <span class="toc-text"> 最后的废话</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&text=Leetcode P53 最大子序和"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&is_video=false&description=Leetcode P53 最大子序和"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Leetcode P53 最大子序和&body=Check out this article: https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&title=Leetcode P53 最大子序和"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/02/25/School/Leetcode_P53_maxSubArray/&name=Leetcode P53 最大子序和&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 CDFMLR
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-146911386-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?9a0d2e6fde93dad496ac79f04f3aba97";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


<!--Livere Comments-->

    <script type="text/javascript">
      (function (d, s) {
        var j, e = d.getElementsByTagName(s)[0];

        if (typeof LivereTower === 'function') { return; }

        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;

        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>

</body>
</html>
