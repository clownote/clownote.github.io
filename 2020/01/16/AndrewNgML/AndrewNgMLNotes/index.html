<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="机器学习Emmmm，这学期在 Coursera 学完了 Andrew Ng 的 Machine Learning 课程。我对这个课程一向是不以为意的，却不小心报了个名，还手贱申请了个经济援助，学完就可以免费拿证书（卖几百块哒），课程期间还送正版的 Matlab Online，这一系列的偶(占)然(小)事(便)件(宜)促使我开始刷这个课了。越学越觉得，嗯，真香，是真的很香！这个课真的是很好的机器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Andrew Ng 机器学习笔记总结">
<meta property="og:url" content="https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/index.html">
<meta property="og:site_name" content="clownote">
<meta property="og:description" content="机器学习Emmmm，这学期在 Coursera 学完了 Andrew Ng 的 Machine Learning 课程。我对这个课程一向是不以为意的，却不小心报了个名，还手贱申请了个经济援助，学完就可以免费拿证书（卖几百块哒），课程期间还送正版的 Matlab Online，这一系列的偶(占)然(小)事(便)件(宜)促使我开始刷这个课了。越学越觉得，嗯，真香，是真的很香！这个课真的是很好的机器学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n5s7zmffj30lv0ca40u.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gauxvtzb5qj30ur0g8wgd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gauyq6oc10j306e04umx0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gauyt0wbq3j30mv08xwfh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78nj8fvy4j30d507agmp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aopbltb1j30f0046dg2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwgy1gax9ziqe3sj324i0nu0z9.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwgy1gaxa3eq7zuj30c5083gm3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jljliww8j30o90dmwjt.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmrwo86pj30ph0dwwm1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmzc2qq4j30ot0ditej.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jul8myufj30mv0cz0xu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n62mi54pj30lw0catay.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwgy1gaxja4d68ej30cb0c3jro.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ta88gafkj30oz0djaeo.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bmwqbebxj30po0dgahc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g9bi5bv4etj30nz06lac1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ds8xkjatj30ob0bd0w0.jpg">
<meta property="article:published_time" content="2020-01-16T12:39:27.000Z">
<meta property="article:modified_time" content="2021-03-12T09:27:41.313Z">
<meta property="article:author" content="CDFMLR">
<meta property="article:tag" content="Machine Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n5s7zmffj30lv0ca40u.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/rabbit.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/rabbit_192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/rabbit_180.png">
          
        
    
    <!-- title -->
    <title>Andrew Ng 机器学习笔记总结</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
    <!--Google search varification (PRIVATE)-->
    <meta name="google-site-verification" content="MrqlpFAD8nDanw3Ypv7ZsIWHLnTdhRuLa4QhSVwxIvc" />
    <!--Google AdSense 关联 (PRIVATE)-->
    <script data-ad-client="ca-pub-1510963483941114" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/28/blog/a-swift-tour-cn-md/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/12/17/AndrewNgML/AndrewNg-MachineLearning-17-LargeScaleMachineLearning/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&text=Andrew Ng 机器学习笔记总结"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&is_video=false&description=Andrew Ng 机器学习笔记总结"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Andrew Ng 机器学习笔记总结&body=Check out this article: https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&name=Andrew Ng 机器学习笔记总结&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">机器学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">回归问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#h-theta-x"><span class="toc-number">2.</span> <span class="toc-text">h_\theta(x)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sum-i-0-m-theta-ix-i"><span class="toc-number">3.</span> <span class="toc-text">\sum_{i&#x3D;0}^m \theta_ix_i</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#left-begin-array-c-x-0-x-1-vdots-x-n-end-array-right"><span class="toc-number">4.</span> <span class="toc-text">\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">梯度下降</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">正规方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8Dvs%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">梯度下降vs正规方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">注：特征缩放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.1.</span> <span class="toc-text">分类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">逻辑回归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB"><span class="toc-number">4.0.1.1.1.</span> <span class="toc-text">多元分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E8%BF%87%E6%8B%9F%E5%90%88"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">注：过拟合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB-1"><span class="toc-number">4.0.1.3.1.</span> <span class="toc-text">多元分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%9F%E5%90%88"><span class="toc-number">4.0.1.3.2.</span> <span class="toc-text">神经网络的拟合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-number">4.0.1.4.</span> <span class="toc-text">支持向量机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.1.4.1.</span> <span class="toc-text">核方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SVM-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%B8"><span class="toc-number">4.0.1.4.2.</span> <span class="toc-text">SVM 中使用核</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB-2"><span class="toc-number">4.0.1.4.3.</span> <span class="toc-text">多元分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-vs-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-vs-SVM"><span class="toc-number">4.0.1.5.</span> <span class="toc-text">逻辑回归 vs 神经网络 vs SVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.1.</span> <span class="toc-text">无监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Means-%E8%81%9A%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">K-Means 聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCA-%E7%BB%B4%E6%95%B0%E7%BA%A6%E5%87%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">PCA 维数约减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">异常检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">高斯分布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%9F%A5%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.3.1.1.</span> <span class="toc-text">异常检查算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">多元高斯分布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%9F%A5"><span class="toc-number">4.1.3.2.1.</span> <span class="toc-text">用多元高斯分布的异常检查</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E6%A7%9B%E9%80%89%E6%8B%A9"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">门槛选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">推荐系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">基于内容推荐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">协同过滤</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Andrew Ng 机器学习笔记总结
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">clownote</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-16T12:39:27.000Z" itemprop="datePublished">2020-01-16</time>
        
        (Updated: <time datetime="2021-03-12T09:27:41.313Z" itemprop="dateModified">2021-03-12</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Machine-Learning/">Machine Learning</a> › <a class="category-link" href="/categories/Machine-Learning/AndrewNg/">AndrewNg</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>Emmmm，这学期在 Coursera 学完了 Andrew Ng 的 Machine Learning 课程。我对这个课程一向是不以为意的，却不小心报了个名，还手贱申请了个经济援助，学完就可以免费拿证书（卖几百块哒），课程期间还送正版的 Matlab Online，这一系列的偶(占)然(小)事(便)件(宜)促使我开始刷这个课了。越学越觉得，嗯，真香，是真的很香！这个课真的是很好的机器学习入门，难怪那么多人推荐。</p>
<p>Coursera 里课程笔记有每一章的总结，总结的非常好，推荐学完之后看一看。但我还是喜欢自己写自己的，所以我之前边看视频边写了几乎涵盖整个课程的<a href="https://clownote.github.io/categories/Machine-Learning/AndrewNg/">笔记</a>，其实好多是在抄老师的原话和PPT😂，就当练习打字、英语还有 $\LaTeX$ 了。放假回家在火车上<del>百无聊赖</del>心血来潮，想到了应该整理一下课程里面学到的东西，就有了这篇文章。</p>
<p>这里我主要是写了各种算法的描述，还从编程作业里提取了算法大概的代码实现，方便日后快速查阅吧。一开始的回归比较简单，所以我写的很少，就堆了点公式（其实是硬卧上铺空调太冷致使我生病了，思路堵塞写不出东西来😷）；后面SVM、推荐系统什么的比较复杂就多写了一些（其实是我掌握的不好，归纳不出重点🤯）。至于课程里老师花大力气讲的关于机器学习系统的设计、优化、debug 还有各种<del>奇技淫巧</del> <del>骚操作</del> 实用技巧 以及 Octave 入门哪一块我就一概不提了，这些东西还是要看老师的视频才能体会到精髓（…优(挂)秀(科)的大学生自然是不能承认原因是自己懒惰的😎）。</p>
<p>由于我看课程的时候全程没有开中文字幕，平时查阅的中文资料也比较少，所以好多术语我都不知道要怎么翻译，写这篇文章的时候我大概查了一些自己难以表达的，其他的全靠臆测，我不保证正确。</p>
<p>Emmm，不小心就写了几百字的废话😂下面就开始吧。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是给x、y数据去训练的。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n5s7zmffj30lv0ca40u.jpg" alt="image-20191105144318970"></p>
<h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><blockquote>
<p>做预测，值域为连续的数（例如区间$[0,100]$）</p>
</blockquote>
<p>数学模型：</p>
<ul>
<li><p><strong>预测函数</strong>：<br>$$</p>
<h1 id="h-theta-x"><a href="#h-theta-x" class="headerlink" title="h_\theta(x)"></a>h_\theta(x)</h1><h1 id="sum-i-0-m-theta-ix-i"><a href="#sum-i-0-m-theta-ix-i" class="headerlink" title="\sum_{i=0}^m \theta_ix_i"></a>\sum_{i=0}^m \theta_ix_i</h1><p>\left[\begin{array}{c}\theta_0 &amp; \theta_1 &amp; \ldots &amp; \theta_n\end{array}\right]</p>
<h1 id="left-begin-array-c-x-0-x-1-vdots-x-n-end-array-right"><a href="#left-begin-array-c-x-0-x-1-vdots-x-n-end-array-right" class="headerlink" title="\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]"></a>\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]</h1><p>\theta^TX<br>$$</p>
</li>
<li><p><strong>待求参数</strong>：$\theta=\left[\begin{array}{c}\theta_0 &amp; \theta_1 &amp; \ldots &amp; \theta_n\end{array}\right]$</p>
</li>
<li><p><strong>代价函数</strong>：<br>$$<br>J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2<br>=\frac{(\sum_{i=1}^mh_\theta(X)-Y)^2}{2m}<br>$$</p>
</li>
</ul>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">J</span> = <span class="title">computeCostMulti</span><span class="params">(X, y, theta)</span></span></span><br><span class="line"><span class="comment">%COMPUTECOSTMULTI Compute cost for linear regression with multiple variables</span></span><br><span class="line"><span class="comment">%   J = COMPUTECOSTMULTI(X, y, theta) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for linear regression to fit the data points in X and y</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span> / (<span class="number">2</span>*m) * (X*theta - y)&#x27; * (X*theta - y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% or less vectorizedly: </span></span><br><span class="line"><span class="comment">% predictions = X * theta;</span></span><br><span class="line"><span class="comment">% sqrErrors = (predictions - y) .^ 2;</span></span><br><span class="line"><span class="comment">% J = 1 / (2*m) * sum(sqrErrors);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优化目标</strong>：找到一组$\theta$使$J$最小。</li>
</ul>
<p>求解方法：</p>
<h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>（这里暂且只讨论 batch gradient descent）</p>
<p>$$<br>\begin{array}{ll}<br>\textrm{repeat until convergence } { \<br>\qquad \theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\<br>\qquad\quad:= \theta_j - \alpha \frac{1}{m} \sum^m_{i=1}[h_\theta(x^{(i)})-y^{(i)}] \cdot x_j^{(i)}\qquad \textrm{for }j:=0, …, n \<br>}<br>\end{array}<br>$$</p>
<p>向量化表示：$\theta=\theta-\frac{\alpha}{m}X^T(h_\theta(X)-Y)$</p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta, J_history]</span> = <span class="title">gradientDescentMulti</span><span class="params">(X, y, theta, alpha, num_iters)</span></span></span><br><span class="line"><span class="comment">%GRADIENTDESCENTMULTI Performs gradient descent to learn theta</span></span><br><span class="line"><span class="comment">%   theta = GRADIENTDESCENTMULTI(x, y, theta, alpha, num_iters) updates theta by</span></span><br><span class="line"><span class="comment">%   taking num_iters gradient steps with learning rate alpha</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line">J_history = <span class="built_in">zeros</span>(num_iters, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line"></span><br><span class="line">    predictions = X * theta;</span><br><span class="line">    errors = (predictions - y);</span><br><span class="line">    theta = theta - alpha / m * (X&#x27; * errors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Save the cost J in every iteration    </span></span><br><span class="line">    J_history(iter) = computeCostMulti(X, y, theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h4><p>$$<br>\theta = (X^TX)^{-1}X^Ty<br>$$<br>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta]</span> = <span class="title">normalEqn</span><span class="params">(X, y)</span></span></span><br><span class="line"><span class="comment">%NORMALEQN Computes the closed-form solution to linear regression </span></span><br><span class="line"><span class="comment">%   NORMALEQN(X,y) computes the closed-form solution to linear </span></span><br><span class="line"><span class="comment">%   regression using the normal equations.</span></span><br><span class="line"></span><br><span class="line">theta = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">2</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">theta = pinv(X&#x27; * X) * X&#x27; * y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里我们求伪逆以确保正常运行。通常造成$X^TX$不可逆的原因是：</p>
<ol>
<li>存在可约特征，即给定的某两/多个特征线性相关，只保留一个删除其他即可解决。（e.g. there are the size of house in feet^2 and the size of house in meter^2, where we know that 1 meter = 3.28 feet）</li>
<li>给定特征过多，($m \le n$). 可以删除一些不重要的特征（考虑PCA算法）</li>
</ol>
<h4 id="梯度下降vs正规方程"><a href="#梯度下降vs正规方程" class="headerlink" title="梯度下降vs正规方程"></a>梯度下降vs正规方程</h4><table>
<thead>
<tr>
<th></th>
<th>Gradient Descent</th>
<th>Normal Equation</th>
</tr>
</thead>
<tbody><tr>
<td>需要选择 alpha</td>
<td>✅</td>
<td>-</td>
</tr>
<tr>
<td>第三方</td>
<td>✅</td>
<td>-</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>$O(kn^2)$</td>
<td>求$X^TX$的伪逆需要$O(n^3)$</td>
</tr>
<tr>
<td>n 相当大时</td>
<td>可以工作</td>
<td>十分缓慢甚至不可计算</td>
</tr>
</tbody></table>
<p>实际上，当 $n&gt;10,000$ 时，我们通常更倾向于使用梯度下降，否则正规方程一般都表现得更好。</p>
<h4 id="注：特征缩放"><a href="#注：特征缩放" class="headerlink" title="注：特征缩放"></a>注：特征缩放</h4><p>我们可以通过使输入值大概在一定的范围内来使梯度下降运行更快，比如说，我们可以把所有值变到 $[-1,1]$ 的范围内，同时，我们还可以通过处理让输入值之间的差距不要太大（例如，输入值中同时有 0.000001 和 1 这样差距大的值会影响梯度下降的效率）。</p>
<p>在实践中，我们通常想要保证变量值在 $[-3,-\frac{1}{3}) \cup (+\frac{1}{3}, +3]$ 这个范围内取值。</p>
<p>为达成该目标，我们做如下操作：</p>
<ol>
<li>Feature scaling</li>
</ol>
<p>$$<br>\begin{array}{rl}<br>\textrm{Range:} &amp; s_i = max(x_i)-min(x_i)\<br>\textrm{Or Range:} &amp; s_i = \textrm{standard deviation of } x_i\<br>\textrm{Scaling:} &amp; x_i:=\frac{x_i}{s_i}<br>\end{array}<br>$$</p>
<ol start="2">
<li>Mean normalizaton</li>
</ol>
<p>$$<br>\begin{array}{rl}<br>\textrm{Mean(Average):} &amp; \mu_i = \frac{sum(x_i)}{m}\<br>\textrm{normalizing:} &amp; x_i:=x_i-\mu_i<br>\end{array}<br>$$</p>
<p>把两个操作和在一起，即：<br>$$<br>x_i:=\frac{x_i-\mu_i}{s_i}<br>$$<br>其中，$\mu_i$ 是特征(i)的值的平均，$s_i$是值的范围。</p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X_norm, mu, sigma]</span> = <span class="title">featureNormalize</span><span class="params">(X)</span></span></span><br><span class="line"><span class="comment">%FEATURENORMALIZE Normalizes the features in X </span></span><br><span class="line"><span class="comment">%   FEATURENORMALIZE(X) returns a normalized version of X where</span></span><br><span class="line"><span class="comment">%   the mean value of each feature is 0 and the standard deviation</span></span><br><span class="line"><span class="comment">%   is 1. This is often a good preprocessing step to do when</span></span><br><span class="line"><span class="comment">%   working with learning algorithms.</span></span><br><span class="line"></span><br><span class="line">X_norm = X;</span><br><span class="line">mu = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">size</span>(X, <span class="number">2</span>));</span><br><span class="line">sigma = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">size</span>(X, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">mu = <span class="built_in">mean</span>(X);</span><br><span class="line">sigma = std(X);</span><br><span class="line">X_norm = (X - mu) ./ sigma;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><blockquote>
<p>做预测，值域为离散的几个特定值（例如 0 或 1；0/1/2/3）</p>
</blockquote>
<h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>假设函数：<br>$$<br>\left{\begin{array}{l}<br>h_\theta(x) = g(\theta^Tx)\<br>z = \theta^T x\<br>g(z) = \frac{1}{1+e^{-z}}\<br>\end{array}\right.<br>$$<br>其中，$g(z)$ 称为 Simoid 函数，或逻辑函数，其图像如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauxvtzb5qj30ur0g8wgd.jpg" alt="image-20190917162504420"></p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> = <span class="title">sigmoid</span><span class="params">(z)</span></span></span><br><span class="line"><span class="comment">%SIGMOID Compute sigmoid functoon</span></span><br><span class="line"><span class="comment">%   J = SIGMOID(z) computes the sigmoid of z.</span></span><br><span class="line"></span><br><span class="line">g = <span class="number">1.0</span> ./ (<span class="number">1.0</span> + <span class="built_in">exp</span>(-z));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上式可化简得：<br>$$<br>h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}<br>$$</p>
<p>$h_\theta$ 的输出是预测值为1的可能性，并有下两式成立：<br>$$<br>h_\theta(x)=P(y=1 \mid x;\theta)=1-P(y=0 \mid x; \theta)<br>$$</p>
<p>$$<br>P(y=0 \mid x;\theta) + P(y=1 \mid x;\theta) = 1<br>$$</p>
<p><strong>决策边界</strong>：逻辑回归的决策边界就是将区域分成$y=0$和 $y=1$ 两部分的一个超平面。</p>
<p>决策边界由假设函数决定。这是由于要完成分类，需用$h_\theta$的输出来决定结果是 0 还是 1。定 0.5 为分界，即：<br>$$<br>\begin{array}{rcl}<br>h_\theta(x) \ge 0.5 &amp;\Rightarrow&amp; y=1\<br>h_\theta(x) &lt; 0.5 &amp;\Rightarrow&amp; y=0<br>\end{array}<br>$$<br>由 Simoid 函数的性质，上式等价为：<br>$$<br>\begin{array}{rcl}<br>\theta^TX \ge 0 &amp;\Rightarrow&amp; y=1\<br>\theta^TX \le 0 &amp;\Rightarrow&amp; y=0\<br>\end{array}<br>$$<br>那么对于给定的一组 $\theta$，例如$\theta=\left[\begin{array}{c}5\-1\0\end{array} \right]$，有 $y=1$ 当且仅当 $5+(-1)x_1+0x_2 \ge 0$，这时决策边界为 $x_1=5$。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauyq6oc10j306e04umx0.jpg" alt="image-20190917173722734"></p>
<p>决策边界也可以是下面这种复杂的情况：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauyt0wbq3j30mv08xwfh.jpg" alt="image-20190917174144868"></p>
<p><strong>逻辑回归模型</strong>：<br>$$<br>\begin{array}{rcl}<br>\textrm{Training set} &amp;:&amp; {(x^{(1)},y^{(1)}), (x^{(2)},y^{(2)}), \ldots, (x^{(m)},y^{(m)})}\<br>\<br>\textrm{m examples} &amp;:&amp;<br>x \in \left[\begin{array}{c}<br>x_0\x_1\ \vdots \ x_n<br>\end{array}\right] \textrm{where }(x_0=1)<br>,\quad y \in {0,1}\<br>\<br>\textrm{Hypothesis} &amp;:&amp; h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}\\<br>\textrm{Cost Function} &amp;:&amp;<br>J(\theta)=-\frac{1}{m}\sum_{i=1}^m\Bigg[y^{(i)}log\Big(h_\theta(x)\Big)+(1-y^{(i)})log\Big(1-h_\theta(x^{(i)})\Big)\Bigg]<br>\end{array}<br>$$<br>向量化表示：<br>$$<br>\begin{array}{l}<br>h=g(X\theta)\<br>J(\theta)=\frac{1}{m}\cdot\big(-y^T log(h) -(1-y)^T log(1-h)\big)<br>\end{array}<br>$$<br><strong>梯度下降</strong>：<br>$$<br>\begin{array}{l}<br>Repeat \quad {\<br>\qquad \theta_j:=\theta_j-\frac{\alpha}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})\cdot x_j^{(i)}\<br>}<br>\end{array}<br>$$<br>向量化表示：<br>$$<br>\theta:=\theta-\frac{\alpha}{m}X^T(g(X\theta)-\overrightarrow{y})<br>$$<br>👉代码实现（使用Advanced Optimization）：</p>
<ol>
<li>提供$J(\theta), \frac{\partial}{\partial\theta_j}J(\theta)$</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J, grad]</span> = <span class="title">costFunction</span><span class="params">(theta, X, y)</span></span></span><br><span class="line"><span class="comment">%COSTFUNCTION Compute cost and gradient for logistic regression</span></span><br><span class="line"><span class="comment">%   J = COSTFUNCTION(theta, X, y) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for logistic regression and the gradient of the cost</span></span><br><span class="line"><span class="comment">%   w.r.t. to the parameters.</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"></span><br><span class="line">h = sigmoid(X*theta);</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span>/m * (-y&#x27;*<span class="built_in">log</span>(h) - (<span class="number">1</span>-y)&#x27;*<span class="built_in">log</span>(<span class="number">1</span>-h));</span><br><span class="line"></span><br><span class="line">grad = <span class="number">1</span>/m * X&#x27;*(h-y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>调用 Advanced Optimization 函数解决优化问题：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">initialTheta = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure>
<h5 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h5><p>我们采用一系列的单元（逻辑）分类来完成多元分类：<br>$$<br>\begin{array}{l}<br>y \in {0,1,\cdots,n}\\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\<br>\vdots\<br>h_\theta^{(0)}(x)=P(y=0|x;\theta)\\<br>prediction = \mathop{max}\limits_{\theta}\big(h_\theta^{(i)}(x)\big)<br>\end{array}<br>$$</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78nj8fvy4j30d507agmp.jpg" alt="img"></p>
<h4 id="注：过拟合"><a href="#注：过拟合" class="headerlink" title="注：过拟合"></a>注：过拟合</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aopbltb1j30f0046dg2.jpg" alt="img"></p>
<p>过拟合对训练集中的数据预测的很好，但对没见过的新样本预测效果不佳。</p>
<p>解决过拟合的方法有：</p>
<ol>
<li><p>减少特征数量（PCA）</p>
</li>
<li><p>正则化：在代价函数中加入 $\theta$ 的权重：</p>
<p>$\mathop{min}\limits_{\theta} \dfrac{1}{2m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum_{j=1}^n \theta_j^2$</p>
<blockquote>
<p>注意，$\theta_0$是我们加上的常数项，不应该被正则化。</p>
</blockquote>
<p>代码实现：</p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J, grad]</span> = <span class="title">lrCostFunction</span><span class="params">(theta, X, y, lambda)</span></span></span><br><span class="line"><span class="comment">%LRCOSTFUNCTION Compute cost and gradient for logistic regression with </span></span><br><span class="line"><span class="comment">%regularization</span></span><br><span class="line"><span class="comment">%   J = LRCOSTFUNCTION(theta, X, y, lambda) computes the cost of using</span></span><br><span class="line"><span class="comment">%   theta as the parameter for regularized logistic regression and the</span></span><br><span class="line"><span class="comment">%   gradient of the cost w.r.t. to the parameters. </span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Unregularized cost function &amp; gradient for logistic regression</span></span><br><span class="line">h = sigmoid(X * theta);</span><br><span class="line">J = <span class="number">1</span>/m * (-y&#x27;*<span class="built_in">log</span>(h) - (<span class="number">1</span>-y)&#x27;*<span class="built_in">log</span>(<span class="number">1</span>-h));</span><br><span class="line">grad = <span class="number">1</span>/m * X&#x27;*(h-y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Regularize</span></span><br><span class="line">temp = theta;</span><br><span class="line">temp(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">J = J + lambda/(<span class="number">2</span>*m) * sum(temp.^<span class="number">2</span>);</span><br><span class="line">grad = grad + lambda/m * temp;</span><br><span class="line"></span><br><span class="line">grad = grad(:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>$$<br>\left[\begin{array}{c}x_0 \ x_1 \ x_2 \ x_3\end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(2)} \ a_2^{(2)} \ a_3^{(2)} \ \end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(3)} \ a_2^{(3)} \ a_3^{(3)} \ \end{array}\right]<br>\rightarrow<br>h_\theta(x)<br>$$</p>
<p>第一层是数据集，称为输入层，可以看作 $a^{(0)}$ ；中间是数个隐藏层，最终得到的就是预测函数，这一层叫做输出层。</p>
<p>$$<br>z^{(j)} = \Theta^{(j-1)}a^{(j-1)}<br>$$</p>
<p>$$<br>a^{(j)} = g(z^{(j)})<br>$$</p>
<p>假设有 c 个层，则:</p>
<p>$$<br>h_\Theta(x)=a^{(c+1)}=g(z^{(c+1)})<br>$$</p>
<p>例如，用一层的神经网络，我们可以建立一些表达逻辑函数的神经网络：<br>$$<br>\begin{array}{l}AND:\&amp;\Theta^{(1)} &amp;=\begin{bmatrix}-30 &amp; 20 &amp; 20\end{bmatrix} \ NOR:\&amp;\Theta^{(1)} &amp;= \begin{bmatrix}10 &amp; -20 &amp; -20\end{bmatrix} \ OR:\&amp;\Theta^{(1)} &amp;= \begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix} \\end{array}<br>$$</p>
<h5 id="多元分类-1"><a href="#多元分类-1" class="headerlink" title="多元分类"></a>多元分类</h5><p>$$<br>y^{(i)}=\begin{bmatrix}1\0\0\0\end{bmatrix},\begin{bmatrix}0\1\0\0\end{bmatrix},\begin{bmatrix}0\0\1\0\end{bmatrix},\begin{bmatrix}0\0\0\1\end{bmatrix}<br>$$</p>
<p>$$<br>\left[\begin{array}{c}x_0 \ x_1 \ x_2 \ x_3\end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(2)} \ a_2^{(2)} \ a_3^{(2)} \ … \end{array}\right]<br>\rightarrow<br>\left[\begin{array}{c}a_1^{(3)} \ a_2^{(3)} \ a_3^{(3)} \ … \end{array}\right]<br>\rightarrow<br>\cdots<br>\rightarrow<br>\left[\begin{array}{c}h_\Theta(x)_1 \ h_\Theta(x)_2 \ h_\Theta(x)_3 \ h_\Theta(x)_4 \end{array}\right]<br>$$</p>
<h5 id="神经网络的拟合"><a href="#神经网络的拟合" class="headerlink" title="神经网络的拟合"></a>神经网络的拟合</h5><table>
<thead>
<tr>
<th>Notation</th>
<th>Represent</th>
</tr>
</thead>
<tbody><tr>
<td>$L$</td>
<td>神经网络中的总层数</td>
</tr>
<tr>
<td>$s_l$</td>
<td>第$l$层中的节点数（不算偏移单元$a_0$）</td>
</tr>
<tr>
<td>$K$</td>
<td>输出节点数</td>
</tr>
</tbody></table>
<p><strong>代价函数</strong>：<br>$$<br>J(\Theta)=-\frac{1}{m}\sum_{i=1}^{m}\sum_{k=1}^{K}\Big[<br>y_k^{(i)}log\Big(\big(h_\Theta(x^{(i)})\big)<em>k\Big)+<br>(1-y_k^{(i)})log\Big(1-\big(h_\Theta(x^{(i)})\big)<em>k\Big)<br>\Big]+<br>\frac{\lambda}{2m}\sum</em>{l=1}^{L-1}\sum</em>{i=1}^{s_l}\sum_{j=1}^{s_{l+1}}\Big(\Theta_{j,i}^{(l)}\Big)^2<br>$$<br><strong>向后传播算法</strong>：<br>$$<br>\begin{array}{lll}<br>\textrm{Give training set }{(x^{(1)},y^{(1)}),…,(x^{(m)},y^{(m)})}\<br>\textrm{Set }\Delta_{i,j}^{(l)}:=0\textrm{ for each } l,i,j \textrm{ (get a matrix full of zeros)}\<br>\mathop{\textrm{For}} \textrm{ training example $t=1$ to $m$}:\<br>\qquad a^{(1)}:= x^{(t)}\<br>\qquad \textrm{Compute $a^{(l)}$ for $l=2,3,\cdots,L$ by forward propagation}\<br>\qquad \textrm{Using $y^{(t)}$ to compute } \delta^{(L)}=a^{(L)}-y^{(t)}\<br>\qquad \textrm{Compute } \delta^{(l)}=\big((\Theta^{(l)})^T\delta^{(l+1)}\big).<em>a^{(l)}.</em>(1-a^{(l)}) \textrm{ for } \delta^{(L-1)},\delta^{(L-2)},…,\delta^{(2)}\<br>\qquad \Delta^{(l)}:=\Delta^{(l)}+\delta^{(l+1)}(a^{(l)})^T\<br>\textrm{End For}\<br>D_{i,j}^{(l)}:=\frac{1}{m}\Delta_{i,j}^{(l)}\textrm{ if } j=0\<br>D_{i,j}^{(l)}:=\frac{1}{m}\big(\Delta_{i,j}^{(l)}+\lambda\Theta_{i,j}^{(l)}\big) \textrm{ if } j\neq 0 \<br>\textrm{Get }<br>\frac{\partial}{\partial\Theta_{i,j}^{(l)}}J(\Theta)=D_{i,j}^{(l)}<br>\end{array}<br>$$<br>注：上式中 $.*$ 代表 Matlab/Octave 中的 element-wise 的乘法。</p>
<p><strong>向后传播的使用</strong>：</p>
<p>先看几个涉及到的方法：</p>
<ul>
<li>参数展开：为使用优化函数，我们需要把所有的$\Theta$矩阵展开并拼接成一个长向量：</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thetaVector = [ Theta1(:); Theta2(:); Theta3(:) ];</span><br><span class="line">deltaVector = [ D1(:); D2(:); D3(:) ];</span><br></pre></td></tr></table></figure>
<p>在得到优化结果后返回原来的矩阵：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Theta1 = <span class="built_in">reshape</span>(thetaVector(<span class="number">1</span>:<span class="number">110</span>),<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(thetaVector(<span class="number">111</span>:<span class="number">220</span>),<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">Theta3 = <span class="built_in">reshape</span>(thetaVector(<span class="number">221</span>:<span class="number">231</span>),<span class="number">1</span>,<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>梯度检查：利用 $\frac{\partial}{\partial\Theta_j}J(\Theta) \approx \frac{J(\Theta_1,…,\Theta_j+\epsilon,…,\Theta_n)-J(\Theta_1,…,\Theta_j-\epsilon,…,\Theta_n)}{2\epsilon}$ 取一个小的邻域如 $\epsilon=10^{-4}$，可以检查我们用向后传播求出的梯度是否正确（若正确，有 gradApprox ≈ deltaVector 成立）。代码实现：</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">	thetaPlus = theta;</span><br><span class="line">	thetaPlus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">	thetaMinus = theta;</span><br><span class="line">	thetaMinus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">	gradApprox(<span class="built_in">i</span>) = (J(thetaPlus) - J(thetaMinus)) / (<span class="number">2</span>*epsilon);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>随即初始化：在开始时，将 $\Theta_{ij}^{(l)}$ 随机初始化，应保证随机值的取值在一个 $[-\epsilon,\epsilon]$ 的范围内（这个 $\epsilon$ 与梯度检查中的无关）。代码实现：</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.</span><br><span class="line"></span><br><span class="line">Theta1 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta2 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br></pre></td></tr></table></figure>
<p>将上述技巧与向后传播算法结合，我们就得到了了训练神经网络的方法：</p>
<ol>
<li>随机初始化</li>
<li>向前传播得到 $h_\Theta(x^{(i)})$ 对任意 $x^{(i)}$</li>
<li>计算代价函数</li>
<li>使用向后传播计算偏导</li>
<li>利用梯度检查验证向后传播是否正确，若没问题则关闭梯度检查功能</li>
<li>使用梯度下降或优化函数得到$\Theta$</li>
</ol>
<p>👉代码实现：</p>
<ol>
<li>随机初始化</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">W</span> = <span class="title">randInitializeWeights</span><span class="params">(L_in, L_out)</span></span></span><br><span class="line"><span class="comment">%RANDINITIALIZEWEIGHTS Randomly initialize the weights of a layer with L_in</span></span><br><span class="line"><span class="comment">%incoming connections and L_out outgoing connections</span></span><br><span class="line"><span class="comment">%   W = RANDINITIALIZEWEIGHTS(L_in, L_out) randomly initializes the weights </span></span><br><span class="line"><span class="comment">%   of a layer with L_in incoming connections and L_out outgoing </span></span><br><span class="line"><span class="comment">%   connections. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Note that W should be set to a matrix of size(L_out, 1 + L_in) as</span></span><br><span class="line"><span class="comment">%   the first column of W handles the &quot;bias&quot; terms</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">W = <span class="built_in">zeros</span>(L_out, <span class="number">1</span> + L_in);</span><br><span class="line"></span><br><span class="line"><span class="comment">% epsilon_init = 0.12</span></span><br><span class="line">epsilon_init = <span class="built_in">sqrt</span>(<span class="number">6</span> / (L_in + L_out));</span><br><span class="line">W = <span class="built_in">rand</span>(L_out, <span class="number">1</span> + L_in) * (<span class="number">2</span> * epsilon_init) - epsilon_init;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>计算代价</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J grad]</span> = <span class="title">nnCostFunction</span><span class="params">(nn_params, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   input_layer_size, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   hidden_layer_size, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   num_labels, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                   X, y, lambda)</span></span></span><br><span class="line"><span class="comment">%NNCOSTFUNCTION Implements the neural network cost function for a two layer</span></span><br><span class="line"><span class="comment">%neural network which performs classification</span></span><br><span class="line"><span class="comment">%   [J grad] = NNCOSTFUNCTON(nn_params, hidden_layer_size, num_labels, ...</span></span><br><span class="line"><span class="comment">%   X, y, lambda) computes the cost and gradient of the neural network. The</span></span><br><span class="line"><span class="comment">%   parameters for the neural network are &quot;unrolled&quot; into the vector</span></span><br><span class="line"><span class="comment">%   nn_params and need to be converted back into the weight matrices. </span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">%   The returned parameter grad should be a &quot;unrolled&quot; vector of the</span></span><br><span class="line"><span class="comment">%   partial derivatives of the neural network.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Reshape nn_params back into the parameters Theta_1 and Theta_2, the weight matrices</span></span><br><span class="line"><span class="comment">% for our 2 layer neural network</span></span><br><span class="line">Theta_1 = <span class="built_in">reshape</span>(nn_params(<span class="number">1</span>:hidden_layer_size * (input_layer_size + <span class="number">1</span>)), ...</span><br><span class="line">                 hidden_layer_size, (input_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Theta_2 = <span class="built_in">reshape</span>(nn_params((<span class="number">1</span> + (hidden_layer_size * (input_layer_size + <span class="number">1</span>))):<span class="keyword">end</span>), ...</span><br><span class="line">                 num_labels, (hidden_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Setup some useful variables</span></span><br><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line">K = num_labels;</span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">Theta_1_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_1));</span><br><span class="line">Theta_2_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_2));</span><br><span class="line"></span><br><span class="line"><span class="comment">% y(5000x1) -&gt; Y(5000x10)</span></span><br><span class="line">Y = <span class="built_in">zeros</span>(m, K);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : m</span><br><span class="line">    Y(<span class="built_in">i</span>, y(<span class="built_in">i</span>)) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Feedforward</span></span><br><span class="line">a_1 = X;</span><br><span class="line">a_1_bias = [<span class="built_in">ones</span>(m, <span class="number">1</span>), a_1];</span><br><span class="line"></span><br><span class="line">z_2 = a_1_bias * Theta_1&#x27;;</span><br><span class="line">a_2 = sigmoid(z_2);</span><br><span class="line">a_2_bias = [<span class="built_in">ones</span>(m, <span class="number">1</span>), a_2];</span><br><span class="line"></span><br><span class="line">z_3 = a_2_bias * Theta_2&#x27;;</span><br><span class="line">a_3 = sigmoid(z_3);</span><br><span class="line">h = a_3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Cost Function</span></span><br><span class="line"><span class="comment">% for i = 1 : K</span></span><br><span class="line"><span class="comment">%     yK = Y(:, i);</span></span><br><span class="line"><span class="comment">%     hK = h(:, i);</span></span><br><span class="line"><span class="comment">%     J += 1/m * (-yK&#x27;*log(hK) - (1-yK)&#x27;*log(1-hK));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% J can be get by element-wise compute more elegantly.</span></span><br><span class="line">J = <span class="number">1</span>/m * sum(sum((-Y.*<span class="built_in">log</span>(h) - (<span class="number">1</span>-Y).*<span class="built_in">log</span>(<span class="number">1</span>-h))));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Regularize</span></span><br><span class="line">J = J + lambda/(<span class="number">2</span>*m) * (sum(sum(Theta_1(:, <span class="number">2</span>:<span class="keyword">end</span>).^<span class="number">2</span>)) + sum(sum(Theta_2(:, <span class="number">2</span>:<span class="keyword">end</span>).^<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Backpropagation</span></span><br><span class="line"></span><br><span class="line">delta_3 = a_3 .- Y;</span><br><span class="line">delta_2 = (delta_3 * Theta_2) .* sigmoidGradient([<span class="built_in">ones</span>(m, <span class="number">1</span>), z_2]);</span><br><span class="line"><span class="comment">% sigmoidGradient: return g = sigmoid(z) .* (1 - sigmoid(z));</span></span><br><span class="line">delta_2 = delta_2(:, <span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">Delta_1 = delta_2&#x27; * a_1_bias;</span><br><span class="line">Delta_2 = delta_3&#x27; * a_2_bias;</span><br><span class="line"></span><br><span class="line">Theta_1_grad = Delta_1 ./ m + lambda/m * [<span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_1, <span class="number">1</span>), <span class="number">1</span>), Theta_1(:, <span class="number">2</span>:<span class="keyword">end</span>)];</span><br><span class="line">Theta_2_grad = Delta_2 ./ m + lambda/m * [<span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta_2, <span class="number">1</span>), <span class="number">1</span>), Theta_2(:, <span class="number">2</span>:<span class="keyword">end</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Unroll gradients</span></span><br><span class="line">grad = [Theta_1_grad(:) ; Theta_2_grad(:)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>预测</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span> = <span class="title">predict</span><span class="params">(Theta1, Theta2, X)</span></span></span><br><span class="line"><span class="comment">%PREDICT Predict the label of an input given a trained neural network</span></span><br><span class="line"><span class="comment">%   p = PREDICT(Theta1, Theta2, X) outputs the predicted label of X given the</span></span><br><span class="line"><span class="comment">%   trained weights of a neural network (Theta1, Theta2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Useful values</span></span><br><span class="line">m = <span class="built_in">size</span>(X, <span class="number">1</span>);</span><br><span class="line">num_labels = <span class="built_in">size</span>(Theta2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">h1 = sigmoid([<span class="built_in">ones</span>(m, <span class="number">1</span>) X] * Theta1&#x27;);</span><br><span class="line">h2 = sigmoid([<span class="built_in">ones</span>(m, <span class="number">1</span>) h1] * Theta2&#x27;);</span><br><span class="line">[dummy, p] = <span class="built_in">max</span>(h2, [], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>驱动</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">input_layer_size  = <span class="number">400</span>;  <span class="comment">% 20x20 Input Images of Digits</span></span><br><span class="line">hidden_layer_size = <span class="number">25</span>;   <span class="comment">% 25 hidden units</span></span><br><span class="line">num_labels = <span class="number">10</span>;          <span class="comment">% 10 labels, from 1 to 10   </span></span><br><span class="line">                          <span class="comment">% (note that we have mapped &quot;0&quot; to label 10)</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nInitializing Neural Network Parameters ...\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;Xy.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nTraining Neural Network... \n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%  value to see how more training helps.</span></span><br><span class="line">options = optimset(<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">lambda = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Create &quot;short hand&quot; for the cost function to be minimized</span></span><br><span class="line">costFunction = @(p) nnCostFunction(p, ...</span><br><span class="line">                                   input_layer_size, ...</span><br><span class="line">                                   hidden_layer_size, ...</span><br><span class="line">                                   num_labels, X, y, lambda);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Now, costFunction is a function that takes in only one argument (the</span></span><br><span class="line"><span class="comment">% neural network parameters)</span></span><br><span class="line">[nn_params, cost] = fmincg(costFunction, initial_nn_params, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Obtain Theta1 and Theta2 back from nn_params</span></span><br><span class="line">Theta1 = <span class="built_in">reshape</span>(nn_params(<span class="number">1</span>:hidden_layer_size * (input_layer_size + <span class="number">1</span>)), ...</span><br><span class="line">                 hidden_layer_size, (input_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(nn_params((<span class="number">1</span> + (hidden_layer_size * (input_layer_size + <span class="number">1</span>))):<span class="keyword">end</span>), ...</span><br><span class="line">                 num_labels, (hidden_layer_size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">pred = predict(Theta1, Theta2, X);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nTraining Set Accuracy: %f\n&#x27;</span>, <span class="built_in">mean</span>(double(pred == y)) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><p>优化目标：<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tx^{(i)})</p>
<ul>
<li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tx^{(i)})\large]</li>
<li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>当 $C$ 值比较大时，这个优化目标会选择将第一个求和项趋于零，这样优化目标就变成了：<br>$$<br>\begin{array}{l}<br>  \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2\\<br>  s.t. \quad \begin{array}{l}<pre><code>  \theta^Tx^&#123;(i)&#125; \ge 1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=1\\
  \theta^Tx^&#123;(i)&#125; \le -1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=0</code></pre>
  \end{array}<br>\end{array}<br>$$<br>由欧氏空间的知识：<br>$$<br>\begin{array}{ccl}<br>||u|| &amp;=&amp; \textrm{length of vector } u= \sqrt{u_1^2+u_2^2}\<br>p &amp;=&amp; \textrm{length of projection of } v \textrm{ onto } u \textrm{ (signed)} \ \<br>u^Tv &amp;=&amp; p \cdot ||u||<br>\end{array}<br>$$<br>上式可表示为：<br>$$<br>\begin{array}{l}<br>  \min_\theta \frac{1}{2}\sum_{j=1}^{n}\theta_j^2<br>  =\frac{1}{2}\Big(\sqrt{\sum_{j=1}^n\theta_j^2}\Big)^2<br>  =\frac{1}{2}||\theta||^2 \\<br>  s.t. \quad \begin{array}{l}<pre><code>  p^&#123;(i)&#125;\cdot ||\theta|| \ge 1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=1\\
  p^&#123;(i)&#125;\cdot ||\theta|| \le -1 &amp; \textrm&#123;if &#125; y^&#123;(i)&#125;=0</code></pre>
  \end{array}\\<br>  \textrm{where $p^{(i)}$ is the projection of $x^{(i)}$ onto the vector $\theta$.}<br>\end{array}<br>$$<br>SVM 会选择最大的间隙：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gax9ziqe3sj324i0nu0z9.jpg" alt="屏幕快照 2019-10-31 12.58.43"></p>
<h5 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a>核方法</h5><p>面对如下分类问题：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaxa3eq7zuj30c5083gm3.jpg" alt="image-20191102114127170"></p>
<p>我们可以使用多项式来回归，例如，当 $\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1x_2+\theta_4x_1^2+\theta_5x_2^2+\cdots\ge 0$ 时预测 $y=1$；</p>
<p>这样有太多多项式比较麻烦，我们可以考虑如下方法：<br>$$<br>\begin{array}{lcl}<br>\textrm{Predict } y=1 &amp;\textrm{if}&amp;\theta_0+\theta_1f_1+\theta_2f_2+\theta_3f_3+\cdots\ge 0<br>\end{array}<br>$$<br>这里的 $f_1=x_1,f_2=x_2,f_3=x_1x_2,f_4=x_1^2,…$</p>
<p>我们用 $f_i$ 替换了多项式，避免了高次项的麻烦，那么如何确定 $f_i$？大概的思想如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jljliww8j30o90dmwjt.jpg" alt="image-20191102124615797"></p>
<p>为方便描述，假设我们只有 $x_0,x_1,x_2$，并且只打算构造 $f_1,f_2,f_3$。那么，不管 $x_0$（偏移项），我们从 $x_1$-$x_2$ 的图像中选择 3 个点，记为 $l^{(1)},l^{(2)},l^{(3)}$，称之为<em>标记点</em>。任给 $x$，我们通过计算其与各标记点的临近程度得到一组 $f_i$：<br>$$<br>f_i = \mathop{\textrm{similarity}}(x,l^{(i)}) = \exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{\sum_{j=1}^n(x_j-l_j^{(i)})^2}{2\sigma^2})<br>$$<br>这里具体的 similarity 函数称为<em>核函数</em>，核函数多种多样。我们这里写的是很常用的 $\exp(-\frac{\sum_{j=1}^n(x_j-l_j^{(i)})^2}{2\sigma^2})$ ，称为 Gaussian Kernel，他的代码实现如下：</p>
<p>由这种方法，我们知道，给定 $x$，对每个 $l^{(i)}$ 我们会得到一个 $f_i$，满足：</p>
<ol>
<li>当 $x$ 接近 $l^{(i)}$ 时</li>
</ol>
<p>$$<br>f_i \approx \lim_{x\to l^{(i)}}\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{0^2}{2\sigma^2}) = 1<br>$$</p>
<ol start="2">
<li>当 $x$ 远离 $l^{(i)}$ 时</li>
</ol>
<p>$$<br>f_i \approx \lim_{||x-l^{(i)}||\to +\infin}\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}) = \exp(-\frac{\infin^2}{2\sigma^2}) = 0<br>$$</p>
<p>$\sigma$ 的选择会影响 $f_i$ 值随 $x$ 远离 $l^{(i)}$ 而下降的速度，$\sigma^2$ 越大，$f_i$减小地越慢：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmrwo86pj30ph0dwwm1.jpg" alt="image-20191102132852867"></p>
<p>使用核方法，我们可以做出这种预测：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jmzc2qq4j30ot0ditej.jpg" alt="image-20191102133600603"></p>
<p>当且仅当给定$x$临近$l^{(1)}$ 或 $l^{(2)}$ 时预测 1，否则预测 0.</p>
<h5 id="SVM-中使用核"><a href="#SVM-中使用核" class="headerlink" title="SVM 中使用核"></a>SVM 中使用核</h5><ol>
<li><p>给定训练集 $(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})$</p>
</li>
<li><p>选择标记点：$l^{(i)}=x^{(i)} \quad \textrm{for }i=1,2,\cdots,m$</p>
</li>
<li><p>对于样本 $x$，计算核：$f_i=\mathop{\textrm{similarity}}(x,l^{(i)}) \quad \textrm{for }i=1,2,\cdots,m$</p>
</li>
<li><p>令 $f=[f_0,f_1,f_2,\cdots,f_m]^T$，其中 $f_0 \equiv 1$。</p>
</li>
</ol>
<p>预测：</p>
<ul>
<li>给定 $x$，计算 $f\in\R^{m+1}$</li>
<li>预测 $y=1$ 如果 $\theta^Tf=\theta_0f_0+\theta_1f_1+\cdots\ge 0$</li>
</ul>
<p>训练：<br>$$<br>\min_\theta<br>C\sum_{i=1}^m \large[ y^{(i)} \mathop{\textrm{cost}_1}(\theta^Tf^{(i)})</p>
<ul>
<li>(1 - y^{(i)})\ \mathop{\textrm{cost}_0}(\theta^Tf^{(i)})\large]</li>
<li>\frac{1}{2}\sum_{j=1}^n \theta_j^2<br>$$<br>实现：</li>
</ul>
<p>我们可以利用诸如 liblinear, libsvm 之类的库来得到 SVM 的 参数 $\theta$，要使用这些库，我们一般需要做以下工作：</p>
<ul>
<li>选择参数 $C$</li>
<li>选择核函数<ul>
<li><strong>No kernel</strong>（即线性核，亦即做逻辑回归：Predict $y=1$ if $\theta^Tx\ge0$），适用于 <strong>n大 m小</strong> 的情况（避免过拟合）</li>
<li><strong>Gaussian kernel</strong>（$f_i=\exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})\textrm{ where } l^{(i)}=x^{(i)} \textrm{ for } i=1,\cdots,m$）适用于 <strong>m大 n小</strong> 的情况（可拟合更复杂的非线性边界）</li>
</ul>
</li>
<li>提供核函数（Gaussian kernel 为例）：</li>
</ul>
<p>$$<br>\begin{array}{l}<br>\textrm{function f = kernel(x1, x2)}\<br>\qquad \textrm{f} = \exp(-\frac{||\textrm{x1}-\textrm{x2}||^2}{2\sigma^2})\<br>\textrm{return}<br>\end{array}<br>$$</p>
<p>注意：使用 Gaussian Kernel 前务必做特征缩放！</p>
<p>👉无核函数的代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sim</span> = <span class="title">linearKernel</span><span class="params">(x1, x2)</span></span></span><br><span class="line"><span class="comment">%LINEARKERNEL returns a linear kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   sim = linearKernel(x1, x2) returns a linear kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   and returns the value in sim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Ensure that x1 and x2 are column vectors</span></span><br><span class="line">x1 = x1(:); x2 = x2(:);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the kernel</span></span><br><span class="line">sim = x1&#x27; * x2;  <span class="comment">% dot product</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>👉高斯核的代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sim</span> = <span class="title">gaussianKernel</span><span class="params">(x1, x2, sigma)</span></span></span><br><span class="line"><span class="comment">%RBFKERNEL returns a radial basis function kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   sim = gaussianKernel(x1, x2) returns a gaussian kernel between x1 and x2</span></span><br><span class="line"><span class="comment">%   and returns the value in sim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Ensure that x1 and x2 are column vectors</span></span><br><span class="line">x1 = x1(:); x2 = x2(:);</span><br><span class="line"></span><br><span class="line">sim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sim = <span class="built_in">exp</span>(-sum((x1 - x2).^<span class="number">2</span>) / (<span class="number">2</span> * sigma ^ <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>👉SVM 示例：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Load X, y, Xtest and ytest</span></span><br><span class="line">load(<span class="string">&#x27;data.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% SVM Parameters</span></span><br><span class="line">C = <span class="number">1</span>;         <span class="comment">% C = 1 ~ 100 is fine</span></span><br><span class="line">sigma = <span class="number">0.1</span>;    <span class="comment">% sigma = 0.03 ~ 0.1 gives somewhat good boundary, less is better</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% We set the tolerance and max_passes lower here so that the code will run</span></span><br><span class="line"><span class="comment">% faster. However, in practice, you will want to run the training to</span></span><br><span class="line"><span class="comment">% convergence.</span></span><br><span class="line">model= svmTrain(X, y, C, @(x1, x2) gaussianKernel(x1, x2, sigma)); </span><br><span class="line">p = svmPredict(model, Xtest);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;Test Accuracy: %f\n&#x27;</span>, <span class="built_in">mean</span>(double(p == ytest)) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h5 id="多元分类-2"><a href="#多元分类-2" class="headerlink" title="多元分类"></a>多元分类</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8jul8myufj30mv0cz0xu.jpg" alt="image-20191102171432072"></p>
<h4 id="逻辑回归-vs-神经网络-vs-SVM"><a href="#逻辑回归-vs-神经网络-vs-SVM" class="headerlink" title="逻辑回归 vs 神经网络 vs SVM"></a>逻辑回归 vs 神经网络 vs SVM</h4><p>$n$ = 特征数（$x\in\R^{n+1}$）</p>
<p>$m$ = 训练样本数</p>
<ul>
<li>n相对于m大 （e.g. $n=10,000, m=10 \sim 1000$）<ul>
<li>逻辑回归，或 无核SVM</li>
</ul>
</li>
<li>n小、m适中（e.g. $n=1\sim1000,m=50,000$）<ul>
<li>用 Gaussian 核 SVM</li>
</ul>
</li>
<li>n小、m大<ul>
<li>创造/添加特征，然后用 逻辑回归或无核SVM</li>
</ul>
</li>
</ul>
<p>神经网络通常可以解决上述任何一种情况，但可能相对较慢。</p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习是只给x数据的，不给y。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8n62mi54pj30lw0catay.jpg" alt="屏幕快照 2019-11-05 14.49.05"></p>
<h3 id="K-Means-聚类"><a href="#K-Means-聚类" class="headerlink" title="K-Means 聚类"></a>K-Means 聚类</h3><blockquote>
<p>把一堆东西自动分成K堆。</p>
</blockquote>
<p>输入：</p>
<ul>
<li>$K$：聚类的个数</li>
<li>${x^{(1)},x^{(2)},\cdots,x^{(m)}}$：训练集</li>
</ul>
<p>输出：</p>
<ul>
<li>$K$ 个类</li>
</ul>
<p>K-Means算法：<br>$$<br>\begin{array}{l}</p>
<p>\textrm{Randomly initialize $K$ cluster centroids $\mu_1, \mu_2,…\mu_k \in \R^n$}\<br>\textrm{Repeat }{\<br>\qquad \textrm{for $i=1$ to $m$:}\qquad\textrm{// Cluster assignment step}\<br>\qquad\qquad c^{(i)} := k \ \textrm{ s.t. } \min_k||x^{(i)}-\mu_k||^2 \<br>\qquad \textrm{for $k=1$ to $K$:}\qquad\textrm{// Move centroid step}\<br>\qquad\qquad \mu_k:= \textrm{average (mean) of points assigned to cluster $k$}\<br>}\</p>
<p>\end{array}<br>$$<br>代价函数：<br>$$<br>J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)=\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}-\mu_{c^{(i)}}||^2<br>$$<br>优化目标：<br>$$<br>\min_{<br>\begin{array}{c}<br>    {1}c^{(1)},\cdots,c^{(m)},\<br>    \mu_1,\cdots,\mu_K<br>\end{array}}<br>J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)<br>$$<br>得到较优解(不一定能得到最优解)的算法：<br>$$<br>\begin{array}{l}<br>\textrm{For $i=1$ to $100$ &lt;or 50~1000&gt; {}\<br>\qquad\textrm{Randomly initialize K-means.}\<br>\qquad\textrm{Run K-means. Get $c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_k$}\<br>\qquad\textrm{Compute cost function (distortion):}\<br>\qquad\qquad J(c^{(1)},\cdots,c^{(m)},\mu_1,\cdots,\mu_K)\<br>\textrm{}}\<br>\textrm{pick clustering that gave lowest $J$.}<br>\end{array}<br>$$<br>$K$的选择：</p>
<ol>
<li>更具实际问题的需求易得；</li>
<li>选择拐点：<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaxja4d68ej30cb0c3jro.jpg" alt="image-20191106171612460"></li>
</ol>
<p>👉<strong>代码实现</strong></p>
<ol>
<li>找最近的类中心：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idx</span> = <span class="title">findClosestCentroids</span><span class="params">(X, centroids)</span></span></span><br><span class="line"><span class="comment">%FINDCLOSESTCENTROIDS computes the centroid memberships for every example</span></span><br><span class="line"><span class="comment">%   idx = FINDCLOSESTCENTROIDS (X, centroids) returns the closest centroids</span></span><br><span class="line"><span class="comment">%   in idx for a dataset X where each row is a single example. idx = m x 1 </span></span><br><span class="line"><span class="comment">%   vector of centroid assignments (i.e. each entry in range [1..K])</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Set K</span></span><br><span class="line">K = <span class="built_in">size</span>(centroids, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">idx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X,<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(X, <span class="number">1</span>)</span><br><span class="line">    min_j = <span class="number">0</span>;</span><br><span class="line">    min_l = Inf;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : <span class="built_in">size</span>(centroids, <span class="number">1</span>)</span><br><span class="line">        l = sum((X(<span class="built_in">i</span>, :) - centroids(<span class="built_in">j</span>, :)) .^ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> l &lt;= min_l</span><br><span class="line">            min_j = <span class="built_in">j</span>;</span><br><span class="line">            min_l = l;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    idx(<span class="built_in">i</span>) = min_j;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>计算中心:</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">centroids</span> = <span class="title">computeCentroids</span><span class="params">(X, idx, K)</span></span></span><br><span class="line"><span class="comment">%COMPUTECENTROIDS returns the new centroids by computing the means of the </span></span><br><span class="line"><span class="comment">%data points assigned to each centroid.</span></span><br><span class="line"><span class="comment">%   centroids = COMPUTECENTROIDS(X, idx, K) returns the new centroids by </span></span><br><span class="line"><span class="comment">%   computing the means of the data points assigned to each centroid. It is</span></span><br><span class="line"><span class="comment">%   given a dataset X where each row is a single data point, a vector</span></span><br><span class="line"><span class="comment">%   idx of centroid assignments (i.e. each entry in range [1..K]) for each</span></span><br><span class="line"><span class="comment">%   example, and K, the number of centroids. You should return a matrix</span></span><br><span class="line"><span class="comment">%   centroids, where each row of centroids is the mean of the data points</span></span><br><span class="line"><span class="comment">%   assigned to it.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Useful variables</span></span><br><span class="line">[m n] = <span class="built_in">size</span>(X);</span><br><span class="line"></span><br><span class="line">centroids = <span class="built_in">zeros</span>(K, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : K</span><br><span class="line">    ck = <span class="built_in">find</span>(idx == <span class="built_in">i</span>);</span><br><span class="line">    centroids(<span class="built_in">i</span>, :) = sum(X(ck,:)) / <span class="built_in">size</span>(ck, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行K-Means</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[centroids, idx]</span> = <span class="title">runkMeans</span><span class="params">(X, initial_centroids, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                      max_iters, plot_progress)</span></span></span><br><span class="line"><span class="comment">%RUNKMEANS runs the K-Means algorithm on data matrix X, where each row of X</span></span><br><span class="line"><span class="comment">%is a single example</span></span><br><span class="line"><span class="comment">%   [centroids, idx] = RUNKMEANS(X, initial_centroids, max_iters, ...</span></span><br><span class="line"><span class="comment">%   plot_progress) runs the K-Means algorithm on data matrix X, where each </span></span><br><span class="line"><span class="comment">%   row of X is a single example. It uses initial_centroids used as the</span></span><br><span class="line"><span class="comment">%   initial centroids. max_iters specifies the total number of interactions </span></span><br><span class="line"><span class="comment">%   of K-Means to execute. plot_progress is a true/false flag that </span></span><br><span class="line"><span class="comment">%   indicates if the function should also plot its progress as the </span></span><br><span class="line"><span class="comment">%   learning happens. This is set to false by default. runkMeans returns </span></span><br><span class="line"><span class="comment">%   centroids, a Kxn matrix of the computed centroids and idx, a m x 1 </span></span><br><span class="line"><span class="comment">%   vector of centroid assignments (i.e. each entry in range [1..K])</span></span><br><span class="line"><span class="comment">% 若使用 plot_progress 需要额外的画图函数实现，这里没有给出.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Set default value for plot progress</span></span><br><span class="line"><span class="keyword">if</span> ~exist(<span class="string">&#x27;plot_progress&#x27;</span>, <span class="string">&#x27;var&#x27;</span>) || <span class="built_in">isempty</span>(plot_progress)</span><br><span class="line">    plot_progress = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the data if we are plotting progress</span></span><br><span class="line"><span class="keyword">if</span> plot_progress</span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize values</span></span><br><span class="line">[m n] = <span class="built_in">size</span>(X);</span><br><span class="line">K = <span class="built_in">size</span>(initial_centroids, <span class="number">1</span>);</span><br><span class="line">centroids = initial_centroids;</span><br><span class="line">previous_centroids = centroids;</span><br><span class="line">idx = <span class="built_in">zeros</span>(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Run K-Means</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:max_iters</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Output progress</span></span><br><span class="line">    fprintf(<span class="string">&#x27;K-Means iteration %d/%d...\n&#x27;</span>, <span class="built_in">i</span>, max_iters);</span><br><span class="line">    <span class="keyword">if</span> exist(<span class="string">&#x27;OCTAVE_VERSION&#x27;</span>)</span><br><span class="line">        fflush(stdout);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% For each example in X, assign it to the closest centroid</span></span><br><span class="line">    idx = findClosestCentroids(X, centroids);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Optionally, plot progress here</span></span><br><span class="line">    <span class="keyword">if</span> plot_progress</span><br><span class="line">        plotProgresskMeans(X, centroids, previous_centroids, idx, K, <span class="built_in">i</span>);</span><br><span class="line">        previous_centroids = centroids;</span><br><span class="line">        fprintf(<span class="string">&#x27;Press enter to continue.\n&#x27;</span>);</span><br><span class="line">        input(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Given the memberships, compute new centroids</span></span><br><span class="line">    centroids = computeCentroids(X, idx, K);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Hold off if we are plotting progress</span></span><br><span class="line"><span class="keyword">if</span> plot_progress</span><br><span class="line">    <span class="built_in">hold</span> off;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>驱动脚本：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Load an example dataset</span></span><br><span class="line">load(<span class="string">&#x27;data.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Settings for running K-Means</span></span><br><span class="line">K = <span class="number">3</span>;</span><br><span class="line">max_iters = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% For consistency, here we set centroids to specific values</span></span><br><span class="line"><span class="comment">% but in practice you want to generate them automatically, such as by</span></span><br><span class="line"><span class="comment">% settings them to be random examples (as can be seen in</span></span><br><span class="line"><span class="comment">% kMeansInitCentroids).</span></span><br><span class="line">initial_centroids = [<span class="number">3</span> <span class="number">3</span>; <span class="number">6</span> <span class="number">2</span>; <span class="number">8</span> <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Run K-Means algorithm. The &#x27;true&#x27; at the end tells our function to plot</span></span><br><span class="line"><span class="comment">% the progress of K-Means</span></span><br><span class="line">[centroids, idx] = runkMeans(X, initial_centroids, max_iters, <span class="built_in">true</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;\nK-Means Done.\n\n&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="PCA-维数约减"><a href="#PCA-维数约减" class="headerlink" title="PCA 维数约减"></a>PCA 维数约减</h3><blockquote>
<p>主成分分析：把n维的数据(投影)降到k维，略去不重要的部分(k&lt;=n)。</p>
</blockquote>
<p><strong>PCA算法</strong>：</p>
<ol>
<li><p>数据预处理</p>
<p>训练集：$x^{(1)},x^{(2)},\cdots,x^{(m)}$</p>
<p>预处理(feature scaling &amp; mean normalization):</p>
<ul>
<li><p>$\mu_j=\frac{1}{m}\sum_{i=1}^m x_j^{(i)},\qquad s_j=\textrm{standard deviation of feature }j$</p>
</li>
<li><p>Replace each $x_j^{(i)}$ with $\frac{x_j-\mu_j}{s_j}$</p>
</li>
</ul>
</li>
</ol>
<p>2)降维</p>
<ol>
<li>计算协方差矩阵$\Sigma$（这个矩阵记做大Sigma，注意和求和号区分）：<br>$$<br>\Sigma = \frac{1}{m}\sum_{i=1}^n(x^{(i)})(x^{(i)})^T<br>$$</li>
<li>求$\Sigma$的特征值(实际上是奇异值分解)：<code>[U, S, V] = svd(Sigma);</code></li>
<li>从上一步svd得到:<br>$$<br>U = \left[\begin{array}{cccc}<br>| &amp; | &amp;  &amp; |\<br>u^{(1)} &amp; u^{(2)} &amp; \cdots &amp; u^{(n)}\<br>| &amp; | &amp;  &amp; |<br>\end{array}\right]<br>\in \R^{n\times n}<br>\Rightarrow<br>U_{reduce}=\left[\begin{array}{cccc}<br>| &amp; | &amp;  &amp; |\<br>u^{(1)} &amp; u^{(2)} &amp; \cdots &amp; u^{(k)}\<br>| &amp; | &amp;  &amp; |<br>\end{array}\right]<br>$$</li>
<li>完成降维：$x\in\R^n\to z\in\R^k$:<br>$$<br>z = U_{reduce}^Tx<br>=\left[\begin{array}{ccc}</li>
</ol>
<p>   – &amp; (u^{(1)})^T &amp; –\<br>    &amp; \vdots &amp; \<br>   – &amp; (u^{(k)})^T &amp; –\<br>   \end{array}\right]x<br>$$</p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% do feature scaling &amp; mean normalization</span></span><br><span class="line"></span><br><span class="line">Sigma = <span class="number">1</span>/m * X&#x27; * X;</span><br><span class="line">[U, S, V] = svd(Sigma);</span><br><span class="line"></span><br><span class="line">Ureduce = U(:, <span class="number">1</span>:K);</span><br><span class="line">Z = X * Ureduce;</span><br></pre></td></tr></table></figure>
<p><strong>数据复原</strong>：将数据还原到原来的维度（$z\in\R^k \to x_{approx}\in\R^n$）：<br>$$<br>x_{approx}=U_{reduce}z<br>$$<br>一般情况下 $x \neq x_{approx}$，我们只能期望 $x_{approx}$ 尽量接近 $x$. </p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ta88gafkj30oz0djaeo.jpg" alt="image-20191110215011122"></p>
<p><strong>$k$(主成分个数)的选择</strong></p>
<p>一般，选择 $k$ 为使得下式成立的最小值：<br>$$<br>\frac{\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}\le0.01<br>$$<br>算法：<br>$$<br>\begin{array}{l}<br>\textrm{Try PCA with } k=1,\cdots,n:\<br>\quad \textrm{Compute } U_{reduce},z^{(1)},\cdots,z^{(m)},x_{approx}^{(1)},\cdots,x_{approx}^{m}\<br>\quad \textrm{Check if } \frac{\frac{1}{m}\sum_{i=1}^m||x^{(i)}-x_{approx}^{(i)}||^2}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}\le0.01<br>\end{array}<br>$$</p>
<h3 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h3><blockquote>
<p>从一堆数据中找出异常于其他的。</p>
</blockquote>
<p>问题描述：给定数据集 ${x^{(1)},x^{(2)},\cdots,x^{(m)}}$，通过训练，判断 $x_{test}$ 是否异常。</p>
<p>要解决这个问题，我们可以对$p(x)$（概率）建立一个模型，选择一个临界值 $\epsilon$，使：<br>$$<br>\begin{array}{l}<br>p(x_{test})&lt;\epsilon \Rightarrow \textrm{anomaly}\<br>p(x_{test})\ge\epsilon \Rightarrow \textrm{OK}<br>\end{array}<br>$$<br>这样问题可以转化为<em>密度值估计</em>。我们常用高斯分布解决这个问题。</p>
<h4 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h4><p>$x$ 服从高斯分布：$x \sim \mathcal{N}(\mu,\sigma^2)$</p>
<p>则，$x$ 的概率为：<br>$$<br>p(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)<br>$$<br>其中参数 $\mu$ 和 $\sigma$ 由下式确定（这是在机器学习里常用的格式，不一定和数学里的一样）：<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}<br>$$</p>
<p>$$<br>\sigma^2=\frac{1}{m}\sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^2<br>$$</p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[mu sigma2]</span> = <span class="title">estimateGaussian</span><span class="params">(X)</span></span></span><br><span class="line"><span class="comment">%ESTIMATEGAUSSIAN This function estimates the parameters of a </span></span><br><span class="line"><span class="comment">%Gaussian distribution using the data in X</span></span><br><span class="line"><span class="comment">%   [mu sigma2] = estimateGaussian(X), </span></span><br><span class="line"><span class="comment">%   The input X is the dataset with each n-dimensional data point in one row</span></span><br><span class="line"><span class="comment">%   The output is an n-dimensional vector mu, the mean of the data set</span></span><br><span class="line"><span class="comment">%   and the variances sigma^2, an n x 1 vector</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Useful variables</span></span><br><span class="line">[m, n] = <span class="built_in">size</span>(X);</span><br><span class="line"></span><br><span class="line">mu = <span class="built_in">zeros</span>(n, <span class="number">1</span>);</span><br><span class="line">sigma2 = <span class="built_in">zeros</span>(n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mu = <span class="built_in">mean</span>(X);</span><br><span class="line">sigma2 = var(X) * (m - <span class="number">1</span>) / m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<p>借此我们便可得到异常检查算法：</p>
<h5 id="异常检查算法"><a href="#异常检查算法" class="headerlink" title="异常检查算法"></a>异常检查算法</h5><ol>
<li>选择认为可能表现出样本异常的数据特征 $x_i$</li>
<li>计算参数 $\mu_1,\cdots,\mu_n,\sigma_1^2,\cdots,\sigma_n^2$ </li>
</ol>
<p>$$<br>\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}<br>$$</p>
<p>$$<br>\sigma^2=\frac{1}{m}\sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^2<br>$$</p>
<ol start="3">
<li>对于新给的样本 $x$，计算 $p(x)$：</li>
</ol>
<p>$$<br>p(x)=\prod_{j=1}^{n}p(x_j;\mu_j,\sigma_j^2)=\prod_{j=1}^{n}\frac{1}{\sqrt{2\pi}\sigma_j}\exp\left(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2}\right)<br>$$</p>
<ol start="4">
<li>如果$p(x)&lt;\epsilon$，则预测异常。</li>
</ol>
<h4 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h4><p>$$<br>p(x;\mu,\Sigma)=\frac<br>{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}<br>$$</p>
<p>参数：</p>
<ul>
<li>$\mu\in\R^n$</li>
<li>$\Sigma\in\R^{n\times n}$ (covariance matrix, <code>Sigma = 1/m * X&#39; * X;</code>)</li>
</ul>
<p>参数的计算：<br>$$<br>\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)} \qquad<br>\Sigma=\frac{1}{m}\sum_{i=1}^m\left(x^{(i)}-\mu\right)\left(x^{(i)}-\mu\right)^T<br>$$</p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span> = <span class="title">multivariateGaussian</span><span class="params">(X, mu, Sigma2)</span></span></span><br><span class="line"><span class="comment">%MULTIVARIATEGAUSSIAN Computes the probability density function of the</span></span><br><span class="line"><span class="comment">%multivariate gaussian distribution.</span></span><br><span class="line"><span class="comment">%    p = MULTIVARIATEGAUSSIAN(X, mu, Sigma2) Computes the probability </span></span><br><span class="line"><span class="comment">%    density function of the examples X under the multivariate gaussian </span></span><br><span class="line"><span class="comment">%    distribution with parameters mu and Sigma2. If Sigma2 is a matrix, it is</span></span><br><span class="line"><span class="comment">%    treated as the covariance matrix. If Sigma2 is a vector, it is treated</span></span><br><span class="line"><span class="comment">%    as the \sigma^2 values of the variances in each dimension (a diagonal</span></span><br><span class="line"><span class="comment">%    covariance matrix)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">k = <span class="built_in">length</span>(mu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span>(Sigma2, <span class="number">2</span>) == <span class="number">1</span>) || (<span class="built_in">size</span>(Sigma2, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    Sigma2 = <span class="built_in">diag</span>(Sigma2);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">X = <span class="built_in">bsxfun</span>(@minus, X, mu(:)&#x27;);</span><br><span class="line">p = (<span class="number">2</span> * <span class="built_in">pi</span>) ^ (- k / <span class="number">2</span>) * det(Sigma2) ^ (<span class="number">-0.5</span>) * ...</span><br><span class="line">    <span class="built_in">exp</span>(<span class="number">-0.5</span> * sum(<span class="built_in">bsxfun</span>(@times, X * pinv(Sigma2), X), <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="用多元高斯分布的异常检查"><a href="#用多元高斯分布的异常检查" class="headerlink" title="用多元高斯分布的异常检查"></a>用多元高斯分布的异常检查</h5><ol>
<li>拟合多元高斯分布的 $p(x)$ 模型，通过参数：</li>
</ol>
<p>$$<br>\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)} \qquad<br>\Sigma=\frac{1}{m}\sum_{i=1}^m\left(x^{(i)}-\mu\right)\left(x^{(i)}-\mu\right)^T<br>$$</p>
<ol start="2">
<li>对于新给 $x$，计算：</li>
</ol>
<p>$$<br>p(x)=\frac<br>{\exp\left(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)}<br>{\sqrt{(2\pi)^{n}|\Sigma|}}<br>$$</p>
<ol start="3">
<li>如果$p(x)&lt;\epsilon$，则预测异常。</li>
</ol>
<h4 id="门槛选择"><a href="#门槛选择" class="headerlink" title="门槛选择"></a>门槛选择</h4><p>通过计算 $F_1$ 值可以得到最适合的 $\epsilon$。</p>
<p>$F_1$ 值由 precision ($prec$) 和 recall ($rec$) 给出：<br>$$<br>F_1=\frac{2\cdot prec \cdot rec}{prec+rec}<br>$$<br>其中：<br>$$<br>prec = \frac{tp}{tp+fp}<br>$$</p>
<p>$$<br>rec = \frac{tp}{tp+fn}<br>$$</p>
<ul>
<li>$tp$ 是 true positives：预测为正，实际也为正</li>
<li>$fp$ 是 false positives：预测为正，实际为负</li>
<li>$fn$ 是 false negatives：预测为负，实际为正</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bmwqbebxj30po0dgahc.jpg" alt="image-20191026152903469"></p>
<p>👉代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[bestEpsilon bestF1]</span> = <span class="title">selectThreshold</span><span class="params">(yval, pval)</span></span></span><br><span class="line"><span class="comment">%SELECTTHRESHOLD Find the best threshold (epsilon) to use for selecting</span></span><br><span class="line"><span class="comment">%outliers</span></span><br><span class="line"><span class="comment">%   [bestEpsilon bestF1] = SELECTTHRESHOLD(yval, pval) finds the best</span></span><br><span class="line"><span class="comment">%   threshold to use for selecting outliers based on the results from a</span></span><br><span class="line"><span class="comment">%   validation set (pval) and the ground truth (yval).</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">bestEpsilon = <span class="number">0</span>;</span><br><span class="line">bestF1 = <span class="number">0</span>;</span><br><span class="line">F1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">stepsize = (<span class="built_in">max</span>(pval) - <span class="built_in">min</span>(pval)) / <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> epsilon = <span class="built_in">min</span>(pval):stepsize:<span class="built_in">max</span>(pval)</span><br><span class="line"></span><br><span class="line">    cvPredictions = pval &lt; epsilon;</span><br><span class="line">    </span><br><span class="line">    tp = sum((cvPredictions == <span class="number">1</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line">    fp = sum((cvPredictions == <span class="number">1</span>) &amp; (yval == <span class="number">0</span>));</span><br><span class="line">    fn = sum((cvPredictions == <span class="number">0</span>) &amp; (yval == <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    prec = tp / (tp + fp);</span><br><span class="line">    rec = tp / (tp + fn);</span><br><span class="line"></span><br><span class="line">    F1 = (<span class="number">2</span> * prec * rec) / (prec + rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> F1 &gt; bestF1</span><br><span class="line">       bestF1 = F1;</span><br><span class="line">       bestEpsilon = epsilon;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><blockquote>
<p>通过评分，推荐用户新内容。</p>
</blockquote>
<p>符号说明：（假设我们要推荐的东西是电影）</p>
<ul>
<li>$n_u$ = 用户数</li>
<li>$n_m$ = 电影数</li>
<li>$r(i,j)=1$ 若用户 $j$ 对电影 $i$ 评过分，否则为 0</li>
<li>$y^{(i,j)}$ = 用户 $j$ 给电影 $i$ 的评分(只有当 $r(i,j)=1$ 时才有定义)</li>
</ul>
<h4 id="基于内容推荐"><a href="#基于内容推荐" class="headerlink" title="基于内容推荐"></a>基于内容推荐</h4><p><strong>预测模型</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9bi5bv4etj30nz06lac1.jpg" alt="屏幕快照 2019-11-26 16.04.26"></p>
<ul>
<li>$r(i,j)=1$ 若用户 $j$ 对电影 $i$ 评过分</li>
<li>$y^{(i,j)}$ = 用户 $j$ 给电影 $i$ 的评分(如果有定义)</li>
<li>$\theta^{(j)}$ 用户 $j$ 的参数（向量）</li>
<li>$x^{(i)}$ 电影 $i$ 的特征（向量）</li>
</ul>
<p>对于用户 $j$，电影 $i$，预测评分：$(\theta^{(j)})^T(x^{(i)})$。</p>
<p><strong>优化目标</strong>：</p>
<ol>
<li>优化 $\theta^{(j)}$ （对于单个用户 $j$ 的参数）</li>
</ol>
<p>$$<br>\min_{\theta^{(j)}}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$</p>
<ol start="2">
<li>优化 $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$（对所有用户）</li>
</ol>
<p>$$<br>\min_{\theta^{(1)},\cdots,\theta^{(n_u)}}<br>\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2<br>$$</p>
<p>我们可以用梯度下降解决问题：<br>$$<br>\begin{array}{l}<br>Repeat\quad{\<br>\qquad \theta_0^{(j)}:=\theta_0^{(j)}-\alpha\sum_{i:r(i,j)=1} \big((\theta^{(j)})^T(x^{(i)})-y^{(i,j)}\big)x_0^{(i)}\<br>\qquad \theta_k^{(j)}:=\theta_k^{(j)}-\alpha\Big[\Big(\sum_{i:r(i,j)=1}\big((\theta^{(j)})^T(x^{(i)})-y^{(i)}\big)x_k^{(i)}\Big)+\lambda\theta_k^{(j)}\Big]\qquad (\textrm{for } k \neq 0)\<br>}<br>\end{array}<br>$$</p>
<h4 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h4><p>在基于内容推荐中我们有时会很难把握电影（我们要推荐的东西）有哪些特征（$x^{(i)}$），我们想让机器学习自己找特征，这就用到协同过滤。</p>
<p><strong>新加的优化目标</strong>：（之前在基于内容推荐里面的优化目标仍需考虑）</p>
<ul>
<li>给定 $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$，学习 $x^{(i)}$:</li>
</ul>
<p>$$<br>\min_{x^{(i)}}\frac{1}{2}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p>
<ul>
<li>给定 $\theta^{(1)},\theta^{(2)},\cdots,\theta^{(n_u)}$ ，学习 $x^{(1)},\cdots,x^{(n_m)}$ ：</li>
</ul>
<p>$$<br>\min_{x^{(1)},\cdots,x^{(n_m)}}\frac{1}{2}<br>\sum_{i=1}^{n_m}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p>
<p><strong>协同过滤</strong>：</p>
<p>现在我们的问题是即没有训练好的 $\theta$，又没有一组充分优化的 $x$，但学习 $\theta$ 要先有 $x$，学习 $x$ 要先有 $\theta$。这就变成了一个类似鸡生蛋、蛋生鸡的问题。</p>
<p>我们可以考虑这样解决这个难题：</p>
<p>首先随机猜一组 $\theta$，然后用这组 $\theta$ 就可以得到一组 $x$；用这组得到的 $x$ 又可以优化 $\theta$，优化后的 $\theta$ 又拿来优化 $x$ …… 不断重复这个过程，我们可以期望得到一组 $x$ 和 $\theta$ 都充分优化的解（事实上它们最终是会收敛的）。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ds8xkjatj30ob0bd0w0.jpg" alt="屏幕快照 2019-11-28 15.20.59"><br>$$<br>\begin{array}{l}</p>
<p>\textrm{Given }<br>x^{(1)},\cdots,x^{(n_m)}<br>\textrm{ , estimate }<br>\theta^{(1)},\cdots,\theta^{(n_u)}:\<br>\quad<br>\min_{\theta^{(1)},\cdots,\theta^{(n_u)}}<br>\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n \left(\theta_k^{(j)}\right)^2\</p>
<p>\textrm {Given }<br>\theta^{(1)},\cdots,\theta^{(n_u)}<br>\textrm{ , estimate }<br>x^{(1)},\cdots,x^{(n_m)}:\<br>\quad<br>\min_{x^{(1)},\cdots,x^{(n_m)}}\frac{1}{2}<br>\sum_{i=1}^{n_m}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2 +<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>\end{array}<br>$$<br>我们随机初始化一组参数，然后重复来回计算 $\theta$ 和 $x$，最终会得到解，但这样比较麻烦，我们可以做的更高效：</p>
<p><strong>同时</strong>优化 $x^{(1)},\cdots,x^{(n_m)}$ 和 $\theta^{(1)},\cdots,\theta^{(n_u)}$:<br>$$<br>J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})=<br>\frac{1}{2}<br>\sum_{(i,j):r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2+<br>\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n \left(x_k^{(i)}\right)^2<br>$$</p>
<p>$$<br>\min_{\begin{array}{c}x^{(1)},\cdots,x^{(n_m)}\\theta^{(1)},\cdots,\theta^{(n_u)}\end{array}}<br>J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})<br>$$</p>
<p><strong>协同过滤算法</strong>：</p>
<ol>
<li>将 $x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)}$ 随机初始化为一些比较小的随机值</li>
<li>优化 $J(x^{(1)},\cdots,x^{(n_m)},\theta^{(1)},\cdots,\theta^{(n_u)})$</li>
<li>对于给定用户，该用户的参数是 $\theta$，则用训练得到的某电影的特征 $x$ ，我们可以预测该用户可能为此电影评分：$\theta^Tx$。</li>
</ol>
<p><strong>低秩矩阵分解</strong>：</p>
<p>我们可以看到，我们最终的预测是这样的：<br>$$<br>Predict = \left[\begin{array}{ccccc} (x^{(1)})^T(\theta^{(1)}) &amp; \ldots &amp; (x^{(1)})^T(\theta^{(n_u)})\ \vdots &amp; \ddots &amp; \vdots \ (x^{(n_m)})^T(\theta^{(1)}) &amp; \ldots &amp; (x^{(n_m)})^T(\theta^{(n_u)})\end{array}\right]<br>$$<br>考虑到几乎不可能有用户把接近所有的电影都评分，这个预测矩阵是稀疏的，存储这个矩阵会造成大量浪费，不妨令：<br>$$<br>X = \left[\begin{array}{ccc}</p>
<ul>
<li>&amp; (x^{(1)})^T &amp; - \<br>&amp; \vdots &amp; \</li>
<li>&amp; (x^{(n_m)})^T &amp; - \<br>\end{array}\right],<br>\qquad<br>\Theta = \left[\begin{array}{ccc}</li>
<li>&amp; (\theta^{(1)})^T &amp; - \<br>&amp; \vdots &amp; \</li>
<li>&amp; (\theta^{(n_u)})^T &amp; - \<br>\end{array}\right]<br>$$<br>则有：<br>$$<br>Predict=X\Theta^T<br>$$<br>我们便将它分为了两部分。用这个方法求取 $X$ 和 $\Theta$，获得推荐系统需要的参数，称之为<strong>低秩矩阵分解</strong>。该方法不仅能在编程时直接通过向量化的手法获得参数，还通过矩阵分解节省了内存空间。</li>
</ul>
<p><strong>寻找相关电影</strong>：</p>
<p>我们常需要推荐与电影 $i$ 相关的电影 $j$，可以这样找到：<br>$$<br>\mathop{\textrm{smallest}} ||x^{(i)}-x^{(j)}||<br>$$<br><strong>均值归一化处理</strong>：</p>
<p>再电影推荐问题中，由于评分总是1到5分（或其他范围），故不用特征缩放，但可以做 mean normalization：<br>$$<br>\mu_i=\mathop{\textrm{average}} y^{(i,:)}<br>$$</p>
<p>$$<br>Y_i = Y_i-\mu_i<br>$$</p>
<p>对用户 $j$, 电影 $i$, 预测:<br>$$<br>\left(\Theta^{(j)}\right)^T\left(x^{(i)}\right)+\mu_i<br>$$<br>👉<strong>代码实现</strong>：</p>
<ol>
<li>代价函数：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[J, grad]</span> = <span class="title">cofiCostFunc</span><span class="params">(params, Y, R, num_users, num_movies, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                  num_features, lambda)</span></span></span><br><span class="line"><span class="comment">%COFICOSTFUNC Collaborative filtering cost function</span></span><br><span class="line"><span class="comment">%   [J, grad] = COFICOSTFUNC(params, Y, R, num_users, num_movies, ...</span></span><br><span class="line"><span class="comment">%   num_features, lambda) returns the cost and gradient for the</span></span><br><span class="line"><span class="comment">%   collaborative filtering problem.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Unfold the U and W matrices from params</span></span><br><span class="line">X = <span class="built_in">reshape</span>(params(<span class="number">1</span>:num_movies*num_features), num_movies, num_features);</span><br><span class="line">Theta = <span class="built_in">reshape</span>(params(num_movies*num_features+<span class="number">1</span>:<span class="keyword">end</span>), ...</span><br><span class="line">                num_users, num_features);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line">X_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X));</span><br><span class="line">Theta_grad = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Theta));</span><br><span class="line"></span><br><span class="line">h = X * Theta&#x27;;</span><br><span class="line">er = (h - Y) .* R;</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span>/<span class="number">2</span> * sum(sum(er.^<span class="number">2</span>));</span><br><span class="line">X_grad = er * Theta;</span><br><span class="line">Theta_grad = er&#x27; * X; </span><br><span class="line"></span><br><span class="line"><span class="comment">% Regularized</span></span><br><span class="line"></span><br><span class="line">J += lambda/<span class="number">2</span> *(sum(sum(Theta.^<span class="number">2</span>)) + sum(sum(X.^<span class="number">2</span>)));</span><br><span class="line">X_grad += lambda * X;</span><br><span class="line">Theta_grad += lambda * Theta;</span><br><span class="line">grad = [X_grad(:); Theta_grad(:)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>均值归一</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Ynorm, Ymean]</span> = <span class="title">normalizeRatings</span><span class="params">(Y, R)</span></span></span><br><span class="line"><span class="comment">%NORMALIZERATINGS Preprocess data by subtracting mean rating for every </span></span><br><span class="line"><span class="comment">%movie (every row)</span></span><br><span class="line"><span class="comment">%   [Ynorm, Ymean] = NORMALIZERATINGS(Y, R) normalized Y so that each movie</span></span><br><span class="line"><span class="comment">%   has a rating of 0 on average, and returns the mean rating in Ymean.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">size</span>(Y);</span><br><span class="line">Ymean = <span class="built_in">zeros</span>(m, <span class="number">1</span>);</span><br><span class="line">Ynorm = <span class="built_in">zeros</span>(<span class="built_in">size</span>(Y));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    idx = <span class="built_in">find</span>(R(<span class="built_in">i</span>, :) == <span class="number">1</span>);</span><br><span class="line">    Ymean(<span class="built_in">i</span>) = <span class="built_in">mean</span>(Y(<span class="built_in">i</span>, idx));</span><br><span class="line">    Ynorm(<span class="built_in">i</span>, idx) = Y(<span class="built_in">i</span>, idx) - Ymean(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>驱动脚本</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%  Normalize Ratings</span></span><br><span class="line">[Ynorm, Ymean] = normalizeRatings(Y, R);</span><br><span class="line"></span><br><span class="line"><span class="comment">%  Useful Values</span></span><br><span class="line">num_users = <span class="built_in">size</span>(Y, <span class="number">2</span>);</span><br><span class="line">num_movies = <span class="built_in">size</span>(Y, <span class="number">1</span>);</span><br><span class="line">num_features = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set Initial Parameters (Theta, X)</span></span><br><span class="line">X = <span class="built_in">randn</span>(num_movies, num_features);</span><br><span class="line">Theta = <span class="built_in">randn</span>(num_users, num_features);</span><br><span class="line"></span><br><span class="line">initial_parameters = [X(:); Theta(:)];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set options for fmincg</span></span><br><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set Regularization</span></span><br><span class="line">lambda = <span class="number">10</span>;</span><br><span class="line">theta = fmincg (@(t)(cofiCostFunc(t, Ynorm, R, num_users, num_movies, ...</span><br><span class="line">                                num_features, lambda)), ...</span><br><span class="line">                initial_parameters, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Unfold the returned theta back into U and W</span></span><br><span class="line">X = <span class="built_in">reshape</span>(theta(<span class="number">1</span>:num_movies*num_features), num_movies, num_features);</span><br><span class="line">Theta = <span class="built_in">reshape</span>(theta(num_movies*num_features+<span class="number">1</span>:<span class="keyword">end</span>), ...</span><br><span class="line">                num_users, num_features);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;Recommender system learning completed.\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p = X * Theta&#x27;;</span><br><span class="line">my_predictions = p(:,<span class="number">1</span>) + Ymean;</span><br></pre></td></tr></table></figure>
<hr>
<p>EOF</p>

  </div>
</article>
<!--Disqus-->


<!--Livere-->

    <div class="blog-post-comments">
        <div id="lv-container" data-id="city" data-uid="MTAyMC80NjEzMi8yMjY0Mw==">
            <noscript>不启用 JavaScript 支持的人是看不到可爱的评论区的。😥</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">机器学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">回归问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#h-theta-x"><span class="toc-number">2.</span> <span class="toc-text">h_\theta(x)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sum-i-0-m-theta-ix-i"><span class="toc-number">3.</span> <span class="toc-text">\sum_{i&#x3D;0}^m \theta_ix_i</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#left-begin-array-c-x-0-x-1-vdots-x-n-end-array-right"><span class="toc-number">4.</span> <span class="toc-text">\left[\begin{array}{c}x_0 \ x_1 \ \vdots \ x_n \end{array}\right]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">梯度下降</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">正规方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8Dvs%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">梯度下降vs正规方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">注：特征缩放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.1.</span> <span class="toc-text">分类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">逻辑回归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB"><span class="toc-number">4.0.1.1.1.</span> <span class="toc-text">多元分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E8%BF%87%E6%8B%9F%E5%90%88"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">注：过拟合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB-1"><span class="toc-number">4.0.1.3.1.</span> <span class="toc-text">多元分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%9F%E5%90%88"><span class="toc-number">4.0.1.3.2.</span> <span class="toc-text">神经网络的拟合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-number">4.0.1.4.</span> <span class="toc-text">支持向量机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.1.4.1.</span> <span class="toc-text">核方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SVM-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%B8"><span class="toc-number">4.0.1.4.2.</span> <span class="toc-text">SVM 中使用核</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB-2"><span class="toc-number">4.0.1.4.3.</span> <span class="toc-text">多元分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-vs-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-vs-SVM"><span class="toc-number">4.0.1.5.</span> <span class="toc-text">逻辑回归 vs 神经网络 vs SVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.1.</span> <span class="toc-text">无监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Means-%E8%81%9A%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">K-Means 聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCA-%E7%BB%B4%E6%95%B0%E7%BA%A6%E5%87%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">PCA 维数约减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">异常检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">高斯分布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%9F%A5%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.3.1.1.</span> <span class="toc-text">异常检查算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">多元高斯分布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%9F%A5"><span class="toc-number">4.1.3.2.1.</span> <span class="toc-text">用多元高斯分布的异常检查</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E6%A7%9B%E9%80%89%E6%8B%A9"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">门槛选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">推荐系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">基于内容推荐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">协同过滤</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&text=Andrew Ng 机器学习笔记总结"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&is_video=false&description=Andrew Ng 机器学习笔记总结"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Andrew Ng 机器学习笔记总结&body=Check out this article: https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&title=Andrew Ng 机器学习笔记总结"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://clownote.github.io/2020/01/16/AndrewNgML/AndrewNgMLNotes/&name=Andrew Ng 机器学习笔记总结&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 CDFMLR
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cdfmlr">项目</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-146911386-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?9a0d2e6fde93dad496ac79f04f3aba97";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


<!--Livere Comments-->

    <script type="text/javascript">
      (function (d, s) {
        var j, e = d.getElementsByTagName(s)[0];

        if (typeof LivereTower === 'function') { return; }

        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;

        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>

</body>
</html>
